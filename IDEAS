=== 2017.09.08

Q: What is the status of (2.2) in [RS]? Is it an axiom
in the system, or is it a provable property of the type system that
merely happens to be written as an inference rule, i.e. like cut
elimination?
A: ???

Q: In figure 3, why do premises œÜ and œà appear downstairs in the
fourth and fifth rules listed, when they already are assumed to follow
from Œû | Œ¶?
A: ???

Q: In the third rule in figure 4, why isn't *s* constrained to somehow
live in œà?
A: I guess it's because it's not that f needs something to live in a
shape to accept it as an argument; it's that f can only give answers
for things that live inside œà. We're asking that s is defined on
the whole cube I, and we can consider the restriction of the cube to
œà before feeding it to f. Thus, I might better ask:

Q: In the third rule in figure 4, why isn't s allowed to be defined
merely on œà? Why must it be defined on the whole cube I?
A: Oh, I see --- it's because the arguments to the function are merely
cube expressions, not general terms. There's no way to even specify a
cube term that's something other than a tuple of projections.

=== 2017.09.09

Q: How do Joyal disks [Joyal97] lead to ‚àû-categories according to [RS]?
A: ???

Q: In [RS] Axiom 4.6, we're not making any additional assumption on
t : I | œÜ |- œà
by saying it's a cofibration, right? My belief is that
œà is just a cofibration by being of that syntactic class.
A: ???

=== 2017.09.10

Q: Is the Finster-Mimram definition of weak omega-categories connected
in a simple way to Joyal's theta-category?
A: Probably can get a good sense by looking in
http://cheng.staff.shef.ac.uk/guidebook/guidebook-new.pdf
which I found from
https://ncatlab.org/nlab/show/Theta+category

=== 2017.09.11

Q: Where is the cubical stuff in the agda source?
A:
I see IZERO in
agda//src/full/Agda/TypeChecking/Monad/Builtin.hs
builtinIZero :: String = "IZERO"
primIZero :: TCM Term = getBuiltin builtinIZero

Q: Where are some exciting uses of primIZero?
A:
agda//src/full/Agda/TypeChecking/Primitive.hs

Q: Where is haskell-mode docs?
A: http://haskell.github.io/haskell-mode/manual/latest/

Q: More emacs advice about haskell dev?
A:
https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md

Q: What's the go-to-definition thing I want to bind to M-.?
A:
haskell-mode-jump-to-def

Q: Why did it take so long the first time I ran it?
A: Dunno, but someone else experienced a similar thing:
https://blog.alainodea.com/en/article/490/haskell-intero-in-emacs-first-impressions-and-howto

Q: Where are the sources to, like, the haskell base library including
the prelude Control.Monad and everything?
A: I thought maybe in
/usr/local/Cellar/ghc/7.10.3b/lib/ghc-7.10.3/
(which
$ brew list ghc
told me about)
but I only see .hi files.
...
Seems to exist online at
http://git.haskell.org/ghc.git/tree/refs/heads/master:/libraries/base/Control

Q: Transportation to the vicinity of wesleyan?
A: "Vermonter" amtrak + M-link bus maybe?
Hotel situation looks like a bummer.
No, nevermind, looks like I can just get a ride up with dlicata@.

Q: How can I git blame one line of a file?
A:
do like
$ git blame Primitive.hs -L404,+1

=== 2017.09.16

Q: How redundant is rule 5 of figure 4 in [RS]? It seems like morally I can
take the assumption that a == b and apply substitution to see
a[s/t] == b[s/t] and then use transitivity from rule 4's f(s) = a[s/t].
A: ???

=== 2017.09.18

Q: Ok, so where are the guts of cubical typechecking going on?
A:
try looking in
agda//src/full/Agda/TypeChecking/Rules/Term.hs
agda//src/full/Agda/TypeChecking/Rules/Builtin.hs
agda//src/full/Agda/TypeChecking/Primitive.hs
agda//src/full/Agda/TypeChecking/Telescope.hs

Q: Is there a way to view all these haskell function docstrings in a nice way?
A:
$ cabal install haddock
$ cabal configure
$ cabal haddock
and generates into
agda//dist/doc/html/Agda/index.html

Q: Why didn't
$ make haddock
work?
A:
mysterious missing dependencies?

# $ make haddock
# doesn't work due to

Q: What are some examples of cubical programs?
A:
agda//test/Fail/Issue2650.agda
agda//test/Fail/Issue2650.agda
agda//test/Succeed/Issue2650.agda
and also a goldmine of stuff in
gh//Saizan/cubical-demo

Q: What are the cubical primitives in
agdalib//prim/Agda/Primitive.agda
sorted by epistemic status?
A:
I definitely understand
 I, i0, i1
 primIMin
 primIMax
 primINeg
 IsOne
 itIsOne
 IsOne1 -- These two are just asserting that
 IsOne2 -- 1 v x = 1 and x v 1 = 1

Q: What's the deal with
<<<
 primPOr : {a : Agda.Primitive.Level} (i j : I)
      {A : .(IsOne (primIMax i j)) ‚Üí Set a} ‚Üí
      (.(p : IsOne i) ‚Üí A _) ‚Üí
      (.(p : IsOne j) ‚Üí A _) ‚Üí .(p : IsOne (primIMax i j)) ‚Üí A p
>>>
?
A: I think I vaguely understand it to be the realization of the disjunctive "systems" in
[CCHM] https://arxiv.org/pdf/1611.02108.pdf
which correspond to the disjunction elimination rules in [RS].

Q: What's the deal with
<<<
 Partial : {a : Agda.Primitive.Level} (A : Set a) ‚Üí I ‚Üí Setœâ
>>>
?
A:
It's described as
<<<
"Partial A œÜ"  is a special version of "(œÜ = i1) ‚Üí A"
>>>
in
gh//Saizan/cubical-demo/blob/master/AIM_Demo/DemoPartial.agda
which I think I kind of get.
I believe
<<<
 PartialP : {a : Agda.Primitive.Level} (œÜ : I)
      (A : .(o : IsOne œÜ) ‚Üí Set a) ‚Üí
      Setœâ
>>>
is just the more dependent 'path-over' version of Partial, sorta? I
see it used in the same file there.

Q: What's the deal with
<<<
 primPFrom1 : {a : Agda.Primitive.Level} {A : I ‚Üí Set a} ‚Üí
      A i1 ‚Üí (i j : I) ‚Üí .(IsOne i) ‚Üí A (primIMax i j)
>>>
A: If I squint it just looks like it's sort of internalizing the fact
that if I know i is already i1, then primIMax i j has to be i1 too, so
I can lift something known to be at A i1 to A (primIMax i j). Maybe
it's just making things definitionally equal that would otherwise be
propositionally equal.

Q: What's the deal with
<<<
 primComp : {a : I ‚Üí Agda.Primitive.Level} (A : (i : I) ‚Üí Set (a i))
      (œÜ : I) ‚Üí
      ((i : I) ‚Üí .(IsOne œÜ) ‚Üí A i) ‚Üí A i0 ‚Üí A i1
>>>
A: This is the composition primitive from the paper.

Q: Wait, I see other primitives still in
gh//Saizan/cubical-demo/blob/master/Primitives.agda
what's the deal with them?
A:
well, primPathPApply does exist in
agda//src/full/Agda/TypeChecking/Primitive.hs
due to
agdac//b0596dde
and CONID exists in
agda//src/full/Agda/TypeChecking/Monad/Builtin.hs
due to
agdac//7a50bedf

Q: Where is that in the agda repo?
A:
agda//src/data/lib/prim/Agda/Primitive.agda

Q: What's going on with the primitive keyword?
A: I guess it's just a way of grabbing primitive function values with the standard name, see
agda//examples/Introduction/Built-in.agda
(which doesn't appear to compile due to a change of the number of arguments of the Integer built-in?)

Q: How is agda's version number spread througout other things?
A: Well, I see commits like agdac//3ca28ee9 but I don't know if there's a
script that achieves all these changes in a simple way.

Q: What're some milestones in the history of editing the cubical code?
A:
agdac//e919f74e due to avezzosi@ https://github.com/Saizan

Q: What's the suffix .hs-boot for?
A: Reifying cycles for mutuall recursive modules, see
https://downloads.haskell.org/~ghc/7.0.3/docs/html/users_guide/separate-compilation.html
and search for 'hs-boot'

Q: What are all these moon-language operators I'm seeing everywhere like
<@>, <#>, <..>, <@@>?
A: They are in fact defined in
agda//src/full/Agda/TypeChecking/Primitive.hs
and some more are in
agda//src/full/Agda/Utils/Functor.hs
<$> is just an infix name for fmap, see
http://git.haskell.org/ghc.git/blob_plain/refs/heads/master:/libraries/base/Data/Functor.hs

Q: How do I think about what [CCHM] calls 'partial elements'?
A: They're the things that are defined over the whole cube, but have
particular known values at subpolyhedra of the cube?

Q: What can I figure out about PrimitiveImpl?
A:
It's made of a Type and a PrimFun

Q: How do I printf in haskell?
A: Debug.Trace.trace, see
https://wiki.haskell.org/Debugging

Q: What's the deal with type IntervalView in
agda//src/full/Agda/Syntax/Internal.hs
A:
It was last touched by
agdac//6d78a1d4
I surmise it's some sort of way of exposing some of the interval term structure...

Q: What's going on with ignoreSharing in
agda//src/full/Agda/TypeChecking/Monad/Builtin.hs
?
A:
It's defined in
agda//src/full/Agda/Syntax/Internal.hs
and I would have named it, like, 'derefSharing' or something.

Q: What's a bang mean in haskell datatype definitions?
A: Strictness annotation, see
https://stackoverflow.com/questions/993112/what-does-the-exclamation-mark-mean-in-a-haskell-declaration

Q: What's an iota-redex, as mentioned in data Term comments in
agda//src/full/Agda/Syntax/Internal.hs
?
A: Something to do with pattern matching, see
https://github.com/agda/agda/issues/2276

Q: What's something that triggers the checking in primPOr that the two overlapping definitions
are consistent on their intersection?
A:
<<<
{-# OPTIONS --cubical #-}
module a where
import Agda.Primitive
open Agda.Primitive.CubicalPrimitives public

data Two : Set where
 ùüô ùüö : Two

x = primPOr i1 i1 {A = Œª _ ‚Üí Two} (Œª _ ‚Üí ùüô) (Œª _ ‚Üí ùüö)
>>>
gives an error as expected.

Q: Why does
(primPOr i0 i1 {A = Œª _ ‚Üí Two} (Œª _ ‚Üí ùüö) (Œª _ ‚Üí ùüô)) itIsOne
give an error about being fully applied?
A: ???

Q: What's the commit that created builtin PATH?
A: agdac//5e8aae7c

Q: Why doesn't Category.agda of
gh//Saizan/cubical-demo/blob/master/Category.agda
at commit 12f3d8f3
seem to compile at agdac//a67e5e2f?
A: ???

Q: How do I run agda from ghci so I can inspect things going on?
A: cabal repl

Q: Also can I just bash stuff into the prompt in *agda* in emacs?
A: Yeah, seems like!

Q: What's this syntax going on in
<<<
foo : ‚àÄ i ‚Üí Partial Bool (i ‚à® ~ i)
foo i (i = i1) = true
foo i (i = i0) = false
>>>
in
gh//Saizan/cubical-demo/blob/master/AIM_Demo/DemoPartial.agda
?
A: Seems like a pattern-matching elimination for values of the type
IsOne?

=== 2017.09.19

Q: Where is this IsOne pattern elimination in the agda abstract syntax?
A:
I see a hint in the use of domFinite, and the comment in
agda//src/full/Agda/Syntax/Common.hs about primIsOne
this leads to looking at
agda//src/full/Agda/TypeChecking/Rules/LHS/Split.hs
which is a big mess.

Q: Can I get any insight by just git blaming
agda//src/full/Agda/Syntax/Abstract.hs
A:
Sure can! I see avezzosi@'s agdac//c584e887 touching a thing called EqualP.
yup,
<<<
  | EqualP Range [(Expr,Expr)]             -- ^ @i = i1@ i.e. cubical face lattice generator
>>>
in
agda//src/full/Agda/Syntax/Concrete.hs

Q: What's an interesting paper about internalizing dependent lambda calculus?
A:
"Outrageous but Meaningful Coincidences" McBride 2010, found in
https://homotopytypetheory.org/2014/03/03/hott-should-eat-itself/

Q: Wow, cabal repl is slow interactively. Even for editing text in
readline. What do?
A:
put
<<<
:set -fobject-code
>>>
in the .ghci file
http://chrisdone.com/posts/making-ghci-fast
https://www.reddit.com/r/haskell/comments/3ddcrw/does_haskell_have_slow_iteration_times_are_those/

Q: What do about the message
Warning: Can't find file "dist-2.6.0/build/autogen/cabal_macros.h" in directories
I see during cabal repl?
A:
Just
$ ln -s dist dist-2.6.0
as andreasabel@ recommends in
http://agda.chalmers.narkive.com/4ACGqXHw/problems-configuring-haskell-mode-and-or-invoking-cabal-repl

Q: More basic stuff about cabal?
A: http://katychuang.com/cabal-guide/

Q: What am I looking at trying to figure out how to typecheck a single expression from repl?
A: agda//src/full/Agda/Syntax/Parser.hs

Q: Where's MonadIO come from?
A:
<<<
:info Control.Monad.IO.Class.MonadIO
class Monad m => Control.Monad.IO.Class.MonadIO (m :: * -> *) where
  Control.Monad.IO.Class.liftIO :: IO a -> m a
  	-- Defined in ‚ÄòControl.Monad.IO.Class‚Äô
instance Control.Monad.IO.Class.MonadIO PM
  -- Defined in ‚ÄòAgda.Syntax.Parser‚Äô
instance Control.Monad.IO.Class.MonadIO IO
  -- Defined in ‚ÄòControl.Monad.IO.Class‚Äô
>>>

Q: What's it good for, vis-a-vis the PM type class?
A: Lifting IO actions *into* PM, not injecting PM into IO. Boo.

Q: Oh, but what do I want for that?
A: runPMIO

Q: How do I get ghci to show types
A:
either
:type <expression>
or
:set +t
(which I could do interactively or put in my .gchi)
according to
https://stackoverflow.com/questions/12659927/using-ghci-to-find-type

Q: How do I get ghci to allow multi-line defns?
A:
:set +m
<<<
Œª> let zzz :: Integer
Œª|     zzz = 2
Œª|
zzz :: Integer
Œª>
>>>
https://stackoverflow.com/questions/2846050/how-to-define-a-function-in-ghci-across-multiple-lines
ugh but then every single line expression requires a double-return
:unset +m
it is, then.

Q: How do I parse a single expression?
A:
<<<
import Agda.Syntax.Parser
let runParse :: String -> IO (Either ParseError Agda.Syntax.Concrete.Expr, [ParseWarning]) ; runParse s = runPMIO (parse exprParser s)
>>>

Q: How can I create a primitive type?
A: Can imitate Bool, did not gain much insight though.

Q: How can I create a simple primitive typed constant?
A: ???

Q: How can I create a primitive typed constant that reduces?
A: ???

Q: Where did this *agda* buffer come from?
Was it from haskell-session-change?
A: ???

Q: How do I run agda tests?
A: well I can just do things like
$ dist/build/agda/agda -i test test/Common/String.agda
for some reason
$ make test
gives me errors

Q: Oh, crumb, cabal build seems to clear whatever incremental state cabal repl has.
I guess I should try to do stuff from inside repl. How do?
A:
I see
parsePragmaOptions
defined in
agda//src/full/Agda/Interaction/Options.hs
being called from
agda//src/full/Agda/TypeChecking/Monad/Options.hs
agda//src/full/Agda/Interaction/Imports.hs
...
red herring?
Hmm.
Well I can stick
<<<
  let argv     = ["-i", "/tmp", "/tmp/a.agda"]
>>>
in runAgda' in
agda//src/full/Agda/Main.hs
and that seems to 'work'.

Q: What's a good solution for TAGS for haskell?
A: ???

Q: Why no builtin thing COLOR even after I define it?
A:
the error is
NoSuchBuiltinName
from
agda//src/full/Agda/TypeChecking/Errors.hs
which may have come from one of
agda//src/full/Agda/TypeChecking/Monad/Builtin.hs
agda//src/full/Agda/TypeChecking/Rules/Builtin.hs
but probably the latter.

Huh, it works after I add
<<<
+  , (builtinColor              |-> BuiltinData tset [builtinRed])
>>>
in
agda//src/full/Agda/TypeChecking/Rules/Builtin.hs
to parallel bool.

=== 2017.09.20

Q: mortberg@'s explanation of cubical types?
A:
https://homotopytypetheory.org/2017/09/16/a-hands-on-introduction-to-cubicaltt/
https://github.com/mortberg/cubicaltt/tree/master/lectures

Q: induction-induction vs. induction-recursion?
A:
https://en.wikipedia.org/wiki/Induction-recursion
https://ncatlab.org/homotopytypetheory/show/inductive-inductive+type
http://cs.swan.ac.uk/~csfnf/papers/indind_finite.pdf
https://ncatlab.org/nlab/show/inductive-inductive+type

Q: dual of applicative and alternative?
A: https://hackage.haskell.org/package/contravariant-1.4/docs/Data-Functor-Contravariant-Divisible.html
people (more or less rightly) complaining about the intensity of the category theory involved on twitter at
https://twitter.com/jb55/status/910293593851490304

Q: Thread on hott mailing list from dlicata@ about how to prove univalence?
A: https://groups.google.com/forum/#!msg/homotopytypetheory/j2KBIvDw53s/YTDK4D0NFQAJ

Q: Where are haddock generated docs?
A: /Users/jreed/.cabal/sandboxes/agda-build/agda/dist/doc/html/Agda/index.html

Q: What's a concrete way to show off the non-fibrancy of ùïÄ?
A: ???

Q: Where's the proof of
<<<
-- The reason we need to add <j> a is that we want the top-left point
-- to be a, if we would have omitted it it would instead have been
-- "transport (<_> A) a". We used to have a version of the system
-- where this was the same as a, this relied on a property which we
-- called "regularity". It was however proved by Dan Licata that this
-- property is not preserved by the algorithm for composition for the
-- universe, so we had to drop it and the user now has to give <j> a
-- explicitly.
>>>
that I see in
https://github.com/mortberg/cubicaltt/blob/master/lectures/lecture2.ctt
A:
https://groups.google.com/forum/#!msg/homotopytypetheory/oXQe5u_Mmtk/3HEDk5g5uq4J
looks like a start, but ??? because I want to ask dan.

Q: What's the relationship between the kan filling that
dlicata@ talks about in
"Cubical infinite-dimensional type theory"
https://www.youtube.com/watch?v=lt8JgGRw7gg
and the modern [CCHM] take?
A: ???

Q: What's a nice compact way of looking at J that I get after
beta-reducing the one in mortberg@'s lecture notes?
A:
<<<
myJ (A : U) (a : A) (P : (b : A) -> Path A a b -> U)
  (d : P a (refl A a)) (b : A) (p : Path A a b) : P b p =
  comp (<i> P (p @ i) (<j> p @ i ‚àß j)) d []
>>>

=== 2017.09.21

Q: What's an example of a monomorphism that's *not* a cofibration?
What's special about face inclusions?
A: ???

Q: What do categories with (merely) weak equivalences allow?
A: simplicial localization, see
https://ncatlab.org/nlab/show/simplicial+localization
there seem to be other constructions for subtypes of CwWE, namely
model categories and homotopical categories, but I don't understand
them yet.

Q: What misconception did I just clear up about gluing in [CCHM]?
A: It's not another thing that you have to define for every type, like
composition is; it's a type constructor. A Glue-type is a type built
out of a phi-restricted fragment of another type, plus some
equivalence glue that is valid on the phi-restriction.

Afterwards you define composition *on* glue-types, and composition
*on* the universe is definable by using glue-types in the definition
body.

Q: Can I get any sort of interlibrary deals through wesleyan
affiliation?
A: I can VPN in and access acm dl at least.
Anything else???

Q: What should I make of the discussion on
https://homotopytypetheory.org/2017/09/16/a-hands-on-introduction-to-cubicaltt/
between shulman@ and mortberg@ about canonicity vs. many-models? I
don't feel like I grasp what's at stake.
A: ???

Q: In [ShuFix] inbetween eqn 4.1 and eqn 4.2, it says
(a) ‚ô≠(A ‚Üí B) ‚Üí ‚ô≠(‚ô≠A ‚Üí ‚ô≠B)
is obtainable. But surely also we can get
(b) ‚ô≠(A ‚Üí B) ‚Üí (‚ô≠A ‚Üí ‚ô≠B)
I'd think, at least?
A: derp, (a) is already stronger than (b).

Q: What's my thoughts on I prefer to think about the '2-categorical
adjoint logic' stuff?
A:

I have judgmental *levels* L, typical element ‚Ñì. I have corresponding
syntactic classes of resources and frames, call them r‚Ñì (variables œÅ‚Ñì)
and f‚Ñì (variables œÜ‚Ñì). I have positive propositions P‚Ñì and negatives N‚Ñì.

Then I have relations r‚Ñì ‚ñπ‚Ñì f‚Ñì, may henceforth elide the ‚Ñì on ‚ñπ.

If I'm to set up F ‚ä£ U and let's say with propositional functions
F : PŒΩ ‚Üí PœÑ and U : NœÑ ‚Üí NŒΩ for {œÑ,ŒΩ} ‚äÜ L then I'm going to need
a resource function f : rŒΩ ‚Üí rœÑ

so that (leaving off œÑ suffixes)

F PŒΩ1 [œÅ1], F PŒΩ2 [œÅ2] |- F PŒΩ3 [œÜ]

translates to

F PŒΩ1 @ œÅ1, F PŒΩ2 @ œÅ2, ‚àÄœÅ.(F PŒΩ3 @ œÅ)‚Üí(œÅ ‚ñπ œÜ) ‚ä¢ œÅ1 * œÅ2 ‚ñπ œÜ

which inverts to (b.c. F PŒΩ @ œÅ = ‚àÉœÅŒΩ.(œÅ = f œÅŒΩ) ‚àß (PŒΩ @ œÅŒΩ))
PŒΩ1 @ œÅŒΩ1, PŒΩ2 @ œÅŒΩ2, ‚àÄœÅ.(F PŒΩ3 @ œÅ)‚Üí(œÅ ‚ñπ œÜ) ‚ä¢ f(œÅ1) * f(œÅ2) ‚ñπ œÜ
which should be equal to
PŒΩ1 @ œÅŒΩ1, PŒΩ2 @ œÅŒΩ2, ‚àÄœÅ.(F PŒΩ3 @ œÅ)‚Üí(œÅ ‚ñπ œÜ) ‚ä¢ f(œÅ1 * œÅ2) ‚ñπ œÜ
and then I could focus and step to
PŒΩ1 @ œÅŒΩ1, PŒΩ2 @ œÅŒΩ2 ‚ä¢ F PŒΩ3 @ f(œÅ1 * œÅ2)
which is
PŒΩ1 @ œÅŒΩ1, PŒΩ2 @ œÅŒΩ2 ‚ä¢ ‚àÉœÅŒΩ.(f(œÅ1 * œÅ2) = f œÅŒΩ) ‚àß (PŒΩ3 @ œÅŒΩ)
and I can choose
PŒΩ1 @ œÅŒΩ1, PŒΩ2 @ œÅŒΩ2 ‚ä¢ PŒΩ3 @ œÅ1 * œÅ2
and this all goes like I expect.

To get focusing of F, I need a function u : fœÑ ‚Üí fŒΩ with

(f œÅŒΩ) ‚ñπ œÜt ‚â° œÅŒΩ ‚ñπ (u œÜt)
       œÑ         ŒΩ

Ok, fine, but how do I rig up a triple adjunction? Negative and
positive props are different. If I have F ‚ä£ U and V ‚ä£ H and arrange
so that, ignoring focusing, (negative) U and (positive) V are somehow the same?

In props:

    PŒΩ    NŒΩ    PŒΩ    NŒΩ
   F ‚Üì ‚ä£ U ‚Üë ‚âÖ V ‚Üë ‚ä£ H ‚Üì
    PœÑ    NœÑ    PœÑ    NœÑ

with functions

    rŒΩ    fŒΩ    rŒΩ    fŒΩ
   f ‚Üì ‚ä£ u ‚Üë ‚âÖ v ‚Üë ‚ä£ h ‚Üì
    rœÑ    fœÑ    rœÑ    fœÑ

Ok, let me just look at what I need to get, let's say, the interprovability

U N ‚ä£‚ä¢ V ‚Üì N

for
U N ‚ä¢ V ‚Üì N
I expand to
U N [œÅ] ‚ä¢ V ‚Üì N [œÜ]
‚àÄœÅŒΩ.((V ‚Üì N) @ œÅŒΩ) ‚Üí (œÅŒΩ ‚ñπ œÜŒΩ), ‚àÄœÜŒΩ.((U N) @ œÜŒΩ) ‚Üí (œÅŒΩ ‚ñπ œÜŒΩ) ‚ä¢ œÅŒΩ ‚ñπ œÜŒΩ
------------> need: œÅŒΩ ‚â§ v (f œÅŒΩ)
‚àÄœÅŒΩ.((V ‚Üì N) @ œÅŒΩ) ‚Üí (œÅŒΩ ‚ñπ œÜŒΩ), ‚àÄœÜŒΩ.((U N) @ œÜŒΩ) ‚Üí (œÅŒΩ ‚ñπ œÜŒΩ) ‚ä¢ v (f œÅŒΩ) ‚ñπ œÜŒΩ
‚àÄœÜŒΩ.((U N) @ œÜŒΩ) ‚Üí (œÅŒΩ ‚ñπ œÜŒΩ) ‚ä¢ (V ‚Üì N) @ v (f œÅŒΩ)
‚àÄœÜŒΩ.((U N) @ œÜŒΩ) ‚Üí (œÅŒΩ ‚ñπ œÜŒΩ) ‚ä¢ ‚Üì N @ f œÅŒΩ
‚àÄœÜŒΩ.((U N) @ œÜŒΩ) ‚Üí (œÅŒΩ ‚ñπ œÜŒΩ), N @ œÜ ‚ä¢ f œÅŒΩ ‚ñπ œÜ
‚àÄœÜŒΩ.((U N) @ œÜŒΩ) ‚Üí (œÅŒΩ ‚ñπ œÜŒΩ), N @ œÜ ‚ä¢ œÅŒΩ ‚ñπ u œÜ
N @ œÜ ‚ä¢ (U N) @ u œÜ
N @ œÜ ‚ä¢ N @ œÜ

for
V ‚Üì N ‚ä¢ U N
I expand to
V ‚Üì N [œÅŒΩ] ‚ä¢ U N [œÜŒΩ]
(V ‚Üì N) @ œÅŒΩ, U N @ œÜŒΩ ‚ä¢ œÅŒΩ ‚ñπ œÜŒΩ
(‚Üì N) @ œÅ, N @ œÜ ‚ä¢ v œÅ ‚ñπ u œÜ
‚àÄœÜ.(N @ œÜ) ‚Üí (œÅ ‚ñπ œÜ), N @ œÜ ‚ä¢ v œÅ ‚ñπ u œÜ
‚àÄœÜ.(N @ œÜ) ‚Üí (œÅ ‚ñπ œÜ), N @ œÜ ‚ä¢ œÅ ‚ñπ h (u œÜ)
‚àÄœÜ.(N @ œÜ) ‚Üí (œÅ ‚ñπ œÜ), N @ œÜ ‚ä¢ œÅ ‚ñπ h (u œÜ)
------------> need: œÜ ‚â§ h (u œÜ)
‚àÄœÜ.(N @ œÜ) ‚Üí (œÅ ‚ñπ œÜ), N @ œÜ ‚ä¢ œÅ ‚ñπ œÜ

Ok, yeah, there's two sorts of adjunctions going on, call them ‚ä£‚ñπ and
‚ä£‚â§, and we have

          ‚ä£‚ñπ
       f ----> u
       |       |
    ‚ä£‚â§ |       | ‚ä£‚â§
       ‚Üì       ‚Üì
       v ----> h
          ‚ä£‚ñπ

ok, sure, so both u and v are the right adjoint of f, in two different
ways; of course they should work out to be 'the same', since adjoints
are unique up to isomorphism.

Let's say I start with ‚ä¢ v (f œÅŒΩ) ‚ñπ œÜŒΩ and I want to get to ‚ä¢ œÅŒΩ ‚ñπ œÜŒΩ.
I can do this immediately by appealing to the unit œÅŒΩ ‚â§ v (f œÅŒΩ),
*or* I can transpose to ‚ä¢ œÅŒΩ ‚ñπ u (h œÜŒΩ) and appealing to the counit
u (h œÜŒΩ) ‚â§ œÜŒΩ.

Similarly if I start with ‚ä¢ œÅ ‚ñπ œÜ and I want to get to ‚ä¢ œÅ ‚ñπ h (u œÜ).
Can do directly with the unit œÜ ‚â§ h (u œÜ), or with the counit
f (v œÅ) ‚â§ œÅ to get ‚ä¢ f (v œÅ) ‚ñπ œÜ and then transposing.

=== 2017.09.22

Q: Why do I think that ‚ôØL should clear the context of coherent
assumptions? [Adj2] doesn't do that, and indeed I have a harder time
convincing myself cut goes through with my version.
A:
I got to this by thinking through how
Œî, Œì, ‚ôØA[r] ‚ä¢ C
‚áî
Œî @ œÅ‚ÇÅ, Œì @ œÅ‚ÇÇ, ‚ôØA @ œÅ‚ÇÉ, C @ œÜ ‚ä¢ f(œÅ‚ÇÅ * œÅ‚ÇÉ), œÅ‚ÇÇ ‚ñπ œÜ
seems to require dropping the œÅ‚ÇÇ to get
f(œÅ‚ÇÅ * œÅ‚ÇÉ) ‚ñπ œÜ
and from there
fœÅ‚ÇÅ * fœÅ‚ÇÉ ‚ñπ œÜ
fœÅ‚ÇÅ * fœÅ‚ÇÉ ‚ñπ œÜ
œÅ‚ÇÉ ‚ñπ u(u(fœÅ‚ÇÅ ‚ä∏ œÜ))
so I can unpack the ‚ôØA @ œÅ‚ÇÉ to get
Œî @ œÅ‚ÇÅ, Œì @ œÅ‚ÇÇ, A @ œÅ', C @ œÜ ‚ä¢ œÅ‚ÇÉ ‚ñπ u(fœÅ‚ÇÅ ‚ä∏ œÜ)
which is equivalent to
Œî @ œÅ‚ÇÅ, Œì @ œÅ‚ÇÇ, A @ œÅ', C @ œÜ ‚ä¢ fœÅ‚ÇÅ * fœÅ' ‚ñπ œÜ
...
Ohhh this is all just a mistake. I can transform
f(œÅ‚ÇÅ * œÅ‚ÇÉ), œÅ‚ÇÇ ‚ñπ œÜ
to
fœÅ‚ÇÅ * fœÅ‚ÇÉ ‚ñπ œÅ‚ÇÇ ‚ä∏ œÜ
fœÅ‚ÇÉ ‚ñπ fœÅ‚ÇÅ ‚ä∏ œÅ‚ÇÇ ‚ä∏ œÜ
ffœÅ‚ÇÉ ‚ñπ fœÅ‚ÇÅ ‚ä∏ œÅ‚ÇÇ ‚ä∏ œÜ
œÅ‚ÇÉ ‚ñπ uu(fœÅ‚ÇÅ ‚ä∏ œÅ‚ÇÇ ‚ä∏ œÜ)
which gives me
Œî @ œÅ‚ÇÅ, Œì @ œÅ‚ÇÇ, A @ œÅ', C @ œÜ ‚ä¢ œÅ' ‚ñπ u(fœÅ‚ÇÅ ‚ä∏ œÅ‚ÇÇ ‚ä∏ œÜ)
or equivalently
Œî @ œÅ‚ÇÅ, Œì @ œÅ‚ÇÇ, A @ œÅ', C @ œÜ ‚ä¢ fœÅ‚ÇÅ * fœÅ' * œÅ‚ÇÇ ‚ñπ œÜ

Q: Reading [ShuFix], what's an example of a mono in Top that's not a subspace inclusion?
A: Take
I = [0,1)
and map I into ‚ÑÇ via
Œªx.exp(2œÄxi)
You get the unit circle, which as a subspace has a different topology from I.

Q: No, this doesn't seem right. What do the brackets around P mean on page 15 of [ShuFix]?
A: ???

=== 2017.09.23

Q: What is the essential reason why valid assumptions, and therefore
boxed types, must depend only on valid things?
A: Because when I clear the context, I can't strand them from the
hypotheses they need to be valid.

Imagine I have signature
A : type
B : A ‚Üí type
and try to prove
a : A true, b : (B a) valid ‚ä¢ ? : ‚ñ° C
I'll immediately try to construct, via ‚ñ°R,
b : (B a) valid ‚ä¢ ? : C
which is nonsense.

Q: How does this play out with categorified judgmental levels?
A: Not 100% sure yet. Wonder if I want to think of the context as a
graph whose edges are morphisms in the level category, or else maybe
allow context annotations to have 'zeroes' in them. I could imagine an
invariant something like

If Œì[Œ≥], x :_p A[m], Œì'[Œ≥'] ‚ä¢ J_q

then for some Œ≥‚ÇÄ such that Œ≥‚ÇÄm ‚äÜ Œ≥ we have

Œì[Œ≥‚ÇÄ] ‚ä¢ A : type_p

A zero in Œì[Œ≥‚ÇÄ] means 'weaken that variable away'
A zero is ‚äÜ any morphism, but otherwise in Œ≥‚ÇÄm ‚äÜ Œ≥ everything has to agree.

This is meant to make

x :_p A[m]

behave just like

x :_q (F_m A) [id_q]

Whose intro rules (for m : p ‚Üí q) I imagine go something like

Œì[Œ≥‚ÇÄ] ‚ä¢ A : type_p    Œ≥‚ÇÄm ‚äÜ Œ≥
-----------------------------
Œì[Œ≥] ‚ä¢ F_m A : type_q

Œì[Œ≥‚ÇÄ] ‚ä¢ M :_p A    Œ≥‚ÇÄm ‚äÜ Œ≥
---------------------------------
Œì[Œ≥] ‚ä¢ F_m M :_q F_m A

Q: What happens if I think of the context as a graph whose edges are labelled with morphisms?
A: I think I want to require commutativity of every diagram implied by
the graph? Or do I? My gut says it's probably required for some
substitution theorem or something.

Q: Is it possible for a neutral expression to have a type that
involves the constant at the head?
A: Sure, here's an example
<<<
module b where

postulate
  o : Set
  a : o -> Set
  b : (y : o) ‚Üí a y
  c : (y : o) ‚Üí a y -> o
  k : o

term : a (c k (b k))
term = b (c k (b k))
>>>

Q: Where did I put some notes about how 2-categorical modalities work
in dependent types?
A: /Users/jreed/wes/texnotes/2017-09-23.ltx

=== 2017.09.24

Q: What's a property I might want to pragmatically require for mode
theories to make typechecking tractable?
A:
If a ‚àò b = c, then
(a) there exists a maximal a' such that a' ‚àò b = c
(b) there exists a maximal b' such that a ‚àò b' = c
where a 'maximal' morphism means one that is the most useful attached
to an assumption. In the idempotent theory of 1 and r, I'm thinking of r ‚â• 1,
and indeed in that situation, I have a best solution (namely r) to both
r ‚àò ? = r
? ‚àò r = r
and a unique solution (namely r) to both
1 ‚àò ? = r
? ‚àò 1 = r
and a unique solution (namely 1) to both
1 ‚àò ? = 1
? ‚àò 1 = 1
and no solution (which is ok) to both
r ‚àò ? = 1
? ‚àò r = 1

Q: What do I make of [Fib2]?
A: The main thing that strikes me is why go to all the effort of
designing and proving coherent a system when you can just translate it
away to FOL, but that's my bias showing.

Q: What's going on with the embedding/encoding distinction in [Fib2]?
(search "A point of contrast with substructural logical frameworks")
A: ???

Q: What are the implications of thinking about two-cells between mode morphisms
(saying things like u ‚àò f ‚â§ 1) versus merely talking about preorders on 'terms'
(saying things like ‚àÄx . u(f(x)) ‚â§ x)
A: ???

Q: What am I getting out of reifying frames instead of what [Fib2] does, namely
thinking of them as structures-with-a-hole?
A: I guess greater uniformity of definition? My F rules look just like
my U rules with different sorts. I can represent classical logic as a
thing with frame constructors?

Q: Is it still possible to carry out a focusing proof for every logic
you can define in [Fib2]?
A: I think maybe yes; because the moment you throw in ‚äô, it's
impossible not to allow the definition of residuals x ‚äô - and - ‚äô x
which correspond to frame operations x ‚Ü£ - and x ‚Ü† -. So control over
frames (as opposed to abstractions) is what lets you define less
focally good logics like queue logic.

Q: What's that other paper dlicata@ thought would be an application of modalities?
A: [OrtonPitts]

=== 2017.09.25

Q: What's something to look for in [ShuFix]?
A: How exactly the properties of ‚ôØ and ‚ô≠ on top of their modal nature
get axiomatized.

Q: To what extent can the same be done with  É?
A: ???

Q: What's a sensible tack on dependent modal stuff?
A: To aggressively track how every type depends modally on its
context.

=== 2017.09.26

Q: Where's my ticket for account renaming?
A: https://wesleyanedu.service-now.com/ess//incident_status.do

Q: Does anything go wrong with totally decoupled term bundles from type bundles
A: ???

=== 2017.09.27

Q: What's the dance we have to do to justify the type upstairs in $FL$ is well-formed?
A:
Something like
<<<
$$\Gamma, y: A^{\alpha} \prov y^{y:=1} : A^{\alpha}$$
$$\Gamma, y: A^{\alpha} \prov (F^{y:=1}_\mm y)^{y:=m} : (F^\alpha_\mm A)^{\alpha'}$$
$${\Gamma, x:(F^\alpha_\mm A)^{\alpha'} \prov   C^\gamma : \rtype}$$

$${\Gamma, y : A^\alpha, x:(F^\alpha_\mm A)^{\alpha'} \prov   C^{\gamma, y := m\gamma(x)} : \rtype}$$
$$
\erule
{\Gamma \prov N^\nu : A^\alpha\qquad \Gamma, x:A^\alpha, \Gamma' \prov M^{\mu} : C^\gamma \qquad \mu \ge \nu \mu(x) \qquad \gamma \ge \nu \gamma(x) \using sub}
{\Gamma, [N^\nu / x]\Gamma' \prov [N^\nu / x] (M^\mu) : [N^\nu / x](C^\gamma)}
$$
>>>
but I'm not super confident in this.

=== 2017.09.28

Q: In [RS] what's an example of a non-exponentiable map between categories?
A: ???

=== 2017.09.29

Q: In [RS], looking at the extension type
 ‚ü® Œ†_{t : I | œà} A |^œÜ_{t.a} ‚ü©
is it possible for A's well-formedness to depend on œà without actually
mentioning t?

(I'm trying to understand when exactly the notation
‚ü® { t : I | œà } ‚Üí A |^œÜ_{t.a} ‚ü©
is justified, as defined at the end of section 2)
A: ???

Q: Where's avezzosi@'s agda implementation stuff for ‚ô≠?
A: agdac//1f943c9 and agdac//154073c , the difference from branch parametric to branch flat.

DONE: convinced IT to let me change my wesleyan account to jcreed@, I
think.

=== 2017.09.30

Q: How to get Skim to open a pdf to a certain page?
A:
https://emacs.stackexchange.com/questions/30344/how-to-link-and-open-a-pdf-file-to-a-specific-page-skim-adobe
links to org-mac.el at
http://orgmode.org/worg/org-contrib/org-mac-link.html
Or wait I can get by on the commandline with just
$ open -a /Applications/Skim.app some.pdf
and I don't even need to give a full path like I do with
$ open /Applications/Skim.app --args `pwd`/some.pdf

Q: How do I reload a file from applescript?
A:
$ osascript -e 'tell document "some.pdf" of application "Skim" to revert'


Q: What's a particular fixing of notation for the cast of characters in a fibration
that makes it look like a pullback?
A:
<<<
œÄ : ‚Ñ∞ ‚Üí ‚Ñ¨

 x
   œÜ   œà
     a   -f‚Üí   b
 ‚ÜßœÄ
   ‚ÜßœÄ
 X   ‚ÜßœÄ   ‚ÜßœÄ   ‚ÜßœÄ
   Œ¶
     A   -F‚Üí   B
>>>

"œÄ is a fibration" = ‚àÄ (A B : ‚Ñ¨)(F : A ‚Üí B)(b : œÄ‚Åª¬π B) ‚Üí ‚àÉ (a : œÄ‚Åª¬π A) (f : a ‚Üí b) √ó f is cartesian.

"f is cartesian" = ‚àÄ (X : ‚Ñ¨) (x : œÄ‚Åª¬π X) (Œ¶ : X ‚Üí A) (œà : œÄ‚Åª¬π (F ‚àò Œ¶) : x ‚Üí b) ‚Üí ‚àÉ! (œÜ : œÄ‚Åª¬π Œ¶ : x ‚Üí a) √ó (f ‚àò œÜ = œà)


Q: What does the bifibration situation look like for the mode 2-multicategory just being a monoid?
A:
<<<
    Œì .
     \  ' .
      \     ' .
    ‚Üß  ‚Üò        '‚Üò
        UA -----‚Üí A
        m
    * .
     \  ' . nm    ‚Üß
    n \     ' .
       ‚Üò        '‚Üò
        * ------‚Üí *
             m

Œì ‚ä¢[nm] A
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Œì ‚ä¢[n] UA

    C ‚Üñ
     ‚Üñ  ' .
      \     ' .
    ‚Üß  \        '
        FA ‚Üê----- A
        m
    * ‚Üñ
     ‚Üñ  ' . mn    ‚Üß
    n \     ' .
       \        '
        * ‚Üê------ *
             m

A ‚ä¢[mn] C
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
FA ‚ä¢[n] C
>>>

=== 2017.10.01

Q: How do I want to generalize the following?
<<<
Suppose I have a fibration
    œÄ
ùîº ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí ùîπ

I can also think of this as a single category ‚ÑÇ living over the arrow category

    p
ùêÑ ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí ùêÅ

The objects in ‚ÑÇ living over ùêÑ are the objects of ùîº.
The objects in ‚ÑÇ living over ùêÅ are the objects of ùîπ.
The arrows in ‚ÑÇ living over 1_ùêÑ are the arrows of ùîº.
The arrows in ‚ÑÇ living over 1_ùêÅ are the arrows of ùîπ.
The remaining arrows in ‚ÑÇ are pairs (E, b) where E is an object
of ùîº and b is an arrow œÄE ‚Üí B in ùîπ.

Composition should be pretty clear. The interesting case is
when we compose e : E1 ‚Üí E2 upstairs with a transverse b : œÄE2 ‚Üí B
and the answer is (b ‚àò œÄe) : œÄE1 ‚Üí B

In general, if F : ‚ÑÇ ‚Üí ùîª and p is an arrow in ùîª, we say _‚ÑÇ has
pullbacks along p_ if the pullback universal property holds like

      X   ‚Üí
        ‚Üò
      ‚Üì   E ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí E'
          ‚îÇ        ‚îÇ
          ‚îÇ        ‚îÇ
          ‚Üì        ‚Üì
          B ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí B'

          over

      ùêÑ   =
        =
      p   ùêÑ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê ùêÑ
          ‚îÇ        ‚îÇ
          p        p
          ‚Üì        ‚Üì
          ùêÅ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê ùêÅ
>>>
A: I think I just want to say: suppose F : ‚ÑÇ ‚Üí ùîª is a functor.
We say a diagram in ùîª like

                   B
                   ‚îÇ
                   ‚îÇg
                   ‚Üì
          C ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí D
              f

has an F-pullback if first of all there is a pullback in ùîª

               œÄ‚ÇÇ
         B√óC ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí B
          ‚îÇ‚îÄ‚îò      ‚îÇ
        œÄ‚ÇÅ‚îÇ        ‚îÇg
          ‚Üì        ‚Üì
          C ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí D
              f

And every ‚ÑÇ-cospan over BCD has a universal cone over œÄ‚ÇÅ,œÄ‚ÇÇ?

Q: So what's the definition of fibration given this idea?
A:
You start with your
    œÄ
ùîº ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí ùîπ

and construct from it ‚ÑÇ ‚îÄF‚Üí (ùêÑ ‚îÄp‚Üí ùêÅ), and demand that p and 1_ùêÅ have
an F-pullback.

Q: Is this the same as F 'creating the pullback of f and g'
A: ???

Q: Relevant links to this question?
A:
https://mathoverflow.net/questions/103065/what-is-the-correct-definition-of-creation-of-limits
https://ncatlab.org/nlab/show/created+limit
http://permalink.gmane.org/gmane.science.mathematics.categories/6644

Q: Is the functor over ùêÑ ‚îÄp‚Üí ùêÅ itself a fibration?
A: Hmm maybe it's an opfibration. Given E, I can certainly lift along
p to œÄE, where the requisite transverse arrow is 1_{œÄE}.

          œÄE ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ E

          ‚Üß        ‚Üß

          ùêÅ ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ùêÑ
               p

Yeah that would require all transverse arrows E ‚Üí B to correspond to
B-arrows that look like œÄE ‚Üí B, which seems true.

Q: Actually wait I'm not so sure about my definition in terms of
F-pullbacks, now. It seems prima facie more general than the fibrancy
condition. When I choose something over

                   ùêÑ
                   ‚îÇ
                   p
                   ‚Üì
          ùêÅ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê ùêÅ

it's not just a ùîπ-morphism downstairs, and an *object* of ùîº, it's a
ùîπ-morphism and a transverse morphism. Does being a fibration guarantee
an F-pullback of _that_?
A: Let's try. I start out with the data

                   E'
                   ‚Üß
                  œÄE'
              b    ‚Üìc'
          B ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí B'

Can I at least form the putative pullback square? Ugh, no, because c'
is going the wrong way. Let's try reversing it?

                   E'
                   ‚Üß
                  œÄE'
              b    ‚Üëc'
          B ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí B'

Hmmm now I've got transverse morphism living over E ‚îÄp‚Üí B is actually
made up of a morphism B ‚Üí œÄE not the other way around. I tried drawing
the diagram

          E ‚îÄ‚îÄe‚îÄ‚îÄ‚Üí E'
          ‚Üß        ‚Üß
         œÄE ‚îÄœÄe‚îÄ‚îÄ‚Üí œÄE'
          ‚ïë        ‚Üëc'
          B ‚îÄ‚îÄb‚îÄ‚îÄ‚Üí B'

which does seem to arise out of fibrancy but I can't seem to
understand what composition in ‚ÑÇ is anymore. Grr.

---

Ok, how about, desperate measures here, maybe ùîª is
        p,q
e ‚ü≥ ùêÑ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí ùêÅ ‚ü≤ b

with all of ùîπ living over b instead of 1_ùêÅ, all of ùîº living over e
instead of 1_ùêÑ and

b ‚àò p = b ‚àò q = q = p ‚àò e = q ‚àò e = q
e ‚àò e = e   b ‚àò b = b

The morphisms that live over p are just pairs (E, œÄE) with no real
morphism content. A morphism that lives over q is what I was trying to
define as a transverse morphism before, namely a triple (E, f, B) with
f : œÄE ‚Üí B.

Now I think I want to consider the pullback of b against p, and I'm
not even sure I can pull that off in this ùîª. Or wait, maybe I can...

              e
          ùêÑ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí ùêÑ
          ‚îÇ‚îÄ‚îò      ‚îÇ
         p‚îÇ        ‚îÇp
          ‚Üì        ‚Üì
          ùêÅ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí ùêÅ
              b

at least commutes. Is it a pullback? The only thing X can be is ùêÑ. The
only thing that the overall diagonal can be is q, because p doesn't
factor through b. So the top input projection has to be e not 1_ùêÑ. The
side input projection could be either p or q. But either of these has
a unique solution:

      ùêÑ   e
        e
      q   ùêÑ ‚îÄ‚îÄe‚îÄ‚îÄ‚Üí ùêÑ
          ‚îÇ‚îÄ‚îò      ‚îÇ
          p        ‚îÇp
          ‚Üì        ‚Üì
          ùêÅ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí ùêÅ
              b

      ùêÑ   e
        1
      p   ùêÑ ‚îÄ‚îÄe‚îÄ‚îÄ‚Üí ùêÑ
          ‚îÇ‚îÄ‚îò      ‚îÇ
          p        ‚îÇp
          ‚Üì        ‚Üì
          ùêÅ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí ùêÅ
              b

Ok, suppose fibrancy, to show pullbacks exist upstairs in ‚ÑÇ. I've got

                   E'

                   ‚Üß

          B ‚îÄ‚îÄf‚îÄ‚îÄ‚Üí œÄE'

living over

                   ùêÑ
                   ‚îÇ
                   p
                   ‚Üì
          ùêÅ ‚îÄ‚îÄb‚îÄ‚îÄ‚Üí ùêÅ

and fibrancy gives me

          E ‚îÄ‚îÄg‚îÄ‚îÄ‚Üí E'

          ‚Üß        ‚Üß

          B ‚îÄ‚îÄœÄg‚îÄ‚Üí œÄE'

with œÄg = f and œÄE = B. This means the e-arrow g composed with the
p-arrow for E' is the transverse arrow (E, œÄg, œÄE'), and so too is the
composite of trivial p-arrow for E and the b-morphism œÄg. I think the
more difficult case of checking that it's a pullback is the left input
projection being q. So imagine

      X        h
                 ‚Üò
      ‚Üß   E ‚îÄ‚îÄg‚îÄ‚îÄ‚Üí E'
     œÄX
      k   ‚Üß        ‚Üß
        ‚Üò
          B ‚îÄ‚îÄf‚îÄ‚îÄ‚Üí B'

living over

      ùêÑ        e
                 ‚Üò
          ùêÑ ‚îÄ‚îÄe‚îÄ‚îÄ‚Üí ùêÑ
          ‚îÇ‚îÄ‚îò      ‚îÇ
      q   p        ‚îÇp
        ‚Üò ‚Üì        ‚Üì
          ùêÅ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí ùêÅ
              b

That is, we have a transverse k : œÄX ‚Üí B in ùîπ and an h : X ‚Üí E' in ùîº
such that œÄh = f ‚àò k. That's exactly what fibrancy wants to give us a
unique arrow X ‚Üí E over k satisfying the appropriate commutativities,
I think.

Q: What's an example of noncofibrant spaces? I.e. map from 0 to the
space is not a cofibration?
A:
https://lists.lehigh.edu/pipermail/algtop-l/2009q1/000332.html
says

one-point compactification of countably infinite discrete space
warsaw circle

but I'm not sure which notion of cofibration is supposed to be going
on for them.

=== 2017.10.02

Q: Some stuff on model categories?
A: http://etale.site/writing/model-cats-for-algebraists.pdf

Q: Big ol book on topology and algebraic topology? Chapter 7 on
cofibrations?
A: http://groupoids.org.uk/pdffiles/topgrpds-e.pdf

Q: What's an example of a Serre fibration (fibrant wrt CW complexes) that's not
a Hurewicz fibration (fibrant wrt all spaces)?
A: https://mathoverflow.net/questions/241575/serre-fibration-vs-hurewicz-fibration

=== 2017.10.03

Q: Does avezzosi@'s flat branch also have cubical stuff in it?
A: Looks like yes.

Q: How do I exercise composeRelevance in
agda//src/full/Agda/Syntax/Common.hs
?
A:
Well it gets called in
agda//src/full/Agda/TypeChecking/Rewriting/NonLinMatch.hs
which defines the typeclass PatternFrom with method patternFrom
which gets called in
agda//src/full/Agda/TypeChecking/Rewriting.hs
in addRewriteRule which call comes after analyzing a Def from type
DeclCont defined in
agda//src/full/Agda/Auto/Syntax.hs
and that Def comes from a variable core living in a TelV which is defined in
agda//src/full/Agda/TypeChecking/Substitute.hs
That data came out of the function telView defined in
agda//src/full/Agda/TypeChecking/Telescope.hs

Q: Why does branch-flat agda get hung up on
{-# COMPILE GHC Level = type () #-}
in
agdalib//prim/Agda/Primitive.agda
?

Q: Well, where does {-# COMPILE GCH ... #-} come from?
A: I don't see COMPILE in
agda//src/full/Agda/Syntax/Parser/Lexer.x
which is sort of worrying.

Ugh it's not something to do with the pragma sharps, is it?
A: Ohhh no, it's because
/.cabal/share/x86_64-osx-ghc-7.10.3/Agda-2.6.0/lib/prim/Agda/
is not properly in version control I think.

Q: What's awesome in making sure I'm not going crazy?
A: agda2-display-program-version
displays the git commit it was compiled at, hallelujah.

Q: Where does this get generated?
A:
agda//src/full/Agda/VersionCommit.hs

Q: So what's going on with
agda//src/data/lib/prim/Agda/Primitive.agda
?
A: Ah, a relatively recent commit agdac//d1e6a0d (which postdates
avezzosi@'s commit) changed the format of these pragmas.

Q: Where does agda look for Primitive.agda?
A:
Well, doing
(setq agda2-program-args '("--no-default-libraries"))
doesn't help.
...
Aha,
agda//CHANGELOG.md (grep for Primitive.agda)
says I want to set environment variable
Agda_datadir

Q: From the commandline, does
$ export Agda_datadir=/Users/jreed/.cabal/sandboxes/agda-build/agda/src/data
work?
A: Yeah!

Q: From elisp?
A:
(setenv "Agda_datadir" "/Users/jreed/.cabal/sandboxes/agda-build/agda/src/data")
and restart the agda process.

Q: Starting point for problems with jump-to-definition?
A: https://stackoverflow.com/questions/28666113/goto-definition-in-emacs-haskell-mode

Q: Where do agda compile logs go when I don't say --verbose?
A: less +F /Users/jreed/.cabal/logs/Agda-2.6.0.log

Q: What should I be using instead of cabal install?
A: make install-bin I guess?

=== 2017.10.04

Q: What's Tom Leinster's aha moment about nerves of categories?
A: https://golem.ph.utexas.edu/category/2008/01/mark_weber_on_nerves_of_catego.html

Q: What's a case where being a fibrant object is nontrivial in a way I understand?
A: The classical model structure on simplicial sets; being a fibrant
object is the same as being a kan complex, i.e. having fillers for all
horns.

Q: What's the intuition for discrete fibrations?
A: With my Grothendieck glasses on, a fibration of categories is like
a functor ‚ÑÇ^op ‚Üí Cat, whereas a discrete fibration is like a functor
‚ÑÇ^op ‚Üí Set.

Suppose œÄ : ùîª ‚Üí ‚ÑÇ comes from the fibers of a presheaf. Then whenever
we have D ‚àà ùîª living over C2 and f : C1 ‚Üí C2, there is a *unique* g
living over f which tells us how to pull the object cod g (an element
of the fiber over C2) back to the object dom g (an element of the
fiber over C1). The fiber over an object is a discrete category from
considering the identity arrows.

Q: Do Street fibrations help me repair the idea from 2017.10.01?
A: Hm, not that I can see, yet. If I say a 'transverse morphism'
living over p is a ‚Ü¶ followed by an iso, then I still can't
post-compose on an arbitrary (i.e. non-iso) ùîπ-morphism.

=== 2017.10.05

Q: Where did I find something on nLab about a fibrationy generalization of profunctors?
A: https://ncatlab.org/nlab/show/Grothendieck+fibration#twosided_version

Q: Where did I find a nice characterization of cartesian morphisms as pullbacks of homsets?
A: http://maths.mq.edu.au/~street/Cicasm.pdf "Categories in categories, and size matters" Ross Street

Q: So am I right that this whole business with comprehension
categories or categories with families is to resolve the mismatch
between syntax, where substitution is associative on the nose, and
naive lccc semantics, where it's not? If we do synthetic,
suitably-univalent category theory, do we get any wins here? Can we
just do the naive lccc thing and get that substitution is associative
up to a path?
A: ???

Q: What's a nice easy-going narrative of all this fibrationy stuff?
A: http://www.cs.nott.ac.uk/~psxpc2/report-2013.pdf "Type Theory through Comprehension Categories"

Q: What do nonfibration functors correspond to Grothendieck-wise?
A: Functors from the base category ùîπ into Prof instead of Cat; that is,
the fibers are connected by profunctors (morphisms in Prof) rather
than functors (morphisms in Cat)
...
More concretely, say I have F : ùîº ‚Üí ùîπ. I want to think of this as a
functor ùîπ^op ‚Üí Prof. An object B in ùîπ goes to its fiber F^*(B) like normal.
A morphism f : B1 ‚Üí B2 in ùîπ should go to some profunctor F^*(B2) ‚Üí F^*(B1), i.e.
a functor F^*(B1)^op √ó F^*(B2) ‚Üí Set. But that's easy; let it be the fiber over f.
The object part is
f‚ôØ(E1, E2) = { e : E1 ‚Üí E2 ‚àà ùîº | F E1 = B1, F E2 = B2, F e = f }
and the arrow part on the first argument is
<<<
f‚ôØ(k : E1a ‚Üí E1b over id_B1, E2) = (Œª e . e ‚àò k) :
{ e : E1b ‚Üí E2 ‚àà ùîº | F e = f }
‚Üí
{ e : E1a ‚Üí E2 ‚àà ùîº | F e = f }
>>>
and the arrow part on the second argument is
<<<
f‚ôØ(E1, k : E2a ‚Üí E2b over id_B2) = (Œª e . k ‚àò e) :
{ e : E1 ‚Üí E2a ‚àà ùîº | F e = f }
‚Üí
{ e : E1 ‚Üí E2b ‚àà ùîº | F e = f }
>>>
I see now how it's critical that things live over the identity so the
equation F e = f still holds after composition.

Q: How do we make a representable profunctor?
A:
F : ùî∏ ‚Üí ùîπ becomes F‚ôØ : ùî∏ √ó ùîπ^op ‚Üí Set via
F#(A, B) = ùîπ(B, F(A))
F#(f : A1 ‚Üí A2, B) = Œªg : ùîπ(B, F(A1)). Ff ‚àò g
F#(A, f : B1 ‚Üí B2) = Œªg : ùîπ(B2, F(A)). g ‚àò f

Q: How do I VPN?
A: http://www.wesleyan.edu/its/services/wireless/vpn.html

Q: How do I do email forwarding?
A: http://www.wesleyan.edu/its/services/accounts/desktop.html

Q: Why can't I view e.g. http://exchange.blogs.wesleyan.edu/
A: Had to be on VPN to make progress, but still can't read.
"Topics related to Outlook and Entourage can be viewed by administrators only."

Q: wesleyan webmail?
A: https://owa.wesleyan.edu/owa/

Q: What started making sense of ends and coends for me?
A: https://ncatlab.org/nlab/show/extranatural+transformation

Q: So where do I find the terms in a comprehension category?
A: ???

Q: What's the answer to the question about [RS] theorem 4.4 I asked Mike?
A: I can find the question in my email by searching for
<<<
I'm taking another pass over this paper trying to digest as much as I
can; really enjoying it. Here's a question that maybe has an easy
answer. I'm just wondering if I'm misunderstanding something that
should be obvious.
>>>
the answer I've generated for myself for now is
<<<
{-# OPTIONS --without-K #-}
module a where

open import HoTT

pre : {A B : Set} (f : A ‚Üí B) (b : B) ‚Üí Set
pre {A} {B} f b = Œ£ A (Œª a ‚Üí f a == b)

lem : {A B C : Set} (f : A ‚Üí B) (g : B ‚Üí C) (c : C)
  ‚Üí pre (g ‚àò f) c ‚âÉ Œ£ (pre g c) (Œª k ‚Üí pre f (fst k))
lem {A} {B} {C} f g c  = equiv into out zig zag where
  into : pre (g ‚àò f) c ‚Üí Œ£ (pre g c) (Œª k ‚Üí pre f (fst k))
  into (a , gfa/c) = ((f a) , gfa/c) , a , idp
  out : Œ£ (pre g c) (Œª k ‚Üí pre f (fst k)) ‚Üí pre (g ‚àò f) c
  out ((b , gb/c) , a , fa/b) = a , (ap g fa/b ‚àô gb/c)
  zig : (b : Œ£ (pre g c) (Œª k ‚Üí pre f (fst k))) ‚Üí into (out b) == b
  zig ((.(f a) , idp) , a , idp) = idp
  zag : (a : pre (g ‚àò f) c) ‚Üí out (into a) == a
  zag (a , gfa/c) = idp

ext : {A B Q : Set} (f : A ‚Üí B) (q : A ‚Üí Q) ‚Üí Set
ext {A} {B} {Q} f q = Œ£ (B ‚Üí Q) (Œª h ‚Üí h ‚àò f == q)

thm : {œÜ œà œá X : Set} (f : œÜ ‚Üí œà) (g : œà ‚Üí œá) (q : œÜ ‚Üí X)
  ‚Üí ext (g ‚àò f) q ‚âÉ Œ£ (ext f q) (Œª k ‚Üí ext g (fst k))
thm f g q = lem (_‚àò g) (_‚àò f) q
>>>
which is to say, indeed, in the nondependent case, having a two-step
extension is the same as having a one-step extension along the
composite.

=== 2017.10.06

Q: What's a great early post ideas that fed into [RS]?
A: https://golem.ph.utexas.edu/category/2012/06/directed_homotopy_type_theory.html

Q: Stuff about stratified spaces that david corfield mentioned in the comments on that post?
A:
https://ocw.mit.edu/courses/mathematics/18-965-geometry-of-manifolds-fall-2004/lecture-notes/lecture12.pdf
http://aimsciences.org/journals/pdfsnews.jsp?paperID=2468&mode=full
https://ncatlab.org/nlab/show/poset-stratified+space#AFRshh

Q: Where's the other post that I'm thinking of?
A: Ah, it's by eriehl@:
https://golem.ph.utexas.edu/category/2017/05/a_type_theory_for_synthetic_ca.html

Q: What's the obstacle to constructing a subuniverse or something that
is Segal, (with specifically the functions between types being the
morphisms) if the universe as is isn't? Can't I just make a DHIT for
this?
A: Well... I realize I need the DHIT to include data for the way that
functions actually do compose. In pseudo-Agda I might say something
like
<<<
data Fset : Set‚ÇÅ where
  name : Set ‚Üí Fset
  mor : {A B : Set} (f : A ‚Üí B) ‚Üí hom (name A) (name B)
  comp : {A B C : Set} (f : A ‚Üí B) (g : B ‚Üí C) ‚Üí (mor f ‚àô mor g) == mor (g ‚àò f)
>>>
where ‚àô denotes segal composition (which I guess I just kind of
presume is freely generated ‚Äî I guess by DHIT I mean 'segal HIT' or
perhaps 'rezk HIT'?) , and ‚àò denotes function composition. Or else
constructing a DHIT doesn't presume segalness, and instead what I
should be doing is throwing in an appropriate 2-simplex for each
function composition, then *proving* somehow that the result is segal.

=== 2017.10.07

Q: Is there any sense in which a bifibration looks like a category of relations on top of a relation?
A: Seems like it, yes.

=== 2017.10.08

Q: For type-checking, and therefore definitional-equality-checking in
[RS]-world, can I get away with considering all finitely many
disjunctive possibilities, as dlicata@ suggested?
A: Yeah, I think maybe so; maybe this even obviates needing to think hard about Œ∑?
I tend to thing that
œÜ ‚à® œà ‚ä¢ a ‚â° rec^{œÜ,œà}_‚à®(b, c) ‚áê‚áí (œà ‚à® (a ‚â° b)) ‚àß (œÜ ‚à® (a ‚â° c))
or maybe equivalently
œÜ ‚à® œà ‚ä¢ a ‚â° rec^{œÜ,œà}_‚à®(b, c) ‚áê‚áí (œÜ ‚áí (a ‚â° b)) ‚àß (œà ‚áí (a ‚â° c))
?

Q: What do I get out of that parametricity-via-bifibrations paper [JG] that dlicata@ mentioned?
A: Not a whole lot yet; I think I'm in a position of somewhat greater
generality by considering an arbitrary finite-product-preserving
bifibration ‚ÑÇ ‚Üí ùîª, for whatever that's worth.

=== 2017.10.09

Q: What's a thought I had about constructivity and cubical stuff?
A: Constructive logic restricts the things you get to do *so that*
every implication you prove is computational, every existential you
prove computes a witness, etc. etc.

What we're finding out with every parametricity theorem we prove, and
with every HoTT-esque system we invent, is that similarly we can
restrict the things we get to do --- in a way that turns out to be
barely any more restrictive than the level of constructiveness we
already got used to --- so that every function is functorial, every
transformation is natural, etc. etc.

The game is not to create a psychologically *noticeable* burden on
programmers by making them annotate how morphisms are preserved, how
naturality squares are created, etc., but rather to discover the set
of operations that preserve things things in a (to use the word
informally) natural (one might say 'effortless') way.

=== 2017.10.10

Q: How make 2-cells in tikzcd?
A:
mshulman@ suggests
<<<
\def\twocell#1{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,from=\mynodeone,to=\mynodetwo]%
}
>>>
in
https://tex.stackexchange.com/questions/362743/2-cells-in-tikz-cd

Q: What else do I need to demand of a cartesian bifibration so that Cat has
a full and faithful embedding in it?
A: Something like a distinguished subcategory of the total category of
the bifibration that consists of the "vertically iso" objects. With
this I can detect that binary relations are functional (because the
opreindexically obtained projection to the domain should then be iso
in this sense) and since fibered maps from one bifibration to another
will have to preserve opreindexing and also this subcategory, we'll
have a functional relation in the output category also.

=== 2017.10.11

Q: Can I characterize trivial objects upstairs in a product-preserving bifibration
by saying that they are the locally terminal objects?
A: Maybe. To be clear, I mean an object Y over A is trivial
if for any other object X over A, there's a unique map X ‚Üí Y over the identity.

             !f
          X ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí Y
          ‚î¨       ‚î¨
          ‚îÇ       ‚îÇ
          ‚Üì       ‚Üì
          A ‚ïê‚ïê‚ïê‚ïê‚ïê A

In the codomain bifibration, the trivial objects are the isomorphisms.
If a morphism s in the arrow category is an iso, then we can compute the
unique filler s‚Åª¬πx.

            s‚Åª¬πx
          X ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí Y
          ‚îÇ       ‚îÇ
        x ‚îÇ       ‚îÇ s
          ‚Üì       ‚Üì
          A ‚ïê‚ïê‚ïê‚ïê‚ïê A

If an s is locally terminal, we can find its inverse via

             s‚Åª¬π
          A ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí Y
          ‚îÇ       ‚îÇ
        1 ‚îÇ       ‚îÇ s
          ‚Üì       ‚Üì
          A ‚ïê‚ïê‚ïê‚ïê‚ïê A

We know that s ‚àò s‚Åª¬π = 1, what about the opposite?

              s      s‚Åª¬π
          Y ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí A ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí Y
          ‚îÇ       ‚îÇ       ‚îÇ
        s ‚îÇ       ‚îÇ 1     ‚îÇ s
          ‚Üì       ‚Üì       ‚Üì
          A ‚ïê‚ïê‚ïê‚ïê‚ïê A ‚ïê‚ïê‚ïê‚ïê‚ïê A

Use the uniqueness in the the fact that s is locally terminal.

Q: Oh wait, this notion doesn't seem stable up to ismorphism in ùîº. What do?
A: I think I can just generalize it to: Y over B is trivial if for any
X over A and any g downstairs, there's a unique f over g.

             !f
          X ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí Y
          ‚î¨       ‚î¨
          ‚îÇ       ‚îÇ
          ‚Üì       ‚Üì
          A ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí B
              g

Q: Should I drop the condition that any opcartesian morphism whose
codomain is trivial is split epi?
A: I can't seem to prove it for the above notion of `trivial', though
I can prove it in the codomain bifibration. It seem to inherently
require upstairs morphisms leaking downstairs, which makes sense in
the codomain bifibration, but won't when I have arbitrary relations
upstairs and just the free product category downstairs.

=== 2017.10.12

Q: What's a dead simple recharacterization of trivial objects?
A: They're the objects for which the unique map into the terminal
object is cartesian! This smells a lot like 'fibrant' objects, but I
guess 'cartesian' is different from 'fibration'?

Q: Are products of opcartesian squares again opcartesian?
A: Not sure they are in general, but seems to be the case in the
codomain bifibration over a category with products. Maybe I need to
demand it. It seems like a kind of distributivity property.

=== 2017.10.13

Q: Is my characterization of categories as relational things actually
a full embedding?
A: Hm, maybe not. Need some kind of grading perhaps.

=== 2017.10.15

Q: What agda did I start writing for relational things?
A:
<<<
{-# OPTIONS --without-K #-}
module b where

open import HoTT


bd : Set ‚Üí Set‚ÇÅ
bd X = Œ£ Set (Œª A ‚Üí A ‚Üí X)

postulate
  fib : {X : Set} ‚Üí bd X ‚Üí Set
  hom : {A B X : Set} {g : B ‚Üí X} {f : A ‚Üí B} ‚Üí fib (B , g) ‚Üí fib (A , g ‚àò f) ‚Üí Set

module _ {A B X : Set} (g : B ‚Üí X) (f : A ‚Üí B) where
  postulate
    reidx : fib (A , g ‚àò f) ‚Üí fib (B , g)
    opidx : fib (B , g) ‚Üí fib (A , g ‚àò f)
    reidx-hom : (t : fib (A , g ‚àò f)) ‚Üí hom (reidx t) t
    opidx-hom : (t : fib (B , g)) ‚Üí hom t (opidx t)
>>>

=== 2017.10.15

Q: What other agda false start did I have before realizing that
Œ∑-naturality is merely some laxer kind of 2-categorical pushout?
A:
<<<
postulate
  ‚ôØ : Set ‚Üí Set
  Œ∑ : {A : Set} ‚Üí A ‚Üí ‚ôØ A
  ‚ôØF : {A B : Set} ‚Üí (A ‚Üí B) ‚Üí ‚ôØ A ‚Üí ‚ôØ B
  ‚ôØnat : {A B : Set} {f : A ‚Üí B} ‚Üí (a : A) ‚Üí ‚ôØF f (Œ∑ a) == Œ∑ (f a)
  ‚ôØ+ : {A B : Set} ‚Üí ‚ôØ (A ‚äî B) ‚Üí ‚ôØ A ‚äî ‚ôØ B
  ‚ôØpush : {A B X : Set} (f : A ‚Üí B) (g : ‚ôØ A ‚Üí X) (h : B ‚Üí X) ‚Üí h ‚àò f == g ‚àò Œ∑ ‚Üí ‚ôØ B ‚Üí X
  ‚ôØpush1 : {A B X : Set} {f : A ‚Üí B} {g : ‚ôØ A ‚Üí X} {h : B ‚Üí X} {p : h ‚àò f == g ‚àò Œ∑}
    ‚Üí ‚ôØpush f g h p ‚àò ‚ôØF f == g
  ‚ôØpush2 : {A B X : Set} {f : A ‚Üí B} {g : ‚ôØ A ‚Üí X} {h : B ‚Üí X} {p : h ‚àò f == g ‚àò Œ∑}
    ‚Üí ‚ôØpush f g h p ‚àò Œ∑ == h
  ‚ôØpushu : {A B X : Set} {f : A ‚Üí B} {g : ‚ôØ A ‚Üí X} {h : B ‚Üí X} {p : h ‚àò f == g ‚àò Œ∑}
    {z : ‚ôØ B ‚Üí X}
    ‚Üí z ‚àò ‚ôØF f == g ‚Üí z ‚àò Œ∑ == h ‚Üí z == ‚ôØpush f g h p
  ‚ôØcompat : {A B : Set} ‚Üí ‚ôØ+ ‚àò Œ∑ {A ‚äî B} == {!!}
>>>
