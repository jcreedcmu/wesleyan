=== 2017.09.08

Q: What is the status of (2.2) in [RS]? Is it an axiom
in the system, or is it a provable property of the type system that
merely happens to be written as an inference rule, i.e. like cut
elimination?
A: ???

Q: In figure 3, why do premises Ï† and Ïˆ appear downstairs in the
fourth and fifth rules listed, when they already are assumed to follow
from Î | Î¦?
A: ???

Q: In the third rule in figure 4, why isn't *s* constrained to somehow
live in Ïˆ?
A: I guess it's because it's not that f needs something to live in a
shape to accept it as an argument; it's that f can only give answers
for things that live inside Ïˆ. We're asking that s is defined on
the whole cube I, and we can consider the restriction of the cube to
Ïˆ before feeding it to f. Thus, I might better ask:

Q: In the third rule in figure 4, why isn't s allowed to be defined
merely on Ïˆ? Why must it be defined on the whole cube I?
A: Oh, I see --- it's because the arguments to the function are merely
cube expressions, not general terms. There's no way to even specify a
cube term that's something other than a tuple of projections.

=== 2017.09.09

Q: How do Joyal disks [Joyal97] lead to âˆ-categories according to [RS]?
A: ???

Q: In [RS] Axiom 4.6, we're not making any additional assumption on
t : I | Ï† |- Ïˆ
by saying it's a cofibration, right? My belief is that
Ïˆ is just a cofibration by being of that syntactic class.
A: ???

=== 2017.09.10

Q: Is the Finster-Mimram definition of weak omega-categories connected
in a simple way to Joyal's theta-category?
A: Probably can get a good sense by looking in
http://cheng.staff.shef.ac.uk/guidebook/guidebook-new.pdf
which I found from
https://ncatlab.org/nlab/show/Theta+category

=== 2017.09.11

Q: Where is the cubical stuff in the agda source?
A:
I see IZERO in
agda//src/full/Agda/TypeChecking/Monad/Builtin.hs
builtinIZero :: String = "IZERO"
primIZero :: TCM Term = getBuiltin builtinIZero

Q: Where are some exciting uses of primIZero?
A:
agda//src/full/Agda/TypeChecking/Primitive.hs

Q: Where is haskell-mode docs?
A: http://haskell.github.io/haskell-mode/manual/latest/

Q: More emacs advice about haskell dev?
A:
https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md

Q: What's the go-to-definition thing I want to bind to M-.?
A:
haskell-mode-jump-to-def

Q: Why did it take so long the first time I ran it?
A: Dunno, but someone else experienced a similar thing:
https://blog.alainodea.com/en/article/490/haskell-intero-in-emacs-first-impressions-and-howto

Q: Where are the sources to, like, the haskell base library including
the prelude Control.Monad and everything?
A: I thought maybe in
/usr/local/Cellar/ghc/7.10.3b/lib/ghc-7.10.3/
(which
$ brew list ghc
told me about)
but I only see .hi files.
...
Seems to exist online at
http://git.haskell.org/ghc.git/tree/refs/heads/master:/libraries/base/Control

Q: Transportation to the vicinity of wesleyan?
A: "Vermonter" amtrak + M-link bus maybe?
Hotel situation looks like a bummer.
No, nevermind, looks like I can just get a ride up with dlicata@.

Q: How can I git blame one line of a file?
A:
do like
$ git blame Primitive.hs -L404,+1

=== 2017.09.16

Q: How redundant is rule 5 of figure 4 in [RS]? It seems like morally I can
take the assumption that a == b and apply substitution to see
a[s/t] == b[s/t] and then use transitivity from rule 4's f(s) = a[s/t].
A: ???

=== 2017.09.18

Q: Ok, so where are the guts of cubical typechecking going on?
A:
try looking in
agda//src/full/Agda/TypeChecking/Rules/Term.hs
agda//src/full/Agda/TypeChecking/Rules/Builtin.hs
agda//src/full/Agda/TypeChecking/Primitive.hs
agda//src/full/Agda/TypeChecking/Telescope.hs

Q: Is there a way to view all these haskell function docstrings in a nice way?
A:
$ cabal install haddock
$ cabal configure
$ cabal haddock
and generates into
agda//dist/doc/html/Agda/index.html

Q: Why didn't
$ make haddock
work?
A:
mysterious missing dependencies?

# $ make haddock
# doesn't work due to

Q: What are some examples of cubical programs?
A:
agda//test/Fail/Issue2650.agda
agda//test/Fail/Issue2650.agda
agda//test/Succeed/Issue2650.agda
and also a goldmine of stuff in
gh//Saizan/cubical-demo

Q: What are the cubical primitives in
agdalib//prim/Agda/Primitive.agda
sorted by epistemic status?
A:
I definitely understand
 I, i0, i1
 primIMin
 primIMax
 primINeg
 IsOne
 itIsOne
 IsOne1 -- These two are just asserting that
 IsOne2 -- 1 v x = 1 and x v 1 = 1

Q: What's the deal with
<<<
 primPOr : {a : Agda.Primitive.Level} (i j : I)
      {A : .(IsOne (primIMax i j)) â†’ Set a} â†’
      (.(p : IsOne i) â†’ A _) â†’
      (.(p : IsOne j) â†’ A _) â†’ .(p : IsOne (primIMax i j)) â†’ A p
>>>
?
A: I think I vaguely understand it to be the realization of the disjunctive "systems" in
[CCHM] https://arxiv.org/pdf/1611.02108.pdf
which correspond to the disjunction elimination rules in [RS].

Q: What's the deal with
<<<
 Partial : {a : Agda.Primitive.Level} (A : Set a) â†’ I â†’ SetÏ‰
>>>
?
A:
It's described as
<<<
"Partial A Ï†"  is a special version of "(Ï† = i1) â†’ A"
>>>
in
gh//Saizan/cubical-demo/blob/master/AIM_Demo/DemoPartial.agda
which I think I kind of get.
I believe
<<<
 PartialP : {a : Agda.Primitive.Level} (Ï† : I)
      (A : .(o : IsOne Ï†) â†’ Set a) â†’
      SetÏ‰
>>>
is just the more dependent 'path-over' version of Partial, sorta? I
see it used in the same file there.

Q: What's the deal with
<<<
 primPFrom1 : {a : Agda.Primitive.Level} {A : I â†’ Set a} â†’
      A i1 â†’ (i j : I) â†’ .(IsOne i) â†’ A (primIMax i j)
>>>
A: If I squint it just looks like it's sort of internalizing the fact
that if I know i is already i1, then primIMax i j has to be i1 too, so
I can lift something known to be at A i1 to A (primIMax i j). Maybe
it's just making things definitionally equal that would otherwise be
propositionally equal.

Q: What's the deal with
<<<
 primComp : {a : I â†’ Agda.Primitive.Level} (A : (i : I) â†’ Set (a i))
      (Ï† : I) â†’
      ((i : I) â†’ .(IsOne Ï†) â†’ A i) â†’ A i0 â†’ A i1
>>>
A: This is the composition primitive from the paper.

Q: Wait, I see other primitives still in
gh//Saizan/cubical-demo/blob/master/Primitives.agda
what's the deal with them?
A:
well, primPathPApply does exist in
agda//src/full/Agda/TypeChecking/Primitive.hs
due to
agdac//b0596dde
and CONID exists in
agda//src/full/Agda/TypeChecking/Monad/Builtin.hs
due to
agdac//7a50bedf

Q: Where is that in the agda repo?
A:
agda//src/data/lib/prim/Agda/Primitive.agda

Q: What's going on with the primitive keyword?
A: I guess it's just a way of grabbing primitive function values with the standard name, see
agda//examples/Introduction/Built-in.agda
(which doesn't appear to compile due to a change of the number of arguments of the Integer built-in?)

Q: How is agda's version number spread througout other things?
A: Well, I see commits like agdac//3ca28ee9 but I don't know if there's a
script that achieves all these changes in a simple way.

Q: What're some milestones in the history of editing the cubical code?
A:
agdac//e919f74e due to avezzosi@ https://github.com/Saizan

Q: What's the suffix .hs-boot for?
A: Reifying cycles for mutuall recursive modules, see
https://downloads.haskell.org/~ghc/7.0.3/docs/html/users_guide/separate-compilation.html
and search for 'hs-boot'

Q: What are all these moon-language operators I'm seeing everywhere like
<@>, <#>, <..>, <@@>?
A: They are in fact defined in
agda//src/full/Agda/TypeChecking/Primitive.hs
and some more are in
agda//src/full/Agda/Utils/Functor.hs
<$> is just an infix name for fmap, see
http://git.haskell.org/ghc.git/blob_plain/refs/heads/master:/libraries/base/Data/Functor.hs

Q: How do I think about what [CCHM] calls 'partial elements'?
A: They're the things that are defined over the whole cube, but have
particular known values at subpolyhedra of the cube?

Q: What can I figure out about PrimitiveImpl?
A:
It's made of a Type and a PrimFun

Q: How do I printf in haskell?
A: Debug.Trace.trace, see
https://wiki.haskell.org/Debugging

Q: What's the deal with type IntervalView in
agda//src/full/Agda/Syntax/Internal.hs
A:
It was last touched by
agdac//6d78a1d4
I surmise it's some sort of way of exposing some of the interval term structure...

Q: What's going on with ignoreSharing in
agda//src/full/Agda/TypeChecking/Monad/Builtin.hs
?
A:
It's defined in
agda//src/full/Agda/Syntax/Internal.hs
and I would have named it, like, 'derefSharing' or something.

Q: What's a bang mean in haskell datatype definitions?
A: Strictness annotation, see
https://stackoverflow.com/questions/993112/what-does-the-exclamation-mark-mean-in-a-haskell-declaration

Q: What's an iota-redex, as mentioned in data Term comments in
agda//src/full/Agda/Syntax/Internal.hs
?
A: Something to do with pattern matching, see
https://github.com/agda/agda/issues/2276

Q: What's something that triggers the checking in primPOr that the two overlapping definitions
are consistent on their intersection?
A:
<<<
{-# OPTIONS --cubical #-}
module a where
import Agda.Primitive
open Agda.Primitive.CubicalPrimitives public

data Two : Set where
 ğŸ™ ğŸš : Two

x = primPOr i1 i1 {A = Î» _ â†’ Two} (Î» _ â†’ ğŸ™) (Î» _ â†’ ğŸš)
>>>
gives an error as expected.

Q: Why does
(primPOr i0 i1 {A = Î» _ â†’ Two} (Î» _ â†’ ğŸš) (Î» _ â†’ ğŸ™)) itIsOne
give an error about being fully applied?
A: ???

Q: What's the commit that created builtin PATH?
A: agdac//5e8aae7c

Q: Why doesn't Category.agda of
gh//Saizan/cubical-demo/blob/master/Category.agda
at commit 12f3d8f3
seem to compile at agdac//a67e5e2f?
A: ???

Q: How do I run agda from ghci so I can inspect things going on?
A: cabal repl

Q: Also can I just bash stuff into the prompt in *agda* in emacs?
A: Yeah, seems like!

Q: What's this syntax going on in
<<<
foo : âˆ€ i â†’ Partial Bool (i âˆ¨ ~ i)
foo i (i = i1) = true
foo i (i = i0) = false
>>>
in
gh//Saizan/cubical-demo/blob/master/AIM_Demo/DemoPartial.agda
?
A: Seems like a pattern-matching elimination for values of the type
IsOne?

=== 2017.09.19

Q: Where is this IsOne pattern elimination in the agda abstract syntax?
A:
I see a hint in the use of domFinite, and the comment in
agda//src/full/Agda/Syntax/Common.hs about primIsOne
this leads to looking at
agda//src/full/Agda/TypeChecking/Rules/LHS/Split.hs
which is a big mess.

Q: Can I get any insight by just git blaming
agda//src/full/Agda/Syntax/Abstract.hs
A:
Sure can! I see avezzosi@'s agdac//c584e887 touching a thing called EqualP.
yup,
<<<
  | EqualP Range [(Expr,Expr)]             -- ^ @i = i1@ i.e. cubical face lattice generator
>>>
in
agda//src/full/Agda/Syntax/Concrete.hs

Q: What's an interesting paper about internalizing dependent lambda calculus?
A:
"Outrageous but Meaningful Coincidences" McBride 2010, found in
https://homotopytypetheory.org/2014/03/03/hott-should-eat-itself/

Q: Wow, cabal repl is slow interactively. Even for editing text in
readline. What do?
A:
put
<<<
:set -fobject-code
>>>
in the .ghci file
http://chrisdone.com/posts/making-ghci-fast
https://www.reddit.com/r/haskell/comments/3ddcrw/does_haskell_have_slow_iteration_times_are_those/

Q: What do about the message
Warning: Can't find file "dist-2.6.0/build/autogen/cabal_macros.h" in directories
I see during cabal repl?
A:
Just
$ ln -s dist dist-2.6.0
as andreasabel@ recommends in
http://agda.chalmers.narkive.com/4ACGqXHw/problems-configuring-haskell-mode-and-or-invoking-cabal-repl

Q: More basic stuff about cabal?
A: http://katychuang.com/cabal-guide/

Q: What am I looking at trying to figure out how to typecheck a single expression from repl?
A: agda//src/full/Agda/Syntax/Parser.hs

Q: Where's MonadIO come from?
A:
<<<
:info Control.Monad.IO.Class.MonadIO
class Monad m => Control.Monad.IO.Class.MonadIO (m :: * -> *) where
  Control.Monad.IO.Class.liftIO :: IO a -> m a
  	-- Defined in â€˜Control.Monad.IO.Classâ€™
instance Control.Monad.IO.Class.MonadIO PM
  -- Defined in â€˜Agda.Syntax.Parserâ€™
instance Control.Monad.IO.Class.MonadIO IO
  -- Defined in â€˜Control.Monad.IO.Classâ€™
>>>

Q: What's it good for, vis-a-vis the PM type class?
A: Lifting IO actions *into* PM, not injecting PM into IO. Boo.

Q: Oh, but what do I want for that?
A: runPMIO

Q: How do I get ghci to show types
A:
either
:type <expression>
or
:set +t
(which I could do interactively or put in my .gchi)
according to
https://stackoverflow.com/questions/12659927/using-ghci-to-find-type

Q: How do I get ghci to allow multi-line defns?
A:
:set +m
<<<
Î»> let zzz :: Integer
Î»|     zzz = 2
Î»|
zzz :: Integer
Î»>
>>>
https://stackoverflow.com/questions/2846050/how-to-define-a-function-in-ghci-across-multiple-lines
ugh but then every single line expression requires a double-return
:unset +m
it is, then.

Q: How do I parse a single expression?
A:
<<<
import Agda.Syntax.Parser
let runParse :: String -> IO (Either ParseError Agda.Syntax.Concrete.Expr, [ParseWarning]) ; runParse s = runPMIO (parse exprParser s)
>>>

Q: How can I create a primitive type?
A: Can imitate Bool, did not gain much insight though.

Q: How can I create a simple primitive typed constant?
A: ???

Q: How can I create a primitive typed constant that reduces?
A: ???

Q: Where did this *agda* buffer come from?
Was it from haskell-session-change?
A: ???

Q: How do I run agda tests?
A: well I can just do things like
$ dist/build/agda/agda -i test test/Common/String.agda
for some reason
$ make test
gives me errors

Q: Oh, crumb, cabal build seems to clear whatever incremental state cabal repl has.
I guess I should try to do stuff from inside repl. How do?
A:
I see
parsePragmaOptions
defined in
agda//src/full/Agda/Interaction/Options.hs
being called from
agda//src/full/Agda/TypeChecking/Monad/Options.hs
agda//src/full/Agda/Interaction/Imports.hs
...
red herring?
Hmm.
Well I can stick
<<<
  let argv     = ["-i", "/tmp", "/tmp/a.agda"]
>>>
in runAgda' in
agda//src/full/Agda/Main.hs
and that seems to 'work'.

Q: What's a good solution for TAGS for haskell?
A: ???

Q: Why no builtin thing COLOR even after I define it?
A:
the error is
NoSuchBuiltinName
from
agda//src/full/Agda/TypeChecking/Errors.hs
which may have come from one of
agda//src/full/Agda/TypeChecking/Monad/Builtin.hs
agda//src/full/Agda/TypeChecking/Rules/Builtin.hs
but probably the latter.

Huh, it works after I add
<<<
+  , (builtinColor              |-> BuiltinData tset [builtinRed])
>>>
in
agda//src/full/Agda/TypeChecking/Rules/Builtin.hs
to parallel bool.

=== 2017.09.20

Q: mortberg@'s explanation of cubical types?
A:
https://homotopytypetheory.org/2017/09/16/a-hands-on-introduction-to-cubicaltt/
https://github.com/mortberg/cubicaltt/tree/master/lectures

Q: induction-induction vs. induction-recursion?
A:
https://en.wikipedia.org/wiki/Induction-recursion
https://ncatlab.org/homotopytypetheory/show/inductive-inductive+type
http://cs.swan.ac.uk/~csfnf/papers/indind_finite.pdf
https://ncatlab.org/nlab/show/inductive-inductive+type

Q: dual of applicative and alternative?
A: https://hackage.haskell.org/package/contravariant-1.4/docs/Data-Functor-Contravariant-Divisible.html
people (more or less rightly) complaining about the intensity of the category theory involved on twitter at
https://twitter.com/jb55/status/910293593851490304

Q: Thread on hott mailing list from dlicata@ about how to prove univalence?
A: https://groups.google.com/forum/#!msg/homotopytypetheory/j2KBIvDw53s/YTDK4D0NFQAJ

Q: Where are haddock generated docs?
A: /Users/jreed/.cabal/sandboxes/agda-build/agda/dist/doc/html/Agda/index.html

Q: What's a concrete way to show off the non-fibrancy of ğ•€?
A: ???

Q: Where's the proof of
<<<
-- The reason we need to add <j> a is that we want the top-left point
-- to be a, if we would have omitted it it would instead have been
-- "transport (<_> A) a". We used to have a version of the system
-- where this was the same as a, this relied on a property which we
-- called "regularity". It was however proved by Dan Licata that this
-- property is not preserved by the algorithm for composition for the
-- universe, so we had to drop it and the user now has to give <j> a
-- explicitly.
>>>
that I see in
https://github.com/mortberg/cubicaltt/blob/master/lectures/lecture2.ctt
A:
https://groups.google.com/forum/#!msg/homotopytypetheory/oXQe5u_Mmtk/3HEDk5g5uq4J
looks like a start, but ??? because I want to ask dan.

Q: What's the relationship between the kan filling that
dlicata@ talks about in
"Cubical infinite-dimensional type theory"
https://www.youtube.com/watch?v=lt8JgGRw7gg
and the modern [CCHM] take?
A: ???

Q: What's a nice compact way of looking at J that I get after
beta-reducing the one in mortberg@'s lecture notes?
A:
<<<
myJ (A : U) (a : A) (P : (b : A) -> Path A a b -> U)
  (d : P a (refl A a)) (b : A) (p : Path A a b) : P b p =
  comp (<i> P (p @ i) (<j> p @ i âˆ§ j)) d []
>>>

=== 2017.09.21

Q: What's an example of a monomorphism that's *not* a cofibration?
What's special about face inclusions?
A: ???

Q: What do categories with (merely) weak equivalences allow?
A: simplicial localization, see
https://ncatlab.org/nlab/show/simplicial+localization
there seem to be other constructions for subtypes of CwWE, namely
model categories and homotopical categories, but I don't understand
them yet.

Q: What misconception did I just clear up about gluing in [CCHM]?
A: It's not another thing that you have to define for every type, like
composition is; it's a type constructor. A Glue-type is a type built
out of a phi-restricted fragment of another type, plus some
equivalence glue that is valid on the phi-restriction.

Afterwards you define composition *on* glue-types, and composition
*on* the universe is definable by using glue-types in the definition
body.

Q: Can I get any sort of interlibrary deals through wesleyan
affiliation?
A: I can VPN in and access acm dl at least.
Anything else???

Q: What should I make of the discussion on
https://homotopytypetheory.org/2017/09/16/a-hands-on-introduction-to-cubicaltt/
between shulman@ and mortberg@ about canonicity vs. many-models? I
don't feel like I grasp what's at stake.
A: ???

Q: In [ShuFix] inbetween eqn 4.1 and eqn 4.2, it says
(a) â™­(A â†’ B) â†’ â™­(â™­A â†’ â™­B)
is obtainable. But surely also we can get
(b) â™­(A â†’ B) â†’ (â™­A â†’ â™­B)
I'd think, at least?
A: derp, (a) is already stronger than (b).

Q: What's my thoughts on I prefer to think about the '2-categorical
adjoint logic' stuff?
A:

I have judgmental *levels* L, typical element â„“. I have corresponding
syntactic classes of resources and frames, call them râ„“ (variables Ïâ„“)
and fâ„“ (variables Ï†â„“). I have positive propositions Pâ„“ and negatives Nâ„“.

Then I have relations râ„“ â–¹â„“ fâ„“, may henceforth elide the â„“ on â–¹.

If I'm to set up F âŠ£ U and let's say with propositional functions
F : PÎ½ â†’ PÏ„ and U : NÏ„ â†’ NÎ½ for {Ï„,Î½} âŠ† L then I'm going to need
a resource function f : rÎ½ â†’ rÏ„

so that (leaving off Ï„ suffixes)

F PÎ½1 [Ï1], F PÎ½2 [Ï2] |- F PÎ½3 [Ï†]

translates to

F PÎ½1 @ Ï1, F PÎ½2 @ Ï2, âˆ€Ï.(F PÎ½3 @ Ï)â†’(Ï â–¹ Ï†) âŠ¢ Ï1 * Ï2 â–¹ Ï†

which inverts to (b.c. F PÎ½ @ Ï = âˆƒÏÎ½.(Ï = f ÏÎ½) âˆ§ (PÎ½ @ ÏÎ½))
PÎ½1 @ ÏÎ½1, PÎ½2 @ ÏÎ½2, âˆ€Ï.(F PÎ½3 @ Ï)â†’(Ï â–¹ Ï†) âŠ¢ f(Ï1) * f(Ï2) â–¹ Ï†
which should be equal to
PÎ½1 @ ÏÎ½1, PÎ½2 @ ÏÎ½2, âˆ€Ï.(F PÎ½3 @ Ï)â†’(Ï â–¹ Ï†) âŠ¢ f(Ï1 * Ï2) â–¹ Ï†
and then I could focus and step to
PÎ½1 @ ÏÎ½1, PÎ½2 @ ÏÎ½2 âŠ¢ F PÎ½3 @ f(Ï1 * Ï2)
which is
PÎ½1 @ ÏÎ½1, PÎ½2 @ ÏÎ½2 âŠ¢ âˆƒÏÎ½.(f(Ï1 * Ï2) = f ÏÎ½) âˆ§ (PÎ½3 @ ÏÎ½)
and I can choose
PÎ½1 @ ÏÎ½1, PÎ½2 @ ÏÎ½2 âŠ¢ PÎ½3 @ Ï1 * Ï2
and this all goes like I expect.

To get focusing of F, I need a function u : fÏ„ â†’ fÎ½ with

(f ÏÎ½) â–¹ Ï†t â‰¡ ÏÎ½ â–¹ (u Ï†t)
       Ï„         Î½

Ok, fine, but how do I rig up a triple adjunction? Negative and
positive props are different. If I have F âŠ£ U and V âŠ£ H and arrange
so that, ignoring focusing, (negative) U and (positive) V are somehow the same?

In props:

    PÎ½    NÎ½    PÎ½    NÎ½
   F â†“ âŠ£ U â†‘ â‰… V â†‘ âŠ£ H â†“
    PÏ„    NÏ„    PÏ„    NÏ„

with functions

    rÎ½    fÎ½    rÎ½    fÎ½
   f â†“ âŠ£ u â†‘ â‰… v â†‘ âŠ£ h â†“
    rÏ„    fÏ„    rÏ„    fÏ„

Ok, let me just look at what I need to get, let's say, the interprovability

U N âŠ£âŠ¢ V â†“ N

for
U N âŠ¢ V â†“ N
I expand to
U N [Ï] âŠ¢ V â†“ N [Ï†]
âˆ€ÏÎ½.((V â†“ N) @ ÏÎ½) â†’ (ÏÎ½ â–¹ Ï†Î½), âˆ€Ï†Î½.((U N) @ Ï†Î½) â†’ (ÏÎ½ â–¹ Ï†Î½) âŠ¢ ÏÎ½ â–¹ Ï†Î½
------------> need: ÏÎ½ â‰¤ v (f ÏÎ½)
âˆ€ÏÎ½.((V â†“ N) @ ÏÎ½) â†’ (ÏÎ½ â–¹ Ï†Î½), âˆ€Ï†Î½.((U N) @ Ï†Î½) â†’ (ÏÎ½ â–¹ Ï†Î½) âŠ¢ v (f ÏÎ½) â–¹ Ï†Î½
âˆ€Ï†Î½.((U N) @ Ï†Î½) â†’ (ÏÎ½ â–¹ Ï†Î½) âŠ¢ (V â†“ N) @ v (f ÏÎ½)
âˆ€Ï†Î½.((U N) @ Ï†Î½) â†’ (ÏÎ½ â–¹ Ï†Î½) âŠ¢ â†“ N @ f ÏÎ½
âˆ€Ï†Î½.((U N) @ Ï†Î½) â†’ (ÏÎ½ â–¹ Ï†Î½), N @ Ï† âŠ¢ f ÏÎ½ â–¹ Ï†
âˆ€Ï†Î½.((U N) @ Ï†Î½) â†’ (ÏÎ½ â–¹ Ï†Î½), N @ Ï† âŠ¢ ÏÎ½ â–¹ u Ï†
N @ Ï† âŠ¢ (U N) @ u Ï†
N @ Ï† âŠ¢ N @ Ï†

for
V â†“ N âŠ¢ U N
I expand to
V â†“ N [ÏÎ½] âŠ¢ U N [Ï†Î½]
(V â†“ N) @ ÏÎ½, U N @ Ï†Î½ âŠ¢ ÏÎ½ â–¹ Ï†Î½
(â†“ N) @ Ï, N @ Ï† âŠ¢ v Ï â–¹ u Ï†
âˆ€Ï†.(N @ Ï†) â†’ (Ï â–¹ Ï†), N @ Ï† âŠ¢ v Ï â–¹ u Ï†
âˆ€Ï†.(N @ Ï†) â†’ (Ï â–¹ Ï†), N @ Ï† âŠ¢ Ï â–¹ h (u Ï†)
âˆ€Ï†.(N @ Ï†) â†’ (Ï â–¹ Ï†), N @ Ï† âŠ¢ Ï â–¹ h (u Ï†)
------------> need: Ï† â‰¤ h (u Ï†)
âˆ€Ï†.(N @ Ï†) â†’ (Ï â–¹ Ï†), N @ Ï† âŠ¢ Ï â–¹ Ï†

Ok, yeah, there's two sorts of adjunctions going on, call them âŠ£â–¹ and
âŠ£â‰¤, and we have

          âŠ£â–¹
       f ----> u
       |       |
    âŠ£â‰¤ |       | âŠ£â‰¤
       â†“       â†“
       v ----> h
          âŠ£â–¹

ok, sure, so both u and v are the right adjoint of f, in two different
ways; of course they should work out to be 'the same', since adjoints
are unique up to isomorphism.

Let's say I start with âŠ¢ v (f ÏÎ½) â–¹ Ï†Î½ and I want to get to âŠ¢ ÏÎ½ â–¹ Ï†Î½.
I can do this immediately by appealing to the unit ÏÎ½ â‰¤ v (f ÏÎ½),
*or* I can transpose to âŠ¢ ÏÎ½ â–¹ u (h Ï†Î½) and appealing to the counit
u (h Ï†Î½) â‰¤ Ï†Î½.

Similarly if I start with âŠ¢ Ï â–¹ Ï† and I want to get to âŠ¢ Ï â–¹ h (u Ï†).
Can do directly with the unit Ï† â‰¤ h (u Ï†), or with the counit
f (v Ï) â‰¤ Ï to get âŠ¢ f (v Ï) â–¹ Ï† and then transposing.

=== 2017.09.22

Q: Why do I think that â™¯L should clear the context of coherent
assumptions? [Adj2] doesn't do that, and indeed I have a harder time
convincing myself cut goes through with my version.
A:
I got to this by thinking through how
Î”, Î“, â™¯A[r] âŠ¢ C
â‡”
Î” @ Ïâ‚, Î“ @ Ïâ‚‚, â™¯A @ Ïâ‚ƒ, C @ Ï† âŠ¢ f(Ïâ‚ * Ïâ‚ƒ), Ïâ‚‚ â–¹ Ï†
seems to require dropping the Ïâ‚‚ to get
f(Ïâ‚ * Ïâ‚ƒ) â–¹ Ï†
and from there
fÏâ‚ * fÏâ‚ƒ â–¹ Ï†
fÏâ‚ * fÏâ‚ƒ â–¹ Ï†
Ïâ‚ƒ â–¹ u(u(fÏâ‚ âŠ¸ Ï†))
so I can unpack the â™¯A @ Ïâ‚ƒ to get
Î” @ Ïâ‚, Î“ @ Ïâ‚‚, A @ Ï', C @ Ï† âŠ¢ Ïâ‚ƒ â–¹ u(fÏâ‚ âŠ¸ Ï†)
which is equivalent to
Î” @ Ïâ‚, Î“ @ Ïâ‚‚, A @ Ï', C @ Ï† âŠ¢ fÏâ‚ * fÏ' â–¹ Ï†
...
Ohhh this is all just a mistake. I can transform
f(Ïâ‚ * Ïâ‚ƒ), Ïâ‚‚ â–¹ Ï†
to
fÏâ‚ * fÏâ‚ƒ â–¹ Ïâ‚‚ âŠ¸ Ï†
fÏâ‚ƒ â–¹ fÏâ‚ âŠ¸ Ïâ‚‚ âŠ¸ Ï†
ffÏâ‚ƒ â–¹ fÏâ‚ âŠ¸ Ïâ‚‚ âŠ¸ Ï†
Ïâ‚ƒ â–¹ uu(fÏâ‚ âŠ¸ Ïâ‚‚ âŠ¸ Ï†)
which gives me
Î” @ Ïâ‚, Î“ @ Ïâ‚‚, A @ Ï', C @ Ï† âŠ¢ Ï' â–¹ u(fÏâ‚ âŠ¸ Ïâ‚‚ âŠ¸ Ï†)
or equivalently
Î” @ Ïâ‚, Î“ @ Ïâ‚‚, A @ Ï', C @ Ï† âŠ¢ fÏâ‚ * fÏ' * Ïâ‚‚ â–¹ Ï†

Q: Reading [ShuFix], what's an example of a mono in Top that's not a subspace inclusion?
A: Take
I = [0,1)
and map I into â„‚ via
Î»x.exp(2Ï€xi)
You get the unit circle, which as a subspace has a different topology from I.

Q: No, this doesn't seem right. What do the brackets around P mean on page 15 of [ShuFix]?
A: ???

=== 2017.09.23

Q: What is the essential reason why valid assumptions, and therefore
boxed types, must depend only on valid things?
A: Because when I clear the context, I can't strand them from the
hypotheses they need to be valid.

Imagine I have signature
A : type
B : A â†’ type
and try to prove
a : A true, b : (B a) valid âŠ¢ ? : â–¡ C
I'll immediately try to construct, via â–¡R,
b : (B a) valid âŠ¢ ? : C
which is nonsense.

Q: How does this play out with categorified judgmental levels?
A: Not 100% sure yet. Wonder if I want to think of the context as a
graph whose edges are morphisms in the level category, or else maybe
allow context annotations to have 'zeroes' in them. I could imagine an
invariant something like

If Î“[Î³], x :_p A[m], Î“'[Î³'] âŠ¢ J_q

then for some Î³â‚€ such that Î³â‚€m âŠ† Î³ we have

Î“[Î³â‚€] âŠ¢ A : type_p

A zero in Î“[Î³â‚€] means 'weaken that variable away'
A zero is âŠ† any morphism, but otherwise in Î³â‚€m âŠ† Î³ everything has to agree.

This is meant to make

x :_p A[m]

behave just like

x :_q (F_m A) [id_q]

Whose intro rules (for m : p â†’ q) I imagine go something like

Î“[Î³â‚€] âŠ¢ A : type_p    Î³â‚€m âŠ† Î³
-----------------------------
Î“[Î³] âŠ¢ F_m A : type_q

Î“[Î³â‚€] âŠ¢ M :_p A    Î³â‚€m âŠ† Î³
---------------------------------
Î“[Î³] âŠ¢ F_m M :_q F_m A

Q: What happens if I think of the context as a graph whose edges are labelled with morphisms?
A: I think I want to require commutativity of every diagram implied by
the graph? Or do I? My gut says it's probably required for some
substitution theorem or something.

Q: Is it possible for a neutral expression to have a type that
involves the constant at the head?
A: Sure, here's an example
<<<
module b where

postulate
  o : Set
  a : o -> Set
  b : (y : o) â†’ a y
  c : (y : o) â†’ a y -> o
  k : o

term : a (c k (b k))
term = b (c k (b k))
>>>

Q: Where did I put some notes about how 2-categorical modalities work
in dependent types?
A: /Users/jreed/wes/texnotes/2017-09-23.ltx

=== 2017.09.24

Q: What's a property I might want to pragmatically require for mode
theories to make typechecking tractable?
A:
If a âˆ˜ b = c, then
(a) there exists a maximal a' such that a' âˆ˜ b = c
(b) there exists a maximal b' such that a âˆ˜ b' = c
where a 'maximal' morphism means one that is the most useful attached
to an assumption. In the idempotent theory of 1 and r, I'm thinking of r â‰¥ 1,
and indeed in that situation, I have a best solution (namely r) to both
r âˆ˜ ? = r
? âˆ˜ r = r
and a unique solution (namely r) to both
1 âˆ˜ ? = r
? âˆ˜ 1 = r
and a unique solution (namely 1) to both
1 âˆ˜ ? = 1
? âˆ˜ 1 = 1
and no solution (which is ok) to both
r âˆ˜ ? = 1
? âˆ˜ r = 1

Q: What do I make of [Fib2]?
A: The main thing that strikes me is why go to all the effort of
designing and proving coherent a system when you can just translate it
away to FOL, but that's my bias showing.

Q: What's going on with the embedding/encoding distinction in [Fib2]?
(search "A point of contrast with substructural logical frameworks")
A: ???

Q: What are the implications of thinking about two-cells between mode morphisms
(saying things like u âˆ˜ f â‰¤ 1) versus merely talking about preorders on 'terms'
(saying things like âˆ€x . u(f(x)) â‰¤ x)
A: ???

Q: What am I getting out of reifying frames instead of what [Fib2] does, namely
thinking of them as structures-with-a-hole?
A: I guess greater uniformity of definition? My F rules look just like
my U rules with different sorts. I can represent classical logic as a
thing with frame constructors?

Q: Is it still possible to carry out a focusing proof for every logic
you can define in [Fib2]?
A: I think maybe yes; because the moment you throw in âŠ™, it's
impossible not to allow the definition of residuals x âŠ™ - and - âŠ™ x
which correspond to frame operations x â†£ - and x â†  -. So control over
frames (as opposed to abstractions) is what lets you define less
focally good logics like queue logic.

Q: What's that other paper dlicata@ thought would be an application of modalities?
A: [OrtonPitts]

=== 2017.09.25

Q: What's something to look for in [ShuFix]?
A: How exactly the properties of â™¯ and â™­ on top of their modal nature
get axiomatized.

Q: To what extent can the same be done with Êƒ?
A: ???

Q: What's a sensible tack on dependent modal stuff?
A: To aggressively track how every type depends modally on its
context.

=== 2017.09.26

Q: Where's my ticket for account renaming?
A: https://wesleyanedu.service-now.com/ess//incident_status.do

Q: Does anything go wrong with totally decoupled term bundles from type bundles
A: ???

=== 2017.09.27

Q: What's the dance we have to do to justify the type upstairs in $FL$ is well-formed?
A:
Something like
<<<
$$\Gamma, y: A^{\alpha} \prov y^{y:=1} : A^{\alpha}$$
$$\Gamma, y: A^{\alpha} \prov (F^{y:=1}_\mm y)^{y:=m} : (F^\alpha_\mm A)^{\alpha'}$$
$${\Gamma, x:(F^\alpha_\mm A)^{\alpha'} \prov   C^\gamma : \rtype}$$

$${\Gamma, y : A^\alpha, x:(F^\alpha_\mm A)^{\alpha'} \prov   C^{\gamma, y := m\gamma(x)} : \rtype}$$
$$
\erule
{\Gamma \prov N^\nu : A^\alpha\qquad \Gamma, x:A^\alpha, \Gamma' \prov M^{\mu} : C^\gamma \qquad \mu \ge \nu \mu(x) \qquad \gamma \ge \nu \gamma(x) \using sub}
{\Gamma, [N^\nu / x]\Gamma' \prov [N^\nu / x] (M^\mu) : [N^\nu / x](C^\gamma)}
$$
>>>
but I'm not super confident in this.

=== 2017.09.28

Q: In [RS] what's an example of a non-exponentiable map between categories?
A: ???

=== 2017.09.29

Q: In [RS], looking at the extension type
 âŸ¨ Î _{t : I | Ïˆ} A |^Ï†_{t.a} âŸ©
is it possible for A's well-formedness to depend on Ïˆ without actually
mentioning t?

(I'm trying to understand when exactly the notation
âŸ¨ { t : I | Ïˆ } â†’ A |^Ï†_{t.a} âŸ©
is justified, as defined at the end of section 2)
A: ???

Q: Where's avezzosi@'s agda implementation stuff for â™­?
A: agdac//1f943c9 and agdac//154073c , the difference from branch parametric to branch flat.

DONE: convinced IT to let me change my wesleyan account to jcreed@, I
think.

=== 2017.09.30

Q: How to get Skim to open a pdf to a certain page?
A:
https://emacs.stackexchange.com/questions/30344/how-to-link-and-open-a-pdf-file-to-a-specific-page-skim-adobe
links to org-mac.el at
http://orgmode.org/worg/org-contrib/org-mac-link.html
Or wait I can get by on the commandline with just
$ open -a /Applications/Skim.app some.pdf
and I don't even need to give a full path like I do with
$ open /Applications/Skim.app --args `pwd`/some.pdf

Q: How do I reload a file from applescript?
A:
$ osascript -e 'tell document "some.pdf" of application "Skim" to revert'


Q: What's a particular fixing of notation for the cast of characters in a fibration
that makes it look like a pullback?
A:
<<<
Ï€ : â„° â†’ â„¬

 x
   Ï†   Ïˆ
     a   -fâ†’   b
 â†§Ï€
   â†§Ï€
 X   â†§Ï€   â†§Ï€   â†§Ï€
   Î¦
     A   -Fâ†’   B
>>>

"Ï€ is a fibration" = âˆ€ (A B : â„¬)(F : A â†’ B)(b : Ï€â»Â¹ B) â†’ âˆƒ (a : Ï€â»Â¹ A) (f : a â†’ b) Ã— f is cartesian.

"f is cartesian" = âˆ€ (X : â„¬) (x : Ï€â»Â¹ X) (Î¦ : X â†’ A) (Ïˆ : Ï€â»Â¹ (F âˆ˜ Î¦) : x â†’ b) â†’ âˆƒ! (Ï† : Ï€â»Â¹ Î¦ : x â†’ a) Ã— (f âˆ˜ Ï† = Ïˆ)


Q: What does the bifibration situation look like for the mode 2-multicategory just being a monoid?
A:
<<<
    Î“ .
     \  ' .
      \     ' .
    â†§  â†˜        'â†˜
        UA -----â†’ A
        m
    * .
     \  ' . nm    â†§
    n \     ' .
       â†˜        'â†˜
        * ------â†’ *
             m

Î“ âŠ¢[nm] A
â•â•â•â•â•â•â•â•â•
Î“ âŠ¢[n] UA

    C â†–
     â†–  ' .
      \     ' .
    â†§  \        '
        FA â†----- A
        m
    * â†–
     â†–  ' . mn    â†§
    n \     ' .
       \        '
        * â†------ *
             m

A âŠ¢[mn] C
â•â•â•â•â•â•â•â•â•
FA âŠ¢[n] C
>>>

=== 2017.10.01

Q: How do I want to generalize the following?
<<<
Suppose I have a fibration
    Ï€
ğ”¼ â”€â”€â”€â”€â†’ ğ”¹

I can also think of this as a single category â„‚ living over the arrow category

    p
ğ„ â”€â”€â”€â”€â†’ ğ

The objects in â„‚ living over ğ„ are the objects of ğ”¼.
The objects in â„‚ living over ğ are the objects of ğ”¹.
The arrows in â„‚ living over 1_ğ„ are the arrows of ğ”¼.
The arrows in â„‚ living over 1_ğ are the arrows of ğ”¹.
The remaining arrows in â„‚ are pairs (E, b) where E is an object
of ğ”¼ and b is an arrow Ï€E â†’ B in ğ”¹.

Composition should be pretty clear. The interesting case is
when we compose e : E1 â†’ E2 upstairs with a transverse b : Ï€E2 â†’ B
and the answer is (b âˆ˜ Ï€e) : Ï€E1 â†’ B

In general, if F : â„‚ â†’ ğ”» and p is an arrow in ğ”», we say _â„‚ has
pullbacks along p_ if the pullback universal property holds like

      X   â†’
        â†˜
      â†“   E â”€â”€â”€â”€â”€â†’ E'
          â”‚        â”‚
          â”‚        â”‚
          â†“        â†“
          B â”€â”€â”€â”€â”€â†’ B'

          over

      ğ„   =
        =
      p   ğ„ â•â•â•â•â•â• ğ„
          â”‚        â”‚
          p        p
          â†“        â†“
          ğ â•â•â•â•â•â• ğ
>>>
A: I think I just want to say: suppose F : â„‚ â†’ ğ”» is a functor.
We say a diagram in ğ”» like

                   B
                   â”‚
                   â”‚g
                   â†“
          C â”€â”€â”€â”€â”€â†’ D
              f

has an F-pullback if first of all there is a pullback in ğ”»

               Ï€â‚‚
         BÃ—C â”€â”€â”€â”€â†’ B
          â”‚â”€â”˜      â”‚
        Ï€â‚â”‚        â”‚g
          â†“        â†“
          C â”€â”€â”€â”€â”€â†’ D
              f

And every â„‚-cospan over BCD has a universal cone over Ï€â‚,Ï€â‚‚?

Q: So what's the definition of fibration given this idea?
A:
You start with your
    Ï€
ğ”¼ â”€â”€â”€â”€â†’ ğ”¹

and construct from it â„‚ â”€Fâ†’ (ğ„ â”€pâ†’ ğ), and demand that p and 1_ğ have
an F-pullback.

Q: Is this the same as F 'creating the pullback of f and g'
A: ???

Q: Relevant links to this question?
A:
https://mathoverflow.net/questions/103065/what-is-the-correct-definition-of-creation-of-limits
https://ncatlab.org/nlab/show/created+limit
http://permalink.gmane.org/gmane.science.mathematics.categories/6644

Q: Is the functor over ğ„ â”€pâ†’ ğ itself a fibration?
A: Hmm maybe it's an opfibration. Given E, I can certainly lift along
p to Ï€E, where the requisite transverse arrow is 1_{Ï€E}.

          Ï€E â†â”€â”€â”€â”€ E

          â†§        â†§

          ğ â†â”€â”€â”€â”€â”€ ğ„
               p

Yeah that would require all transverse arrows E â†’ B to correspond to
B-arrows that look like Ï€E â†’ B, which seems true.

Q: Actually wait I'm not so sure about my definition in terms of
F-pullbacks, now. It seems prima facie more general than the fibrancy
condition. When I choose something over

                   ğ„
                   â”‚
                   p
                   â†“
          ğ â•â•â•â•â•â• ğ

it's not just a ğ”¹-morphism downstairs, and an *object* of ğ”¼, it's a
ğ”¹-morphism and a transverse morphism. Does being a fibration guarantee
an F-pullback of _that_?
A: Let's try. I start out with the data

                   E'
                   â†§
                  Ï€E'
              b    â†“c'
          B â”€â”€â”€â”€â”€â†’ B'

Can I at least form the putative pullback square? Ugh, no, because c'
is going the wrong way. Let's try reversing it?

                   E'
                   â†§
                  Ï€E'
              b    â†‘c'
          B â”€â”€â”€â”€â”€â†’ B'

Hmmm now I've got transverse morphism living over E â”€pâ†’ B is actually
made up of a morphism B â†’ Ï€E not the other way around. I tried drawing
the diagram

          E â”€â”€eâ”€â”€â†’ E'
          â†§        â†§
         Ï€E â”€Ï€eâ”€â”€â†’ Ï€E'
          â•‘        â†‘c'
          B â”€â”€bâ”€â”€â†’ B'

which does seem to arise out of fibrancy but I can't seem to
understand what composition in â„‚ is anymore. Grr.

---

Ok, how about, desperate measures here, maybe ğ”» is
        p,q
e âŸ³ ğ„ â”€â”€â”€â”€â”€â†’ ğ âŸ² b

with all of ğ”¹ living over b instead of 1_ğ, all of ğ”¼ living over e
instead of 1_ğ„ and

b âˆ˜ p = b âˆ˜ q = q = p âˆ˜ e = q âˆ˜ e = q
e âˆ˜ e = e   b âˆ˜ b = b

The morphisms that live over p are just pairs (E, Ï€E) with no real
morphism content. A morphism that lives over q is what I was trying to
define as a transverse morphism before, namely a triple (E, f, B) with
f : Ï€E â†’ B.

Now I think I want to consider the pullback of b against p, and I'm
not even sure I can pull that off in this ğ”». Or wait, maybe I can...

              e
          ğ„ â”€â”€â”€â”€â”€â†’ ğ„
          â”‚â”€â”˜      â”‚
         pâ”‚        â”‚p
          â†“        â†“
          ğ â”€â”€â”€â”€â”€â†’ ğ
              b

at least commutes. Is it a pullback? The only thing X can be is ğ„. The
only thing that the overall diagonal can be is q, because p doesn't
factor through b. So the top input projection has to be e not 1_ğ„. The
side input projection could be either p or q. But either of these has
a unique solution:

      ğ„   e
        e
      q   ğ„ â”€â”€eâ”€â”€â†’ ğ„
          â”‚â”€â”˜      â”‚
          p        â”‚p
          â†“        â†“
          ğ â”€â”€â”€â”€â”€â†’ ğ
              b

      ğ„   e
        1
      p   ğ„ â”€â”€eâ”€â”€â†’ ğ„
          â”‚â”€â”˜      â”‚
          p        â”‚p
          â†“        â†“
          ğ â”€â”€â”€â”€â”€â†’ ğ
              b

Ok, suppose fibrancy, to show pullbacks exist upstairs in â„‚. I've got

                   E'

                   â†§

          B â”€â”€fâ”€â”€â†’ Ï€E'

living over

                   ğ„
                   â”‚
                   p
                   â†“
          ğ â”€â”€bâ”€â”€â†’ ğ

and fibrancy gives me

          E â”€â”€gâ”€â”€â†’ E'

          â†§        â†§

          B â”€â”€Ï€gâ”€â†’ Ï€E'

with Ï€g = f and Ï€E = B. This means the e-arrow g composed with the
p-arrow for E' is the transverse arrow (E, Ï€g, Ï€E'), and so too is the
composite of trivial p-arrow for E and the b-morphism Ï€g. I think the
more difficult case of checking that it's a pullback is the left input
projection being q. So imagine

      X        h
                 â†˜
      â†§   E â”€â”€gâ”€â”€â†’ E'
     Ï€X
      k   â†§        â†§
        â†˜
          B â”€â”€fâ”€â”€â†’ B'

living over

      ğ„        e
                 â†˜
          ğ„ â”€â”€eâ”€â”€â†’ ğ„
          â”‚â”€â”˜      â”‚
      q   p        â”‚p
        â†˜ â†“        â†“
          ğ â”€â”€â”€â”€â”€â†’ ğ
              b

That is, we have a transverse k : Ï€X â†’ B in ğ”¹ and an h : X â†’ E' in ğ”¼
such that Ï€h = f âˆ˜ k. That's exactly what fibrancy wants to give us a
unique arrow X â†’ E over k satisfying the appropriate commutativities,
I think.

Q: What's an example of noncofibrant spaces? I.e. map from 0 to the
space is not a cofibration?
A:
https://lists.lehigh.edu/pipermail/algtop-l/2009q1/000332.html
says

one-point compactification of countably infinite discrete space
warsaw circle

but I'm not sure which notion of cofibration is supposed to be going
on for them.

=== 2017.10.02

Q: Some stuff on model categories?
A: http://etale.site/writing/model-cats-for-algebraists.pdf

Q: Big ol book on topology and algebraic topology? Chapter 7 on
cofibrations?
A: http://groupoids.org.uk/pdffiles/topgrpds-e.pdf

Q: What's an example of a Serre fibration (fibrant wrt CW complexes) that's not
a Hurewicz fibration (fibrant wrt all spaces)?
A: https://mathoverflow.net/questions/241575/serre-fibration-vs-hurewicz-fibration

=== 2017.10.03

Q: Does avezzosi@'s flat branch also have cubical stuff in it?
A: Looks like yes.

Q: How do I exercise composeRelevance in
agda//src/full/Agda/Syntax/Common.hs
?
A:
Well it gets called in
agda//src/full/Agda/TypeChecking/Rewriting/NonLinMatch.hs
which defines the typeclass PatternFrom with method patternFrom
which gets called in
agda//src/full/Agda/TypeChecking/Rewriting.hs
in addRewriteRule which call comes after analyzing a Def from type
DeclCont defined in
agda//src/full/Agda/Auto/Syntax.hs
and that Def comes from a variable core living in a TelV which is defined in
agda//src/full/Agda/TypeChecking/Substitute.hs
That data came out of the function telView defined in
agda//src/full/Agda/TypeChecking/Telescope.hs

Q: Why does branch-flat agda get hung up on
{-# COMPILE GHC Level = type () #-}
in
agdalib//prim/Agda/Primitive.agda
?

Q: Well, where does {-# COMPILE GCH ... #-} come from?
A: I don't see COMPILE in
agda//src/full/Agda/Syntax/Parser/Lexer.x
which is sort of worrying.

Ugh it's not something to do with the pragma sharps, is it?
A: Ohhh no, it's because
/.cabal/share/x86_64-osx-ghc-7.10.3/Agda-2.6.0/lib/prim/Agda/
is not properly in version control I think.

Q: What's awesome in making sure I'm not going crazy?
A: agda2-display-program-version
displays the git commit it was compiled at, hallelujah.

Q: Where does this get generated?
A:
agda//src/full/Agda/VersionCommit.hs

Q: So what's going on with
agda//src/data/lib/prim/Agda/Primitive.agda
?
A: Ah, a relatively recent commit agdac//d1e6a0d (which postdates
avezzosi@'s commit) changed the format of these pragmas.

Q: Where does agda look for Primitive.agda?
A:
Well, doing
(setq agda2-program-args '("--no-default-libraries"))
doesn't help.
...
Aha,
agda//CHANGELOG.md (grep for Primitive.agda)
says I want to set environment variable
Agda_datadir

Q: From the commandline, does
$ export Agda_datadir=/Users/jreed/.cabal/sandboxes/agda-build/agda/src/data
work?
A: Yeah!

Q: From elisp?
A:
(setenv "Agda_datadir" "/Users/jreed/.cabal/sandboxes/agda-build/agda/src/data")
and restart the agda process.

Q: Starting point for problems with jump-to-definition?
A: https://stackoverflow.com/questions/28666113/goto-definition-in-emacs-haskell-mode

Q: Where do agda compile logs go when I don't say --verbose?
A: less +F /Users/jreed/.cabal/logs/Agda-2.6.0.log

Q: What should I be using instead of cabal install?
A: make install-bin I guess?

=== 2017.10.04

Q: What's Tom Leinster's aha moment about nerves of categories?
A: https://golem.ph.utexas.edu/category/2008/01/mark_weber_on_nerves_of_catego.html

Q: What's a case where being a fibrant object is nontrivial in a way I understand?
A: The classical model structure on simplicial sets; being a fibrant
object is the same as being a kan complex, i.e. having fillers for all
horns.

Q: What's the intuition for discrete fibrations?
A: With my Grothendieck glasses on, a fibration of categories is like
a functor â„‚^op â†’ Cat, whereas a discrete fibration is like a functor
â„‚^op â†’ Set.

Suppose Ï€ : ğ”» â†’ â„‚ comes from the fibers of a presheaf. Then whenever
we have D âˆˆ ğ”» living over C2 and f : C1 â†’ C2, there is a *unique* g
living over f which tells us how to pull the object cod g (an element
of the fiber over C2) back to the object dom g (an element of the
fiber over C1). The fiber over an object is a discrete category from
considering the identity arrows.

Q: Do Street fibrations help me repair the idea from 2017.10.01?
A: Hm, not that I can see, yet. If I say a 'transverse morphism'
living over p is a â†¦ followed by an iso, then I still can't
post-compose on an arbitrary (i.e. non-iso) ğ”¹-morphism.

=== 2017.10.05

Q: Where did I find something on nLab about a fibrationy generalization of profunctors?
A: https://ncatlab.org/nlab/show/Grothendieck+fibration#twosided_version

Q: Where did I find a nice characterization of cartesian morphisms as pullbacks of homsets?
A: http://maths.mq.edu.au/~street/Cicasm.pdf "Categories in categories, and size matters" Ross Street

Q: So am I right that this whole business with comprehension
categories or categories with families is to resolve the mismatch
between syntax, where substitution is associative on the nose, and
naive lccc semantics, where it's not? If we do synthetic,
suitably-univalent category theory, do we get any wins here? Can we
just do the naive lccc thing and get that substitution is associative
up to a path?
A: ???

Q: What's a nice easy-going narrative of all this fibrationy stuff?
A: http://www.cs.nott.ac.uk/~psxpc2/report-2013.pdf "Type Theory through Comprehension Categories"

Q: What do nonfibration functors correspond to Grothendieck-wise?
A: Functors from the base category ğ”¹ into Prof instead of Cat; that is,
the fibers are connected by profunctors (morphisms in Prof) rather
than functors (morphisms in Cat)
...
More concretely, say I have F : ğ”¼ â†’ ğ”¹. I want to think of this as a
functor ğ”¹^op â†’ Prof. An object B in ğ”¹ goes to its fiber F^*(B) like normal.
A morphism f : B1 â†’ B2 in ğ”¹ should go to some profunctor F^*(B2) â†’ F^*(B1), i.e.
a functor F^*(B1)^op Ã— F^*(B2) â†’ Set. But that's easy; let it be the fiber over f.
The object part is
fâ™¯(E1, E2) = { e : E1 â†’ E2 âˆˆ ğ”¼ | F E1 = B1, F E2 = B2, F e = f }
and the arrow part on the first argument is
<<<
fâ™¯(k : E1a â†’ E1b over id_B1, E2) = (Î» e . e âˆ˜ k) :
{ e : E1b â†’ E2 âˆˆ ğ”¼ | F e = f }
â†’
{ e : E1a â†’ E2 âˆˆ ğ”¼ | F e = f }
>>>
and the arrow part on the second argument is
<<<
fâ™¯(E1, k : E2a â†’ E2b over id_B2) = (Î» e . k âˆ˜ e) :
{ e : E1 â†’ E2a âˆˆ ğ”¼ | F e = f }
â†’
{ e : E1 â†’ E2b âˆˆ ğ”¼ | F e = f }
>>>
I see now how it's critical that things live over the identity so the
equation F e = f still holds after composition.

Q: How do we make a representable profunctor?
A:
F : ğ”¸ â†’ ğ”¹ becomes Fâ™¯ : ğ”¸ Ã— ğ”¹^op â†’ Set via
F#(A, B) = ğ”¹(B, F(A))
F#(f : A1 â†’ A2, B) = Î»g : ğ”¹(B, F(A1)). Ff âˆ˜ g
F#(A, f : B1 â†’ B2) = Î»g : ğ”¹(B2, F(A)). g âˆ˜ f

Q: How do I VPN?
A: http://www.wesleyan.edu/its/services/wireless/vpn.html

Q: How do I do email forwarding?
A: http://www.wesleyan.edu/its/services/accounts/desktop.html

Q: Why can't I view e.g. http://exchange.blogs.wesleyan.edu/
A: Had to be on VPN to make progress, but still can't read.
"Topics related to Outlook and Entourage can be viewed by administrators only."

Q: wesleyan webmail?
A: https://owa.wesleyan.edu/owa/

Q: What started making sense of ends and coends for me?
A: https://ncatlab.org/nlab/show/extranatural+transformation

Q: So where do I find the terms in a comprehension category?
A: ???

Q: What's the answer to the question about [RS] theorem 4.4 I asked Mike?
A: I can find the question in my email by searching for
<<<
I'm taking another pass over this paper trying to digest as much as I
can; really enjoying it. Here's a question that maybe has an easy
answer. I'm just wondering if I'm misunderstanding something that
should be obvious.
>>>
the answer I've generated for myself for now is
<<<
{-# OPTIONS --without-K #-}
module a where

open import HoTT

pre : {A B : Set} (f : A â†’ B) (b : B) â†’ Set
pre {A} {B} f b = Î£ A (Î» a â†’ f a == b)

lem : {A B C : Set} (f : A â†’ B) (g : B â†’ C) (c : C)
  â†’ pre (g âˆ˜ f) c â‰ƒ Î£ (pre g c) (Î» k â†’ pre f (fst k))
lem {A} {B} {C} f g c  = equiv into out zig zag where
  into : pre (g âˆ˜ f) c â†’ Î£ (pre g c) (Î» k â†’ pre f (fst k))
  into (a , gfa/c) = ((f a) , gfa/c) , a , idp
  out : Î£ (pre g c) (Î» k â†’ pre f (fst k)) â†’ pre (g âˆ˜ f) c
  out ((b , gb/c) , a , fa/b) = a , (ap g fa/b âˆ™ gb/c)
  zig : (b : Î£ (pre g c) (Î» k â†’ pre f (fst k))) â†’ into (out b) == b
  zig ((.(f a) , idp) , a , idp) = idp
  zag : (a : pre (g âˆ˜ f) c) â†’ out (into a) == a
  zag (a , gfa/c) = idp

ext : {A B Q : Set} (f : A â†’ B) (q : A â†’ Q) â†’ Set
ext {A} {B} {Q} f q = Î£ (B â†’ Q) (Î» h â†’ h âˆ˜ f == q)

thm : {Ï† Ïˆ Ï‡ X : Set} (f : Ï† â†’ Ïˆ) (g : Ïˆ â†’ Ï‡) (q : Ï† â†’ X)
  â†’ ext (g âˆ˜ f) q â‰ƒ Î£ (ext f q) (Î» k â†’ ext g (fst k))
thm f g q = lem (_âˆ˜ g) (_âˆ˜ f) q
>>>
which is to say, indeed, in the nondependent case, having a two-step
extension is the same as having a one-step extension along the
composite.

=== 2017.10.06

Q: What's a great early post ideas that fed into [RS]?
A: https://golem.ph.utexas.edu/category/2012/06/directed_homotopy_type_theory.html

Q: Stuff about stratified spaces that david corfield mentioned in the comments on that post?
A:
https://ocw.mit.edu/courses/mathematics/18-965-geometry-of-manifolds-fall-2004/lecture-notes/lecture12.pdf
http://aimsciences.org/journals/pdfsnews.jsp?paperID=2468&mode=full
https://ncatlab.org/nlab/show/poset-stratified+space#AFRshh

Q: Where's the other post that I'm thinking of?
A: Ah, it's by eriehl@:
https://golem.ph.utexas.edu/category/2017/05/a_type_theory_for_synthetic_ca.html

Q: What's the obstacle to constructing a subuniverse or something that
is Segal, (with specifically the functions between types being the
morphisms) if the universe as is isn't? Can't I just make a DHIT for
this?
A: Well... I realize I need the DHIT to include data for the way that
functions actually do compose. In pseudo-Agda I might say something
like
<<<
data Fset : Setâ‚ where
  name : Set â†’ Fset
  mor : {A B : Set} (f : A â†’ B) â†’ hom (name A) (name B)
  comp : {A B C : Set} (f : A â†’ B) (g : B â†’ C) â†’ (mor f âˆ™ mor g) == mor (g âˆ˜ f)
>>>
where âˆ™ denotes segal composition (which I guess I just kind of
presume is freely generated â€” I guess by DHIT I mean 'segal HIT' or
perhaps 'rezk HIT'?) , and âˆ˜ denotes function composition. Or else
constructing a DHIT doesn't presume segalness, and instead what I
should be doing is throwing in an appropriate 2-simplex for each
function composition, then *proving* somehow that the result is segal.

=== 2017.10.07

Q: Is there any sense in which a bifibration looks like a category of relations on top of a relation?
A: Seems like it, yes.

=== 2017.10.08

Q: For type-checking, and therefore definitional-equality-checking in
[RS]-world, can I get away with considering all finitely many
disjunctive possibilities, as dlicata@ suggested?
A: Yeah, I think maybe so; maybe this even obviates needing to think hard about Î·?
I tend to thing that
Ï† âˆ¨ Ïˆ âŠ¢ a â‰¡ rec^{Ï†,Ïˆ}_âˆ¨(b, c) â‡â‡’ (Ïˆ âˆ¨ (a â‰¡ b)) âˆ§ (Ï† âˆ¨ (a â‰¡ c))
or maybe equivalently
Ï† âˆ¨ Ïˆ âŠ¢ a â‰¡ rec^{Ï†,Ïˆ}_âˆ¨(b, c) â‡â‡’ (Ï† â‡’ (a â‰¡ b)) âˆ§ (Ïˆ â‡’ (a â‰¡ c))
?

Q: What do I get out of that parametricity-via-bifibrations paper [JG] that dlicata@ mentioned?
A: Not a whole lot yet; I think I'm in a position of somewhat greater
generality by considering an arbitrary finite-product-preserving
bifibration â„‚ â†’ ğ”», for whatever that's worth.

=== 2017.10.09

Q: What's a thought I had about constructivity and cubical stuff?
A: Constructive logic restricts the things you get to do *so that*
every implication you prove is computational, every existential you
prove computes a witness, etc. etc.

What we're finding out with every parametricity theorem we prove, and
with every HoTT-esque system we invent, is that similarly we can
restrict the things we get to do --- in a way that turns out to be
barely any more restrictive than the level of constructiveness we
already got used to --- so that every function is functorial, every
transformation is natural, etc. etc.

The game is not to create a psychologically *noticeable* burden on
programmers by making them annotate how morphisms are preserved, how
naturality squares are created, etc., but rather to discover the set
of operations that preserve things things in a (to use the word
informally) natural (one might say 'effortless') way.

=== 2017.10.10

Q: How make 2-cells in tikzcd?
A:
mshulman@ suggests
<<<
\def\twocell#1{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,from=\mynodeone,to=\mynodetwo]%
}
>>>
in
https://tex.stackexchange.com/questions/362743/2-cells-in-tikz-cd

Q: What else do I need to demand of a cartesian bifibration so that Cat has
a full and faithful embedding in it?
A: Something like a distinguished subcategory of the total category of
the bifibration that consists of the "vertically iso" objects. With
this I can detect that binary relations are functional (because the
opreindexically obtained projection to the domain should then be iso
in this sense) and since fibered maps from one bifibration to another
will have to preserve opreindexing and also this subcategory, we'll
have a functional relation in the output category also.

=== 2017.10.11

Q: Can I characterize trivial objects upstairs in a product-preserving bifibration
by saying that they are the locally terminal objects?
A: Maybe. To be clear, I mean an object Y over A is trivial
if for any other object X over A, there's a unique map X â†’ Y over the identity.

             !f
          X â”€â”€â”€â”€â†’ Y
          â”¬       â”¬
          â”‚       â”‚
          â†“       â†“
          A â•â•â•â•â• A

In the codomain bifibration, the trivial objects are the isomorphisms.
If a morphism s in the arrow category is an iso, then we can compute the
unique filler sâ»Â¹x.

            sâ»Â¹x
          X â”€â”€â”€â”€â†’ Y
          â”‚       â”‚
        x â”‚       â”‚ s
          â†“       â†“
          A â•â•â•â•â• A

If an s is locally terminal, we can find its inverse via

             sâ»Â¹
          A â”€â”€â”€â”€â†’ Y
          â”‚       â”‚
        1 â”‚       â”‚ s
          â†“       â†“
          A â•â•â•â•â• A

We know that s âˆ˜ sâ»Â¹ = 1, what about the opposite?

              s      sâ»Â¹
          Y â”€â”€â”€â”€â†’ A â”€â”€â”€â”€â†’ Y
          â”‚       â”‚       â”‚
        s â”‚       â”‚ 1     â”‚ s
          â†“       â†“       â†“
          A â•â•â•â•â• A â•â•â•â•â• A

Use the uniqueness in the the fact that s is locally terminal.

Q: Oh wait, this notion doesn't seem stable up to ismorphism in ğ”¼. What do?
A: I think I can just generalize it to: Y over B is trivial if for any
X over A and any g downstairs, there's a unique f over g.

             !f
          X â”€â”€â”€â”€â†’ Y
          â”¬       â”¬
          â”‚       â”‚
          â†“       â†“
          A â”€â”€â”€â”€â†’ B
              g

Q: Should I drop the condition that any opcartesian morphism whose
codomain is trivial is split epi?
A: I can't seem to prove it for the above notion of `trivial', though
I can prove it in the codomain bifibration. It seem to inherently
require upstairs morphisms leaking downstairs, which makes sense in
the codomain bifibration, but won't when I have arbitrary relations
upstairs and just the free product category downstairs.

=== 2017.10.12

Q: What's a dead simple recharacterization of trivial objects?
A: They're the objects for which the unique map into the terminal
object is cartesian! This smells a lot like 'fibrant' objects, but I
guess 'cartesian' is different from 'fibration'?

Q: Are products of opcartesian squares again opcartesian?
A: Not sure they are in general, but seems to be the case in the
codomain bifibration over a category with products. Maybe I need to
demand it. It seems like a kind of distributivity property.

=== 2017.10.13

Q: Is my characterization of categories as relational things actually
a full embedding?
A: Hm, maybe not. Need some kind of grading perhaps.

=== 2017.10.15

Q: What agda did I start writing for relational things?
A:
<<<
{-# OPTIONS --without-K #-}
module b where

open import HoTT


bd : Set â†’ Setâ‚
bd X = Î£ Set (Î» A â†’ A â†’ X)

postulate
  fib : {X : Set} â†’ bd X â†’ Set
  hom : {A B X : Set} {g : B â†’ X} {f : A â†’ B} â†’ fib (B , g) â†’ fib (A , g âˆ˜ f) â†’ Set

module _ {A B X : Set} (g : B â†’ X) (f : A â†’ B) where
  postulate
    reidx : fib (A , g âˆ˜ f) â†’ fib (B , g)
    opidx : fib (B , g) â†’ fib (A , g âˆ˜ f)
    reidx-hom : (t : fib (A , g âˆ˜ f)) â†’ hom (reidx t) t
    opidx-hom : (t : fib (B , g)) â†’ hom t (opidx t)
>>>

=== 2017.10.15

Q: What other agda false start did I have before realizing that
Î·-naturality is merely some laxer kind of 2-categorical pushout?
A:
<<<
postulate
  â™¯ : Set â†’ Set
  Î· : {A : Set} â†’ A â†’ â™¯ A
  â™¯F : {A B : Set} â†’ (A â†’ B) â†’ â™¯ A â†’ â™¯ B
  â™¯nat : {A B : Set} {f : A â†’ B} â†’ (a : A) â†’ â™¯F f (Î· a) == Î· (f a)
  â™¯+ : {A B : Set} â†’ â™¯ (A âŠ” B) â†’ â™¯ A âŠ” â™¯ B
  â™¯push : {A B X : Set} (f : A â†’ B) (g : â™¯ A â†’ X) (h : B â†’ X) â†’ h âˆ˜ f == g âˆ˜ Î· â†’ â™¯ B â†’ X
  â™¯push1 : {A B X : Set} {f : A â†’ B} {g : â™¯ A â†’ X} {h : B â†’ X} {p : h âˆ˜ f == g âˆ˜ Î·}
    â†’ â™¯push f g h p âˆ˜ â™¯F f == g
  â™¯push2 : {A B X : Set} {f : A â†’ B} {g : â™¯ A â†’ X} {h : B â†’ X} {p : h âˆ˜ f == g âˆ˜ Î·}
    â†’ â™¯push f g h p âˆ˜ Î· == h
  â™¯pushu : {A B X : Set} {f : A â†’ B} {g : â™¯ A â†’ X} {h : B â†’ X} {p : h âˆ˜ f == g âˆ˜ Î·}
    {z : â™¯ B â†’ X}
    â†’ z âˆ˜ â™¯F f == g â†’ z âˆ˜ Î· == h â†’ z == â™¯push f g h p
  â™¯compat : {A B : Set} â†’ â™¯+ âˆ˜ Î· {A âŠ” B} == {!!}
>>>
