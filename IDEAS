=== 2017.09.08

Q: What is the status of (2.2) in [RS]? Is it an axiom
in the system, or is it a provable property of the type system that
merely happens to be written as an inference rule, i.e. like cut
elimination?
A: ???

Q: In figure 3, why do premises Ï† and Ïˆ appear downstairs in the
fourth and fifth rules listed, when they already are assumed to follow
from Î | Î¦?
A: ???

Q: In the third rule in figure 4, why isn't *s* constrained to somehow
live in Ïˆ?
A: I guess it's because it's not that f needs something to live in a
shape to accept it as an argument; it's that f can only give answers
for things that live inside Ïˆ. We're asking that s is defined on
the whole cube I, and we can consider the restriction of the cube to
Ïˆ before feeding it to f. Thus, I might better ask:

Q: In the third rule in figure 4, why isn't s allowed to be defined
merely on Ïˆ? Why must it be defined on the whole cube I?
A: Oh, I see --- it's because the arguments to the function are merely
cube expressions, not general terms. There's no way to even specify a
cube term that's something other than a tuple of projections.

=== 2017.09.09

Q: How do Joyal disks [Joyal97] lead to âˆ-categories according to [RS]?
A: ???

Q: In [RS] Axiom 4.6, we're not making any additional assumption on
t : I | Ï† |- Ïˆ
by saying it's a cofibration, right? My belief is that
Ïˆ is just a cofibration by being of that syntactic class.
A: ???

=== 2017.09.10

Q: Is the Finster-Mimram definition of weak omega-categories connected
in a simple way to Joyal's theta-category?
A: Probably can get a good sense by looking in
http://cheng.staff.shef.ac.uk/guidebook/guidebook-new.pdf
which I found from
https://ncatlab.org/nlab/show/Theta+category

=== 2017.09.11

Q: Where is the cubical stuff in the agda source?
A:
I see IZERO in
agda//src/full/Agda/TypeChecking/Monad/Builtin.hs
builtinIZero :: String = "IZERO"
primIZero :: TCM Term = getBuiltin builtinIZero

Q: Where are some exciting uses of primIZero?
A:
agda//src/full/Agda/TypeChecking/Primitive.hs

Q: Where is haskell-mode docs?
A: http://haskell.github.io/haskell-mode/manual/latest/

Q: More emacs advice about haskell dev?
A:
https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md

Q: What's the thing I want to bind to M-.?
A:
haskell-mode-jump-to-def

It seemed to take a long-ass time the first time I ran it, dunno why.

Q: Where are the sources to, like, the haskell base library including
the prelude Control.Monad and everything?
A: I thought maybe in
/usr/local/Cellar/ghc/7.10.3b/lib/ghc-7.10.3/
(which
$ brew list ghc
told me about)
but I only see .hi files.
...
Seems to exist online at
http://git.haskell.org/ghc.git/tree/refs/heads/master:/libraries/base/Control

Q: Transportation to the vicinity of wesleyan?
A: "Vermonter" amtrak + M-link bus maybe?
Hotel situation looks like a bummer.
No, nevermind, looks like I can just get a ride up with dlicata@.

Q: How can I git blame one line of a file?
A:
do like
$ git blame Primitive.hs -L404,+1

=== 2017.09.16

Q: How redundant is rule 5 of figure 4 in [RS]? It seems like morally I can
take the assumption that a == b and apply substitution to see
a[s/t] == b[s/t] and then use transitivity from rule 4's f(s) = a[s/t].
A: ???

=== 2017.09.18

Q: Ok, so where are the guts of cubical typechecking going on?
A:
try looking in
agda//src/full/Agda/TypeChecking/Rules/Term.hs
agda//src/full/Agda/TypeChecking/Rules/Builtin.hs
agda//src/full/Agda/TypeChecking/Primitive.hs
agda//src/full/Agda/TypeChecking/Telescope.hs

Q: Is there a way to view all these haskell function docstrings in a nice way?
A:
$ cabal install haddock
$ cabal configure
$ cabal haddock
and generates into
agda//dist/doc/html/Agda/index.html

Q: Why didn't
$ make haddock
work?
A:
mysterious missing dependencies?

# $ make haddock
# doesn't work due to

Q: What are some examples of cubical programs?
A:
agda//test/Fail/Issue2650.agda
agda//test/Fail/Issue2650.agda
agda//test/Succeed/Issue2650.agda
and also a goldmine of stuff in
gh//Saizan/cubical-demo

Q: What are the cubical primitives in
agdalib//prim/Agda/Primitive.agda
sorted by epistemic status?
A:
I definitely understand
 I, i0, i1
 primIMin
 primIMax
 primINeg
 IsOne
 itIsOne
 IsOne1 -- These two are just asserting that
 IsOne2 -- 1 v x = 1 and x v 1 = 1

Q: What's the deal with
<<<
 primPOr : {a : Agda.Primitive.Level} (i j : I)
      {A : .(IsOne (primIMax i j)) â†’ Set a} â†’
      (.(p : IsOne i) â†’ A _) â†’
      (.(p : IsOne j) â†’ A _) â†’ .(p : IsOne (primIMax i j)) â†’ A p
>>>
?
A: I think I vaguely understand it to be the realization of the disjunctive "systems" in
[CCHM] https://arxiv.org/pdf/1611.02108.pdf
which correspond to the disjunction elimination rules in [RS].

Q: What's the deal with
<<<
 Partial : {a : Agda.Primitive.Level} (A : Set a) â†’ I â†’ SetÏ‰
>>>
?
A:
It's described as
<<<
"Partial A Ï†"  is a special version of "(Ï† = i1) â†’ A"
>>>
in
gh//Saizan/cubical-demo/blob/master/AIM_Demo/DemoPartial.agda
which I think I kind of get.
I believe
<<<
 PartialP : {a : Agda.Primitive.Level} (Ï† : I)
      (A : .(o : IsOne Ï†) â†’ Set a) â†’
      SetÏ‰
>>>
is just the more dependent 'path-over' version of Partial, sorta? I
see it used in the same file there.

Q: What's the deal with
<<<
 primPFrom1 : {a : Agda.Primitive.Level} {A : I â†’ Set a} â†’
      A i1 â†’ (i j : I) â†’ .(IsOne i) â†’ A (primIMax i j)
>>>
A: If I squint it just looks like it's sort of internalizing the fact
that if I know i is already i1, then primIMax i j has to be i1 too, so
I can lift something known to be at A i1 to A (primIMax i j). Maybe
it's just making things definitionally equal that would otherwise be
propositionally equal.

Q: What's the deal with
<<<
 primComp : {a : I â†’ Agda.Primitive.Level} (A : (i : I) â†’ Set (a i))
      (Ï† : I) â†’
      ((i : I) â†’ .(IsOne Ï†) â†’ A i) â†’ A i0 â†’ A i1
>>>
A: This is the composition primitive from the paper.

Q: Wait, I see other primitives still in
gh//Saizan/cubical-demo/blob/master/Primitives.agda
what's the deal with them?
A:
well, primPathPApply does exist in
agda//src/full/Agda/TypeChecking/Primitive.hs
due to
agdac//b0596dde
and CONID exists in
agda//src/full/Agda/TypeChecking/Monad/Builtin.hs
due to
agdac//7a50bedf

Q: Where is that in the agda repo?
A:
agda//src/data/lib/prim/Agda/Primitive.agda

Q: What's going on with the primitive keyword?
A: I guess it's just a way of grabbing primitive function values with the standard name, see
agda//examples/Introduction/Built-in.agda
(which doesn't appear to compile due to a change of the number of arguments of the Integer built-in?)

Q: How is agda's version number spread througout other things?
A: Well, I see commits like agdac//3ca28ee9 but I don't know if there's a
script that achieves all these changes in a simple way.

Q: What're some milestones in the history of editing the cubical code?
A:
agdac//e919f74e due to Andrea Vezzosi https://github.com/Saizan

Q: What's the suffix .hs-boot for?
A: Reifying cycles for mutuall recursive modules, see
https://downloads.haskell.org/~ghc/7.0.3/docs/html/users_guide/separate-compilation.html
and search for 'hs-boot'

Q: What are all these moon-language operators I'm seeing everywhere like
<@>, <#>, <..>, <@@>?
A: They are in fact defined in
agda//src/full/Agda/TypeChecking/Primitive.hs
and some more are in
agda//src/full/Agda/Utils/Functor.hs
<$> is just an infix name for fmap, see
http://git.haskell.org/ghc.git/blob_plain/refs/heads/master:/libraries/base/Data/Functor.hs

Q: How do I think about what [CCHM] calls 'partial elements'?
A: They're the things that are defined over the whole cube, but have
particular known values at subpolyhedra of the cube?

Q: What can I figure out about PrimitiveImpl?
A:
It's made of a Type and a PrimFun

Q: How do I printf in haskell?
A: Debug.Trace.trace, see
https://wiki.haskell.org/Debugging

Q: What's the deal with type IntervalView in
agda//src/full/Agda/Syntax/Internal.hs
A:
It was last touched by
agdac//6d78a1d4
I surmise it's some sort of way of exposing some of the interval term structure...

Q: What's going on with ignoreSharing in
agda//src/full/Agda/TypeChecking/Monad/Builtin.hs
?
A:
It's defined in
agda//src/full/Agda/Syntax/Internal.hs
and I would have named it, like, 'derefSharing' or something.

Q: What's a bang mean in haskell datatype definitions?
A: Strictness annotation, see
https://stackoverflow.com/questions/993112/what-does-the-exclamation-mark-mean-in-a-haskell-declaration

Q: What's an iota-redex, as mentioned in data Term comments in
agda//src/full/Agda/Syntax/Internal.hs
?
A: Something to do with pattern matching, see
https://github.com/agda/agda/issues/2276

Q: What's something that triggers the checking in primPOr that the two overlapping definitions
are consistent on their intersection?
A:
<<<
{-# OPTIONS --cubical #-}
module a where
import Agda.Primitive
open Agda.Primitive.CubicalPrimitives public

data Two : Set where
 ğŸ™ ğŸš : Two

x = primPOr i1 i1 {A = Î» _ â†’ Two} (Î» _ â†’ ğŸ™) (Î» _ â†’ ğŸš)
>>>
gives an error as expected.

Q: Why does
(primPOr i0 i1 {A = Î» _ â†’ Two} (Î» _ â†’ ğŸš) (Î» _ â†’ ğŸ™)) itIsOne
give an error about being fully applied?
A: ???

Q: What's the commit that created builtin PATH?
A: agdac//5e8aae7c

Q: Why doesn't Category.agda of
gh//Saizan/cubical-demo/blob/master/Category.agda
at commit 12f3d8f3
seem to compile at agdac//a67e5e2f?
A: ???

Q: How do I run agda from ghci so I can inspect things going on?
A: cabal repl

Q: Also can I just bash stuff into the prompt in *agda* in emacs?
A: Yeah, seems like!

Q: What's this syntax going on in
<<<
foo : âˆ€ i â†’ Partial Bool (i âˆ¨ ~ i)
foo i (i = i1) = true
foo i (i = i0) = false
>>>
in
gh//Saizan/cubical-demo/blob/master/AIM_Demo/DemoPartial.agda
?
A: Seems like a pattern-matching elimination for values of the type
IsOne?

=== 2017.09.19

Q: Where is this IsOne pattern elimination in the agda abstract syntax?
A:
I see a hint in the use of domFinite, and the comment in
agda//src/full/Agda/Syntax/Common.hs about primIsOne
this leads to looking at
agda//src/full/Agda/TypeChecking/Rules/LHS/Split.hs
which is a big mess.

Q: Can I get any insight by just git blaming
agda//src/full/Agda/Syntax/Abstract.hs
A:
Sure can! I see Vezzosi's agdac//c584e887 touching a thing called EqualP.
yup,
<<<
  | EqualP Range [(Expr,Expr)]             -- ^ @i = i1@ i.e. cubical face lattice generator
>>>
in
agda//src/full/Agda/Syntax/Concrete.hs

Q: What's an interesting paper about internalizing dependent lambda calculus?
A:
"Outrageous but Meaningful Coincidences" McBride 2010, found in
https://homotopytypetheory.org/2014/03/03/hott-should-eat-itself/

Q: Wow, cabal repl is slow interactively. Even for editing text in
readline. What do?
A:
put
<<<
:set -fobject-code
>>>
in the .ghci file
http://chrisdone.com/posts/making-ghci-fast
https://www.reddit.com/r/haskell/comments/3ddcrw/does_haskell_have_slow_iteration_times_are_those/

Q: What do about the message
Warning: Can't find file "dist-2.6.0/build/autogen/cabal_macros.h" in directories
I see during cabal repl?
A:
Just
$ ln -s dist dist-2.6.0
as andreas abel recommends in
http://agda.chalmers.narkive.com/4ACGqXHw/problems-configuring-haskell-mode-and-or-invoking-cabal-repl

Q: More basic stuff about cabal?
A: http://katychuang.com/cabal-guide/

Q: What am I looking at trying to figure out how to typecheck a single expression from repl?
A: agda//src/full/Agda/Syntax/Parser.hs

Q: Where's MonadIO come from?
A:
<<<
:info Control.Monad.IO.Class.MonadIO
class Monad m => Control.Monad.IO.Class.MonadIO (m :: * -> *) where
  Control.Monad.IO.Class.liftIO :: IO a -> m a
  	-- Defined in â€˜Control.Monad.IO.Classâ€™
instance Control.Monad.IO.Class.MonadIO PM
  -- Defined in â€˜Agda.Syntax.Parserâ€™
instance Control.Monad.IO.Class.MonadIO IO
  -- Defined in â€˜Control.Monad.IO.Classâ€™
>>>

Q: What's it good for, vis-a-vis the PM type class?
A: Lifting IO actions *into* PM, not injecting PM into IO. Boo.

Q: Oh, but what do I want for that?
A: runPMIO

Q: How do I get ghci to show types
A:
either
:type <expression>
or
:set +t
(which I could do interactively or put in my .gchi)
according to
https://stackoverflow.com/questions/12659927/using-ghci-to-find-type

Q: How do I get ghci to allow multi-line defns?
A:
:set +m
<<<
Î»> let zzz :: Integer
Î»|     zzz = 2
Î»|
zzz :: Integer
Î»>
>>>
https://stackoverflow.com/questions/2846050/how-to-define-a-function-in-ghci-across-multiple-lines
ugh but then every single line expression requires a double-return
:unset +m
it is, then.

Q: How do I parse a single expression?
A:
<<<
import Agda.Syntax.Parser
let runParse :: String -> IO (Either ParseError Agda.Syntax.Concrete.Expr, [ParseWarning]) ; runParse s = runPMIO (parse exprParser s)
>>>

Q: How can I create a primitive type?
A: Can imitate Bool, did not gain much insight though.

Q: How can I create a simple primitive typed constant?
A: ???

Q: How can I create a primitive typed constant that reduces?
A: ???

Q: Where did this *agda* buffer come from?
Was it from haskell-session-change?
A: ???

Q: How do I run agda tests?
A: well I can just do things like
$ dist/build/agda/agda -i test test/Common/String.agda
for some reason
$ make test
gives me errors

Q: Oh, crumb, cabal build seems to clear whatever incremental state cabal repl has.
I guess I should try to do stuff from inside repl. How do?
A:
I see
parsePragmaOptions
defined in
agda//src/full/Agda/Interaction/Options.hs
being called from
agda//src/full/Agda/TypeChecking/Monad/Options.hs
agda//src/full/Agda/Interaction/Imports.hs
...
red herring?
Hmm.
Well I can stick
<<<
  let argv     = ["-i", "/tmp", "/tmp/a.agda"]
>>>
in runAgda' in
agda//src/full/Agda/Main.hs
and that seems to 'work'.

Q: What's a good solution for TAGS for haskell?
A: ???

Q: Why no builtin thing COLOR even after I define it?
A:
the error is
NoSuchBuiltinName
from
agda//src/full/Agda/TypeChecking/Errors.hs
which may have come from one of
agda//src/full/Agda/TypeChecking/Monad/Builtin.hs
agda//src/full/Agda/TypeChecking/Rules/Builtin.hs
but probably the latter.

Huh, it works after I add
<<<
+  , (builtinColor              |-> BuiltinData tset [builtinRed])
>>>
in
agda//src/full/Agda/TypeChecking/Rules/Builtin.hs
to parallel bool.

=== 2017.09.20

Q: mortberg@'s explanation of cubical types?
A:
https://homotopytypetheory.org/2017/09/16/a-hands-on-introduction-to-cubicaltt/
https://github.com/mortberg/cubicaltt/tree/master/lectures

Q: induction-induction vs. induction-recursion?
A:
https://en.wikipedia.org/wiki/Induction-recursion
https://ncatlab.org/homotopytypetheory/show/inductive-inductive+type
http://cs.swan.ac.uk/~csfnf/papers/indind_finite.pdf
https://ncatlab.org/nlab/show/inductive-inductive+type

Q: dual of applicative and alternative?
A: https://hackage.haskell.org/package/contravariant-1.4/docs/Data-Functor-Contravariant-Divisible.html
people (more or less rightly) complaining about the intensity of the category theory involved on twitter at
https://twitter.com/jb55/status/910293593851490304

Q: Thread on hott mailing list from dlicata@ about how to prove univalence?
A: https://groups.google.com/forum/#!msg/homotopytypetheory/j2KBIvDw53s/YTDK4D0NFQAJ

Q: Where are haddock generated docs?
A: /Users/jreed/.cabal/sandboxes/agda-build/agda/dist/doc/html/Agda/index.html

Q: What's a concrete way to show off the non-fibrancy of II?
A: ???

Q: Where's the proof of
<<<
-- The reason we need to add <j> a is that we want the top-left point
-- to be a, if we would have omitted it it would instead have been
-- "transport (<_> A) a". We used to have a version of the system
-- where this was the same as a, this relied on a property which we
-- called "regularity". It was however proved by Dan Licata that this
-- property is not preserved by the algorithm for composition for the
-- universe, so we had to drop it and the user now has to give <j> a
-- explicitly.
>>>
that I see in
https://github.com/mortberg/cubicaltt/blob/master/lectures/lecture2.ctt
A:
https://groups.google.com/forum/#!msg/homotopytypetheory/oXQe5u_Mmtk/3HEDk5g5uq4J
looks like a start, but ??? because I want to ask dan.

Q: What's the relationship between the kan filling that
dlicata@ talks about in
"Cubical infinite-dimensional type theory"
https://www.youtube.com/watch?v=lt8JgGRw7gg
and the modern [CCHM] take?
A: ???

Q: What's a nice compact way of looking at J that I get after
beta-reducing the one in mortberg@'s lecture notes?
A:
<<<
myJ (A : U) (a : A) (P : (b : A) -> Path A a b -> U)
  (d : P a (refl A a)) (b : A) (p : Path A a b) : P b p =
  comp (<i> P (p @ i) (<j> p @ i âˆ§ j)) d []
>>>

=== 2017.09.21

Q: What's an example of a monomorphism that's *not* a cofibration?
What's special about face inclusions?
A: ???

Q: What do categories with (merely) weak equivalences allow?
A: simplicial localization, see
https://ncatlab.org/nlab/show/simplicial+localization
there seem to be other constructions for subtypes of CwWE, namely
model categories and homotopical categories, but I don't understand
them yet.

Q: What misconception did I just clear up about gluing in [CCHM]?
A: It's not another thing that you have to define for every type, like
composition is; it's a type constructor. A Glue-type is a type built
out of a phi-restricted fragment of another type, plus some
equivalence glue that is valid on the phi-restriction.

Afterwards you define composition *on* glue-types, and composition
*on* the universe is definable by using glue-types in the definition
body.

Q: Can I get any sort of interlibrary deals through wesleyan
affiliation?
A: ???

Q: What should I make of the discussion on
https://homotopytypetheory.org/2017/09/16/a-hands-on-introduction-to-cubicaltt/
between shulman@ and mortberg@ about canonicity vs. many-models? I
don't feel like I grasp what's at stake.
A: ???

Q: In [ShuFix] inbetween eqn 4.1 and eqn 4.2, it says
â™­(A â†’ B) â†’ â™­(â™­A â†’ â™­B)
is obtainable. But surely also we can get
â™­(A â†’ B) â†’ (â™­A â†’ â™­B)
I'd think, at least?
A: ???

Q: What's my thoughts on I prefer to think about the '2-categorical
adjoint logic' stuff?
A:

I have judgmental *levels* L, typical element â„“. I have corresponding
syntactic classes of resources and frames, call them râ„“ (variables Ïâ„“)
and fâ„“ (variables Ï†â„“). I have positive propositions Pâ„“ and negatives Nâ„“.

Then I have relations râ„“ â–¹â„“ fâ„“, may henceforth elide the â„“ on â–¹.

If I'm to set up F âŠ£ U and let's say with propositional functions
F : PÎ½ â†’ PÏ„ and U : NÏ„ â†’ NÎ½ for {Ï„,Î½} âŠ† L then I'm going to need
a resource function f : rÎ½ â†’ rÏ„

so that (leaving off Ï„ suffixes)

F PÎ½1 [Ï1], F PÎ½2 [Ï2] |- F PÎ½3 [Ï†]

translates to

F PÎ½1 @ Ï1, F PÎ½2 @ Ï2, âˆ€Ï.(F PÎ½3 @ Ï)â†’(Ï â–¹ Ï†) âŠ¢ Ï1 * Ï2 â–¹ Ï†

which inverts to (b.c. F PÎ½ @ Ï = âˆƒÏÎ½.(Ï = f ÏÎ½) âˆ§ (PÎ½ @ ÏÎ½))
PÎ½1 @ ÏÎ½1, PÎ½2 @ ÏÎ½2, âˆ€Ï.(F PÎ½3 @ Ï)â†’(Ï â–¹ Ï†) âŠ¢ f(Ï1) * f(Ï2) â–¹ Ï†
which should be equal to
PÎ½1 @ ÏÎ½1, PÎ½2 @ ÏÎ½2, âˆ€Ï.(F PÎ½3 @ Ï)â†’(Ï â–¹ Ï†) âŠ¢ f(Ï1 * Ï2) â–¹ Ï†
and then I could focus and step to
PÎ½1 @ ÏÎ½1, PÎ½2 @ ÏÎ½2 âŠ¢ F PÎ½3 @ f(Ï1 * Ï2)
which is
PÎ½1 @ ÏÎ½1, PÎ½2 @ ÏÎ½2 âŠ¢ âˆƒÏÎ½.(f(Ï1 * Ï2) = f ÏÎ½) âˆ§ (PÎ½3 @ ÏÎ½)
and I can choose
PÎ½1 @ ÏÎ½1, PÎ½2 @ ÏÎ½2 âŠ¢ PÎ½3 @ Ï1 * Ï2
and this all goes like I expect.

To get focusing of F, I need a function u : fÏ„ â†’ fÎ½ with

(f ÏÎ½) â–¹ Ï†t â‰¡ ÏÎ½ â–¹ (u Ï†t)
       Ï„         Î½

Ok, fine, but how do I rig up a triple adjunction? Negative and
positive props are different. If I have F âŠ£ U and V âŠ£ H and arrange
so that, ignoring focusing, (negative) U and (positive) V are somehow the same?

In props:

    PÎ½    NÎ½    PÎ½    NÎ½
   F â†“ âŠ£ U â†‘ â‰… V â†‘ âŠ£ H â†“
    PÏ„    NÏ„    PÏ„    NÏ„

with functions

    rÎ½    fÎ½    rÎ½    fÎ½
   f â†“ âŠ£ u â†‘ â‰… v â†‘ âŠ£ h â†“
    rÏ„    fÏ„    rÏ„    fÏ„

Ok, let me just look at what I need to get, let's say, the interprovability

U N âŠ£âŠ¢ V â†“ N

for
U N âŠ¢ V â†“ N
I expand to
U N [Ï] âŠ¢ V â†“ N [Ï†]
âˆ€ÏÎ½.((V â†“ N) @ ÏÎ½) â†’ (ÏÎ½ â–¹ Ï†Î½), âˆ€Ï†Î½.((U N) @ Ï†Î½) â†’ (ÏÎ½ â–¹ Ï†Î½) âŠ¢ ÏÎ½ â–¹ Ï†Î½
------------> need: ÏÎ½ â‰¤ v (f ÏÎ½)
âˆ€ÏÎ½.((V â†“ N) @ ÏÎ½) â†’ (ÏÎ½ â–¹ Ï†Î½), âˆ€Ï†Î½.((U N) @ Ï†Î½) â†’ (ÏÎ½ â–¹ Ï†Î½) âŠ¢ v (f ÏÎ½) â–¹ Ï†Î½
âˆ€Ï†Î½.((U N) @ Ï†Î½) â†’ (ÏÎ½ â–¹ Ï†Î½) âŠ¢ (V â†“ N) @ v (f ÏÎ½)
âˆ€Ï†Î½.((U N) @ Ï†Î½) â†’ (ÏÎ½ â–¹ Ï†Î½) âŠ¢ â†“ N @ f ÏÎ½
âˆ€Ï†Î½.((U N) @ Ï†Î½) â†’ (ÏÎ½ â–¹ Ï†Î½), N @ Ï† âŠ¢ f ÏÎ½ â–¹ Ï†
âˆ€Ï†Î½.((U N) @ Ï†Î½) â†’ (ÏÎ½ â–¹ Ï†Î½), N @ Ï† âŠ¢ ÏÎ½ â–¹ u Ï†
N @ Ï† âŠ¢ (U N) @ u Ï†
N @ Ï† âŠ¢ N @ Ï†

for
V â†“ N âŠ¢ U N
I expand to
V â†“ N [ÏÎ½] âŠ¢ U N [Ï†Î½]
(V â†“ N) @ ÏÎ½, U N @ Ï†Î½ âŠ¢ ÏÎ½ â–¹ Ï†Î½
(â†“ N) @ Ï, N @ Ï† âŠ¢ v Ï â–¹ u Ï†
âˆ€Ï†.(N @ Ï†) â†’ (Ï â–¹ Ï†), N @ Ï† âŠ¢ v Ï â–¹ u Ï†
âˆ€Ï†.(N @ Ï†) â†’ (Ï â–¹ Ï†), N @ Ï† âŠ¢ Ï â–¹ h (u Ï†)
âˆ€Ï†.(N @ Ï†) â†’ (Ï â–¹ Ï†), N @ Ï† âŠ¢ Ï â–¹ h (u Ï†)
------------> need: Ï† â‰¤ h (u Ï†)
âˆ€Ï†.(N @ Ï†) â†’ (Ï â–¹ Ï†), N @ Ï† âŠ¢ Ï â–¹ Ï†

Ok, yeah, there's two sorts of adjunctions going on, call them âŠ£â–¹ and
âŠ£â‰¤, and we have

          âŠ£â–¹
       f ----> u
       |       |
    âŠ£â‰¤ |       | âŠ£â‰¤
       â†“       â†“
       v ----> h
          âŠ£â–¹

ok, sure, so both u and v are the right adjoint of f, in two different
ways; of course they should work out to be 'the same', since adjoints
are unique up to isomorphism.

Let's say I start with âŠ¢ v (f ÏÎ½) â–¹ Ï†Î½ and I want to get to âŠ¢ ÏÎ½ â–¹ Ï†Î½.
I can do this immediately by appealing to the unit ÏÎ½ â‰¤ v (f ÏÎ½),
*or* I can transpose to âŠ¢ ÏÎ½ â–¹ u (h Ï†Î½) and appealing to the counit
u (h Ï†Î½) â‰¤ Ï†Î½.

Similarly if I start with âŠ¢ Ï â–¹ Ï† and I want to get to âŠ¢ Ï â–¹ h (u Ï†).
Can do directly with the unit Ï† â‰¤ h (u Ï†), or with the counit
f (v Ï) â‰¤ Ï to get âŠ¢ f (v Ï) â–¹ Ï† and then transposing.

=== 2017.09.22

Q: Why do I think that â™¯L should clear the context of coherent
assumptions? [Adj2] doesn't do that, and indeed I have a harder time
convincing myself cut goes through with my version.
A:
I got to this by thinking through how
Î”, Î“, â™¯A[r] âŠ¢ C
â‡”
Î” @ Ïâ‚, Î“ @ Ïâ‚‚, â™¯A @ Ïâ‚ƒ, C @ Ï† âŠ¢ f(Ïâ‚ * Ïâ‚ƒ), Ïâ‚‚ â–¹ Ï†
seems to require dropping the Ïâ‚‚ to get
f(Ïâ‚ * Ïâ‚ƒ) â–¹ Ï†
and from there
fÏâ‚ * fÏâ‚ƒ â–¹ Ï†
fÏâ‚ * fÏâ‚ƒ â–¹ Ï†
Ïâ‚ƒ â–¹ u(u(fÏâ‚ âŠ¸ Ï†))
so I can unpack the â™¯A @ Ïâ‚ƒ to get
Î” @ Ïâ‚, Î“ @ Ïâ‚‚, A @ Ï', C @ Ï† âŠ¢ Ïâ‚ƒ â–¹ u(fÏâ‚ âŠ¸ Ï†)
which is equivalent to
Î” @ Ïâ‚, Î“ @ Ïâ‚‚, A @ Ï', C @ Ï† âŠ¢ fÏâ‚ * fÏ' â–¹ Ï†
...
Ohhh this is all just a mistake. I can transform
f(Ïâ‚ * Ïâ‚ƒ), Ïâ‚‚ â–¹ Ï†
to
fÏâ‚ * fÏâ‚ƒ â–¹ Ïâ‚‚ âŠ¸ Ï†
fÏâ‚ƒ â–¹ fÏâ‚ âŠ¸ Ïâ‚‚ âŠ¸ Ï†
ffÏâ‚ƒ â–¹ fÏâ‚ âŠ¸ Ïâ‚‚ âŠ¸ Ï†
Ïâ‚ƒ â–¹ uu(fÏâ‚ âŠ¸ Ïâ‚‚ âŠ¸ Ï†)
which gives me
Î” @ Ïâ‚, Î“ @ Ïâ‚‚, A @ Ï', C @ Ï† âŠ¢ Ï' â–¹ u(fÏâ‚ âŠ¸ Ïâ‚‚ âŠ¸ Ï†)
or equivalently
Î” @ Ïâ‚, Î“ @ Ïâ‚‚, A @ Ï', C @ Ï† âŠ¢ fÏâ‚ * fÏ' * Ïâ‚‚ â–¹ Ï†

Q: Reading [ShuFix], what's an example of a mono in Top that's not a subspace inclusion?
A: Take
I = [0,1)
and map I into â„‚ via
Î»x.exp(2Ï€xi)
You get the unit circle, which as a subspace has a different topology from I.

Q: No, this doesn't seem right. What do the brackets around P mean on page 15 of [ShuFix]?
A: ???

=== 2017.09.23

Q: What is the essential reason why valid assumptions, and therefore
boxed types, must depend only on valid things?
A: Because when I clear the context, I can't strand them from the
hypotheses they need to be valid.

Imagine I have signature
A : type
B : A â†’ type
and try to prove
a : A true, b : (B a) valid âŠ¢ ? : â–¡ C
I'll immediately try to construct, via â–¡R,
b : (B a) valid âŠ¢ ? : C
which is nonsense.

Q: How does this play out with categorified judgmental levels?
A: Not 100% sure yet. Wonder if I want to think of the context as a
graph whose edges are morphisms in the level category, or else maybe
allow context annotations to have 'zeroes' in them. I could imagine an
invariant something like

If Î“[Î³], x :_p A[m], Î“'[Î³'] âŠ¢ J_q

then for some Î³â‚€ such that Î³â‚€m âŠ† Î³ we have

Î“[Î³â‚€] âŠ¢ A : type_p

A zero in Î“[Î³â‚€] means 'weaken that variable away'
A zero is âŠ† any morphism, but otherwise in Î³â‚€m âŠ† Î³ everything has to agree.

This is meant to make

x :_p A[m]

behave just like

x :_q (F_m A) [id_q]

Whose intro rules (for m : p â†’ q) I imagine go something like

Î“[Î³â‚€] âŠ¢ A : type_p    Î³â‚€m âŠ† Î³
-----------------------------
Î“[Î³] âŠ¢ F_m A : type_q

Î“[Î³â‚€] âŠ¢ M :_p A    Î³â‚€m âŠ† Î³
---------------------------------
Î“[Î³] âŠ¢ F_m M :_q F_m A

Q: What happens if I think of the context as a graph whose edges are labelled with morphisms?
A: I think I want to require commutativity of every diagram implied by
the graph? Or do I? My gut says it's probably required for some
substitution theorem or something.

Q: Is it possible for a neutral expression to have a type that
involves the constant at the head?
A: Sure, here's an example
<<<
module b where

postulate
  o : Set
  a : o -> Set
  b : (y : o) â†’ a y
  c : (y : o) â†’ a y -> o
  k : o

term : a (c k (b k))
term = b (c k (b k))
>>>

Q: Where did I put some notes about how 2-categorical modalities work
in dependent types?
A: /Users/jreed/wes/texnotes/2017-09-23.ltx

=== 2017.09.24

Q: What's a property I might want to pragmatically require for mode
theories to make typechecking tractable?
A:
If a âˆ˜ b = c, then
(a) there exists a maximal a' such that a' âˆ˜ b = c
(b) there exists a maximal b' such that a âˆ˜ b' = c
where a 'maximal' morphism means one that is the most useful attached
to an assumption. In the idempotent theory of 1 and r, I'm thinking of r â‰¥ 1,
and indeed in that situation, I have a best solution (namely r) to both
r âˆ˜ ? = r
? âˆ˜ r = r
and a unique solution (namely r) to both
1 âˆ˜ ? = r
? âˆ˜ 1 = r
and a unique solution (namely 1) to both
1 âˆ˜ ? = 1
? âˆ˜ 1 = 1
and no solution (which is ok) to both
r âˆ˜ ? = 1
? âˆ˜ r = 1

Q: What do I make of [Fib2]?
A: The main thing that strikes me is why go to all the effort of
designing and proving coherent a system when you can just translate it
away to FOL, but that's my bias showing.

Q: What's going on with the embedding/encoding distinction in [Fib2]?
A: ???

Q: What are the implications of thinking about two-cells between mode morphisms
(saying things like u âˆ˜ f â‰¤ 1) and merely talking about preorders on 'terms'
(saying things like âˆ€x . u(f(x)) â‰¤ x)
A: ???

Q: What am I getting out of reifying frames instead of what [Fib2] does, namely
thinking of them as structures-with-a-hole?
A: I guess greater uniformity of definition? My F rules look just like
my U rules with different sorts. I can represent classical logic as a
thing with frame constructors?

Q: Is it still possible to carry out a focusing proof for every logic
you can define in [Fib2]?
A: I think maybe yes; because the moment you throw in âŠ™, it's
impossible not to allow the definition of residuals x âŠ™ - and - âŠ™ x
which correspond to frame operations x â†£ - and x â†  -. So control over
frames (as opposed to abstractions) is what lets you define less
focally good logics like queue logic.

Q: What's that other paper dlicata@ thought would be an application of modalities?
A: [OrtonPitts]

=== 2017.09.25

Q: What's something to look for in [ShuFix]?
A: How exactly the properties of â™¯ and â™­ on top of their modal nature
get axiomatized.

Q: To what extent can the same be done with Êƒ?
A: ???

Q: What's a sensible tack on dependent modal stuff?
A: To aggressively track how every type depends modally on its
context.

=== 2017.09.26

Q: Where's my ticket for account renaming?
A: https://wesleyanedu.service-now.com/ess//incident_status.do

Q: Does anything go wrong with totally decoupled term bundles from type bundles
A: ???

=== 2017.09.27

Q: What's the dance we have to do to justify the type upstairs in $FL$ is well-formed?
A:
Something like
<<<
$$\Gamma, y: A^{\alpha} \prov y^{y:=1} : A^{\alpha}$$
$$\Gamma, y: A^{\alpha} \prov (F^{y:=1}_\mm y)^{y:=m} : (F^\alpha_\mm A)^{\alpha'}$$
$${\Gamma, x:(F^\alpha_\mm A)^{\alpha'} \prov   C^\gamma : \rtype}$$

$${\Gamma, y : A^\alpha, x:(F^\alpha_\mm A)^{\alpha'} \prov   C^{\gamma, y := m\gamma(x)} : \rtype}$$
$$
\erule
{\Gamma \prov N^\nu : A^\alpha\qquad \Gamma, x:A^\alpha, \Gamma' \prov M^{\mu} : C^\gamma \qquad \mu \ge \nu \mu(x) \qquad \gamma \ge \nu \gamma(x) \using sub}
{\Gamma, [N^\nu / x]\Gamma' \prov [N^\nu / x] (M^\mu) : [N^\nu / x](C^\gamma)}
$$
>>>
but I'm not super confident in this.

=== 2017.09.28

Q: In [RS] what's an example of a non-exponentiable map between categories?
A: ???

=== 2017.09.29

Q: In [RS], looking at the extension type
 âŸ¨ Î _{t : I | Ïˆ} A |^Ï†_{t.a} âŸ©
is it possible for A's well-formedness to depend on Ïˆ without actually
mentioning t?

(I'm trying to understand when exactly the notation
âŸ¨ { t : I | Ïˆ } â†’ A |^Ï†_{t.a} âŸ©
is justified, as defined at the end of section 2)
A: ???

Q: Where's avezzosi@'s agda implementation stuff for â™­?
A: agdac//1f943c9 and agdac//154073c, the difference from branch parametric to branch flat.

DONE: convinced IT to let me change my wesleyan account to jcreed@, I
think.

=== 2017.09.30

Q: How to get Skim to open a pdf to a certain page?
A:
https://emacs.stackexchange.com/questions/30344/how-to-link-and-open-a-pdf-file-to-a-specific-page-skim-adobe
links to org-mac.el at
http://orgmode.org/worg/org-contrib/org-mac-link.html
Or wait I can get by on the commandline with just
$ open -a /Applications/Skim.app some.pdf
and I don't even need to give a full path like I do with
$ open /Applications/Skim.app --args `pwd`/some.pdf

Q: How do I reload a file from applescript?
A:
$ osascript -e 'tell document "some.pdf" of application "Skim" to revert'


Q: What's a particular fixing of notation for the cast of characters in a fibration
that makes it look like a pullback?
A:
<<<
Ï€ : â„° â†’ â„¬

 x
   Ï†   Ïˆ
     a   -fâ†’   b
 â†§Ï€
   â†§Ï€
 X   â†§Ï€   â†§Ï€   â†§Ï€
   Î¦
     A   -Fâ†’   B
>>>

"Ï€ is a fibration" = âˆ€ (A B : â„¬)(F : A â†’ B)(b : Ï€â»Â¹ B) â†’ âˆƒ (a : Ï€â»Â¹ A) (f : a â†’ b) Ã— f is cartesian.

"f is cartesian" = âˆ€ (X : â„¬) (x : Ï€â»Â¹ X) (Î¦ : X â†’ A) (Ïˆ : Ï€â»Â¹ (F âˆ˜ Î¦) : x â†’ b) â†’ âˆƒ! (Ï† : Ï€â»Â¹ Î¦ : x â†’ a) Ã— (f âˆ˜ Ï† = Ïˆ)


Q: What does the bifibration situation look like for the mode 2-multicategory just being a monoid?
A:
<<<
    Î“ .
     \  ' .
      \     ' .
    â†§  â†˜        'â†˜
        UA -----â†’ A
        m
    * .
     \  ' . nm    â†§
    n \     ' .
       â†˜        'â†˜
        * ------â†’ *
             m

Î“ âŠ¢[nm] A
â•â•â•â•â•â•â•â•â•
Î“ âŠ¢[n] UA

    C â†–
     â†–  ' .
      \     ' .
    â†§  \        '
        FA â†----- A
        m
    * â†–
     â†–  ' . mn    â†§
    n \     ' .
       \        '
        * â†------ *
             m

A âŠ¢[mn] C
â•â•â•â•â•â•â•â•â•
FA âŠ¢[n] C
>>>

=== 2017.10.01

Q: How do I want to generalize the following?
<<<
Suppose I have a fibration
    Ï€
ğ”¼ â”€â”€â”€â”€â†’ ğ”¹

I can also think of this as a single category â„‚ living over the arrow category

    p
ğ„ â”€â”€â”€â”€â†’ ğ

The objects in â„‚ living over ğ„ are the objects of ğ”¼.
The objects in â„‚ living over ğ are the objects of ğ”¹.
The arrows in â„‚ living over 1_ğ„ are the arrows of ğ”¼.
The arrows in â„‚ living over 1_ğ are the arrows of ğ”¹.
The remaining arrows in â„‚ are pairs (E, b) where E is an object
of ğ”¼ and b is an arrow Ï€E â†’ B in ğ”¹.

Composition should be pretty clear. The interesting case is
when we compose e : E1 â†’ E2 upstairs with a transverse b : Ï€E2 â†’ B
and the answer is (b âˆ˜ Ï€e) : Ï€E1 â†’ B

In general, if F : â„‚ â†’ ğ”» and p is an arrow in ğ”», we say _â„‚ has
pullbacks along p_ if the pullback universal property holds like

      X   â†’
        â†˜
      â†“   E â”€â”€â”€â”€â”€â†’ E'
          â”‚        â”‚
          â”‚        â”‚
          â†“        â†“
          B â”€â”€â”€â”€â”€â†’ B'

          over

      ğ„   =
        =
      p   ğ„ â•â•â•â•â•â• ğ„
          â”‚        â”‚
          p        p
          â†“        â†“
          ğ â•â•â•â•â•â• ğ
>>>
A: I think I just want to say: suppose F : â„‚ â†’ ğ”» is a functor.
We say a diagram in ğ”» like

                   B
                   â”‚
                   â”‚g
                   â†“
          C â”€â”€â”€â”€â”€â†’ D
              f

has an F-pullback if first of all there is a pullback in ğ”»

               Ï€â‚‚
         BÃ—C â”€â”€â”€â”€â†’ B
          â”‚â”€â”˜      â”‚
        Ï€â‚â”‚        â”‚g
          â†“        â†“
          C â”€â”€â”€â”€â”€â†’ D
              f

And every â„‚-cospan over BCD has a universal cone over Ï€â‚,Ï€â‚‚?

Q: So what's the definition of fibration given this idea?
A:
You start with your
    Ï€
ğ”¼ â”€â”€â”€â”€â†’ ğ”¹

and construct from it â„‚ â”€Fâ†’ (ğ„ â”€pâ†’ ğ), and demand that p and 1_ğ have
an F-pullback.

Q: Is this the same as F 'creating the pullback of f and g'
A: ???

Q: Relevant links to this question?
A:
https://mathoverflow.net/questions/103065/what-is-the-correct-definition-of-creation-of-limits
https://ncatlab.org/nlab/show/created+limit
http://permalink.gmane.org/gmane.science.mathematics.categories/6644

Q: Is the functor over ğ„ â”€pâ†’ ğ itself a fibration?
A: Hmm maybe it's an opfibration. Given E, I can certainly lift along
p to Ï€E, where the requisite transverse arrow is 1_{Ï€E}.

          Ï€E â†â”€â”€â”€â”€ E

          â†§        â†§

          ğ â†â”€â”€â”€â”€â”€ ğ„
               p

Yeah that would require all transverse arrows E â†’ B to correspond to
B-arrows that look like Ï€E â†’ B, which seems true.

Q: Actually wait I'm not so sure about my definition in terms of
F-pullbacks, now. It seems prima facie more general than the fibrancy
condition. When I choose something over

                   ğ„
                   â”‚
                   p
                   â†“
          ğ â•â•â•â•â•â• ğ

it's not just a ğ”¹-morphism downstairs, and an *object* of ğ”¼, it's a
ğ”¹-morphism and a transverse morphism. Does being a fibration guarantee
an F-pullback of _that_?
A: Let's try. I start out with the data

                   E'
                   â†§
                  Ï€E'
              b    â†“c'
          B â”€â”€â”€â”€â”€â†’ B'

Can I at least form the putative pullback square? Ugh, no, because c'
is going the wrong way. Let's try reversing it?

                   E'
                   â†§
                  Ï€E'
              b    â†‘c'
          B â”€â”€â”€â”€â”€â†’ B'

Hmmm now I've got transverse morphism living over E â”€pâ†’ B is actually
made up of a morphism B â†’ Ï€E not the other way around. I tried drawing
the diagram

          E â”€â”€eâ”€â”€â†’ E'
          â†§        â†§
         Ï€E â”€Ï€eâ”€â”€â†’ Ï€E'
          â•‘        â†‘c'
          B â”€â”€bâ”€â”€â†’ B'

which does seem to arise out of fibrancy but I can't seem to
understand what composition in â„‚ is anymore. Grr.

---

Ok, how about, desperate measures here, maybe ğ”» is
        p,q
e âŸ³ ğ„ â”€â”€â”€â”€â”€â†’ ğ âŸ² b

with all of ğ”¹ living over b instead of 1_ğ, all of ğ”¼ living over e
instead of 1_ğ„ and

b âˆ˜ p = b âˆ˜ q = q = p âˆ˜ e = q âˆ˜ e = q
e âˆ˜ e = e   b âˆ˜ b = b

The morphisms that live over p are just pairs (E, Ï€E) with no real
morphism content. A morphism that lives over q is what I was trying to
define as a transverse morphism before, namely a triple (E, f, B) with
f : Ï€E â†’ B.

Now I think I want to consider the pullback of b against p, and I'm
not even sure I can pull that off in this ğ”». Or wait, maybe I can...

              e
          ğ„ â”€â”€â”€â”€â”€â†’ ğ„
          â”‚â”€â”˜      â”‚
         pâ”‚        â”‚p
          â†“        â†“
          ğ â”€â”€â”€â”€â”€â†’ ğ
              b

at least commutes. Is it a pullback? The only thing X can be is ğ„. The
only thing that the overall diagonal can be is q, because p doesn't
factor through b. So the top input projection has to be e not 1_ğ„. The
side input projection could be either p or q. But either of these has
a unique solution:

      ğ„   e
        e
      q   ğ„ â”€â”€eâ”€â”€â†’ ğ„
          â”‚â”€â”˜      â”‚
          p        â”‚p
          â†“        â†“
          ğ â”€â”€â”€â”€â”€â†’ ğ
              b

      ğ„   e
        1
      p   ğ„ â”€â”€eâ”€â”€â†’ ğ„
          â”‚â”€â”˜      â”‚
          p        â”‚p
          â†“        â†“
          ğ â”€â”€â”€â”€â”€â†’ ğ
              b

Ok, suppose fibrancy, to show pullbacks exist upstairs in â„‚. I've got

                   E'

                   â†§

          B â”€â”€fâ”€â”€â†’ Ï€E'

living over

                   ğ„
                   â”‚
                   p
                   â†“
          ğ â”€â”€bâ”€â”€â†’ ğ

and fibrancy gives me

          E â”€â”€gâ”€â”€â†’ E'

          â†§        â†§

          B â”€â”€Ï€gâ”€â†’ Ï€E'

with Ï€g = f and Ï€E = B. This means the e-arrow g composed with the
p-arrow for E' is the transverse arrow (E, Ï€g, Ï€E'), and so too is the
composite of trivial p-arrow for E and the b-morphism Ï€g. I think the
more difficult case of checking that it's a pullback is the left input
projection being q. So imagine

      X        h
                 â†˜
      â†§   E â”€â”€gâ”€â”€â†’ E'
     Ï€X
      k   â†§        â†§
        â†˜
          B â”€â”€fâ”€â”€â†’ B'

living over

      ğ„        e
                 â†˜
          ğ„ â”€â”€eâ”€â”€â†’ ğ„
          â”‚â”€â”˜      â”‚
      q   p        â”‚p
        â†˜ â†“        â†“
          ğ â”€â”€â”€â”€â”€â†’ ğ
              b

That is, we have a transverse k : Ï€X â†’ B in ğ”¹ and an h : X â†’ E' in ğ”¼
such that Ï€h = f âˆ˜ k. That's exactly what fibrancy wants to give us a
unique arrow X â†’ E over k satisfying the appropriate commutativities,
I think.