=== 2017.09.08

Q: What is the status of (2.2) in [RS]? Is it an axiom
in the system, or is it a provable property of the type system that
merely happens to be written as an inference rule, i.e. like cut
elimination?
A: ???

Q: In figure 3, why do premises œÜ and œà appear downstairs in the
fourth and fifth rules listed, when they already are assumed to follow
from Œû | Œ¶?
A: ???

Q: In the third rule in figure 4, why isn't *s* constrained to somehow
live in œà?
A: I guess it's because it's not that f needs something to live in a
shape to accept it as an argument; it's that f can only give answers
for things that live inside œà. We're asking that s is defined on
the whole cube I, and we can consider the restriction of the cube to
œà before feeding it to f. Thus, I might better ask:

Q: In the third rule in figure 4, why isn't s allowed to be defined
merely on œà? Why must it be defined on the whole cube I?
A: Oh, I see --- it's because the arguments to the function are merely
cube expressions, not general terms. There's no way to even specify a
cube term that's something other than a tuple of projections.

=== 2017.09.09

Q: How do Joyal disks [Joyal97] lead to ‚àû-categories according to [RS]?
A: ???

Q: In [RS] Axiom 4.6, we're not making any additional assumption on
t : I | œÜ |- œà
by saying it's a cofibration, right? My belief is that
œà is just a cofibration by being of that syntactic class.
A: ???

=== 2017.09.10

Q: Is the Finster-Mimram definition of weak omega-categories connected
in a simple way to Joyal's theta-category?
A: Probably can get a good sense by looking in
http://cheng.staff.shef.ac.uk/guidebook/guidebook-new.pdf
which I found from
https://ncatlab.org/nlab/show/Theta+category

=== 2017.09.11

Q: Where is the cubical stuff in the agda source?
A:
I see IZERO in
agda//src/full/Agda/TypeChecking/Monad/Builtin.hs
builtinIZero :: String = "IZERO"
primIZero :: TCM Term = getBuiltin builtinIZero

Q: Where are some exciting uses of primIZero?
A:
agda//src/full/Agda/TypeChecking/Primitive.hs

Q: Where is haskell-mode docs?
A: http://haskell.github.io/haskell-mode/manual/latest/

Q: More emacs advice about haskell dev?
A:
https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md

Q: What's the thing I want to bind to M-.?
A:
haskell-mode-jump-to-def

It seemed to take a long-ass time the first time I ran it, dunno why.

Q: Where are the sources to, like, the haskell base library including
the prelude Control.Monad and everything?
A: I thought maybe in
/usr/local/Cellar/ghc/7.10.3b/lib/ghc-7.10.3/
(which
$ brew list ghc
told me about)
but I only see .hi files.
...
Seems to exist online at
http://git.haskell.org/ghc.git/tree/refs/heads/master:/libraries/base/Control

Q: Transportation to the vicinity of wesleyan?
A: "Vermonter" amtrak + M-link bus maybe?
Hotel situation looks like a bummer.
No, nevermind, looks like I can just get a ride up with dlicata@.

Q: How can I git blame one line of a file?
A:
do like
$ git blame Primitive.hs -L404,+1

=== 2017.09.16

Q: How redundant is rule 5 of figure 4 in [RS]? It seems like morally I can
take the assumption that a == b and apply substitution to see
a[s/t] == b[s/t] and then use transitivity from rule 4's f(s) = a[s/t].
A: ???

=== 2017.09.18

Q: Ok, so where are the guts of cubical typechecking going on?
A:
try looking in
agda//src/full/Agda/TypeChecking/Rules/Term.hs
agda//src/full/Agda/TypeChecking/Rules/Builtin.hs
agda//src/full/Agda/TypeChecking/Primitive.hs
agda//src/full/Agda/TypeChecking/Telescope.hs

Q: Is there a way to view all these haskell function docstrings in a nice way?
A:
$ cabal install haddock
$ cabal configure
$ cabal haddock
and generates into
agda//dist/doc/html/Agda/index.html

Q: Why didn't
$ make haddock
work?
A:
mysterious missing dependencies?

# $ make haddock
# doesn't work due to

Q: What are some examples of cubical programs?
A:
agda//test/Fail/Issue2650.agda
agda//test/Fail/Issue2650.agda
agda//test/Succeed/Issue2650.agda
and also a goldmine of stuff in
gh//Saizan/cubical-demo

Q: What are the cubical primitives in
agdalib//prim/Agda/Primitive.agda
sorted by epistemic status?
A:
I definitely understand
 I, i0, i1
 primIMin
 primIMax
 primINeg
 IsOne
 itIsOne
 IsOne1 -- These two are just asserting that
 IsOne2 -- 1 v x = 1 and x v 1 = 1

Q: What's the deal with
<<<
 primPOr : {a : Agda.Primitive.Level} (i j : I)
      {A : .(IsOne (primIMax i j)) ‚Üí Set a} ‚Üí
      (.(p : IsOne i) ‚Üí A _) ‚Üí
      (.(p : IsOne j) ‚Üí A _) ‚Üí .(p : IsOne (primIMax i j)) ‚Üí A p
>>>
?
A: I think I vaguely understand it to be the realization of the disjunctive "systems" in
[CCHM] https://arxiv.org/pdf/1611.02108.pdf
which correspond to the disjunction elimination rules in [RS].

Q: What's the deal with
<<<
 Partial : {a : Agda.Primitive.Level} (A : Set a) ‚Üí I ‚Üí Setœâ
>>>
?
A:
It's described as
<<<
"Partial A œÜ"  is a special version of "(œÜ = i1) ‚Üí A"
>>>
in
gh//Saizan/cubical-demo/blob/master/AIM_Demo/DemoPartial.agda
which I think I kind of get.
I believe
<<<
 PartialP : {a : Agda.Primitive.Level} (œÜ : I)
      (A : .(o : IsOne œÜ) ‚Üí Set a) ‚Üí
      Setœâ
>>>
is just the more dependent 'path-over' version of Partial, sorta? I
see it used in the same file there.

Q: What's the deal with
<<<
 primPFrom1 : {a : Agda.Primitive.Level} {A : I ‚Üí Set a} ‚Üí
      A i1 ‚Üí (i j : I) ‚Üí .(IsOne i) ‚Üí A (primIMax i j)
>>>
A: If I squint it just looks like it's sort of internalizing the fact
that if I know i is already i1, then primIMax i j has to be i1 too, so
I can lift something known to be at A i1 to A (primIMax i j). Maybe
it's just making things definitionally equal that would otherwise be
propositionally equal.

Q: What's the deal with
<<<
 primComp : {a : I ‚Üí Agda.Primitive.Level} (A : (i : I) ‚Üí Set (a i))
      (œÜ : I) ‚Üí
      ((i : I) ‚Üí .(IsOne œÜ) ‚Üí A i) ‚Üí A i0 ‚Üí A i1
>>>
A: This is the composition primitive from the paper.

Q: Wait, I see other primitives still in
gh//Saizan/cubical-demo/blob/master/Primitives.agda
what's the deal with them?
A:
well, primPathPApply does exist in
agda//src/full/Agda/TypeChecking/Primitive.hs
due to
agdac//b0596dde
and CONID exists in
agda//src/full/Agda/TypeChecking/Monad/Builtin.hs
due to
agdac//7a50bedf

Q: Where is that in the agda repo?
A:
agda//src/data/lib/prim/Agda/Primitive.agda

Q: What's going on with the primitive keyword?
A: I guess it's just a way of grabbing primitive function values with the standard name, see
agda//examples/Introduction/Built-in.agda
(which doesn't appear to compile due to a change of the number of arguments of the Integer built-in?)

Q: How is agda's version number spread througout other things?
A: Well, I see commits like agdac//3ca28ee9 but I don't know if there's a
script that achieves all these changes in a simple way.

Q: What're some milestones in the history of editing the cubical code?
A:
agdac//e919f74e due to Andrea Vezzosi https://github.com/Saizan

Q: What's the suffix .hs-boot for?
A: Reifying cycles for mutuall recursive modules, see
https://downloads.haskell.org/~ghc/7.0.3/docs/html/users_guide/separate-compilation.html
and search for 'hs-boot'

Q: What are all these moon-language operators I'm seeing everywhere like
<@>, <#>, <..>, <@@>?
A: They are in fact defined in
agda//src/full/Agda/TypeChecking/Primitive.hs
and some more are in
agda//src/full/Agda/Utils/Functor.hs
<$> is just an infix name for fmap, see
http://git.haskell.org/ghc.git/blob_plain/refs/heads/master:/libraries/base/Data/Functor.hs

Q: How do I think about what [CCHM] calls 'partial elements'?
A: They're the things that are defined over the whole cube, but have
particular known values at subpolyhedra of the cube?

Q: What can I figure out about PrimitiveImpl?
A:
It's made of a Type and a PrimFun

Q: How do I printf in haskell?
A: Debug.Trace.trace, see
https://wiki.haskell.org/Debugging

Q: What's the deal with type IntervalView in
agda//src/full/Agda/Syntax/Internal.hs
A:
It was last touched by
agdac//6d78a1d4
I surmise it's some sort of way of exposing some of the interval term structure...

Q: What's going on with ignoreSharing in
agda//src/full/Agda/TypeChecking/Monad/Builtin.hs
?
A:
It's defined in
agda//src/full/Agda/Syntax/Internal.hs
and I would have named it, like, 'derefSharing' or something.

Q: What's a bang mean in haskell datatype definitions?
A: Strictness annotation, see
https://stackoverflow.com/questions/993112/what-does-the-exclamation-mark-mean-in-a-haskell-declaration

Q: What's an iota-redex, as mentioned in data Term comments in
agda//src/full/Agda/Syntax/Internal.hs
?
A: Something to do with pattern matching, see
https://github.com/agda/agda/issues/2276

Q: What's something that triggers the checking in primPOr that the two overlapping definitions
are consistent on their intersection?
A:
<<<
{-# OPTIONS --cubical #-}
module a where
import Agda.Primitive
open Agda.Primitive.CubicalPrimitives public

data Two : Set where
 ùüô ùüö : Two

x = primPOr i1 i1 {A = Œª _ ‚Üí Two} (Œª _ ‚Üí ùüô) (Œª _ ‚Üí ùüö)
>>>
gives an error as expected.

Q: Why does
(primPOr i0 i1 {A = Œª _ ‚Üí Two} (Œª _ ‚Üí ùüö) (Œª _ ‚Üí ùüô)) itIsOne
give an error about being fully applied?
A: ???

Q: What's the commit that created builtin PATH?
A: agdac//5e8aae7c

Q: Why doesn't Category.agda of
gh//Saizan/cubical-demo/blob/master/Category.agda
at commit 12f3d8f3
seem to compile at agdac//a67e5e2f?
A: ???

Q: How do I run agda from ghci so I can inspect things going on?
A: cabal repl

Q: Also can I just bash stuff into the prompt in *agda* in emacs?
A: Yeah, seems like!

Q: What's this syntax going on in
<<<
foo : ‚àÄ i ‚Üí Partial Bool (i ‚à® ~ i)
foo i (i = i1) = true
foo i (i = i0) = false
>>>
in
gh//Saizan/cubical-demo/blob/master/AIM_Demo/DemoPartial.agda
?
A: Seems like a pattern-matching elimination for values of the type
IsOne?

=== 2017.09.19

Q: Where is this IsOne pattern elimination in the agda abstract syntax?
A:
I see a hint in the use of domFinite, and the comment in
agda//src/full/Agda/Syntax/Common.hs about primIsOne
this leads to looking at
agda//src/full/Agda/TypeChecking/Rules/LHS/Split.hs
which is a big mess.

Q: Can I get any insight by just git blaming
agda//src/full/Agda/Syntax/Abstract.hs
A:
Sure can! I see Vezzosi's agdac//c584e887 touching a thing called EqualP.
yup,
<<<
  | EqualP Range [(Expr,Expr)]             -- ^ @i = i1@ i.e. cubical face lattice generator
>>>
in
agda//src/full/Agda/Syntax/Concrete.hs

Q: What's an interesting paper about internalizing dependent lambda calculus?
A:
"Outrageous but Meaningful Coincidences" McBride 2010, found in
https://homotopytypetheory.org/2014/03/03/hott-should-eat-itself/

Q: Wow, cabal repl is slow interactively. Even for editing text in
readline. What do?
A:
put
<<<
:set -fobject-code
>>>
in the .ghci file
http://chrisdone.com/posts/making-ghci-fast
https://www.reddit.com/r/haskell/comments/3ddcrw/does_haskell_have_slow_iteration_times_are_those/

Q: What do about the message
Warning: Can't find file "dist-2.6.0/build/autogen/cabal_macros.h" in directories
I see during cabal repl?
A:
Just
$ ln -s dist dist-2.6.0
as andreas abel recommends in
http://agda.chalmers.narkive.com/4ACGqXHw/problems-configuring-haskell-mode-and-or-invoking-cabal-repl

Q: More basic stuff about cabal?
A: http://katychuang.com/cabal-guide/

Q: What am I looking at trying to figure out how to typecheck a single expression from repl?
A: agda//src/full/Agda/Syntax/Parser.hs

Q: Where's MonadIO come from?
A:
<<<
:info Control.Monad.IO.Class.MonadIO
class Monad m => Control.Monad.IO.Class.MonadIO (m :: * -> *) where
  Control.Monad.IO.Class.liftIO :: IO a -> m a
  	-- Defined in ‚ÄòControl.Monad.IO.Class‚Äô
instance Control.Monad.IO.Class.MonadIO PM
  -- Defined in ‚ÄòAgda.Syntax.Parser‚Äô
instance Control.Monad.IO.Class.MonadIO IO
  -- Defined in ‚ÄòControl.Monad.IO.Class‚Äô
>>>

Q: What's it good for, vis-a-vis the PM type class?
A: Lifting IO actions *into* PM, not injecting PM into IO. Boo.

Q: Oh, but what do I want for that?
A: runPMIO

Q: How do I get ghci to show types
A:
either
:type <expression>
or
:set +t
(which I could do interactively or put in my .gchi)
according to
https://stackoverflow.com/questions/12659927/using-ghci-to-find-type

Q: How do I get ghci to allow multi-line defns?
A:
:set +m
<<<
Œª> let zzz :: Integer
Œª|     zzz = 2
Œª|
zzz :: Integer
Œª>
>>>
https://stackoverflow.com/questions/2846050/how-to-define-a-function-in-ghci-across-multiple-lines
ugh but then every single line expression requires a double-return
:unset +m
it is, then.

Q: How do I parse a single expression?
A:
<<<
import Agda.Syntax.Parser
let runParse :: String -> IO (Either ParseError Agda.Syntax.Concrete.Expr, [ParseWarning]) ; runParse s = runPMIO (parse exprParser s)
>>>

Q: How can I create a primitive type?
A: Can imitate Bool, did not gain much insight though.

Q: How can I create a simple primitive typed constant?
A: ???

Q: How can I create a primitive typed constant that reduces?
A: ???

Q: Where did this *agda* buffer come from?
Was it from haskell-session-change?
A: ???

Q: How do I run agda tests?
A: well I can just do things like
$ dist/build/agda/agda -i test test/Common/String.agda
for some reason
$ make test
gives me errors

Q: Oh, crumb, cabal build seems to clear whatever incremental state cabal repl has.
I guess I should try to do stuff from inside repl. How do?
A:
I see
parsePragmaOptions
defined in
agda//src/full/Agda/Interaction/Options.hs
being called from
agda//src/full/Agda/TypeChecking/Monad/Options.hs
agda//src/full/Agda/Interaction/Imports.hs
...
red herring?
Hmm.
Well I can stick
<<<
  let argv     = ["-i", "/tmp", "/tmp/a.agda"]
>>>
in runAgda' in
agda//src/full/Agda/Main.hs
and that seems to 'work'.

Q: What's a good solution for TAGS for haskell?
A: ???

Q: Why no builtin thing COLOR even after I define it?
A:
the error is
NoSuchBuiltinName
from
agda//src/full/Agda/TypeChecking/Errors.hs
which may have come from one of
agda//src/full/Agda/TypeChecking/Monad/Builtin.hs
agda//src/full/Agda/TypeChecking/Rules/Builtin.hs
but probably the latter.

Huh, it works after I add
<<<
+  , (builtinColor              |-> BuiltinData tset [builtinRed])
>>>
in
agda//src/full/Agda/TypeChecking/Rules/Builtin.hs
to parallel bool.

=== 2017.09.20

Q: mortberg@'s explanation of cubical types?
A:
https://homotopytypetheory.org/2017/09/16/a-hands-on-introduction-to-cubicaltt/
https://github.com/mortberg/cubicaltt/tree/master/lectures

Q: induction-induction vs. induction-recursion?
A:
https://en.wikipedia.org/wiki/Induction-recursion
https://ncatlab.org/homotopytypetheory/show/inductive-inductive+type
http://cs.swan.ac.uk/~csfnf/papers/indind_finite.pdf
https://ncatlab.org/nlab/show/inductive-inductive+type

Q: dual of applicative and alternative?
A: https://hackage.haskell.org/package/contravariant-1.4/docs/Data-Functor-Contravariant-Divisible.html
people (more or less rightly) complaining about the intensity of the category theory involved on twitter at
https://twitter.com/jb55/status/910293593851490304

Q: Thread on hott mailing list from dlicata@ about how to prove univalence?
A: https://groups.google.com/forum/#!msg/homotopytypetheory/j2KBIvDw53s/YTDK4D0NFQAJ

Q: Where are haddock generated docs?
A: /Users/jreed/.cabal/sandboxes/agda-build/agda/dist/doc/html/Agda/index.html

Q: What's a concrete way to show off the non-fibrancy of II?
A: ???

Q: Where's the proof of
<<<
-- The reason we need to add <j> a is that we want the top-left point
-- to be a, if we would have omitted it it would instead have been
-- "transport (<_> A) a". We used to have a version of the system
-- where this was the same as a, this relied on a property which we
-- called "regularity". It was however proved by Dan Licata that this
-- property is not preserved by the algorithm for composition for the
-- universe, so we had to drop it and the user now has to give <j> a
-- explicitly.
>>>
that I see in
https://github.com/mortberg/cubicaltt/blob/master/lectures/lecture2.ctt
A:
https://groups.google.com/forum/#!msg/homotopytypetheory/oXQe5u_Mmtk/3HEDk5g5uq4J
looks like a start, but ??? because I want to ask dan.

Q: What's the relationship between the kan filling that
dlicata@ talks about in
"Cubical infinite-dimensional type theory"
https://www.youtube.com/watch?v=lt8JgGRw7gg
and the modern [CCHM] take?
A: ???

Q: What's a nice compact way of looking at J that I get after
beta-reducing the one in mortberg@'s lecture notes?
A:
<<<
myJ (A : U) (a : A) (P : (b : A) -> Path A a b -> U)
  (d : P a (refl A a)) (b : A) (p : Path A a b) : P b p =
  comp (<i> P (p @ i) (<j> p @ i ‚àß j)) d []
>>>

=== 2017.09.21

Q: What's an example of a monomorphism that's *not* a cofibration?
What's special about face inclusions?
A: ???

Q: What do categories with (merely) weak equivalences allow?
A: simplicial localization, see
https://ncatlab.org/nlab/show/simplicial+localization
there seem to be other constructions for subtypes of CwWE, namely
model categories and homotopical categories, but I don't understand
them yet.

Q: What misconception did I just clear up about gluing in [CCHM]?
A: It's not another thing that you have to define for every type, like
composition is; it's a type constructor. A Glue-type is a type built
out of a phi-restricted fragment of another type, plus some
equivalence glue that is valid on the phi-restriction.

Afterwards you define composition *on* glue-types, and composition
*on* the universe is definable by using glue-types in the definition
body.

Q: Can I get any sort of interlibrary deals through wesleyan
affiliation?
A: ???

Q: What should I make of the discussion on
https://homotopytypetheory.org/2017/09/16/a-hands-on-introduction-to-cubicaltt/
between shulman@ and mortberg@ about canonicity vs. many-models? I
don't feel like I grasp what's at stake.
A: ???

Q: In [ShuFix] inbetween eqn 4.1 and eqn 4.2, it says
‚ô≠(A ‚Üí B) ‚Üí ‚ô≠(‚ô≠A ‚Üí ‚ô≠B)
is obtainable. But surely also we can get
‚ô≠(A ‚Üí B) ‚Üí (‚ô≠A ‚Üí ‚ô≠B)
I'd think, at least?
A: ???

Q: What's my thoughts on I prefer to think about the '2-categorical
adjoint logic' stuff?
A:

I have judgmental *levels* L, typical element ‚Ñì. I have corresponding
syntactic classes of resources and frames, call them r‚Ñì (variables œÅ‚Ñì)
and f‚Ñì (variables œÜ‚Ñì). I have positive propositions P‚Ñì and negatives N‚Ñì.

Then I have relations r‚Ñì ‚ñπ‚Ñì f‚Ñì, may henceforth elide the ‚Ñì on ‚ñπ.

If I'm to set up F ‚ä£ U and let's say with propositional functions
F : PŒΩ ‚Üí PœÑ and U : NœÑ ‚Üí NŒΩ for {œÑ,ŒΩ} ‚äÜ L then I'm going to need
a resource function f : rŒΩ ‚Üí rœÑ

so that (leaving off œÑ suffixes)

F PŒΩ1 [œÅ1], F PŒΩ2 [œÅ2] |- F PŒΩ3 [œÜ]

translates to

F PŒΩ1 @ œÅ1, F PŒΩ2 @ œÅ2, ‚àÄœÅ.(F PŒΩ3 @ œÅ)‚Üí(œÅ ‚ñπ œÜ) ‚ä¢ œÅ1 * œÅ2 ‚ñπ œÜ

which inverts to (b.c. F PŒΩ @ œÅ = ‚àÉœÅŒΩ.(œÅ = f œÅŒΩ) ‚àß (PŒΩ @ œÅŒΩ))
PŒΩ1 @ œÅŒΩ1, PŒΩ2 @ œÅŒΩ2, ‚àÄœÅ.(F PŒΩ3 @ œÅ)‚Üí(œÅ ‚ñπ œÜ) ‚ä¢ f(œÅ1) * f(œÅ2) ‚ñπ œÜ
which should be equal to
PŒΩ1 @ œÅŒΩ1, PŒΩ2 @ œÅŒΩ2, ‚àÄœÅ.(F PŒΩ3 @ œÅ)‚Üí(œÅ ‚ñπ œÜ) ‚ä¢ f(œÅ1 * œÅ2) ‚ñπ œÜ
and then I could focus and step to
PŒΩ1 @ œÅŒΩ1, PŒΩ2 @ œÅŒΩ2 ‚ä¢ F PŒΩ3 @ f(œÅ1 * œÅ2)
which is
PŒΩ1 @ œÅŒΩ1, PŒΩ2 @ œÅŒΩ2 ‚ä¢ ‚àÉœÅŒΩ.(f(œÅ1 * œÅ2) = f œÅŒΩ) ‚àß (PŒΩ3 @ œÅŒΩ)
and I can choose
PŒΩ1 @ œÅŒΩ1, PŒΩ2 @ œÅŒΩ2 ‚ä¢ PŒΩ3 @ œÅ1 * œÅ2
and this all goes like I expect.

To get focusing of F, I need a function u : fœÑ ‚Üí fŒΩ with

(f œÅŒΩ) ‚ñπ œÜt ‚â° œÅŒΩ ‚ñπ (u œÜt)
       œÑ         ŒΩ

Ok, fine, but how do I rig up a triple adjunction? Negative and
positive props are different. If I have F ‚ä£ U and V ‚ä£ H and arrange
so that, ignoring focusing, (negative) U and (positive) V are somehow the same?

In props:

    PŒΩ    NŒΩ    PŒΩ    NŒΩ
   F ‚Üì ‚ä£ U ‚Üë ‚âÖ V ‚Üë ‚ä£ H ‚Üì
    PœÑ    NœÑ    PœÑ    NœÑ

with functions

    rŒΩ    fŒΩ    rŒΩ    fŒΩ
   f ‚Üì ‚ä£ u ‚Üë ‚âÖ v ‚Üë ‚ä£ h ‚Üì
    rœÑ    fœÑ    rœÑ    fœÑ

Ok, let me just look at what I need to get, let's say, the interprovability

U N ‚ä£‚ä¢ V ‚Üì N

for
U N ‚ä¢ V ‚Üì N
I expand to
U N [œÅ] ‚ä¢ V ‚Üì N [œÜ]
‚àÄœÅŒΩ.((V ‚Üì N) @ œÅŒΩ) ‚Üí (œÅŒΩ ‚ñπ œÜŒΩ), ‚àÄœÜŒΩ.((U N) @ œÜŒΩ) ‚Üí (œÅŒΩ ‚ñπ œÜŒΩ) ‚ä¢ œÅŒΩ ‚ñπ œÜŒΩ
------------> need: œÅŒΩ ‚â§ v (f œÅŒΩ)
‚àÄœÅŒΩ.((V ‚Üì N) @ œÅŒΩ) ‚Üí (œÅŒΩ ‚ñπ œÜŒΩ), ‚àÄœÜŒΩ.((U N) @ œÜŒΩ) ‚Üí (œÅŒΩ ‚ñπ œÜŒΩ) ‚ä¢ v (f œÅŒΩ) ‚ñπ œÜŒΩ
‚àÄœÜŒΩ.((U N) @ œÜŒΩ) ‚Üí (œÅŒΩ ‚ñπ œÜŒΩ) ‚ä¢ (V ‚Üì N) @ v (f œÅŒΩ)
‚àÄœÜŒΩ.((U N) @ œÜŒΩ) ‚Üí (œÅŒΩ ‚ñπ œÜŒΩ) ‚ä¢ ‚Üì N @ f œÅŒΩ
‚àÄœÜŒΩ.((U N) @ œÜŒΩ) ‚Üí (œÅŒΩ ‚ñπ œÜŒΩ), N @ œÜ ‚ä¢ f œÅŒΩ ‚ñπ œÜ
‚àÄœÜŒΩ.((U N) @ œÜŒΩ) ‚Üí (œÅŒΩ ‚ñπ œÜŒΩ), N @ œÜ ‚ä¢ œÅŒΩ ‚ñπ u œÜ
N @ œÜ ‚ä¢ (U N) @ u œÜ
N @ œÜ ‚ä¢ N @ œÜ

for
V ‚Üì N ‚ä¢ U N
I expand to
V ‚Üì N [œÅŒΩ] ‚ä¢ U N [œÜŒΩ]
(V ‚Üì N) @ œÅŒΩ, U N @ œÜŒΩ ‚ä¢ œÅŒΩ ‚ñπ œÜŒΩ
(‚Üì N) @ œÅ, N @ œÜ ‚ä¢ v œÅ ‚ñπ u œÜ
‚àÄœÜ.(N @ œÜ) ‚Üí (œÅ ‚ñπ œÜ), N @ œÜ ‚ä¢ v œÅ ‚ñπ u œÜ
‚àÄœÜ.(N @ œÜ) ‚Üí (œÅ ‚ñπ œÜ), N @ œÜ ‚ä¢ œÅ ‚ñπ h (u œÜ)
‚àÄœÜ.(N @ œÜ) ‚Üí (œÅ ‚ñπ œÜ), N @ œÜ ‚ä¢ œÅ ‚ñπ h (u œÜ)
------------> need: œÜ ‚â§ h (u œÜ)
‚àÄœÜ.(N @ œÜ) ‚Üí (œÅ ‚ñπ œÜ), N @ œÜ ‚ä¢ œÅ ‚ñπ œÜ

Ok, yeah, there's two sorts of adjunctions going on, call them ‚ä£‚ñπ and
‚ä£‚â§, and we have

          ‚ä£‚ñπ
       f ----> u
       |       |
    ‚ä£‚â§ |       | ‚ä£‚â§
       ‚Üì       ‚Üì
       v ----> h
          ‚ä£‚ñπ

ok, sure, so both u and v are the right adjoint of f, in two different
ways; of course they should work out to be 'the same', since adjoints
are unique up to isomorphism.

Let's say I start with ‚ä¢ v (f œÅŒΩ) ‚ñπ œÜŒΩ and I want to get to ‚ä¢ œÅŒΩ ‚ñπ œÜŒΩ.
I can do this immediately by appealing to the unit œÅŒΩ ‚â§ v (f œÅŒΩ),
*or* I can transpose to ‚ä¢ œÅŒΩ ‚ñπ u (h œÜŒΩ) and appealing to the counit
u (h œÜŒΩ) ‚â§ œÜŒΩ.

Similarly if I start with ‚ä¢ œÅ ‚ñπ œÜ and I want to get to ‚ä¢ œÅ ‚ñπ h (u œÜ).
Can do directly with the unit œÜ ‚â§ h (u œÜ), or with the counit
f (v œÅ) ‚â§ œÅ to get ‚ä¢ f (v œÅ) ‚ñπ œÜ and then transposing.

=== 2017.09.22

Q: Why do I think that ‚ôØL should clear the context of coherent
assumptions? [Adj2] doesn't do that, and indeed I have a harder time
convincing myself cut goes through with my version.
A:
I got to this by thinking through how
Œî, Œì, ‚ôØA[r] ‚ä¢ C
‚áî
Œî @ œÅ‚ÇÅ, Œì @ œÅ‚ÇÇ, ‚ôØA @ œÅ‚ÇÉ, C @ œÜ ‚ä¢ f(œÅ‚ÇÅ * œÅ‚ÇÉ), œÅ‚ÇÇ ‚ñπ œÜ
seems to require dropping the œÅ‚ÇÇ to get
f(œÅ‚ÇÅ * œÅ‚ÇÉ) ‚ñπ œÜ
and from there
fœÅ‚ÇÅ * fœÅ‚ÇÉ ‚ñπ œÜ
fœÅ‚ÇÅ * fœÅ‚ÇÉ ‚ñπ œÜ
œÅ‚ÇÉ ‚ñπ u(u(fœÅ‚ÇÅ ‚ä∏ œÜ))
so I can unpack the ‚ôØA @ œÅ‚ÇÉ to get
Œî @ œÅ‚ÇÅ, Œì @ œÅ‚ÇÇ, A @ œÅ', C @ œÜ ‚ä¢ œÅ‚ÇÉ ‚ñπ u(fœÅ‚ÇÅ ‚ä∏ œÜ)
which is equivalent to
Œî @ œÅ‚ÇÅ, Œì @ œÅ‚ÇÇ, A @ œÅ', C @ œÜ ‚ä¢ fœÅ‚ÇÅ * fœÅ' ‚ñπ œÜ
...
Ohhh this is all just a mistake. I can transform
f(œÅ‚ÇÅ * œÅ‚ÇÉ), œÅ‚ÇÇ ‚ñπ œÜ
to
fœÅ‚ÇÅ * fœÅ‚ÇÉ ‚ñπ œÅ‚ÇÇ ‚ä∏ œÜ
fœÅ‚ÇÉ ‚ñπ fœÅ‚ÇÅ ‚ä∏ œÅ‚ÇÇ ‚ä∏ œÜ
ffœÅ‚ÇÉ ‚ñπ fœÅ‚ÇÅ ‚ä∏ œÅ‚ÇÇ ‚ä∏ œÜ
œÅ‚ÇÉ ‚ñπ uu(fœÅ‚ÇÅ ‚ä∏ œÅ‚ÇÇ ‚ä∏ œÜ)
which gives me
Œî @ œÅ‚ÇÅ, Œì @ œÅ‚ÇÇ, A @ œÅ', C @ œÜ ‚ä¢ œÅ' ‚ñπ u(fœÅ‚ÇÅ ‚ä∏ œÅ‚ÇÇ ‚ä∏ œÜ)
or equivalently
Œî @ œÅ‚ÇÅ, Œì @ œÅ‚ÇÇ, A @ œÅ', C @ œÜ ‚ä¢ fœÅ‚ÇÅ * fœÅ' * œÅ‚ÇÇ ‚ñπ œÜ

Q: Reading [ShuFix], what's an example of a mono in Top that's not a subspace inclusion?
A: Take
I = [0,1)
and map I into ‚ÑÇ via
Œªx.exp(2œÄxi)
You get the unit circle, which as a subspace has a different topology from I.

Q: No, this doesn't seem right. What do the brackets around P mean on page 15 of [ShuFix]?
A: ???

=== 2017.09.23

Q: What is the essential reason why valid assumptions, and therefore
boxed types, must depend only on valid things?
A: Because when I clear the context, I can't strand them from the
hypotheses they need to be valid.

Imagine I have signature
A : type
B : A ‚Üí type
and try to prove
a : A true, b : (B a) valid ‚ä¢ ? : ‚ñ° C
I'll immediately try to construct, via ‚ñ°R,
b : (B a) valid ‚ä¢ ? : C
which is nonsense.

Q: How does this play out with categorified judgmental levels?
A: Not 100% sure yet. Wonder if I want to think of the context as a
graph whose edges are morphisms in the level category, or else maybe
allow context annotations to have 'zeroes' in them. I could imagine an
invariant something like

If Œì[Œ≥], x :_p A[m], Œì'[Œ≥'] ‚ä¢ J_q

then for some Œ≥‚ÇÄ such that Œ≥‚ÇÄm ‚äÜ Œ≥ we have

Œì[Œ≥‚ÇÄ] ‚ä¢ A : type_p

A zero in Œì[Œ≥‚ÇÄ] means 'weaken that variable away'
A zero is ‚äÜ any morphism, but otherwise in Œ≥‚ÇÄm ‚äÜ Œ≥ everything has to agree.

This is meant to make

x :_p A[m]

behave just like

x :_q (F_m A) [id_q]

Whose intro rules (for m : p ‚Üí q) I imagine go something like

Œì[Œ≥‚ÇÄ] ‚ä¢ A : type_p    Œ≥‚ÇÄm ‚äÜ Œ≥
-----------------------------
Œì[Œ≥] ‚ä¢ F_m A : type_q

Œì[Œ≥‚ÇÄ] ‚ä¢ M :_p A    Œ≥‚ÇÄm ‚äÜ Œ≥
---------------------------------
Œì[Œ≥] ‚ä¢ F_m M :_q F_m A

Q: What happens if I think of the context as a graph whose edges are labelled with morphisms?
A: I think I want to require commutativity of every diagram implied by
the graph? Or do I? My gut says it's probably required for some
substitution theorem or something.

Q: Is it possible for a neutral expression to have a type that
involves the constant at the head?
A: Sure, here's an example
<<<
module b where

postulate
  o : Set
  a : o -> Set
  b : (y : o) ‚Üí a y
  c : (y : o) ‚Üí a y -> o
  k : o

term : a (c k (b k))
term = b (c k (b k))
>>>

Q: Where did I put some notes about how 2-categorical modalities work
in dependent types?
A: /Users/jreed/wes/texnotes/2017-09-23.ltx

=== 2017.09.24

Q: What's a property I might want to pragmatically require for mode
theories to make typechecking tractable?
A:
If a ‚àò b = c, then
(a) there exists a maximal a' such that a' ‚àò b = c
(b) there exists a maximal b' such that a ‚àò b' = c
where a 'maximal' morphism means one that is the most useful attached
to an assumption. In the idempotent theory of 1 and r, I'm thinking of r ‚â• 1,
and indeed in that situation, I have a best solution (namely r) to both
r ‚àò ? = r
? ‚àò r = r
and a unique solution (namely r) to both
1 ‚àò ? = r
? ‚àò 1 = r
and a unique solution (namely 1) to both
1 ‚àò ? = 1
? ‚àò 1 = 1
and no solution (which is ok) to both
r ‚àò ? = 1
? ‚àò r = 1

Q: What do I make of [Fib2]?
A: The main thing that strikes me is why go to all the effort of
designing and proving coherent a system when you can just translate it
away to FOL, but that's my bias showing.

Q: What's going on with the embedding/encoding distinction in [Fib2]?
A: ???

Q: What are the implications of thinking about two-cells between mode morphisms
(saying things like u ‚àò f ‚â§ 1) and merely talking about preorders on 'terms'
(saying things like ‚àÄx . u(f(x)) ‚â§ x)
A: ???

Q: What am I getting out of reifying frames instead of what [Fib2] does, namely
thinking of them as structures-with-a-hole?
A: I guess greater uniformity of definition? My F rules look just like
my U rules with different sorts. I can represent classical logic as a
thing with frame constructors?

Q: Is it still possible to carry out a focusing proof for every logic
you can define in [Fib2]?
A: I think maybe yes; because the moment you throw in ‚äô, it's
impossible not to allow the definition of residuals x ‚äô - and - ‚äô x
which correspond to frame operations x ‚Ü£ - and x ‚Ü† -. So control over
frames (as opposed to abstractions) is what lets you define less
focally good logics like queue logic.

Q: What's that other paper dlicata@ thought would be an application of modalities?
A: [OrtonPitts]

=== 2017.09.25

Q: What's something to look for in [ShuFix]?
A: How exactly the properties of ‚ôØ and ‚ô≠ on top of their modal nature
get axiomatized.

Q: To what extent can the same be done with  É?
A: ???

Q: What's a sensible tack on dependent modal stuff?
A: To aggressively track how every type depends modally on its
context.

=== 2017.09.26

Q: Where's my ticket for account renaming?
A: https://wesleyanedu.service-now.com/ess//incident_status.do

Q: Does anything go wrong with totally decoupled term bundles from type bundles
A: ???
