=== 2017.09.08

Q: What is the status of (2.2) in [RS]? Is it an axiom
in the system, or is it a provable property of the type system that
merely happens to be written as an inference rule, i.e. like cut
elimination?
A: ???

Q: In figure 3, why do premises œÜ and œà appear downstairs in the
fourth and fifth rules listed, when they already are assumed to follow
from Œû | Œ¶?
A: ???

Q: In the third rule in figure 4, why isn't *s* constrained to somehow
live in œà?
A: I guess it's because it's not that f needs something to live in a
shape to accept it as an argument; it's that f can only give answers
for things that live inside œà. We're asking that s is defined on
the whole cube I, and we can consider the restriction of the cube to
œà before feeding it to f. Thus, I might better ask:

Q: In the third rule in figure 4, why isn't s allowed to be defined
merely on œà? Why must it be defined on the whole cube I?
A: Oh, I see --- it's because the arguments to the function are merely
cube expressions, not general terms. There's no way to even specify a
cube term that's something other than a tuple of projections.

=== 2017.09.09

Q: How do Joyal disks [Joyal97] lead to ‚àû-categories according to [RS]?
A: ???

Q: In [RS] Axiom 4.6, we're not making any additional assumption on
t : I | œÜ |- œà
by saying it's a cofibration, right? My belief is that
œà is just a cofibration by being of that syntactic class.
A: ???

=== 2017.09.10

Q: Is the Finster-Mimram definition of weak omega-categories connected
in a simple way to Joyal's theta-category?
A: Probably can get a good sense by looking in
http://cheng.staff.shef.ac.uk/guidebook/guidebook-new.pdf
which I found from
https://ncatlab.org/nlab/show/Theta+category

=== 2017.09.11

Q: Where is the cubical stuff in the agda source?
A:
I see IZERO in
agda//src/full/Agda/TypeChecking/Monad/Builtin.hs
builtinIZero :: String = "IZERO"
primIZero :: TCM Term = getBuiltin builtinIZero

Q: Where are some exciting uses of primIZero?
A:
agda//src/full/Agda/TypeChecking/Primitive.hs

Q: Where is haskell-mode docs?
A: http://haskell.github.io/haskell-mode/manual/latest/

Q: More emacs advice about haskell dev?
A:
https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md

Q: What's the go-to-definition thing I want to bind to M-.?
A:
haskell-mode-jump-to-def

Q: Why did it take so long the first time I ran it?
A: Dunno, but someone else experienced a similar thing:
https://blog.alainodea.com/en/article/490/haskell-intero-in-emacs-first-impressions-and-howto

Q: Where are the sources to, like, the haskell base library including
the prelude Control.Monad and everything?
A: I thought maybe in
/usr/local/Cellar/ghc/7.10.3b/lib/ghc-7.10.3/
(which
$ brew list ghc
told me about)
but I only see .hi files.
...
Seems to exist online at
http://git.haskell.org/ghc.git/tree/refs/heads/master:/libraries/base/Control

Q: Transportation to the vicinity of wesleyan?
A: "Vermonter" amtrak + M-link bus maybe?
Hotel situation looks like a bummer.
No, nevermind, looks like I can just get a ride up with dlicata@.

Q: How can I git blame one line of a file?
A:
do like
$ git blame Primitive.hs -L404,+1

=== 2017.09.16

Q: How redundant is rule 5 of figure 4 in [RS]? It seems like morally I can
take the assumption that a == b and apply substitution to see
a[s/t] == b[s/t] and then use transitivity from rule 4's f(s) = a[s/t].
A: ???

=== 2017.09.18

Q: Ok, so where are the guts of cubical typechecking going on?
A:
try looking in
agda//src/full/Agda/TypeChecking/Rules/Term.hs
agda//src/full/Agda/TypeChecking/Rules/Builtin.hs
agda//src/full/Agda/TypeChecking/Primitive.hs
agda//src/full/Agda/TypeChecking/Telescope.hs

Q: Is there a way to view all these haskell function docstrings in a nice way?
A:
$ cabal install haddock
$ cabal configure
$ cabal haddock
and generates into
agda//dist/doc/html/Agda/index.html

Q: Why didn't
$ make haddock
work?
A:
mysterious missing dependencies?

# $ make haddock
# doesn't work due to

Q: What are some examples of cubical programs?
A:
agda//test/Fail/Issue2650.agda
agda//test/Fail/Issue2650.agda
agda//test/Succeed/Issue2650.agda
and also a goldmine of stuff in
gh//Saizan/cubical-demo

Q: What are the cubical primitives in
agdalib//prim/Agda/Primitive.agda
sorted by epistemic status?
A:
I definitely understand
 I, i0, i1
 primIMin
 primIMax
 primINeg
 IsOne
 itIsOne
 IsOne1 -- These two are just asserting that
 IsOne2 -- 1 v x = 1 and x v 1 = 1

Q: What's the deal with
<<<
 primPOr : {a : Agda.Primitive.Level} (i j : I)
      {A : .(IsOne (primIMax i j)) ‚Üí Set a} ‚Üí
      (.(p : IsOne i) ‚Üí A _) ‚Üí
      (.(p : IsOne j) ‚Üí A _) ‚Üí .(p : IsOne (primIMax i j)) ‚Üí A p
>>>
?
A: I think I vaguely understand it to be the realization of the disjunctive "systems" in
[CCHM] https://arxiv.org/pdf/1611.02108.pdf
which correspond to the disjunction elimination rules in [RS].

Q: What's the deal with
<<<
 Partial : {a : Agda.Primitive.Level} (A : Set a) ‚Üí I ‚Üí Setœâ
>>>
?
A:
It's described as
<<<
"Partial A œÜ"  is a special version of "(œÜ = i1) ‚Üí A"
>>>
in
gh//Saizan/cubical-demo/blob/master/AIM_Demo/DemoPartial.agda
which I think I kind of get.
I believe
<<<
 PartialP : {a : Agda.Primitive.Level} (œÜ : I)
      (A : .(o : IsOne œÜ) ‚Üí Set a) ‚Üí
      Setœâ
>>>
is just the more dependent 'path-over' version of Partial, sorta? I
see it used in the same file there.

Q: What's the deal with
<<<
 primPFrom1 : {a : Agda.Primitive.Level} {A : I ‚Üí Set a} ‚Üí
      A i1 ‚Üí (i j : I) ‚Üí .(IsOne i) ‚Üí A (primIMax i j)
>>>
A: If I squint it just looks like it's sort of internalizing the fact
that if I know i is already i1, then primIMax i j has to be i1 too, so
I can lift something known to be at A i1 to A (primIMax i j). Maybe
it's just making things definitionally equal that would otherwise be
propositionally equal.

Q: What's the deal with
<<<
 primComp : {a : I ‚Üí Agda.Primitive.Level} (A : (i : I) ‚Üí Set (a i))
      (œÜ : I) ‚Üí
      ((i : I) ‚Üí .(IsOne œÜ) ‚Üí A i) ‚Üí A i0 ‚Üí A i1
>>>
A: This is the composition primitive from the paper.

Q: Wait, I see other primitives still in
gh//Saizan/cubical-demo/blob/master/Primitives.agda
what's the deal with them?
A:
well, primPathPApply does exist in
agda//src/full/Agda/TypeChecking/Primitive.hs
due to
agdac//b0596dde
and CONID exists in
agda//src/full/Agda/TypeChecking/Monad/Builtin.hs
due to
agdac//7a50bedf

Q: Where is that in the agda repo?
A:
agda//src/data/lib/prim/Agda/Primitive.agda

Q: What's going on with the primitive keyword?
A: I guess it's just a way of grabbing primitive function values with the standard name, see
agda//examples/Introduction/Built-in.agda
(which doesn't appear to compile due to a change of the number of arguments of the Integer built-in?)

Q: How is agda's version number spread througout other things?
A: Well, I see commits like agdac//3ca28ee9 but I don't know if there's a
script that achieves all these changes in a simple way.

Q: What're some milestones in the history of editing the cubical code?
A:
agdac//e919f74e due to avezzosi@ https://github.com/Saizan

Q: What's the suffix .hs-boot for?
A: Reifying cycles for mutuall recursive modules, see
https://downloads.haskell.org/~ghc/7.0.3/docs/html/users_guide/separate-compilation.html
and search for 'hs-boot'

Q: What are all these moon-language operators I'm seeing everywhere like
<@>, <#>, <..>, <@@>?
A: They are in fact defined in
agda//src/full/Agda/TypeChecking/Primitive.hs
and some more are in
agda//src/full/Agda/Utils/Functor.hs
<$> is just an infix name for fmap, see
http://git.haskell.org/ghc.git/blob_plain/refs/heads/master:/libraries/base/Data/Functor.hs

Q: How do I think about what [CCHM] calls 'partial elements'?
A: They're the things that are defined over the whole cube, but have
particular known values at subpolyhedra of the cube?

Q: What can I figure out about PrimitiveImpl?
A:
It's made of a Type and a PrimFun

Q: How do I printf in haskell?
A: Debug.Trace.trace, see
https://wiki.haskell.org/Debugging

Q: What's the deal with type IntervalView in
agda//src/full/Agda/Syntax/Internal.hs
A:
It was last touched by
agdac//6d78a1d4
I surmise it's some sort of way of exposing some of the interval term structure...

Q: What's going on with ignoreSharing in
agda//src/full/Agda/TypeChecking/Monad/Builtin.hs
?
A:
It's defined in
agda//src/full/Agda/Syntax/Internal.hs
and I would have named it, like, 'derefSharing' or something.

Q: What's a bang mean in haskell datatype definitions?
A: Strictness annotation, see
https://stackoverflow.com/questions/993112/what-does-the-exclamation-mark-mean-in-a-haskell-declaration

Q: What's an iota-redex, as mentioned in data Term comments in
agda//src/full/Agda/Syntax/Internal.hs
?
A: Something to do with pattern matching, see
https://github.com/agda/agda/issues/2276

Q: What's something that triggers the checking in primPOr that the two overlapping definitions
are consistent on their intersection?
A:
<<<
{-# OPTIONS --cubical #-}
module a where
import Agda.Primitive
open Agda.Primitive.CubicalPrimitives public

data Two : Set where
 ùüô ùüö : Two

x = primPOr i1 i1 {A = Œª _ ‚Üí Two} (Œª _ ‚Üí ùüô) (Œª _ ‚Üí ùüö)
>>>
gives an error as expected.

Q: Why does
(primPOr i0 i1 {A = Œª _ ‚Üí Two} (Œª _ ‚Üí ùüö) (Œª _ ‚Üí ùüô)) itIsOne
give an error about being fully applied?
A: ???

Q: What's the commit that created builtin PATH?
A: agdac//5e8aae7c

Q: Why doesn't Category.agda of
gh//Saizan/cubical-demo/blob/master/Category.agda
at commit 12f3d8f3
seem to compile at agdac//a67e5e2f?
A: ???

Q: How do I run agda from ghci so I can inspect things going on?
A: cabal repl

Q: Also can I just bash stuff into the prompt in *agda* in emacs?
A: Yeah, seems like!

Q: What's this syntax going on in
<<<
foo : ‚àÄ i ‚Üí Partial Bool (i ‚à® ~ i)
foo i (i = i1) = true
foo i (i = i0) = false
>>>
in
gh//Saizan/cubical-demo/blob/master/AIM_Demo/DemoPartial.agda
?
A: Seems like a pattern-matching elimination for values of the type
IsOne?

=== 2017.09.19

Q: Where is this IsOne pattern elimination in the agda abstract syntax?
A:
I see a hint in the use of domFinite, and the comment in
agda//src/full/Agda/Syntax/Common.hs about primIsOne
this leads to looking at
agda//src/full/Agda/TypeChecking/Rules/LHS/Split.hs
which is a big mess.

Q: Can I get any insight by just git blaming
agda//src/full/Agda/Syntax/Abstract.hs
A:
Sure can! I see avezzosi@'s agdac//c584e887 touching a thing called EqualP.
yup,
<<<
  | EqualP Range [(Expr,Expr)]             -- ^ @i = i1@ i.e. cubical face lattice generator
>>>
in
agda//src/full/Agda/Syntax/Concrete.hs

Q: What's an interesting paper about internalizing dependent lambda calculus?
A:
"Outrageous but Meaningful Coincidences" McBride 2010, found in
https://homotopytypetheory.org/2014/03/03/hott-should-eat-itself/

Q: Wow, cabal repl is slow interactively. Even for editing text in
readline. What do?
A:
put
<<<
:set -fobject-code
>>>
in the .ghci file
http://chrisdone.com/posts/making-ghci-fast
https://www.reddit.com/r/haskell/comments/3ddcrw/does_haskell_have_slow_iteration_times_are_those/

Q: What do about the message
Warning: Can't find file "dist-2.6.0/build/autogen/cabal_macros.h" in directories
I see during cabal repl?
A:
Just
$ ln -s dist dist-2.6.0
as andreasabel@ recommends in
http://agda.chalmers.narkive.com/4ACGqXHw/problems-configuring-haskell-mode-and-or-invoking-cabal-repl

Q: More basic stuff about cabal?
A: http://katychuang.com/cabal-guide/

Q: What am I looking at trying to figure out how to typecheck a single expression from repl?
A: agda//src/full/Agda/Syntax/Parser.hs

Q: Where's MonadIO come from?
A:
<<<
:info Control.Monad.IO.Class.MonadIO
class Monad m => Control.Monad.IO.Class.MonadIO (m :: * -> *) where
  Control.Monad.IO.Class.liftIO :: IO a -> m a
  	-- Defined in ‚ÄòControl.Monad.IO.Class‚Äô
instance Control.Monad.IO.Class.MonadIO PM
  -- Defined in ‚ÄòAgda.Syntax.Parser‚Äô
instance Control.Monad.IO.Class.MonadIO IO
  -- Defined in ‚ÄòControl.Monad.IO.Class‚Äô
>>>

Q: What's it good for, vis-a-vis the PM type class?
A: Lifting IO actions *into* PM, not injecting PM into IO. Boo.

Q: Oh, but what do I want for that?
A: runPMIO

Q: How do I get ghci to show types
A:
either
:type <expression>
or
:set +t
(which I could do interactively or put in my .gchi)
according to
https://stackoverflow.com/questions/12659927/using-ghci-to-find-type

Q: How do I get ghci to allow multi-line defns?
A:
:set +m
<<<
Œª> let zzz :: Integer
Œª|     zzz = 2
Œª|
zzz :: Integer
Œª>
>>>
https://stackoverflow.com/questions/2846050/how-to-define-a-function-in-ghci-across-multiple-lines
ugh but then every single line expression requires a double-return
:unset +m
it is, then.

Q: How do I parse a single expression?
A:
<<<
import Agda.Syntax.Parser
let runParse :: String -> IO (Either ParseError Agda.Syntax.Concrete.Expr, [ParseWarning]) ; runParse s = runPMIO (parse exprParser s)
>>>

Q: How can I create a primitive type?
A: Can imitate Bool, did not gain much insight though.

Q: How can I create a simple primitive typed constant?
A: ???

Q: How can I create a primitive typed constant that reduces?
A: ???

Q: Where did this *agda* buffer come from?
Was it from haskell-session-change?
A: ???

Q: How do I run agda tests?
A: well I can just do things like
$ dist/build/agda/agda -i test test/Common/String.agda
for some reason
$ make test
gives me errors

Q: Oh, crumb, cabal build seems to clear whatever incremental state cabal repl has.
I guess I should try to do stuff from inside repl. How do?
A:
I see
parsePragmaOptions
defined in
agda//src/full/Agda/Interaction/Options.hs
being called from
agda//src/full/Agda/TypeChecking/Monad/Options.hs
agda//src/full/Agda/Interaction/Imports.hs
...
red herring?
Hmm.
Well I can stick
<<<
  let argv     = ["-i", "/tmp", "/tmp/a.agda"]
>>>
in runAgda' in
agda//src/full/Agda/Main.hs
and that seems to 'work'.

Q: What's a good solution for TAGS for haskell?
A: ???

Q: Why no builtin thing COLOR even after I define it?
A:
the error is
NoSuchBuiltinName
from
agda//src/full/Agda/TypeChecking/Errors.hs
which may have come from one of
agda//src/full/Agda/TypeChecking/Monad/Builtin.hs
agda//src/full/Agda/TypeChecking/Rules/Builtin.hs
but probably the latter.

Huh, it works after I add
<<<
+  , (builtinColor              |-> BuiltinData tset [builtinRed])
>>>
in
agda//src/full/Agda/TypeChecking/Rules/Builtin.hs
to parallel bool.

=== 2017.09.20

Q: mortberg@'s explanation of cubical types?
A:
https://homotopytypetheory.org/2017/09/16/a-hands-on-introduction-to-cubicaltt/
https://github.com/mortberg/cubicaltt/tree/master/lectures

Q: induction-induction vs. induction-recursion?
A:
https://en.wikipedia.org/wiki/Induction-recursion
https://ncatlab.org/homotopytypetheory/show/inductive-inductive+type
http://cs.swan.ac.uk/~csfnf/papers/indind_finite.pdf
https://ncatlab.org/nlab/show/inductive-inductive+type

Q: dual of applicative and alternative?
A: https://hackage.haskell.org/package/contravariant-1.4/docs/Data-Functor-Contravariant-Divisible.html
people (more or less rightly) complaining about the intensity of the category theory involved on twitter at
https://twitter.com/jb55/status/910293593851490304

Q: Thread on hott mailing list from dlicata@ about how to prove univalence?
A: https://groups.google.com/forum/#!msg/homotopytypetheory/j2KBIvDw53s/YTDK4D0NFQAJ

Q: Where are haddock generated docs?
A: /Users/jreed/.cabal/sandboxes/agda-build/agda/dist/doc/html/Agda/index.html

Q: What's a concrete way to show off the non-fibrancy of ùïÄ?
A: ???

Q: Where's the proof of
<<<
-- The reason we need to add <j> a is that we want the top-left point
-- to be a, if we would have omitted it it would instead have been
-- "transport (<_> A) a". We used to have a version of the system
-- where this was the same as a, this relied on a property which we
-- called "regularity". It was however proved by Dan Licata that this
-- property is not preserved by the algorithm for composition for the
-- universe, so we had to drop it and the user now has to give <j> a
-- explicitly.
>>>
that I see in
https://github.com/mortberg/cubicaltt/blob/master/lectures/lecture2.ctt
A:
https://groups.google.com/forum/#!msg/homotopytypetheory/oXQe5u_Mmtk/3HEDk5g5uq4J
looks like a start, but ??? because I want to ask dan.

Q: What's the relationship between the kan filling that
dlicata@ talks about in
"Cubical infinite-dimensional type theory"
https://www.youtube.com/watch?v=lt8JgGRw7gg
and the modern [CCHM] take?
A: ???

Q: What's a nice compact way of looking at J that I get after
beta-reducing the one in mortberg@'s lecture notes?
A:
<<<
myJ (A : U) (a : A) (P : (b : A) -> Path A a b -> U)
  (d : P a (refl A a)) (b : A) (p : Path A a b) : P b p =
  comp (<i> P (p @ i) (<j> p @ i ‚àß j)) d []
>>>

=== 2017.09.21

Q: What's an example of a monomorphism that's *not* a cofibration?
What's special about face inclusions?
A: ???

Q: What do categories with (merely) weak equivalences allow?
A: simplicial localization, see
https://ncatlab.org/nlab/show/simplicial+localization
there seem to be other constructions for subtypes of CwWE, namely
model categories and homotopical categories, but I don't understand
them yet.

Q: What misconception did I just clear up about gluing in [CCHM]?
A: It's not another thing that you have to define for every type, like
composition is; it's a type constructor. A Glue-type is a type built
out of a phi-restricted fragment of another type, plus some
equivalence glue that is valid on the phi-restriction.

Afterwards you define composition *on* glue-types, and composition
*on* the universe is definable by using glue-types in the definition
body.

Q: Can I get any sort of interlibrary deals through wesleyan
affiliation?
A: I can VPN in and access acm dl at least.
Anything else???

Q: What should I make of the discussion on
https://homotopytypetheory.org/2017/09/16/a-hands-on-introduction-to-cubicaltt/
between mshulman@ and mortberg@ about canonicity vs. many-models? I
don't feel like I grasp what's at stake.
A: ???

Q: In [ShuFix] inbetween eqn 4.1 and eqn 4.2, it says
(a) ‚ô≠(A ‚Üí B) ‚Üí ‚ô≠(‚ô≠A ‚Üí ‚ô≠B)
is obtainable. But surely also we can get
(b) ‚ô≠(A ‚Üí B) ‚Üí (‚ô≠A ‚Üí ‚ô≠B)
I'd think, at least?
A: derp, (a) is already stronger than (b).

Q: What's my thoughts on I prefer to think about the '2-categorical
adjoint logic' stuff?
A:

I have judgmental *levels* L, typical element ‚Ñì. I have corresponding
syntactic classes of resources and frames, call them r‚Ñì (variables œÅ‚Ñì)
and f‚Ñì (variables œÜ‚Ñì). I have positive propositions P‚Ñì and negatives N‚Ñì.

Then I have relations r‚Ñì ‚ñπ‚Ñì f‚Ñì, may henceforth elide the ‚Ñì on ‚ñπ.

If I'm to set up F ‚ä£ U and let's say with propositional functions
F : PŒΩ ‚Üí PœÑ and U : NœÑ ‚Üí NŒΩ for {œÑ,ŒΩ} ‚äÜ L then I'm going to need
a resource function f : rŒΩ ‚Üí rœÑ

so that (leaving off œÑ suffixes)

F PŒΩ1 [œÅ1], F PŒΩ2 [œÅ2] |- F PŒΩ3 [œÜ]

translates to

F PŒΩ1 @ œÅ1, F PŒΩ2 @ œÅ2, ‚àÄœÅ.(F PŒΩ3 @ œÅ)‚Üí(œÅ ‚ñπ œÜ) ‚ä¢ œÅ1 * œÅ2 ‚ñπ œÜ

which inverts to (b.c. F PŒΩ @ œÅ = ‚àÉœÅŒΩ.(œÅ = f œÅŒΩ) ‚àß (PŒΩ @ œÅŒΩ))
PŒΩ1 @ œÅŒΩ1, PŒΩ2 @ œÅŒΩ2, ‚àÄœÅ.(F PŒΩ3 @ œÅ)‚Üí(œÅ ‚ñπ œÜ) ‚ä¢ f(œÅ1) * f(œÅ2) ‚ñπ œÜ
which should be equal to
PŒΩ1 @ œÅŒΩ1, PŒΩ2 @ œÅŒΩ2, ‚àÄœÅ.(F PŒΩ3 @ œÅ)‚Üí(œÅ ‚ñπ œÜ) ‚ä¢ f(œÅ1 * œÅ2) ‚ñπ œÜ
and then I could focus and step to
PŒΩ1 @ œÅŒΩ1, PŒΩ2 @ œÅŒΩ2 ‚ä¢ F PŒΩ3 @ f(œÅ1 * œÅ2)
which is
PŒΩ1 @ œÅŒΩ1, PŒΩ2 @ œÅŒΩ2 ‚ä¢ ‚àÉœÅŒΩ.(f(œÅ1 * œÅ2) = f œÅŒΩ) ‚àß (PŒΩ3 @ œÅŒΩ)
and I can choose
PŒΩ1 @ œÅŒΩ1, PŒΩ2 @ œÅŒΩ2 ‚ä¢ PŒΩ3 @ œÅ1 * œÅ2
and this all goes like I expect.

To get focusing of F, I need a function u : fœÑ ‚Üí fŒΩ with

(f œÅŒΩ) ‚ñπ œÜt ‚â° œÅŒΩ ‚ñπ (u œÜt)
       œÑ         ŒΩ

Ok, fine, but how do I rig up a triple adjunction? Negative and
positive props are different. If I have F ‚ä£ U and V ‚ä£ H and arrange
so that, ignoring focusing, (negative) U and (positive) V are somehow the same?

In props:

    PŒΩ    NŒΩ    PŒΩ    NŒΩ
   F ‚Üì ‚ä£ U ‚Üë ‚âÖ V ‚Üë ‚ä£ H ‚Üì
    PœÑ    NœÑ    PœÑ    NœÑ

with functions

    rŒΩ    fŒΩ    rŒΩ    fŒΩ
   f ‚Üì ‚ä£ u ‚Üë ‚âÖ v ‚Üë ‚ä£ h ‚Üì
    rœÑ    fœÑ    rœÑ    fœÑ

Ok, let me just look at what I need to get, let's say, the interprovability

U N ‚ä£‚ä¢ V ‚Üì N

for
U N ‚ä¢ V ‚Üì N
I expand to
U N [œÅ] ‚ä¢ V ‚Üì N [œÜ]
‚àÄœÅŒΩ.((V ‚Üì N) @ œÅŒΩ) ‚Üí (œÅŒΩ ‚ñπ œÜŒΩ), ‚àÄœÜŒΩ.((U N) @ œÜŒΩ) ‚Üí (œÅŒΩ ‚ñπ œÜŒΩ) ‚ä¢ œÅŒΩ ‚ñπ œÜŒΩ
------------> need: œÅŒΩ ‚â§ v (f œÅŒΩ)
‚àÄœÅŒΩ.((V ‚Üì N) @ œÅŒΩ) ‚Üí (œÅŒΩ ‚ñπ œÜŒΩ), ‚àÄœÜŒΩ.((U N) @ œÜŒΩ) ‚Üí (œÅŒΩ ‚ñπ œÜŒΩ) ‚ä¢ v (f œÅŒΩ) ‚ñπ œÜŒΩ
‚àÄœÜŒΩ.((U N) @ œÜŒΩ) ‚Üí (œÅŒΩ ‚ñπ œÜŒΩ) ‚ä¢ (V ‚Üì N) @ v (f œÅŒΩ)
‚àÄœÜŒΩ.((U N) @ œÜŒΩ) ‚Üí (œÅŒΩ ‚ñπ œÜŒΩ) ‚ä¢ ‚Üì N @ f œÅŒΩ
‚àÄœÜŒΩ.((U N) @ œÜŒΩ) ‚Üí (œÅŒΩ ‚ñπ œÜŒΩ), N @ œÜ ‚ä¢ f œÅŒΩ ‚ñπ œÜ
‚àÄœÜŒΩ.((U N) @ œÜŒΩ) ‚Üí (œÅŒΩ ‚ñπ œÜŒΩ), N @ œÜ ‚ä¢ œÅŒΩ ‚ñπ u œÜ
N @ œÜ ‚ä¢ (U N) @ u œÜ
N @ œÜ ‚ä¢ N @ œÜ

for
V ‚Üì N ‚ä¢ U N
I expand to
V ‚Üì N [œÅŒΩ] ‚ä¢ U N [œÜŒΩ]
(V ‚Üì N) @ œÅŒΩ, U N @ œÜŒΩ ‚ä¢ œÅŒΩ ‚ñπ œÜŒΩ
(‚Üì N) @ œÅ, N @ œÜ ‚ä¢ v œÅ ‚ñπ u œÜ
‚àÄœÜ.(N @ œÜ) ‚Üí (œÅ ‚ñπ œÜ), N @ œÜ ‚ä¢ v œÅ ‚ñπ u œÜ
‚àÄœÜ.(N @ œÜ) ‚Üí (œÅ ‚ñπ œÜ), N @ œÜ ‚ä¢ œÅ ‚ñπ h (u œÜ)
‚àÄœÜ.(N @ œÜ) ‚Üí (œÅ ‚ñπ œÜ), N @ œÜ ‚ä¢ œÅ ‚ñπ h (u œÜ)
------------> need: œÜ ‚â§ h (u œÜ)
‚àÄœÜ.(N @ œÜ) ‚Üí (œÅ ‚ñπ œÜ), N @ œÜ ‚ä¢ œÅ ‚ñπ œÜ

Ok, yeah, there's two sorts of adjunctions going on, call them ‚ä£‚ñπ and
‚ä£‚â§, and we have

          ‚ä£‚ñπ
       f ----> u
       |       |
    ‚ä£‚â§ |       | ‚ä£‚â§
       ‚Üì       ‚Üì
       v ----> h
          ‚ä£‚ñπ

ok, sure, so both u and v are the right adjoint of f, in two different
ways; of course they should work out to be 'the same', since adjoints
are unique up to isomorphism.

Let's say I start with ‚ä¢ v (f œÅŒΩ) ‚ñπ œÜŒΩ and I want to get to ‚ä¢ œÅŒΩ ‚ñπ œÜŒΩ.
I can do this immediately by appealing to the unit œÅŒΩ ‚â§ v (f œÅŒΩ),
*or* I can transpose to ‚ä¢ œÅŒΩ ‚ñπ u (h œÜŒΩ) and appealing to the counit
u (h œÜŒΩ) ‚â§ œÜŒΩ.

Similarly if I start with ‚ä¢ œÅ ‚ñπ œÜ and I want to get to ‚ä¢ œÅ ‚ñπ h (u œÜ).
Can do directly with the unit œÜ ‚â§ h (u œÜ), or with the counit
f (v œÅ) ‚â§ œÅ to get ‚ä¢ f (v œÅ) ‚ñπ œÜ and then transposing.

=== 2017.09.22

Q: Why do I think that ‚ôØL should clear the context of coherent
assumptions? [Adj2] doesn't do that, and indeed I have a harder time
convincing myself cut goes through with my version.
A:
I got to this by thinking through how
Œî, Œì, ‚ôØA[r] ‚ä¢ C
‚áî
Œî @ œÅ‚ÇÅ, Œì @ œÅ‚ÇÇ, ‚ôØA @ œÅ‚ÇÉ, C @ œÜ ‚ä¢ f(œÅ‚ÇÅ * œÅ‚ÇÉ), œÅ‚ÇÇ ‚ñπ œÜ
seems to require dropping the œÅ‚ÇÇ to get
f(œÅ‚ÇÅ * œÅ‚ÇÉ) ‚ñπ œÜ
and from there
fœÅ‚ÇÅ * fœÅ‚ÇÉ ‚ñπ œÜ
fœÅ‚ÇÅ * fœÅ‚ÇÉ ‚ñπ œÜ
œÅ‚ÇÉ ‚ñπ u(u(fœÅ‚ÇÅ ‚ä∏ œÜ))
so I can unpack the ‚ôØA @ œÅ‚ÇÉ to get
Œî @ œÅ‚ÇÅ, Œì @ œÅ‚ÇÇ, A @ œÅ', C @ œÜ ‚ä¢ œÅ‚ÇÉ ‚ñπ u(fœÅ‚ÇÅ ‚ä∏ œÜ)
which is equivalent to
Œî @ œÅ‚ÇÅ, Œì @ œÅ‚ÇÇ, A @ œÅ', C @ œÜ ‚ä¢ fœÅ‚ÇÅ * fœÅ' ‚ñπ œÜ
...
Ohhh this is all just a mistake. I can transform
f(œÅ‚ÇÅ * œÅ‚ÇÉ), œÅ‚ÇÇ ‚ñπ œÜ
to
fœÅ‚ÇÅ * fœÅ‚ÇÉ ‚ñπ œÅ‚ÇÇ ‚ä∏ œÜ
fœÅ‚ÇÉ ‚ñπ fœÅ‚ÇÅ ‚ä∏ œÅ‚ÇÇ ‚ä∏ œÜ
ffœÅ‚ÇÉ ‚ñπ fœÅ‚ÇÅ ‚ä∏ œÅ‚ÇÇ ‚ä∏ œÜ
œÅ‚ÇÉ ‚ñπ uu(fœÅ‚ÇÅ ‚ä∏ œÅ‚ÇÇ ‚ä∏ œÜ)
which gives me
Œî @ œÅ‚ÇÅ, Œì @ œÅ‚ÇÇ, A @ œÅ', C @ œÜ ‚ä¢ œÅ' ‚ñπ u(fœÅ‚ÇÅ ‚ä∏ œÅ‚ÇÇ ‚ä∏ œÜ)
or equivalently
Œî @ œÅ‚ÇÅ, Œì @ œÅ‚ÇÇ, A @ œÅ', C @ œÜ ‚ä¢ fœÅ‚ÇÅ * fœÅ' * œÅ‚ÇÇ ‚ñπ œÜ

Q: Reading [ShuFix], what's an example of a mono in Top that's not a subspace inclusion?
A: Take
I = [0,1)
and map I into ‚ÑÇ via
Œªx.exp(2œÄxi)
You get the unit circle, which as a subspace has a different topology from I.

Q: No, this doesn't seem right. What do the brackets around P mean on page 15 of [ShuFix]?
A: ???

=== 2017.09.23

Q: What is the essential reason why valid assumptions, and therefore
boxed types, must depend only on valid things?
A: Because when I clear the context, I can't strand them from the
hypotheses they need to be valid.

Imagine I have signature
A : type
B : A ‚Üí type
and try to prove
a : A true, b : (B a) valid ‚ä¢ ? : ‚ñ° C
I'll immediately try to construct, via ‚ñ°R,
b : (B a) valid ‚ä¢ ? : C
which is nonsense.

Q: How does this play out with categorified judgmental levels?
A: Not 100% sure yet. Wonder if I want to think of the context as a
graph whose edges are morphisms in the level category, or else maybe
allow context annotations to have 'zeroes' in them. I could imagine an
invariant something like

If Œì[Œ≥], x :_p A[m], Œì'[Œ≥'] ‚ä¢ J_q

then for some Œ≥‚ÇÄ such that Œ≥‚ÇÄm ‚äÜ Œ≥ we have

Œì[Œ≥‚ÇÄ] ‚ä¢ A : type_p

A zero in Œì[Œ≥‚ÇÄ] means 'weaken that variable away'
A zero is ‚äÜ any morphism, but otherwise in Œ≥‚ÇÄm ‚äÜ Œ≥ everything has to agree.

This is meant to make

x :_p A[m]

behave just like

x :_q (F_m A) [id_q]

Whose intro rules (for m : p ‚Üí q) I imagine go something like

Œì[Œ≥‚ÇÄ] ‚ä¢ A : type_p    Œ≥‚ÇÄm ‚äÜ Œ≥
-----------------------------
Œì[Œ≥] ‚ä¢ F_m A : type_q

Œì[Œ≥‚ÇÄ] ‚ä¢ M :_p A    Œ≥‚ÇÄm ‚äÜ Œ≥
---------------------------------
Œì[Œ≥] ‚ä¢ F_m M :_q F_m A

Q: What happens if I think of the context as a graph whose edges are labelled with morphisms?
A: I think I want to require commutativity of every diagram implied by
the graph? Or do I? My gut says it's probably required for some
substitution theorem or something.

Q: Is it possible for a neutral expression to have a type that
involves the constant at the head?
A: Sure, here's an example
<<<
module b where

postulate
  o : Set
  a : o -> Set
  b : (y : o) ‚Üí a y
  c : (y : o) ‚Üí a y -> o
  k : o

term : a (c k (b k))
term = b (c k (b k))
>>>

Q: Where did I put some notes about how 2-categorical modalities work
in dependent types?
A: texnotes//2017-09-23.ltx

=== 2017.09.24

Q: What's a property I might want to pragmatically require for mode
theories to make typechecking tractable?
A:
If a ‚àò b = c, then
(a) there exists a maximal a' such that a' ‚àò b = c
(b) there exists a maximal b' such that a ‚àò b' = c
where a 'maximal' morphism means one that is the most useful attached
to an assumption. In the idempotent theory of 1 and r, I'm thinking of r ‚â• 1,
and indeed in that situation, I have a best solution (namely r) to both
r ‚àò ? = r
? ‚àò r = r
and a unique solution (namely r) to both
1 ‚àò ? = r
? ‚àò 1 = r
and a unique solution (namely 1) to both
1 ‚àò ? = 1
? ‚àò 1 = 1
and no solution (which is ok) to both
r ‚àò ? = 1
? ‚àò r = 1

Q: What do I make of [Fib2]?
A: The main thing that strikes me is why go to all the effort of
designing and proving coherent a system when you can just translate it
away to FOL, but that's my bias showing.

Q: What's going on with the embedding/encoding distinction in [Fib2]?
(search "A point of contrast with substructural logical frameworks")
A: ???

Q: What are the implications of thinking about two-cells between mode morphisms
(saying things like u ‚àò f ‚â§ 1) versus merely talking about preorders on 'terms'
(saying things like ‚àÄx . u(f(x)) ‚â§ x)
A: ???

Q: What am I getting out of reifying frames instead of what [Fib2] does, namely
thinking of them as structures-with-a-hole?
A: I guess greater uniformity of definition? My F rules look just like
my U rules with different sorts. I can represent classical logic as a
thing with frame constructors?

Q: Is it still possible to carry out a focusing proof for every logic
you can define in [Fib2]?
A: I think maybe yes; because the moment you throw in ‚äô, it's
impossible not to allow the definition of residuals x ‚äô - and - ‚äô x
which correspond to frame operations x ‚Ü£ - and x ‚Ü† -. So control over
frames (as opposed to abstractions) is what lets you define less
focally good logics like queue logic.

Q: What's that other paper dlicata@ thought would be an application of modalities?
A: [OrtonPitts]

=== 2017.09.25

Q: What's something to look for in [ShuFix]?
A: How exactly the properties of ‚ôØ and ‚ô≠ on top of their modal nature
get axiomatized.

Q: To what extent can the same be done with  É?
A: ???

Q: What's a sensible tack on dependent modal stuff?
A: To aggressively track how every type depends modally on its
context.

=== 2017.09.26

Q: Where's my ticket for account renaming?
A: https://wesleyanedu.service-now.com/ess//incident_status.do

Q: Does anything go wrong with totally decoupled term bundles from type bundles
A: ???

=== 2017.09.27

Q: What's the dance we have to do to justify the type upstairs in $FL$ is well-formed?
A:
Something like
<<<
$$\Gamma, y: A^{\alpha} \prov y^{y:=1} : A^{\alpha}$$
$$\Gamma, y: A^{\alpha} \prov (F^{y:=1}_\mm y)^{y:=m} : (F^\alpha_\mm A)^{\alpha'}$$
$${\Gamma, x:(F^\alpha_\mm A)^{\alpha'} \prov   C^\gamma : \rtype}$$

$${\Gamma, y : A^\alpha, x:(F^\alpha_\mm A)^{\alpha'} \prov   C^{\gamma, y := m\gamma(x)} : \rtype}$$
$$
\erule
{\Gamma \prov N^\nu : A^\alpha\qquad \Gamma, x:A^\alpha, \Gamma' \prov M^{\mu} : C^\gamma \qquad \mu \ge \nu \mu(x) \qquad \gamma \ge \nu \gamma(x) \using sub}
{\Gamma, [N^\nu / x]\Gamma' \prov [N^\nu / x] (M^\mu) : [N^\nu / x](C^\gamma)}
$$
>>>
but I'm not super confident in this.

=== 2017.09.28

Q: In [RS] what's an example of a non-exponentiable map between categories?
A: ???

=== 2017.09.29

Q: In [RS], looking at the extension type
 ‚ü® Œ†_{t : I | œà} A |^œÜ_{t.a} ‚ü©
is it possible for A's well-formedness to depend on œà without actually
mentioning t?

(I'm trying to understand when exactly the notation
‚ü® { t : I | œà } ‚Üí A |^œÜ_{t.a} ‚ü©
is justified, as defined at the end of section 2)
A: ???

Q: Where's avezzosi@'s agda implementation stuff for ‚ô≠?
A: agdac//1f943c9 and agdac//154073c , the difference from branch parametric to branch flat.

DONE: convinced IT to let me change my wesleyan account to jcreed@, I
think.

=== 2017.09.30

Q: How to get Skim to open a pdf to a certain page?
A:
https://emacs.stackexchange.com/questions/30344/how-to-link-and-open-a-pdf-file-to-a-specific-page-skim-adobe
links to org-mac.el at
http://orgmode.org/worg/org-contrib/org-mac-link.html
Or wait I can get by on the commandline with just
$ open -a /Applications/Skim.app some.pdf
and I don't even need to give a full path like I do with
$ open /Applications/Skim.app --args `pwd`/some.pdf

Q: How do I reload a file from applescript?
A:
$ osascript -e 'tell document "some.pdf" of application "Skim" to revert'


Q: What's a particular fixing of notation for the cast of characters in a fibration
that makes it look like a pullback?
A:
<<<
œÄ : ‚Ñ∞ ‚Üí ‚Ñ¨

 x
   œÜ   œà
     a   -f‚Üí   b
 ‚ÜßœÄ
   ‚ÜßœÄ
 X   ‚ÜßœÄ   ‚ÜßœÄ   ‚ÜßœÄ
   Œ¶
     A   -F‚Üí   B
>>>

"œÄ is a fibration" = ‚àÄ (A B : ‚Ñ¨)(F : A ‚Üí B)(b : œÄ‚Åª¬π B) ‚Üí ‚àÉ (a : œÄ‚Åª¬π A) (f : a ‚Üí b) √ó f is cartesian.

"f is cartesian" = ‚àÄ (X : ‚Ñ¨) (x : œÄ‚Åª¬π X) (Œ¶ : X ‚Üí A) (œà : œÄ‚Åª¬π (F ‚àò Œ¶) : x ‚Üí b) ‚Üí ‚àÉ! (œÜ : œÄ‚Åª¬π Œ¶ : x ‚Üí a) √ó (f ‚àò œÜ = œà)


Q: What does the bifibration situation look like for the mode 2-multicategory just being a monoid?
A:
<<<
    Œì .
     \  ' .
      \     ' .
    ‚Üß  ‚Üò        '‚Üò
        UA -----‚Üí A
        m
    * .
     \  ' . nm    ‚Üß
    n \     ' .
       ‚Üò        '‚Üò
        * ------‚Üí *
             m

Œì ‚ä¢[nm] A
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Œì ‚ä¢[n] UA

    C ‚Üñ
     ‚Üñ  ' .
      \     ' .
    ‚Üß  \        '
        FA ‚Üê----- A
        m
    * ‚Üñ
     ‚Üñ  ' . mn    ‚Üß
    n \     ' .
       \        '
        * ‚Üê------ *
             m

A ‚ä¢[mn] C
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
FA ‚ä¢[n] C
>>>

=== 2017.10.01

Q: How do I want to generalize the following?
<<<
Suppose I have a fibration
    œÄ
ùîº ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí ùîπ

I can also think of this as a single category ‚ÑÇ living over the arrow category

    p
ùêÑ ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí ùêÅ

The objects in ‚ÑÇ living over ùêÑ are the objects of ùîº.
The objects in ‚ÑÇ living over ùêÅ are the objects of ùîπ.
The arrows in ‚ÑÇ living over 1_ùêÑ are the arrows of ùîº.
The arrows in ‚ÑÇ living over 1_ùêÅ are the arrows of ùîπ.
The remaining arrows in ‚ÑÇ are pairs (E, b) where E is an object
of ùîº and b is an arrow œÄE ‚Üí B in ùîπ.

Composition should be pretty clear. The interesting case is
when we compose e : E1 ‚Üí E2 upstairs with a transverse b : œÄE2 ‚Üí B
and the answer is (b ‚àò œÄe) : œÄE1 ‚Üí B

In general, if F : ‚ÑÇ ‚Üí ùîª and p is an arrow in ùîª, we say _‚ÑÇ has
pullbacks along p_ if the pullback universal property holds like

      X   ‚Üí
        ‚Üò
      ‚Üì   E ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí E'
          ‚îÇ        ‚îÇ
          ‚îÇ        ‚îÇ
          ‚Üì        ‚Üì
          B ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí B'

          over

      ùêÑ   =
        =
      p   ùêÑ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê ùêÑ
          ‚îÇ        ‚îÇ
          p        p
          ‚Üì        ‚Üì
          ùêÅ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê ùêÅ
>>>
A: I think I just want to say: suppose F : ‚ÑÇ ‚Üí ùîª is a functor.
We say a diagram in ùîª like

                   B
                   ‚îÇ
                   ‚îÇg
                   ‚Üì
          C ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí D
              f

has an F-pullback if first of all there is a pullback in ùîª

               œÄ‚ÇÇ
         B√óC ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí B
          ‚îÇ‚îÄ‚îò      ‚îÇ
        œÄ‚ÇÅ‚îÇ        ‚îÇg
          ‚Üì        ‚Üì
          C ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí D
              f

And every ‚ÑÇ-cospan over BCD has a universal cone over œÄ‚ÇÅ,œÄ‚ÇÇ?

Q: So what's the definition of fibration given this idea?
A:
You start with your
    œÄ
ùîº ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí ùîπ

and construct from it ‚ÑÇ ‚îÄF‚Üí (ùêÑ ‚îÄp‚Üí ùêÅ), and demand that p and 1_ùêÅ have
an F-pullback.

Q: Is this the same as F 'creating the pullback of f and g'
A: ???

Q: Relevant links to this question?
A:
https://mathoverflow.net/questions/103065/what-is-the-correct-definition-of-creation-of-limits
https://ncatlab.org/nlab/show/created+limit
http://permalink.gmane.org/gmane.science.mathematics.categories/6644

Q: Is the functor over ùêÑ ‚îÄp‚Üí ùêÅ itself a fibration?
A: Hmm maybe it's an opfibration. Given E, I can certainly lift along
p to œÄE, where the requisite transverse arrow is 1_{œÄE}.

          œÄE ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ E

          ‚Üß        ‚Üß

          ùêÅ ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ùêÑ
               p

Yeah that would require all transverse arrows E ‚Üí B to correspond to
B-arrows that look like œÄE ‚Üí B, which seems true.

Q: Actually wait I'm not so sure about my definition in terms of
F-pullbacks, now. It seems prima facie more general than the fibrancy
condition. When I choose something over

                   ùêÑ
                   ‚îÇ
                   p
                   ‚Üì
          ùêÅ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê ùêÅ

it's not just a ùîπ-morphism downstairs, and an *object* of ùîº, it's a
ùîπ-morphism and a transverse morphism. Does being a fibration guarantee
an F-pullback of _that_?
A: Let's try. I start out with the data

                   E'
                   ‚Üß
                  œÄE'
              b    ‚Üìc'
          B ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí B'

Can I at least form the putative pullback square? Ugh, no, because c'
is going the wrong way. Let's try reversing it?

                   E'
                   ‚Üß
                  œÄE'
              b    ‚Üëc'
          B ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí B'

Hmmm now I've got transverse morphism living over E ‚îÄp‚Üí B is actually
made up of a morphism B ‚Üí œÄE not the other way around. I tried drawing
the diagram

          E ‚îÄ‚îÄe‚îÄ‚îÄ‚Üí E'
          ‚Üß        ‚Üß
         œÄE ‚îÄœÄe‚îÄ‚îÄ‚Üí œÄE'
          ‚ïë        ‚Üëc'
          B ‚îÄ‚îÄb‚îÄ‚îÄ‚Üí B'

which does seem to arise out of fibrancy but I can't seem to
understand what composition in ‚ÑÇ is anymore. Grr.

---

Ok, how about, desperate measures here, maybe ùîª is
        p,q
e ‚ü≥ ùêÑ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí ùêÅ ‚ü≤ b

with all of ùîπ living over b instead of 1_ùêÅ, all of ùîº living over e
instead of 1_ùêÑ and

b ‚àò p = b ‚àò q = q = p ‚àò e = q ‚àò e = q
e ‚àò e = e   b ‚àò b = b

The morphisms that live over p are just pairs (E, œÄE) with no real
morphism content. A morphism that lives over q is what I was trying to
define as a transverse morphism before, namely a triple (E, f, B) with
f : œÄE ‚Üí B.

Now I think I want to consider the pullback of b against p, and I'm
not even sure I can pull that off in this ùîª. Or wait, maybe I can...

              e
          ùêÑ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí ùêÑ
          ‚îÇ‚îÄ‚îò      ‚îÇ
         p‚îÇ        ‚îÇp
          ‚Üì        ‚Üì
          ùêÅ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí ùêÅ
              b

at least commutes. Is it a pullback? The only thing X can be is ùêÑ. The
only thing that the overall diagonal can be is q, because p doesn't
factor through b. So the top input projection has to be e not 1_ùêÑ. The
side input projection could be either p or q. But either of these has
a unique solution:

      ùêÑ   e
        e
      q   ùêÑ ‚îÄ‚îÄe‚îÄ‚îÄ‚Üí ùêÑ
          ‚îÇ‚îÄ‚îò      ‚îÇ
          p        ‚îÇp
          ‚Üì        ‚Üì
          ùêÅ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí ùêÅ
              b

      ùêÑ   e
        1
      p   ùêÑ ‚îÄ‚îÄe‚îÄ‚îÄ‚Üí ùêÑ
          ‚îÇ‚îÄ‚îò      ‚îÇ
          p        ‚îÇp
          ‚Üì        ‚Üì
          ùêÅ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí ùêÅ
              b

Ok, suppose fibrancy, to show pullbacks exist upstairs in ‚ÑÇ. I've got

                   E'

                   ‚Üß

          B ‚îÄ‚îÄf‚îÄ‚îÄ‚Üí œÄE'

living over

                   ùêÑ
                   ‚îÇ
                   p
                   ‚Üì
          ùêÅ ‚îÄ‚îÄb‚îÄ‚îÄ‚Üí ùêÅ

and fibrancy gives me

          E ‚îÄ‚îÄg‚îÄ‚îÄ‚Üí E'

          ‚Üß        ‚Üß

          B ‚îÄ‚îÄœÄg‚îÄ‚Üí œÄE'

with œÄg = f and œÄE = B. This means the e-arrow g composed with the
p-arrow for E' is the transverse arrow (E, œÄg, œÄE'), and so too is the
composite of trivial p-arrow for E and the b-morphism œÄg. I think the
more difficult case of checking that it's a pullback is the left input
projection being q. So imagine

      X        h
                 ‚Üò
      ‚Üß   E ‚îÄ‚îÄg‚îÄ‚îÄ‚Üí E'
     œÄX
      k   ‚Üß        ‚Üß
        ‚Üò
          B ‚îÄ‚îÄf‚îÄ‚îÄ‚Üí B'

living over

      ùêÑ        e
                 ‚Üò
          ùêÑ ‚îÄ‚îÄe‚îÄ‚îÄ‚Üí ùêÑ
          ‚îÇ‚îÄ‚îò      ‚îÇ
      q   p        ‚îÇp
        ‚Üò ‚Üì        ‚Üì
          ùêÅ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí ùêÅ
              b

That is, we have a transverse k : œÄX ‚Üí B in ùîπ and an h : X ‚Üí E' in ùîº
such that œÄh = f ‚àò k. That's exactly what fibrancy wants to give us a
unique arrow X ‚Üí E over k satisfying the appropriate commutativities,
I think.

Q: What's an example of noncofibrant spaces? I.e. map from 0 to the
space is not a cofibration?
A:
https://lists.lehigh.edu/pipermail/algtop-l/2009q1/000332.html
says

one-point compactification of countably infinite discrete space
warsaw circle

but I'm not sure which notion of cofibration is supposed to be going
on for them.

=== 2017.10.02

Q: Some stuff on model categories?
A: http://etale.site/writing/model-cats-for-algebraists.pdf

Q: Big ol book on topology and algebraic topology? Chapter 7 on
cofibrations?
A: http://groupoids.org.uk/pdffiles/topgrpds-e.pdf

Q: What's an example of a Serre fibration (fibrant wrt CW complexes) that's not
a Hurewicz fibration (fibrant wrt all spaces)?
A: https://mathoverflow.net/questions/241575/serre-fibration-vs-hurewicz-fibration

=== 2017.10.03

Q: Does avezzosi@'s flat branch also have cubical stuff in it?
A: Looks like yes.

Q: How do I exercise composeRelevance in
agda//src/full/Agda/Syntax/Common.hs
?
A:
Well it gets called in
agda//src/full/Agda/TypeChecking/Rewriting/NonLinMatch.hs
which defines the typeclass PatternFrom with method patternFrom
which gets called in
agda//src/full/Agda/TypeChecking/Rewriting.hs
in addRewriteRule which call comes after analyzing a Def from type
DeclCont defined in
agda//src/full/Agda/Auto/Syntax.hs
and that Def comes from a variable core living in a TelV which is defined in
agda//src/full/Agda/TypeChecking/Substitute.hs
That data came out of the function telView defined in
agda//src/full/Agda/TypeChecking/Telescope.hs

Q: Why does branch-flat agda get hung up on
{-# COMPILE GHC Level = type () #-}
in
agdalib//prim/Agda/Primitive.agda
?

Q: Well, where does {-# COMPILE GCH ... #-} come from?
A: I don't see COMPILE in
agda//src/full/Agda/Syntax/Parser/Lexer.x
which is sort of worrying.

Ugh it's not something to do with the pragma sharps, is it?
A: Ohhh no, it's because
/.cabal/share/x86_64-osx-ghc-7.10.3/Agda-2.6.0/lib/prim/Agda/
is not properly in version control I think.

Q: What's awesome in making sure I'm not going crazy?
A: agda2-display-program-version
displays the git commit it was compiled at, hallelujah.

Q: Where does this get generated?
A:
agda//src/full/Agda/VersionCommit.hs

Q: So what's going on with
agda//src/data/lib/prim/Agda/Primitive.agda
?
A: Ah, a relatively recent commit agdac//d1e6a0d (which postdates
avezzosi@'s commit) changed the format of these pragmas.

Q: Where does agda look for Primitive.agda?
A:
Well, doing
(setq agda2-program-args '("--no-default-libraries"))
doesn't help.
...
Aha,
agda//CHANGELOG.md (grep for Primitive.agda)
says I want to set environment variable
Agda_datadir

Q: From the commandline, does
$ export Agda_datadir=/Users/jreed/.cabal/sandboxes/agda-build/agda/src/data
work?
A: Yeah!

Q: From elisp?
A:
(setenv "Agda_datadir" "/Users/jreed/.cabal/sandboxes/agda-build/agda/src/data")
and restart the agda process.

Q: Starting point for problems with jump-to-definition?
A: https://stackoverflow.com/questions/28666113/goto-definition-in-emacs-haskell-mode

Q: Where do agda compile logs go when I don't say --verbose?
A: less +F /Users/jreed/.cabal/logs/Agda-2.6.0.log

Q: What should I be using instead of cabal install?
A: make install-bin I guess?

=== 2017.10.04

Q: What's Tom Leinster's aha moment about nerves of categories?
A: https://golem.ph.utexas.edu/category/2008/01/mark_weber_on_nerves_of_catego.html

Q: What's a case where being a fibrant object is nontrivial in a way I understand?
A: The classical model structure on simplicial sets; being a fibrant
object is the same as being a kan complex, i.e. having fillers for all
horns.

Q: What's the intuition for discrete fibrations?
A: With my Grothendieck glasses on, a fibration of categories is like
a functor ‚ÑÇ^op ‚Üí Cat, whereas a discrete fibration is like a functor
‚ÑÇ^op ‚Üí Set.

Suppose œÄ : ùîª ‚Üí ‚ÑÇ comes from the fibers of a presheaf. Then whenever
we have D ‚àà ùîª living over C2 and f : C1 ‚Üí C2, there is a *unique* g
living over f which tells us how to pull the object cod g (an element
of the fiber over C2) back to the object dom g (an element of the
fiber over C1). The fiber over an object is a discrete category from
considering the identity arrows.

Q: Do Street fibrations help me repair the idea from 2017.10.01?
A: Hm, not that I can see, yet. If I say a 'transverse morphism'
living over p is a ‚Ü¶ followed by an iso, then I still can't
post-compose on an arbitrary (i.e. non-iso) ùîπ-morphism.

=== 2017.10.05

Q: Where did I find something on nLab about a fibrationy generalization of profunctors?
A: https://ncatlab.org/nlab/show/Grothendieck+fibration#twosided_version

Q: Where did I find a nice characterization of cartesian morphisms as pullbacks of homsets?
A: http://maths.mq.edu.au/~street/Cicasm.pdf "Categories in categories, and size matters" Ross Street

Q: So am I right that this whole business with comprehension
categories or categories with families is to resolve the mismatch
between syntax, where substitution is associative on the nose, and
naive lccc semantics, where it's not? If we do synthetic,
suitably-univalent category theory, do we get any wins here? Can we
just do the naive lccc thing and get that substitution is associative
up to a path?
A: ???

Q: What's a nice easy-going narrative of all this fibrationy stuff?
A: http://www.cs.nott.ac.uk/~psxpc2/report-2013.pdf "Type Theory through Comprehension Categories"

Q: What do nonfibration functors correspond to Grothendieck-wise?
A: Functors from the base category ùîπ into Prof instead of Cat; that is,
the fibers are connected by profunctors (morphisms in Prof) rather
than functors (morphisms in Cat)
...
More concretely, say I have F : ùîº ‚Üí ùîπ. I want to think of this as a
functor ùîπ^op ‚Üí Prof. An object B in ùîπ goes to its fiber F^*(B) like normal.
A morphism f : B1 ‚Üí B2 in ùîπ should go to some profunctor F^*(B2) ‚Üí F^*(B1), i.e.
a functor F^*(B1)^op √ó F^*(B2) ‚Üí Set. But that's easy; let it be the fiber over f.
The object part is
f‚ôØ(E1, E2) = { e : E1 ‚Üí E2 ‚àà ùîº | F E1 = B1, F E2 = B2, F e = f }
and the arrow part on the first argument is
<<<
f‚ôØ(k : E1a ‚Üí E1b over id_B1, E2) = (Œª e . e ‚àò k) :
{ e : E1b ‚Üí E2 ‚àà ùîº | F e = f }
‚Üí
{ e : E1a ‚Üí E2 ‚àà ùîº | F e = f }
>>>
and the arrow part on the second argument is
<<<
f‚ôØ(E1, k : E2a ‚Üí E2b over id_B2) = (Œª e . k ‚àò e) :
{ e : E1 ‚Üí E2a ‚àà ùîº | F e = f }
‚Üí
{ e : E1 ‚Üí E2b ‚àà ùîº | F e = f }
>>>
I see now how it's critical that things live over the identity so the
equation F e = f still holds after composition.

Q: How do we make a representable profunctor?
A:
F : ùî∏ ‚Üí ùîπ becomes F‚ôØ : ùî∏ √ó ùîπ^op ‚Üí Set via
F#(A, B) = ùîπ(B, F(A))
F#(f : A1 ‚Üí A2, B) = Œªg : ùîπ(B, F(A1)). Ff ‚àò g
F#(A, f : B1 ‚Üí B2) = Œªg : ùîπ(B2, F(A)). g ‚àò f

Q: How do I VPN?
A: http://www.wesleyan.edu/its/services/wireless/vpn.html

Q: How do I do email forwarding?
A: http://www.wesleyan.edu/its/services/accounts/desktop.html

Q: Why can't I view e.g. http://exchange.blogs.wesleyan.edu/
A: Had to be on VPN to make progress, but still can't read.
"Topics related to Outlook and Entourage can be viewed by administrators only."

Q: wesleyan webmail?
A: https://owa.wesleyan.edu/owa/

Q: What started making sense of ends and coends for me?
A: https://ncatlab.org/nlab/show/extranatural+transformation

Q: So where do I find the terms in a comprehension category?
A: ???

Q: What's the answer to the question about [RS] theorem 4.4 I asked Mike?
A: I can find the question in my email by searching for
<<<
I'm taking another pass over this paper trying to digest as much as I
can; really enjoying it. Here's a question that maybe has an easy
answer. I'm just wondering if I'm misunderstanding something that
should be obvious.
>>>
the answer I've generated for myself for now is
<<<
{-# OPTIONS --without-K #-}
module a where

open import HoTT

pre : {A B : Set} (f : A ‚Üí B) (b : B) ‚Üí Set
pre {A} {B} f b = Œ£ A (Œª a ‚Üí f a == b)

lem : {A B C : Set} (f : A ‚Üí B) (g : B ‚Üí C) (c : C)
  ‚Üí pre (g ‚àò f) c ‚âÉ Œ£ (pre g c) (Œª k ‚Üí pre f (fst k))
lem {A} {B} {C} f g c  = equiv into out zig zag where
  into : pre (g ‚àò f) c ‚Üí Œ£ (pre g c) (Œª k ‚Üí pre f (fst k))
  into (a , gfa/c) = ((f a) , gfa/c) , a , idp
  out : Œ£ (pre g c) (Œª k ‚Üí pre f (fst k)) ‚Üí pre (g ‚àò f) c
  out ((b , gb/c) , a , fa/b) = a , (ap g fa/b ‚àô gb/c)
  zig : (b : Œ£ (pre g c) (Œª k ‚Üí pre f (fst k))) ‚Üí into (out b) == b
  zig ((.(f a) , idp) , a , idp) = idp
  zag : (a : pre (g ‚àò f) c) ‚Üí out (into a) == a
  zag (a , gfa/c) = idp

ext : {A B Q : Set} (f : A ‚Üí B) (q : A ‚Üí Q) ‚Üí Set
ext {A} {B} {Q} f q = Œ£ (B ‚Üí Q) (Œª h ‚Üí h ‚àò f == q)

thm : {œÜ œà œá X : Set} (f : œÜ ‚Üí œà) (g : œà ‚Üí œá) (q : œÜ ‚Üí X)
  ‚Üí ext (g ‚àò f) q ‚âÉ Œ£ (ext f q) (Œª k ‚Üí ext g (fst k))
thm f g q = lem (_‚àò g) (_‚àò f) q
>>>
which is to say, indeed, in the nondependent case, having a two-step
extension is the same as having a one-step extension along the
composite.

=== 2017.10.06

Q: What's a great early post ideas that fed into [RS]?
A: https://golem.ph.utexas.edu/category/2012/06/directed_homotopy_type_theory.html

Q: Stuff about stratified spaces that david corfield mentioned in the comments on that post?
A:
https://ocw.mit.edu/courses/mathematics/18-965-geometry-of-manifolds-fall-2004/lecture-notes/lecture12.pdf
http://aimsciences.org/journals/pdfsnews.jsp?paperID=2468&mode=full
https://ncatlab.org/nlab/show/poset-stratified+space#AFRshh

Q: Where's the other post that I'm thinking of?
A: Ah, it's by eriehl@:
https://golem.ph.utexas.edu/category/2017/05/a_type_theory_for_synthetic_ca.html

Q: What's the obstacle to constructing a subuniverse or something that
is Segal, (with specifically the functions between types being the
morphisms) if the universe as is isn't? Can't I just make a DHIT for
this?
A: Well... I realize I need the DHIT to include data for the way that
functions actually do compose. In pseudo-Agda I might say something
like
<<<
data Fset : Set‚ÇÅ where
  name : Set ‚Üí Fset
  mor : {A B : Set} (f : A ‚Üí B) ‚Üí hom (name A) (name B)
  comp : {A B C : Set} (f : A ‚Üí B) (g : B ‚Üí C) ‚Üí (mor f ‚àô mor g) == mor (g ‚àò f)
>>>
where ‚àô denotes segal composition (which I guess I just kind of
presume is freely generated ‚Äî I guess by DHIT I mean 'segal HIT' or
perhaps 'rezk HIT'?) , and ‚àò denotes function composition. Or else
constructing a DHIT doesn't presume segalness, and instead what I
should be doing is throwing in an appropriate 2-simplex for each
function composition, then *proving* somehow that the result is segal.

=== 2017.10.07

Q: Is there any sense in which a bifibration looks like a category of relations on top of a relation?
A: Seems like it, yes.

=== 2017.10.08

Q: For type-checking, and therefore definitional-equality-checking in
[RS]-world, can I get away with considering all finitely many
disjunctive possibilities, as dlicata@ suggested?
A: Yeah, I think maybe so; maybe this even obviates needing to think hard about Œ∑?
I tend to thing that
œÜ ‚à® œà ‚ä¢ a ‚â° rec^{œÜ,œà}_‚à®(b, c) ‚áê‚áí (œà ‚à® (a ‚â° b)) ‚àß (œÜ ‚à® (a ‚â° c))
or maybe equivalently
œÜ ‚à® œà ‚ä¢ a ‚â° rec^{œÜ,œà}_‚à®(b, c) ‚áê‚áí (œÜ ‚áí (a ‚â° b)) ‚àß (œà ‚áí (a ‚â° c))
?

Q: What do I get out of that parametricity-via-bifibrations paper [JG] that dlicata@ mentioned?
A: Not a whole lot yet; I think I'm in a position of somewhat greater
generality by considering an arbitrary finite-product-preserving
bifibration ‚ÑÇ ‚Üí ùîª, for whatever that's worth.

=== 2017.10.09

Q: What's a thought I had about constructivity and cubical stuff?
A: Constructive logic restricts the things you get to do *so that*
every implication you prove is computational, every existential you
prove computes a witness, etc. etc.

What we're finding out with every parametricity theorem we prove, and
with every HoTT-esque system we invent, is that similarly we can
restrict the things we get to do --- in a way that turns out to be
barely any more restrictive than the level of constructiveness we
already got used to --- so that every function is functorial, every
transformation is natural, etc. etc.

The game is not to create a psychologically *noticeable* burden on
programmers by making them annotate how morphisms are preserved, how
naturality squares are created, etc., but rather to discover the set
of operations that preserve things things in a (to use the word
informally) natural (one might say 'effortless') way.

=== 2017.10.10

Q: How make 2-cells in tikzcd?
A:
mshulman@ suggests
<<<
\def\twocell#1{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,from=\mynodeone,to=\mynodetwo]%
}
>>>
in
https://tex.stackexchange.com/questions/362743/2-cells-in-tikz-cd

Q: What else do I need to demand of a cartesian bifibration so that Cat has
a full and faithful embedding in it?
A: Something like a distinguished subcategory of the total category of
the bifibration that consists of the "vertically iso" objects. With
this I can detect that binary relations are functional (because the
opreindexically obtained projection to the domain should then be iso
in this sense) and since fibered maps from one bifibration to another
will have to preserve opreindexing and also this subcategory, we'll
have a functional relation in the output category also.

=== 2017.10.11

Q: Can I characterize trivial objects upstairs in a product-preserving bifibration
by saying that they are the locally terminal objects?
A: Maybe. To be clear, I mean an object Y over A is trivial
if for any other object X over A, there's a unique map X ‚Üí Y over the identity.

             !f
          X ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí Y
          ‚î¨       ‚î¨
          ‚îÇ       ‚îÇ
          ‚Üì       ‚Üì
          A ‚ïê‚ïê‚ïê‚ïê‚ïê A

In the codomain bifibration, the trivial objects are the isomorphisms.
If a morphism s in the arrow category is an iso, then we can compute the
unique filler s‚Åª¬πx.

            s‚Åª¬πx
          X ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí Y
          ‚îÇ       ‚îÇ
        x ‚îÇ       ‚îÇ s
          ‚Üì       ‚Üì
          A ‚ïê‚ïê‚ïê‚ïê‚ïê A

If an s is locally terminal, we can find its inverse via

             s‚Åª¬π
          A ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí Y
          ‚îÇ       ‚îÇ
        1 ‚îÇ       ‚îÇ s
          ‚Üì       ‚Üì
          A ‚ïê‚ïê‚ïê‚ïê‚ïê A

We know that s ‚àò s‚Åª¬π = 1, what about the opposite?

              s      s‚Åª¬π
          Y ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí A ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí Y
          ‚îÇ       ‚îÇ       ‚îÇ
        s ‚îÇ       ‚îÇ 1     ‚îÇ s
          ‚Üì       ‚Üì       ‚Üì
          A ‚ïê‚ïê‚ïê‚ïê‚ïê A ‚ïê‚ïê‚ïê‚ïê‚ïê A

Use the uniqueness in the the fact that s is locally terminal.

Q: Oh wait, this notion doesn't seem stable up to ismorphism in ùîº. What do?
A: I think I can just generalize it to: Y over B is trivial if for any
X over A and any g downstairs, there's a unique f over g.

             !f
          X ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí Y
          ‚î¨       ‚î¨
          ‚îÇ       ‚îÇ
          ‚Üì       ‚Üì
          A ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí B
              g

Q: Should I drop the condition that any opcartesian morphism whose
codomain is trivial is split epi?
A: I can't seem to prove it for the above notion of `trivial', though
I can prove it in the codomain bifibration. It seem to inherently
require upstairs morphisms leaking downstairs, which makes sense in
the codomain bifibration, but won't when I have arbitrary relations
upstairs and just the free product category downstairs.

=== 2017.10.12

Q: What's a dead simple recharacterization of trivial objects?
A: They're the objects for which the unique map into the terminal
object is cartesian! This smells a lot like 'fibrant' objects, but I
guess 'cartesian' is different from 'fibration'?

Q: Are products of opcartesian squares again opcartesian?
A: Not sure they are in general, but seems to be the case in the
codomain bifibration over a category with products. Maybe I need to
demand it. It seems like a kind of distributivity property.

=== 2017.10.13

Q: Is my characterization of categories as relational things actually
a full embedding?
A: Hm, maybe not. Need some kind of grading perhaps.

=== 2017.10.14

Q: What agda did I start writing for relational things?
A:
<<<
{-# OPTIONS --without-K #-}
module b where

open import HoTT


bd : Set ‚Üí Set‚ÇÅ
bd X = Œ£ Set (Œª A ‚Üí A ‚Üí X)

postulate
  fib : {X : Set} ‚Üí bd X ‚Üí Set
  hom : {A B X : Set} {g : B ‚Üí X} {f : A ‚Üí B} ‚Üí fib (B , g) ‚Üí fib (A , g ‚àò f) ‚Üí Set

module _ {A B X : Set} (g : B ‚Üí X) (f : A ‚Üí B) where
  postulate
    reidx : fib (A , g ‚àò f) ‚Üí fib (B , g)
    opidx : fib (B , g) ‚Üí fib (A , g ‚àò f)
    reidx-hom : (t : fib (A , g ‚àò f)) ‚Üí hom (reidx t) t
    opidx-hom : (t : fib (B , g)) ‚Üí hom t (opidx t)
>>>

=== 2017.10.15

Q: What other agda false start did I have before realizing that
Œ∑-naturality is merely some laxer kind of 2-categorical pushout?
A:
<<<
postulate
  ‚ôØ : Set ‚Üí Set
  Œ∑ : {A : Set} ‚Üí A ‚Üí ‚ôØ A
  ‚ôØF : {A B : Set} ‚Üí (A ‚Üí B) ‚Üí ‚ôØ A ‚Üí ‚ôØ B
  ‚ôØnat : {A B : Set} {f : A ‚Üí B} ‚Üí (a : A) ‚Üí ‚ôØF f (Œ∑ a) == Œ∑ (f a)
  ‚ôØ+ : {A B : Set} ‚Üí ‚ôØ (A ‚äî B) ‚Üí ‚ôØ A ‚äî ‚ôØ B
  ‚ôØpush : {A B X : Set} (f : A ‚Üí B) (g : ‚ôØ A ‚Üí X) (h : B ‚Üí X) ‚Üí h ‚àò f == g ‚àò Œ∑ ‚Üí ‚ôØ B ‚Üí X
  ‚ôØpush1 : {A B X : Set} {f : A ‚Üí B} {g : ‚ôØ A ‚Üí X} {h : B ‚Üí X} {p : h ‚àò f == g ‚àò Œ∑}
    ‚Üí ‚ôØpush f g h p ‚àò ‚ôØF f == g
  ‚ôØpush2 : {A B X : Set} {f : A ‚Üí B} {g : ‚ôØ A ‚Üí X} {h : B ‚Üí X} {p : h ‚àò f == g ‚àò Œ∑}
    ‚Üí ‚ôØpush f g h p ‚àò Œ∑ == h
  ‚ôØpushu : {A B X : Set} {f : A ‚Üí B} {g : ‚ôØ A ‚Üí X} {h : B ‚Üí X} {p : h ‚àò f == g ‚àò Œ∑}
    {z : ‚ôØ B ‚Üí X}
    ‚Üí z ‚àò ‚ôØF f == g ‚Üí z ‚àò Œ∑ == h ‚Üí z == ‚ôØpush f g h p
  ‚ôØcompat : {A B : Set} ‚Üí ‚ôØ+ ‚àò Œ∑ {A ‚äî B} == {!!}
>>>

=== 2017.10.16

Q: Any progress on thinking about agda-ization of stuff?
A: Yeah, I returned to dealing with the fibers over a function as an
explicit set, and made some progress that way.

Q: What's the same as a heteromorphism in a bifibration?
A: If f : A ‚Üí B and P lives over A and Q lives over B,
then either a morphism Œ£_f P ‚Üí Q (over id_B) or a morphism
P ‚Üí f^* Q (over id_A) is just as good as a morphism over f.

=== 2017.10.17

Q: What's a better way to prove equalities of equalities of functions
from a coproduct?
A: ???

=== 2017.10.18

Q: Can I get away with relatively few judgmental additions?
A: Yeah, just Œì ; ‚ôØ n ‚ä¢ M : A seems to capture everything I need for
composition and functionality.

=== 2017.10.19

Q: Do I want to represent ‚ôØ variables explicitly?
A: Maybe not; it does make push look very natural, but it involves
inventing names for so many more things.

=== 2017.10.20

Q: But wait, what is ‚ôØn semantically?
A: It's a perfectly sensible thing! The category I want to interpret
into has (let's call them) 'meshes' for objects and 'mesh morphisms'
for arrows. A mesh is a choice of set M0, category M1, and a
(sufficiently-well-behaved) bifibration ‚àÇ : M1 ‚Üí (FinSet/M0)^op.
Well-behaved probably at least means: preserves products, products of
opcartesian morphisms are opcartesian, Beck-Chevalley holds.

A mesh morphism (M0, M1, ‚àÇM) ‚Üí (N0, N1, ‚àÇN) is a functor F1 : M1 ‚Üí N1
and a set function F0 : M0 ‚Üí N0 such that the obvious square commutes,
and F1 probably has to preserve products and bifibration structure
appropriately.

‚ôØn is the 'free mesh on an n-ary relation'. Its M0 is n. Its M1 has
for objects comprehensions Œì; E ‚ñπ œÉ that I described in
texnotes//2017-10-13.ltx .

Except here E can have only relation symbols and equalities in it.

Q: Since I know all morphisms upstairs in ‚ôØn are variable-for-variable
substitutions, can I say anything special about how 'pull' (fibration
reindexing) works?
A: Let some œÜ : œÑ' ‚Üí œÑ be given (œÑ, œÑ' are morphisms in the base
category, i.e. m ‚Üí n and m' ‚Üí n, with œÜ actually being a function m ‚Üí
m' because of the ^op) and suppose we have a Œì; E ‚ñπ œÉ over œÑ. The
reindexing is Œì, Œî_{œÑ'}; E, œÉ = œÜ ‚ñπ id_{Œî_{œÑ'}} over œÑ'. Hmm. No
notationally obvious reduction I can make, but I do expect to be able to assert

(1) Œì, x : A; E, x = y ‚ñπ œÉ

to be isomorphic to

(2) Œì; [y/x]E ‚ñπ [y/x]œÉ

=== 2017.10.21

Q: How on earth am I supposed to prove semantically that the walking
$n$-ary relation behaves correctly? I feel dumb not being able to.
A: ???

=== 2017.10.22

Q: How do I draw extra tikz stuff after a commutative diagramon is laid out?
A:
https://tex.stackexchange.com/questions/394922/draw-an-ellipse-in-tikz-cd-around-diagram

Q: Why am I getting weird problems in tikz-cd inside a \def?
A:
https://tex.stackexchange.com/questions/253207/creating-a-new-command-for-commutative-squares

=== 2017.10.23

Q: What gives me a shred of hope about reasoning about bifibrations?
A: That the free `glom E and B together' bifibration maybe seems to
exist after all, and admits a somewhat explicit description.

=== 2017.10.24

Q: Nope, wrong again. I was relying on the free complete category functor
preserving limits, which of course it doesn't. What can I do?
A: Oh wait I can `glom ùîº and ùîπ together' by putting *ùîº* in the base,
and putting something like ùîº^‚Üí up top; except constrained to only include
the stuff over the identity.

Q: Then is ùîº ‚Üí ùîπ a pullback of that?
A: Yes, I think so, along p^*.

=== 2017.10.25

Q: What happens if I iterate that construction, starting from a
codomain fibration?
A: Looks like I get simplices in the base category!

=== 2017.10.26

Q: Is the `sufficiently trivial' condition on the functor T : ùîª ‚Üí ùîº sufficient
to guarantee existence of a mesh morphism out of the ùïÑ constructed from
pullback of cod : ùîª^‚Üí ‚Üí ùîª along F : ‚ÑÇ ‚Üí ùîª?

A: No, grr, I think I need `sufficiently cartesian', which is a much
uglier condition.

=== 2017.10.27

Q: Is there some nice generalization of `has a right adjoint' and `is an opfibration'
that covers their respective lifting properties?
A: ???

=== 2017.10.28

Q: Can I just get away with identifying meshes with the functors ‚ÑÇ ‚Üí ùîª I've
been using? Or, more to the point, can I just say a mesh is a
function X ‚Üí ùîª for some finitely complete category ùîª?
A: Maybe? I might even merely need pullbacks along arrows that are
in the image of the lift of that function to L(X) ‚Üí ùîª.

Q: What's that nice Tom Leinster post about the nerve construction
and why the simplicial category is chosen to be what it is?
A: https://golem.ph.utexas.edu/category/2008/01/mark_weber_on_nerves_of_catego.html

Q: So how does this translate into relationy things?
A: Well, I suspect the thing that plays the role of graphs
is, let's call them premeshes, which are spans of sets

       P
      / \
     /   \
    ‚Üì     ‚Üì
    R     C

Where P is is the set of all legs/projections of all relations in a mesh
collected together as a set. The left leg of the span picks out which
relation that particular projection comes from, and the right leg of the span
picks out which object the projection goes to. So the walking relation
on n things always has R a singleton, and the right leg of the span being
an isomorphism.

This is just the normal notion of a hypergraph, but 'proof-relevant' or
'categorified' or whatever; edges aren't just subsets of vertices, but
witnesses by set elements in P.

=== 2017.10.29

Q: How do I characterize the mesh maps between one free map and another?
A: Looks like a slightly messy diagrammatic thing.

=== 2017.10.30

Q: What'd I get out of the conversation with Dan?
A: (a) the thing that seems to make the modal stuff work is thinking
with profunctors, which is interesting. (b) at some point I need intro
and elim rules for at least functions ‚ôØn ‚Üí U, which maybe correspond
to the intro and elim rules for glue types in cubical hott?

=== 2017.10.31

Q: What's an interesting paper about verified programming for contracts?
A: https://blockstream.com/simplicity.pdf

Q: What's the other paper of noam@'s that I should read?
A: https://arxiv.org/pdf/1501.05115.pdf

=== 2017.11.01

Q: Is there a process Œ∂ that takes any ‚ÑÇ ‚àà Cat
and yields a functor Œ∂‚ÑÇ : ‚ÑÇ ‚Üí Set
that gives the simplest possible set assignment
where, like, `all possible function phenomena happen'?
A:
What I have in mind for the arrow category
‚Ä¢‚Üí‚Ä¢ is that it spits out a constant (not iso) map 2 ‚Üí 2.
I would also accept the map 3 ‚Üí 2 that sends {0,1,2} to {0,0,1}.
That's an even better account of `all phenomena happening': there's
an object with no preimages, one preimage, multiple preimages.

I could consider an even stronger version, where I take
‚Ä¢‚Üí‚Ä¢ to

œÄ‚ÇÅ : {(m, n) | n < m} ‚Üí ‚Ñï

so that I have something with every finite preimage-count.
What would I do for ‚Ä¢‚Üí‚Ä¢‚Üí‚Ä¢?

Let's call it f : A ‚Üí B and g : B ‚Üí C.

Let's see, every element in the rightmost set is named after how much
branching it experiences to the left. So a sequence of natural
numbers, in this case. So C = [[1]]. An element of B says which
element of C it belongs to, what index in its `ancestors' it is, and
how much branching remains to its left: so, [[1]] √ó ‚Ñï √ó [1]. Or, wait,
no, I can read off how much branching remains to its left by simply
indexing into the [[1]]. So B = [[1]] x ‚Ñï, subject to the constraint
that the ‚Ñï is less than the length of the list. An element of A says
which element of B it belongs to, and what index it is, so, [[1]] √ó ‚Ñï
√ó ‚Ñï, subject to the constraint that we can index twice.

Ok, I can carry out this pattern unto ‚Ä¢‚Üí‚Ä¢‚Üí...‚Üí‚Ä¢ just fine. How about a
commutative triangle? What does it mean for `every possible thing to
happen'? Ok, let me say that a `possible thing happening' for the
preimage of a point x ‚àà Œ∂‚ÑÇ(C) means a functor F : ‚ÑÇ/C ‚Üí Set where
F(id) = {*}.

I think I see the something like universal property that it ought to
satisfy now: Let ‚ÑÇ be given. Œ∂‚ÑÇ : ‚ÑÇ ‚Üí Set has the property that for
any (finite?) functor R : ‚ÑÇ ‚Üí Set, there's a unique *mono* natural
transformation R ‚Üí Œ∂‚ÑÇ.

All right, so I see that a `behavior' is a functor R : ‚ÑÇ^op ‚Üí Set. A
`behavior from the point of view of an object C ‚àà ‚ÑÇ' is all behaviors
quotiented by something. I think Œ∂‚ÑÇ takes C to the set of all
behaviors from the point of view of C. I can consider R √ó yC to
restrict to stuff upstream from C. Two behaviors R, S are identified
if R √ó yC is naturally isomorphic to S √ó yC, I guess? This is the variance-choice
of the yoneda embedding for which, if I take ‚ÑÇ = C0 ‚Üí C1 ‚Üí C2, I get

y(C0) = 1 ‚Üê 0 ‚Üê 0
y(C1) = 1 ‚Üê 1 ‚Üê 0
y(C0) = 1 ‚Üê 1 ‚Üê 1

No, I got something backwards somewhere, hmm..

=== 2017.11.02

Q: What kind of postulates would I have to add to express that the
ambient universe is being interpreted in some kind of `universal'
presheaf? I don't necessarily think I need `that much' universality,
but I should figure out what *kind* of universality I mean:
A:
I might suppose that every type actually, all along, lives in
Set^{(a‚Üíb)^op} for some two-object category a‚Üíb. What would that mean?
At least that somewhere I have yoneda types [a] and [b] and there is
precisely one function between [a] and [b]. How can I probe the
presheaf structure of a type X, knowing that? Well, the yoneda lemma
tells me exactly that maps [a] ‚Üí X are in exact correspondence with
elements of X(a), and [b] ‚Üí X with elements of X(b), and I can get
from X(b) to X(a) be precomposing with the canonical function [a] ‚Üí
[b]. So that gives me pretty much everything.

What I think I mean by `universal presheaf' is that every type is secretly
all along a Sets^{X‚ÇÅ^op √ó X‚ÇÇ^op √ó ‚ãØ} for a sufficiently large class of X·µ¢,
like perhaps all finite ones.

The postulates this seems to correspond to, then, is postulating a
bunch of little mini-universes of types whose maps amongst themselves
are totally determined.

I could imagine postulating simply that, if you have an internal category
in Agda located at ‚ÑÇ : Set, with hom : ‚ÑÇ ‚Üí ‚ÑÇ ‚Üí Set, then you get a
Ref : ‚ÑÇ ‚Üí Set
such that for any (C D : ‚ÑÇ) the function space Ref C ‚Üí Ref D
is equivalent to hom C D.

Q: What happens if I take the category of sets and functions?
A: I get Ref : Set ‚Üí Set such that Ref C ‚Üí Ref D ‚â° C ‚Üí D
Clearly this Ref should work out to be id_Set. Maybe it's even provable,
given enough parametricity.

Q: What happens if I take the category of sets and relations?
A: I get Ref : Set ‚Üí Set such that Ref C ‚Üí Ref D ‚â° C ‚Üí D ‚Üí Set
That's pretty neat! I guess this Ref is like the nondeterminism monad.

Q: What happens if I take the category of sets and opfunctions?
A: I get Ref : Set ‚Üí Set such that Ref C ‚Üí Ref D ‚â° D ‚Üí C
One might hope that Ref is then some kind of dualizing involution on types.

Q: Stepping back a bit, if I wanted to say `all types are graphs',
I'd demand that semantically every type is a Set^{(V‚ááE)}, which
is like saying there's a [V] and an [E] and a dom, cod: [V] ‚Üí [E].
But also I `know' that [V] should actually be 1. What does that identification
correspond to?
A:
Actually, if I interpret what I said above nitpickily, [V] should *not* be 1.
The type 1 is the terminal object; as a presheaf it has one vertex and one edge.
If [V] were 1, there would be no map from [E] to [V].

Q: But if I consider the category of *reflexive* graphs, with
dom : V ‚Üê E
cod : V ‚Üê E
id : V ‚Üí E
with the expected commutativities, then I get [V] and [E] and cod, dom : [V] ‚Üí [E]
and id : [E] ‚Üí [V]. Can I prove [V] equivalent to 1?
A: Hm, no, I still have no way of getting from an arbitrary type X to
either [V] or [E]. But semantically,
[V] =
  Vs: 1 (the morphism 1_V : V ‚Üí V, which is equal to other morphisms like
          dom id : V ‚Üí V)
  Es: 1 (the morphism id : V ‚Üí E)
[E] =
  Vs: 2 (the morphisms dom : E ‚Üí V and cod : E ‚Üí V)
  Es: 3 (the morphisms 1_E, id o dom, id o cod : E ‚Üí E)
In this case [V] *is* 1.

Q: How would I represent this understanding as postulates?
A: I guess it's a matter of internalizing what I know about the
construction of products (and also general limits, colimits,
exponentials, Œ†s and Œ£s) in presheaf categories.

Q: Assuming I have a category ‚ÑÇ, what do I say about products, for instance?
A: Hm, I'm tempted to say that, like
([V] ‚Üí A √ó B) ‚â° ([V] ‚Üí A) √ó ([V] ‚Üí B)
but I already know this --- this isn't a special fact about [V], it's just a fact
about A √ó B

Q: What's really the issue?
A: It's more like some kind of Œ∑ property.
I have X, Y, and Z for *every* object C ‚àà ‚ÑÇ,
[C] ‚Üí Z ‚â° ([C] ‚Üí X) √ó ([C] ‚Üí Y)
then in fact
Z = X √ó Y

Q: Can I get away with summarizing this principle by postulating

    (P : Set ‚Üí Set) (universal : (C : ‚ÑÇ) P [ C ]) ‚Üí P 1

A: No; it smoothly gives me what I want for the product case, but it's
clearly inconsistent. I could just narrowly tailor P to be the
disjunction

    Œª T . (T ‚â° [C‚ÇÅ]) ‚à® (T ‚â° [C‚ÇÇ]) ‚à® ‚ãØ ‚à® (T ‚â° [C_n])

when ‚ÑÇ is finite, and if the yoneda embedding of ‚ÑÇ doesn't happen to
produce a terminal object (as with the category of graphs), then we
get a contradiction.

Q: How about saying that for any two types (X Y : Set), if
    (C : ‚ÑÇ) ‚Üí ([C] ‚Üí X) ‚â° ([C] ‚Üí Y)
then
X ‚â° Y?
A: This seems semantically motivated, but I'm not sure how it plays
with multiple `index categories' interacting. Seems to work for products
and though; having
[C] ‚Üí Z ‚â° ([C] ‚Üí X) √ó ([C] ‚Üí Y)
for every (C : ‚ÑÇ) means having
[C] ‚Üí Z ‚â° ([C] ‚Üí X √ó Y)
for every (C : ‚ÑÇ), so Z ‚â° X √ó Y.

Q: What about coproducts?
A:
We should be able to obtain (a) that
[C] ‚Üí X + Y ‚â° ([C] ‚Üí X) + ([C] ‚Üí Y)
and (b) that
    (C : ‚ÑÇ) ‚Üí ([C] ‚Üí Z ‚â° ([C] ‚Üí X) + ([C] ‚Üí Y))
implies
    Z = X + Y
By similar reasoning as above, at least we have that (a) implies (b), given
the `extensionality' lemma that probing with [C]s suffice to tell types apart.
But (a) is interesting; it seems to suggest that ([C] ‚Üí ‚Äî) preserves colimits?
And therefore maybe has a right adjoint, as well as a left?

Q: What can I do with
([C] ‚Üí X) ‚Üí R ‚â° X ‚Üí C*R
A: Well, I can certainly show that ([C] ‚Üí ‚Äî) preserves coproducts at least.

Note that proving

(R : Set) ‚Üí (Z ‚Üí R ‚â° X ‚Üí R √ó Y ‚Üí R)
----------------------
(R : Set) ‚Üí (([C] ‚Üí Z) ‚Üí R ‚â° (([C] ‚Üí X) ‚Üí R) √ó (([C] ‚Üí Y) ‚Üí R))

would be enough, by substituting X + Y / Z; but armed with the right adjoint,
I can rewrite the bottom to

Z ‚Üí C*R ‚â° (X ‚Üí C*R) √ó (Y ‚Üí C*R)

so that it becomes an instance of the top.

(or maybe I need parametricity for it to be *really* enough, to
transform the bottom to ([C] ‚Üí Z) ‚â° ([C] ‚Üí X) + ([C] ‚Üí Y) but whatevs)

Q: Does this really preserve colimits?
A: No! See texnotes//yoneda-and-colimits.ltx for a counterexample. I
think I was even a bit conservative in writing down all the mess that
is ùüö ‚Üí ùüö √ó ùüö; there are also four knight's-move arrows down and to the
right.

Q: What's a more basic demand than
    (C : ‚ÑÇ) ‚Üí ([C] ‚Üí X) ‚â° ([C] ‚Üí Y)
implies
    X ‚â° Y
?
A:
    (C : ‚ÑÇ) ‚Üí ([C] ‚Üí X) ‚Üí ([C] ‚Üí Y)
is equivalent
    X ‚Üí Y
so long as it's natural in C!

i.e. if
f : (C : ‚ÑÇ) ‚Üí ([C] ‚Üí X) ‚Üí ([C] ‚Üí Y)
then for every category morphism g : D ‚Üí C ‚àà ‚ÑÇ,
and every actual function h : [C] ‚Üí X we have
f C h ‚àò [g] ‚â° f D (h ‚àò [g]) : [D] ‚Üí Y

I think I would have needed to explicitly demand naturality in the
equivalence case anyhow, not sure at all that the fibrancy of Œ†s gives
the right naturality.

I was about to say, for each natural f we poop out a fout : X ‚Üí Y,
such that composition of fout with some [C] ‚Üí X leads to the
*specified* (by f) composite [C] ‚Üí Y, but of course to accomplish that
I just want to do the usual thing of exhibiting that there *exists* a
function in the easy direction, namely from X ‚Üí Y to

    (f : (C : ‚ÑÇ) ‚Üí ([C] ‚Üí X) ‚Üí ([C] ‚Üí Y)) √ó (f is natural in C)

and then demand that *that particular function* is an equivalence.

Q: What does that make me think?
A: That it would be nice to have already pulled myself up by
bootstraps and be able to say that instead of a category ‚ÑÇ
internalized in the usual way by having
    Obj : Set
    Mor : Obj ‚Üí Obj ‚Üí Set
    etc.
I'd like to ask for an internal category in the sense of
like, asking for a Rezk space.

Then I would say that if ‚ÑÇ : Set and Rezk(‚ÑÇ) holds, or some such, then
there is a map [_] : ‚ÑÇ ‚Üí Set,
but then perhaps the maps
(f : (C : ‚ÑÇ) ‚Üí ([C] ‚Üí X) ‚Üí ([C] ‚Üí Y))
would have naturality baked in?

Q: Can I imagine that [_] still does *something* when ‚ÑÇ is merely some
janky graph, and not a real category?
A: Maybe --- maybe I could consider it to be operating on the free
category? No, that would wreck its behavior on real categories,
wouldn't it?

Anyhow it seems prima facie dangerous to say that
(X ‚Üí Y) ‚Üí ((C : ‚ÑÇ) ‚Üí ([C] ‚Üí X) ‚Üí ([C] ‚Üí Y))
is an equivalence unless ‚ÑÇ is legitimately a *category*
and Œ†s out of it are adequately constrained.

Q: Is there an adjointy operation that `completes' presheaves Œî^op ‚Üí
Sets to categories but which is idempotent?
A: Yeah, I think so?

=== 2017.11.03

Q: What's a recap of my line of thinking so far?
A:
* Start with the idea that we're doing dependent type theory in a presheaf category.
  Instead of an object in Sets, every type is secretly a Sets^{‚ÑÇ^op}.

* Characterize what this provides internally as:
  - You get yoneda types [C], [D], ... for any objects C, D, ... ‚àà ‚ÑÇ.
  - Functions between yoneda types correspond to morphisms
  - Any function X ‚Üí Y can be interpreted as a natural transformation
    (C : ‚ÑÇ) ‚Üí ([C] ‚Üí X) ‚Üí ([C] ‚Üí Y)
    and this interpretation is an equivalence.

* Generalize to imagining that we're working in
  Sets^{‚ÑÇ‚ÇÅ^op √ó ‚ÑÇ‚ÇÇ^op √ó ...} for a broad class of categories ‚ÑÇ‚ÇÅ, ‚ÑÇ‚ÇÇ, ...

* How could I describe a choice of these ‚ÑÇ internally?
  (a) give a type ‚ÑÇ : Set which `is a category' qua Rezk space
  (b) I give a type ‚ÑÇ : Set and hom : ‚ÑÇ ‚Üí ‚ÑÇ ‚Üí Set and ‚àò and rid such
      that all the usual stuff.
  (c) [new thought as of this morning] I remember that every category
      is a subcategory of a concrete category, and give a collection
      of sets C, D, etc. and a collection of functions between them
      that are closed under composition.
  (d) [`universal' variant] For every function X ‚Üí Y at all I give
      a multiplicity, and a description of how mulitplicities
      are compatible with composition. (this is basically just
      (c) with `the collection of sets' being set to `all of Set‚ÇÅ')

Q: How I do I think about what this accomplishes?
A: It takes the actual universe of sets and functions, and a
description of an alternate one, where I've deleted or duplicated some
functions, and asserts that the alternate universe has a real
existence as types and homsets.

Like: I take the set 2 and notice that {id, swap} are closed under
composition. Then I get a type 2' where {id, swap} are the *only*
endomaps.

Q: What's a potentially nice way to corral some of these assumptions together?
A: There is an evident map from an indexed set (X : Set) √ó (S : X ‚Üí Set)
to a category whose objects are X and whose morphisms x ‚Üí y are all
functions S x ‚Üí S y. Postulate that this map is an equivalence.

Q: Going even farther, I observe that I can map from an indexed set
(X : Set) √ó (S : X ‚Üí Set)
to a *simplicial* set on X
(C : ‚Ñï ‚Üí Set) √ó (simplicial maps among the Cs)
by setting
C 0 = X
C 1 with vertices x, y = S x ‚Üí S y
C 2 with vertices x, y, z = a commuting triangle of functions S x ‚Üí S y ‚Üí S z
etc.
Can I demand that *that* translation has an inverse?
A: Hm, maybe not. What if the simplicial set *isn't* a category?
Like, let's say my simplicial set has three vertices and two edges
‚Ä¢ ‚Üí ‚Ä¢ ‚Üí ‚Ä¢ but no third arrow spanning the whole line. Yeah, there can
be no type that gives rise to that simplicial set.

=== 2017.11.04

Q: So for the usual semantics of dependent type theory with univalent
equality into simplicial sets, how do we get around the fact that the
category of groupoids isn't lccc? Is it
(a) no, actually it is lccc, or
(b) the wide subcategory of fibrations is lccc
A: ???

=== 2017.11.05

Q: What did mshulman@ say about the reflection principle I suggested?
A: Compared it to feferman's ZFC/S
https://arxiv.org/pdf/1603.03272.pdf
https://golem.ph.utexas.edu/category/2009/11/feferman_set_theory.html

=== 2017.11.06

Q: What's another paper about generalizing from functions to relations?
A:
"Arrows are strong monads"
http://www-kb.is.s.u-tokyo.ac.jp/~asada/papers/arrStrMnd.pdf


=== 2017.11.07

Q: What's going on the 'galois theory' of profunctor optics?
A: I see from Bartosz's talk
https://www.youtube.com/watch?v=l1FCXUi6Vlw
"Profunctor Optics: The Categorical Approach - Bartosz Milewski"
with accompanying blog post
https://bartoszmilewski.com/2017/07/07/profunctor-optics-the-categorical-view/
that there's some inverse relationship between more *special* type
classes on p and more *general* optics when you say

type SomeOptic s t a b
    = forall p. SomeTypeClass p => p a b -> p s t

=== 2017.11.08

Q: What's an interesting spatial metaphor for all this relational nonsense?
A: Weighted convex combinations.

A `relation over a, b, c, ...' corresponds to a formal linear
combination of a, b, c, ... with nonnegative coefficients.

We can push by duplicating or dropping coefficients.

We can pull by taking the sum of colliding coeffients, using the zero
coefficient for things that we pulled into existence out of thin air.

The product of two `relations' just takes the formal sum of the two sums.

Q: Is this actually a mesh? What's the cartesian category?
A: Perhaps its objects are formal linear sums over some multiset
objects. So if {a, b, c} is the set of objects *of the mesh* then the
objects upstairs actually include things like 2a + 3b + 5b + 7c which
is not the same as (but can be pulled to) 2a + 8b + 7c, because those
two copies of b are different. What are the morphisms? I'm guessing
substitutions of names, together with ‚â• on coefficients. So there
should be a morphism

2a + 8b + 7c ---> 2a + 3b + 5b + 7c

which is the pullback of

a + b + c ---> a + b + b + c

which is directly a substitution morphism?

Q: To always be able to do pullbacks, do I actually need to be integer-weighted,
not real-weighted? So that, e.g., there's always a morphism
n a + m b + p c ---> a + b + c
?
A: Maybe? Except, wait, then there *isn't* an arrow if n happens to be zero.

Q: What's a conceptual tension I experience?
A:
In some way, I want to add a bit of structure to every type that
captures `betweenness' relationships; morphism-like entities with
three ends to their boundary, source, target, and median. But this
would mean that every actual categorical directed morphism would exist
as a point in the type, and I'm not sure how I feel about that. In the case
of HoTT, we certainly can use path induction to extract a generic point, by

    generic : (A : Set) (x y : A) (p : x == y) ‚Üí A
    generic A x .x idp = x

but this seems to crucially involve the fact that we're dealing with
*equality* specifically. It's not clear a directed morphism has
generic points in the same way --- at least not *in the type A itself*.

Q: What occurs to me to try next?
A: Maybe there's a sense in which the `virtual points of A' all live
in a separate region, into which A injects. There's A at time 0, and
there's ‚óãA at time 1, which includes more morphism data about A, and
of course A injects into ‚óãA.

Q: But do I still end up having some notion of `generic point' of a
directed morphism?
A: Maybe. Trying to unpack the definition of functional relation
(being be a trivial object upon projection *out* of the codomain)
means having a zero coefficient if you look at the domain coefficient
only --- so a directed morphism is a virtual in-between point between
two points that sits at the codomain, maybe?

Q: What's the defining category look like in my head now?
A:
    domain, codomain             median
Points <------ Betweenness Facts ------> Virtual Points
   |                  ‚Üë
   +------------------+
         refl

Q: Doesn't really seem that much different from a reflexive graph, does it.
A: Nope. Doesn't seem clear that virtual points are anything other
than a redundant fibering over `betweenness facts'. Hmm.

Q: What's another option?
A:
       domain, codomain, median             refl
Virtual Points <------ Betweenness Facts <------ Points

Q: What's the right notion of associativity for betweenness?
A: In the same way that the associativity of categorical composition
is really there to guarantee that n-ary composites canonically make
sense, I'd want axioms to guarantee that being in the convex hull of n
points canonically to make sense. Being in a triangle
    n ‚àà [a, b, c]
is equivalent to
    ‚àÉ x ‚àà [a, b] . n ‚àà [x, c]
but also to any other permutation of a, b, c, e.g.
    ‚àÉ x ‚àà [c, b] . n ‚àà [x, a]

Q: How could the universe be so structured?
A:
Points and virtual points are sets.
Betweenness facts are spans (D ‚Üê R ‚Üí C)

Imagine a three-way relation R among {0, 1, 2} and {A, B} and {X, Y, Z, W}
with elements like
(0,A,X)
(0,B,X)
(1,A,Y)
(1,A,W)
(2,A,W)

Now there is a (proof-relevant) binary relation S with some duplicates
(0,A)
(0,B)
(1,A)
(1,A)
(2,A)

S is `between' {0, 1, 2} and {A, B}. But the relation
((0,A),X)
((0,B),X)
((1,A),Y)
((1,A),W)
((2,A),W)

(where I'm not notating the difference between the two copies of
(1,A), but the difference is real) is a proof that R is between S and
{X, Y, Z, Y}.

Q: What's the moral of this?
A: That reflection of morphisms back into points seems necessary and
sufficient for a binary notion of relation to explain n-ary relations.

Q: How do I fill in cells with colors in tikzcd?
A: https://tex.stackexchange.com/questions/256835/tikz-cd-shade-faces-of-commutative-cube

Q: Does one get to use ‚à®L at at lax judgment on the right in lax logic?
A: For sure, yes.

=== 2017.11.09

Q: What do I need to throw in the proof theory in order to be able to see
that a square is the union of two triangles?
A: Not sure. I could just add as an axiom that

‚ä¢ ‚óã((x = 0 ‚àß y = 1) ‚à® x = y) ‚à® ‚óã((x = 1 ‚àß y = 0) ‚à® x = y)

or equivalently

‚ä¢ ‚óã((x = 0 ‚àß y = 0) ‚à® x = 1 - y) ‚à® ‚óã((x = 1 ‚àß y = 1) ‚à® x = 1 - y)

but both of these seem dissatisfyingly particular.

Q: What would I do if x and y weren't typed ùüö but rather ùüõ, ùüú, etc.?
A: I can just barely visualize a possible plane through ùüö √ó ùüõ = {0,1} √ó {a,b,c}
that suggests the provability

x : ùüö, y: ùüõ ‚ä¢ ‚óã([0a] ‚à® P) ‚à®  ‚óã([1b] ‚à® [1c] ‚à® P)

where

P = [1a] ‚à® [0b] ‚à® [0c]
[x‚ÇÄy‚ÇÄ] = (x = x‚ÇÄ ‚àß y = y‚ÇÄ)

The principle I'm imagining that I'm using is that if pick an ordering
of the elements of ùüö, and of the elements of ùüõ, (in this case 0 < 1
and a < b < c) and you pick a subset of the vertices called P, and you
define L, `the part of the cube below the plane' as all the vertices
below some vertex in P according to the product order on ùüö √ó ùüõ, and U
symmetrically as the upper part, then *if* L ‚à™ U is all vertices of
the cube, then perhaps ‚ä¢ ‚óãU ‚à® ‚óãL

Q: Can I make anything out of the fact that I can map ùüö √ó ùüõ into ùüö √ó ùüö?
A: The mapping I have in mind is:

Œª (x : ùüö) Œª (y : ùüõ) . (
  x,
  case y of a ‚Ü¶ 1 | b ‚Ü¶ 0 | c ‚Ü¶ 0
)

which does send P into x = y and determines L and U to be such that
we're back to proving

‚ä¢ ‚óã((x = 0 ‚àß y = 1) ‚à® x = y) ‚à® ‚óã((x = 1 ‚àß y = 0) ‚à® x = y)

so it'd be nice if I could just `inverse image that back' to the ùüö √ó ùüõ
or more complicated cases.

Alternatively, I could take the map

Œª (x : ùüö) Œª (y : ùüõ) . (
  x,
  case y of a ‚Ü¶ 0 | b ‚Ü¶ 1 | c ‚Ü¶ 1
)

and be back in the case of proving

‚ä¢ ‚óã((x = 0 ‚àß y = 0) ‚à® x = 1 - y) ‚à® ‚óã((x = 1 ‚àß y = 1) ‚à® x = 1 - y)

Q: But would either of these be effective for the `majority vote on the cube'
example I also had thought of?
A: That was setting P = [001] ‚à® [010] ‚à® [100] on ùüö¬≥ and asserting
‚ä¢ ‚óã([000] ‚à® P) ‚à® ‚óã([111] ‚à® [110] ‚à® [101] ‚à® [011] ‚à® P)
and... yeah, it's not clear how to canonically map down on to either
of those.

Q: Do I want, like, a type
‚Ä¢ ‚Äî ‚Ä¢ ‚Äî ‚Ä¢
that has one point that's decisively in the convex hull of the other two?
A: Dunno. At least this makes me realize that I can internally
define a ternary betweenness predicate
A‚ü®B‚ü©C
as
‚óã(A ‚à® C) ‚áê‚áí ‚óã(A ‚à® B) ‚à® ‚óã(B ‚à® C)

Q: Wouldn't it be simpler just to say B ‚áí ‚óã(A ‚à® C)?
A:
Lemme check if it's equivalent:
B ‚áí ‚óã(A ‚à® C) ‚ä¢ ‚óã(A ‚à® C) ‚áí ‚óã(A ‚à® B) ‚à® ‚óã(B ‚à® C) ? √ó
B ‚áí ‚óã(A ‚à® C) ‚ä¢ ‚óã(A ‚à® B) ‚à® ‚óã(B ‚à® C) ‚áí ‚óã(A ‚à® C) ? ‚úì
‚óã(A ‚à® B) ‚à® ‚óã(B ‚à® C) ‚áê‚áí ‚óã(A ‚à® C) ‚ä¢ B ‚áí ‚óã(A ‚à® C) ? √ó
Nope.

Q: How do I interpret
(*)       ‚óã(A ‚à® C) ‚áê‚áí ‚óã(A ‚à® B) ‚à® ‚óã(B ‚à® C)
?
A: It's a quite strong notion of betweenness --- not only does B *fit* between
A and C, it's a barrier between them. Here's an example of the point B being between the
parallel line segments A and C, and not satisfying (*)
+     +
| \ / |
|  X  |
| / \ |
+     +
A  B  C

We don't get that the square ‚óã(A ‚à® C) fits inside the bowtie
‚óã(A ‚à® B) ‚à® ‚óã(B ‚à® C).

=== 2017.11.10

Q: Where in emacs's source is the visible bell image coming from?
A:
I see
imageNamed:NSImageNameCaution
in
emacs/src/nsterm.m

=== 2017.11.11

Q: Whose thesis has some useful things about fibrations in it?
A: Jonas Frey
"A fibrational study of realizability toposes"
https://arxiv.org/abs/1403.3672

Q: What's that popl 2018 paper about cps translating dependent types, and what
do I think is significant about it?
A:
"Type-Preserving CPS Translation of Œ£ and Œ† Types is Not Not Possible"
https://www.williamjbowman.com/resources/cps-sigma.pdf
https://popl18.sigplan.org/event/popl-2018-papers-type-preserving-cps-translation-of-and-types-is-not-not-possible
So first of all the passage from (A ‚Üí ‚ä•) ‚Üí ‚ä• to
    ‚àÄŒ±.(A ‚Üí Œ±) ‚Üí Œ±                                                           (*)
forehead-smackingly obvious-(or at least satisfying-)in-hindsight.
This one type (*) is at the nexus of so much of what I'm trying to understand lately;
one, the authors depend on (a tiny sprinkling of) /internalized parametricity/ to make
their theorems hang together. Two, as Bartosz Milewski often points out,
the parametricity fact that A ‚âÖ ‚àÄŒ±.(A ‚Üí Œ±) ‚Üí Œ± is the "programmer's Yoneda lemma".
Three, (*) is tantalizingly a special case of the type

    (‚Üì‚ÜëP)^r = ‚Üì‚àÄœÜ.(‚Üì‚àÄœÅ.P^œÅ ‚áí œÅ‚ñπœÜ) ‚áí r‚ñπœÜ

that shows up in my "logical recipes", degenerating back into (*) if
you trivialize the resource level.

Q: Why licenses me at *all* to postulate that, e.g.
‚ä¢ ‚óã(x = 0 ‚à® m) ‚à® ‚óã(x = 1 ‚à® m) ‚à® ‚óã(y = 0 ‚à® m) ‚à® ‚óã(y = 1 ‚à® m)
Isn't this in stark violation of the idea that any disjunction proved in the empty
context means one of its disjuncts is provable alone?
A: Ah, but I'm forgetting that it's not in the empty context; there's actually assumptions
x : ùüö, y : ùüö
which are something like
x : ‚óã(1 + 1), y : ‚óã(1 + 1)
So there must be something in ‚óã that has a little bit of either left asynchronousness
or left synchronousness that I can fruitfully use before ‚à®R. It's as if I can
take out a little bit of a loan on laxness and still apply ‚óãL somehow.

An alternative thought is that I also require nonemptiness of m to
make that work, so maybe there's some left-work on ‚óám that helps me out.

Q: Can I make the logic of ‚óã take semantics in simplicial sets, maybe?
A: I thought I could define a closure operator on downward-closed sets of
simplices, but then I realized that downward closure would mean that only
really the sets of vertices would matter.

Q: Going back to the idea of the join binary operator ‚ãÜ, isn't it the
case that if I tried to define ‚óã as A ‚ãÜ A, that this isn't quite
right?
A: Yeah, this isn't the all-at-once-from-the-vertices-all-the-way-up
closure, it's just one step of nonidempotent `closure'. If 3 = 1 + 1 +
1, then 3 ‚ãÜ 3 is only the boundary of the triangle, and 3 ‚ãÜ 3 ‚ãÜ 3 is
the interior as well. So actually ‚óãA is more like
    A ‚à® (A ‚ãÜ A) ‚à® (A ‚ãÜ A ‚ãÜ A) ‚à® ‚ãØ            (‚Ä†)

Q: Can there be a unit for ‚ãÜ?
A: Seems unlikely, since ‚óã‚ä• = ‚ä•, so if I were to say
    ‚óãA = U ‚à® A ‚à® (A ‚ãÜ A) ‚à® (A ‚ãÜ A ‚ãÜ A) ‚à® ‚ãØ
with the notion that U ‚ãÜ A = A, then
    ‚óã‚ä• = U ‚à® ‚ä• ‚à® (‚ä• ‚ãÜ ‚ä•) ‚à® (‚ä• ‚ãÜ ‚ä• ‚ãÜ ‚ä•) ‚à® ‚ãØ
And I definitely know ‚ä• ‚ãÜ ‚ä• = ‚ä•, so this is telling me
    ‚ä• = ‚óã‚ä• = U
which *doesn't* work as a unit. So I might be stuck with
the unitless expression (‚Ä†) as a quasi-definition of ‚óã in terms of ‚ãÜ.

‚ãÜ is topological join and ‚óã is convex hull, then
‚óãA ‚âà A ‚à® (A ‚ãÜ A) ‚à® (A ‚ãÜ A ‚ãÜ A) ‚à® ‚ãØ

=== 2017.11.12

Q: What's another interesting POPL'18 paper?
A: "Intrinsically-Typed Definitional Interpreters for Imperative Languages"

=== 2017.11.13

Q: What's the difference between 2-cell coercions Œ± ‚áí Œ≤ : type
in depdep2 and mere functions Œº : Œ≤ ‚Üí Œ± running the other direction?
A: ???

Q: What's the reason for using telescopes rather than whole-context
simultaneous substitutions?
A: ???

Q: What's another view of what a mesh is?
A:
A fibration over FinSet is a mesh that supports push, but not
necessarily pull or product. This can perhaps more easily be seen by
viewing it grothendieckly as a functor FinSet^op ‚Üí Cat; for every
boundary *size* we get a fiber of relation-morphisms over that
boundary.

Q: No, wait this isn't quite right, is it?
A: It doesn't seem to distinguish between endpoints and unary
relations over endpoints.

Q: What's a collage?
A: What you get from taking a profunctor H : C ‚á∏ D and producing
the category that's C + D + [heteromorphisms of H]

=== 2017.11.14

Q: What's another idea for what to take the presheaf category over?
A: Finite *co*relations. This seems to bake in push and pull, so that
I only need to axiomatize (or, like, Segal-condition-ize) on taking
(perhaps separately both nullary and binary) products of relations.

=== 2017.11.15

Q: How do I understand the fibrational perspective on mode theories in terms
of my more translate-away habit of thinking?
A:
Imagine a mode theory with one mode and the constant ‚äô with type
x : m, y : m ‚ä¢ x ‚äô y : m

In this we think of having a /type at m/. Prior to translation,
what a type-at-m is, is a type-level expression with kind

    m‚Å∫ ‚Üí type or
    m‚Åª ‚Üí type

depending on whether it's a positive or negative type. We have
two genuine types m‚Å∫ and m‚Åª in the metalanguage.

The propositional connective that reflects this mode operator is
A : mtype, B : mtype ‚ä¢ A ‚äô B : mtype

and this comes out as the definition

for all A, B : m‚Å∫ ‚Üí type
(A ‚äô B) @ œÅ = ‚àÉŒ±Œ≤. (œÅ ‚â§ Œ± ‚äô Œ≤) √ó (A @ Œ±) √ó (B @ Œ≤)
I guess then actually the type of ‚äô is
x : m‚Å∫, y : m‚Å∫ ‚ä¢ x ‚äô y : m‚Å∫

Q: So how would I think about dependent types in this setting?
A:
I'd have to introduce a mode operator that looks more like a sigma than
a monoid multiplication, maybe something like:

    x : m, y : m ‚Üí n ‚ä¢ œÑ x y : n

then I'd have a definition like one of the following options,
perhaps:

(1) -------------------------

(* most straightforward thing I could think of *)

(Œ£_œÑ (x : A) . B) @ œÅ =
  ‚àÉ(Œ± : m)(Œ≤ : m ‚Üí n). (œÅ ‚â§ œÑ Œ± Œ≤)
    √ó (A @ Œ±)
    √ó (B @ Œ≤)

where A : m ‚Üí type
      B : (m ‚Üí n) ‚Üí type
      (Œ£_œÑ (x : A) . B) : n ‚Üí type

(2) -------------------------

(* some weird cps conjecture? *)

(Œ£_œÑ (x : A) . B) @ œÅ =
  ‚àÉ(Œ± : m)(Œ≤ : m ‚Üí n). (œÅ ‚â§ œÑ Œ± Œ≤)
    √ó (A @ Œ±)
    √ó (B @ (Œªk : (n ‚Üí type). ŒªŒº: m.  k (Œ≤ Œº)))

where A : m ‚Üí type
      B : ((n ‚Üí type) ‚Üí (m ‚Üí type)) ‚Üí type
      (Œ£_œÑ (x : A) . B) : n ‚Üí type

(3) -------------------------

(* this actually seems to capture *dependency* properly *)

x : m, y : n ‚ä¢ œÑ x y : p

(Œ£_œÑ (x : A) . B) @ (œÅ : p) =
  ‚àÉ(Œ± : m)(Œ≤ : n). (œÅ ‚â§ œÑ Œ± Œ≤)
    √ó (a : A @ Œ±)
    √ó (B Œ± a Œ≤)

where A : m ‚Üí type
      B : (Œº : m) ‚Üí (A Œº) ‚Üí n ‚Üí type
      (Œ£_œÑ (x : A) . B) : p ‚Üí type

=== 2017.11.16

Q: Can I extract any of the example from depdep2 and port them over
to this way of thinking?
A: ???

=== 2017.11.17

Q: Does Œ£ involve a polarity shift? What polarity is it, even?
A:
I want
to think Œ£ is pos and Œ† is neg from adjoint considerations, but I
still think about fst and snd with Œ£. The type of the snd involves
*projecting* the value of fst, not a let-construct which gives you
both.

=== 2017.11.18

Q: How did I get astral plane unicode (incl. emoji) to work in emacs?
A:
https://emacs.stackexchange.com/questions/20186/a-build-of-gui-emacs-for-os-x-that-can-display-emoji
(setq after-make-frame-functions
      '(select-frame
        (lambda (frame) (set-fontset-font t 'symbol (font-spec :family "Apple Color Emoji")
                                          frame 'prepend))))
Then make a new frame.

=== 2017.11.19

Q: What's the useful idea I had yesterday?
A: That the contract of the translation @ is that it takes a type-in-context
and a mode-type-in-context, and the existential quantifiers range over
hypothetical mode-types-in-context.

=== 2017.11.20

Q: Do I want to go the whole contextual modal route?
A: Seems sort of appropriate, and LSR already did so.

Q: How do I interpret "Can there be vague objects?"?
https://academic.oup.com/analysis/article-abstract/38/4/208/131350?redirectedFrom=fulltext
A:
Let a and b be given such that
¬¨‚ñ°(a = b)
Suppose a = b. Then by identity elimination, ¬¨‚ñ°(a = a), hence a contradiction,
since surely ‚ñ°(a = a). So we've concluded that ¬¨(a = b).

But this is all sort of assuming that terms survive modal
context-clearing. I wonder if that's significant. It doesn't seem like
an immediate deal-breaker, since assuming that a and b exist as terms
in all future worlds doesn't seem to constrain *which* terms they are
in all future worlds; they might be different, or vary differently
from one another. And yet ¬¨‚ñ°(a = b) ‚ä¢ ¬¨(a = b), apparently.

=== 2017.11.21

Q: Are the base kinds in some kind of ‚Ä†-category?
A: Hm, I thought so, but now I think not; There's some kind of converse, relative
to the shifts, but I can't compose arbitrary zigzags together.

=== 2017.11.22

Q: So what do I want?
A: Maybe just an ordinary category, and speak of an optionally flipped
choice of morphism at the very end --- not unlike a bifibration giving
you the ability to operate as a fibration or opfibration.

Q: Anything worth saying about the distinction between the data
structure ‚ñπ and the proposition ‚ñπ?
A: That I'm still kind of confused about.

=== 2017.11.23

Q: When do I want base kinds and when general kinds?
A: ???

=== 2017.11.24

Q: Can I get away with just general binary relations, instead of specific ‚â§ and ‚óÉ like ones?
A: I think I still want to retain information about which polarity
they are in the representation language.

=== 2017.11.25

Q: What interesting thing did rntz@ point out about Nuyts bridges?
A: That in his setup, he actually did want localization and core to be `mutually idempotent'
and therefore not commutative, in the sense that
 core ‚àò loc = loc
 loc ‚àò core = core
rather than in Nuyts's case, where
 loc ‚àò core = loc
because core leaves bridges and loc turns them into isomorphisms.

Q: Which way around does the adjunction go?
A:
loc ‚ä£ forget ‚ä£ core
where forget : ùîærpd ‚Üí ‚ÑÇat

loc ‚ÑÇ ‚Üí ùîæ ‚àà ùîærpd
==================
‚ÑÇ ‚Üí forget ùîæ ‚àà ‚ÑÇat

ùîæ ‚Üí core ‚ÑÇ ‚àà ùîærpd
==================
forget ùîæ ‚Üí ‚ÑÇ ‚àà ‚ÑÇat

=== 2017.11.26

Q: Let me say that F' and G' : ‚ÑÇ ‚Üí ‚ÑÇ are _trijoint_ if there are
adjoint ‚ÑÇ ‚Üí ‚ÑÇ functors
F ‚ä£ G ‚ä£ H
such that F' = G ‚àò F and G' = G ‚àò H

Further say coinductively that F' and G' are _hereditarily triadjoint_ (write it
F' ‚ñπ G') when there are hered. triadj. functors
F ‚ñπ G ‚ñπ H
such that F' = G ‚àò F and G' = G ‚àò H.

This means there are
A ‚ñπ B ‚ñπ C and  D ‚ñπ E ‚ñπ F
such that
various stuff.

Can I make anything of this?
A: ???

Q: What's the two-arrow definition of a coend?
A:
If you have F : ‚ÑÇ^op √ó ‚ÑÇ ‚Üí ùîª and you want to compute

‚à´^C:‚ÑÇ F(C, C)

you can do it by taking the colimit of

  ‚àê F(c', c) ‚áâ ‚àê F(c, c)
‚ÑÇ(c, c')       c

The two arrows are the two ways of squeezing an arbitrary F(c', c)
into the diagonal; one by pushing it covariantly out to F(c', c')
along the f : c ‚Üí c', two by pulling it covariantly back to F(c, c)
along f backwards.

=== 2017.11.27

Q: What's a paper on semantics of focusing I'd like to understand better?
A: "A Categorical Semantics for Polarized MALL" Masahiro Hamano & Philip Scott
http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=F9C7CB8E4B64F242C54550FFA3578760?doi=10.1.1.92.6638&rep=rep1&type=pdf

=== 2017.11.28

Q: How do I do any kind of semantics that lines up nicely with counting proofs in
focused logic?
A: ???

=== 2017.11.29

Q: What's the right way of thinking about parametricity categorically?
A: ???

=== 2017.11.30

Q: Can I make anything out of the notion that parametricity is about an intuitionistically
*growing* set of equalities between things? Or preservation of colimits or something?
A: ???

=== 2017.12.01

Q: What's an interesting relational structure?
A: A "undirected graph object" in Cat, except that we
require a *fibration* ‚àÇ : E ‚Üí V √ó V and a twist functor ~ : E ‚Üí E
such that ~ ‚àò ‚àÇ = ‚àÇ ‚àò ~ for the evident ~ : V √ó V ‚Üí V √ó V.

=== 2017.12.02

Q: What'd I learn from talking to Dan?
A: The coend used to interpret multiplicatives might just be a sort of
profunctor composition.

=== 2017.12.03

Q: What am I struggling with suprisingly?
A: Trying to just show that I can interpret ‚â§ functorially.

=== 2017.12.04

Q: Can I, though?
A: Yes, if I'm careful enough.

=== 2017.12.05

Q: What's blocking me now?
A: Not understanding how a model can validate a‚Å∫ ‚äß ‚ä•

=== 2017.12.06

Q: What have I been reading lately?
A: Bunch of bernardy-moulin parametricity stuff.
"Toward a computational interpretation of parametricity"
"A computational interpretation of parametricity"
"Type-Theory In Color"
"A Presheaf Model of Parametric Type Theory"
Moulin's thesis, "Internalizing Parametricity"

=== 2017.12.07

Q: What's the deal with their erasure?
A: It feels like normal and irrelevant things are fibered over valid things.

=== 2017.12.08

Q: What in the world is going on with coercions and dependent function extensionality?
A: Dunno. I thought I could make up a type constructor that accomodated relations
being paths-in-the-universe, and it seems like I should be able to get from

(‚àÄi‚àÄj A @ i) ‚Üí (‚àÄi‚àÄj A @ j)

(or Œ±-equivalently (‚àÄi‚àÄj A @ i) ‚Üí (‚àÄj‚àÄi A @ i))

to

‚àÄi‚àÄj . A @ i ‚Üí A @ j

inside Bernardy-Moulin's own system, so that seems a look like an
arbitrary coercion.

=== 2017.12.09

Q: Wait, isn't this kind of problematic?
A: here's my thinking:

Let P‚Å± be a macro for any of the following equivalent things:
 ‚¶á A,·µ¢ Œ®_A P ‚¶à     ‚¶á A, Œ®_A P ‚¶à @ i
 A ‚ãà·µ¢ P           (A ‚ãà P) @ i

Their rule P·¥Ä…™ Ä-P Ä·¥á·¥Ö says
 a ‚àà i.P‚Å± ‚â° P a

Then for any i : ùïÄ ‚ä¢ A : rtype I can define
M : (‚àÄi‚àÄj . A @ i) ‚Üí (‚àÄi‚àÄj . A @ j)
M : Œª(f : ‚àÄi‚àÄj.A[i/i]). ‚ü®i‚ü©‚ü®j‚ü© f @ j @ i

and then

N : (f : ‚àÄi‚àÄj . A @ i) ‚Üí (M f @ 0 ‚àà i.(‚àÄj . A @ j))
N : (f : ‚àÄi‚àÄj . A @ i) ‚Üí ((‚ü®j‚ü© f @ j @ 0) ‚àà i.(‚àÄj . A @ j))
N : Œªf . (M f) !

...

then surely I have
P‚Å∞ ‚Üí ‚àÄi.P‚Å±
?

Q: No, wait, what?
A:
I think I figured out the mistake I made. Arbitrary coercion is
*not* possible in Bernardy-Moulin.

The conditions on their rule I…¥-F·¥ú…¥ for Œ¶ are stronger than I realized.
They require that you have
 i : ùïÄ ‚ä¢ A : type
 i : ùïÄ, x : A ‚ä¢ B : type
 t : (x : A[O]) ‚Üí B[O]
 u : (x : ‚àÄi.A) ‚Üí (t (x @ O) ‚àà ‚àÄi . B[x @ i / x])

and having merely

 u' : (x : ‚àÄi.A) ‚Üí (‚àÄi . B[x @ i / x])

is *not* enough to build a u of the appropriate type! I was being
sloppy in thinking merely along the lines of "any time I have a path
type with an endpoint nailed down (y ‚àà ‚àÄi.Y) that's strictly more
information than having a path type without any endpoints nailed down
(‚àÄi.Y), I can always just apply it to 0 and find out what the endpoint
is" which is true enough for *closed* path types, but not applicable
to the situation that's actually happening here because of scope
issues. if I have u' as above, then I know I can turn it into

Œªx . (u' x)! : (x : ‚àÄi.A) ‚Üí (u' x 0 ‚àà ‚àÄi . B[x @ i / x])

but there doesn't appear to be any way of expressing u' x 0 as a
function of x @ 0.

I…¥-F·¥ú…¥ isn't saying that *any* old function
  (x : ‚àÄi.A) ‚Üí (‚àÄi . B[x @ i / x])
can have its quantifiers hoisted up to ‚àÄi.(x : A) ‚Üí B, only the ones
with certain endpoints, namely the ones that only depend on x through
x @ 0.

Q: What's a thought for an axiom that covers pretty much all of
what's going on in Bernardy-Moulin -except- for dependent function extensionality?
A:
I can derive a certain amount of stuff (like P·¥Ä…™ ÄP Ä·¥á·¥Ö) from asserting that
there is an equivalence between
 A ‚Üí Set
and
 (C : ùïÄ ‚Üí Set) √ó C 0 ‚â° A

But I think I want to go further and establish, as usual, that a *certain* function
(C : ùïÄ ‚Üí Set) (p : C 0 ‚â° A) (a : A) ‚Üí Set
is an equivalence from (C : ùïÄ ‚Üí Set) √ó (C 0 ‚â° A) to (A ‚Üí Set). It's

Œª C p a ‚Üí (M : (i : ùïÄ) ‚Üí C i) √ó (coe p (M 0) ‚â° a)

Or I can rephrase a bit if I have nicely-reducing path types around.
Then I can say that I want the function

E : (A ‚àà i.U) ‚Üí (A ‚Üí U)
E œÄ a = a ‚àà i . œÄ @ i

to be an equivalence. That may be a bit circular, but it is nice and concise.

Q: This is a lot to absorb. What's going on?
A: P·¥Ä…™ ÄP Ä·¥á·¥Ö is saying that any relation can be represented as a path type.
This establishes that we can go from
 A ‚Üí Set
to
 (C : ùïÄ ‚Üí Set) √ó C 0 ‚â° A
It was looking at ! and ‚¶á_,_‚¶à that convinced me that the inverse map
is the specific map I think it is: the *elements* of the type
a ‚àà i.A are the maps M : ‚àÄi.A such that M @ 0 ‚â° a.

=== 2017.12.10

Q: Why was my bitbucket push slow?
A: ipv6 to bitbucket was timing out; ipv4 still fine.
https://grosse.io/blog/posts/Fixing-slow-Bitbucket-git-connections-via-SSH
https://confluence.atlassian.com/bbkb/recent-ipv6-changes-840796883.html

=== 2017.12.11

Q: What do I need for B-M's relational symmetry in iterated parametricity?
A: A kind of Œ∑-contraction for path types:

  lam-rewrite : ‚àÄ {‚Ñì} {A : ùïÄ ‚Üí Set ‚Ñì} {a : A O}
    (R : Path A a) ‚Üí lam (Œª j ‚Üí R * j) ‚Ü¶ R
  {-# REWRITE lam-rewrite #-}

which I stuck in Sharp1.agda and haven't ported to Sharp.agda yet.

=== 2017.12.12

Q: Does the 'internal category' nonsense also lead to requiring a semantics
that looks something like a presheaf over a countable power of a category?
A: ???

Q: What the heck is the deal with the B-M symmetry, really?
A: ???

=== 2017.12.13

Q: Can I do the presheaf semantics purely syntactically?
A: ???

=== 2017.12.14

Q: What's the thought I had about internal vs. external type theory?
A:
External type theory is
- ordinary type constructors
- linear types

- refinement types
Internal type theory is
- monads
- HoTT and univalence
- directed HoTT
- types as metric spaces
- parametric polymorphism, in that if you *don't* have things like polymorphic
equality, then you get parametricity.

=== 2017.12.15

Q: Is there much difficulty in trying to extend what I have to the dependent case?
A: ???

=== 2017.12.16

Q: Where's that old gears code?
A:
http://jsfiddle.net/fb48vshg/1/
http://jsfiddle.net/nv109w81/

=== 2017.12.17

Q: What do I do about universes?
A: Maybe I can get some yoneda leverage out of

Uhat(C) = Nat(yC, Uhat) ‚âà ‚àÉPhat . Nat(Phat, yC)

because of U's nature as an object classifier.

=== 2017.12.18

Q: What's that other idea I had about defining what a mesh is?
A: Choose a set X and consider the category Cell(X) whose

objects are functions Y ‚Üí X for a finite set Y
morphisms Y1 ‚Üí X to Y2 ‚Üí X are commutative squares

Z ----> Y1
|       |
|       |
v       v
Y2 ---> X

for Z a finite set, with composition given by pullback.
A functor F : Cell(X) ‚Üí Set gives the data of how pull and push work in the mesh.
Where do I get coproducts from? I should demand

z ‚àà F(0 -!-> X)

if z1 ‚àà F(A -f-> X) and z2 ‚àà F(B -g-> X) then
there exists (z1,z2) ‚àà F(A + B -(f,g)-> X)

with some universal properties? Do I know that

F(A + B -(f,g)-> X) = F(A -f-> X) √ó F(B -g-> X)

? No, merely that it includes it. But that inclusion should be
associative or something.

=== 2018.01.17

Q: So how do I arrange a purely syntactic *explanation* of a generic
presheaf model of dependent types?
A: Let's first page back in conclusively what the presheaf model *is*,
and prior to that, what a model of dependent types *is* at all.

A context Œì is interpreted as an object of the category.
A substitution Œì ‚ä¢ Œ∏ : Œî is interpreted as a morphism Œì ‚Üí Œî.
A type Œì ‚ä¢ A : type is a weakening/projection morphism œÄ : Œì, A ‚Üí Œì
A term Œì ‚ä¢ M : A is section of its type, M : Œì ‚Üí Œì , A such that
M ; œÄ = id.

Carrying out a substitution on a type is pullback. If we have
Œì ‚ä¢ Œ∏ : Œî (i.e. a morphism Œì ‚Üí Œî) and Œì ‚ä¢ A : type (i.e. a morphism A ‚Üí Œî)
then we can do a pullback to get Œ∏A ‚Üí Œì.

Carrying out a substitution on a term is a use of the pullback UMP.
If M;œÄ = id then Œ∏;M;œÄ = id;Œ∏ and therefore we get a section
Œì ‚Üí Œì, Œ∏A that is Œ∏M.

Context comprehension just takes the object of the newly added type as
the object that is the context.

Q: What are some nicely organized notes about this stuff?
A: http://math.cmu.edu/~cnewstea/talks/20170301.pdf

=== 2018.01.18

Q: What's the shape of the interpretation of a type, then?
A: Something like the [[A]]_c and [[A]]_f structure I had before. I
don't quite understand naturality, though. Maybe I need to really
think about the interpretation of a type as the extended context.

=== 2018.01.19

Q: What's an easy way to remember why presheaf categories are lccc?
A:
The fact that a slice of a presheaf category is again a presheaf category,
specifically over a category of elements:

\hat ‚ÑÇ / X ‚âÖ \hat {‚à´_‚ÑÇ X}

=== 2018.01.20

Q: What happens to contravariance when I consider the case where ‚ÑÇ = Set?
A: Duh, it goes away, because I'm only considering sets. The ccc structure
of Set/X and Set^X are both exactly the boring pointwise thing I expect.

=== 2018.01.21

Q: How do I check the existence of the counit epsilon for any of these?
I am so lost in technical fiddliness.
A: ???

=== 2018.01.22

Q: Actually, what goes wrong when I just try to barrel ahead with the
syntactic definition of how pi-types work, assuming I am confident
about how I've set up [[Œì]]_f and [[A]]_f and so on?
A: Actually, nothing seems to go wrong so far? I may have just been making several
errors to do with substitution. I needed to be careful to remember that of course
Œ¶ ‚àò (Œ∏[M/x]) = (Œ¶ ‚àò Œ∏) [Œ¶M / x]
which comes up when I must rewrite
[[Œì]]_g ‚àò ([[Œì]]_h [ [[A]]_h(y) / y ])
into
[[Œì]]_{hg} [ [[Œì]]_g [[A]]_h(y) / y ]
and not the incorrect
[[Œì]]_{hg} [         [[A]]_h(y) / y ]

=== 2018.01.23

Q: What was the equality constraint I had figured out before?
Does it actually hold for definitional equality?
A: It's something like if Œì ‚ä¢ M : A then
‚ü¶ A ‚üß_f (‚ü¶ M ‚üß_c) ‚â° ‚ü¶ Œì ‚üß_f ‚ü¶ M ‚üß_d

=== 2018.01.24

Q: How's this compare to what I seem to be conjecturing for the lambda case?
A: Not quite the same deal at all. I'm missing the involvement of the context.

=== 2018.01.25

Q: How to reconcile this?
A: Maybe by not trying to `factor out' the context substitution from
the get-go.

=== 2018.02.01

Q: So now can I simplify what I have of the syntactic presheaf model
by considering contexts translated at paths?
A: Slightly, but it seems to present its own difficulties. The main
friction is persistent off-by-one discrepancies between one
translation and another. Afaict, there's not a clear sense in which a
context x : A, y : B, z : C wants to be associated with two morphisms
or three --- it wants two for translating the context to a context,
but three for translating the context to a substitution. Maybe this is
ok, though, not sure.

=== 2018.02.02

Q: Now how do I connect this back to Bernardy-Moulin?
A: ???

=== 2018.02.05

Q: I claim in
https://gist.github.com/jcreedcmu/a8c2546c045150b05da62449667c7386
in the second paragraph a certain claim about embu. How do I prove it?
A:
'lemma' in
<<<
embu-inv : ‚àÄ {‚Ñì} {A : Set ‚Ñì}
  ‚Üí (A ‚Üí Set ‚Ñì) ‚Üí A ‚àà i ¬∑ Set ‚Ñì
embu-inv {‚Ñì} {A} = embu-equiv .is-equiv.g

embu-fg : ‚àÄ {‚Ñì} {A : Set ‚Ñì} (P : A ‚Üí Set ‚Ñì)
  ‚Üí embu (embu-inv P) == P
embu-fg {‚Ñì} {A} = embu-equiv .is-equiv.f-g

embu-round : ‚àÄ {‚Ñì} {A : Set ‚Ñì} (P : A ‚Üí Set ‚Ñì) (a : A)
            ‚Üí embu (embu-inv P) a ‚Üí P a
embu-round P a t = coe (app= (embu-fg P) a) t

lemma : ‚àÄ {‚Ñì} {A : Set ‚Ñì} (asm : (p : A ‚àà i ¬∑ Set ‚Ñì) (a : A) ‚Üí a ‚àà i ¬∑ (p * i))
  ‚Üí (R : A ‚Üí Set ‚Ñì) (a : A) ‚Üí R a
lemma asm R a = embu-round R a (asm (embu-inv R) a) where
>>>
which can be tacked on to
wes//agda/bernardy-moulin/Parametricity.agda

Q: Wait a minute, my agda encoding doesn't use linearity of ray-valued
variables i : ùïÄ. What goes wrong, then? Seems like something should go wrong.
A: ???

=== 2018.02.06

Q: What's a snappy thing to say about the extension relation _‚Üó_ in page 5 of [LOPS]?
A: It's a morphism in the category of elements of the preheaf.

=== 2018.02.07

Q: What's the current obstacle to overcome?
A: Understanding the Bernardy-Moulin presheaf semantics, particularly
(a) how the universe gets interpreted
(b) what linearity is crucial for
(c) what their talking about symmetry is crucial for

Q: What's the thought I have about the larger-scale direction I'm heading?
A: I want to be able to *program knowing that I live in some
open-world presheaf model*, which I can mentally extend (even though in some sense
it was already extended) almost as if I allocate ref cells.

Q: Ref cells? Huh?
A: Like --- I know at runtime, in ML, say, I can allocate a ref cell
of any type. But to support this semantically, I need to say that I
have a Store which is (something like) a map (œÑ : Tp) ‚Üí Set,
quantifying over all object-language types. Similarly, I want to have
operations in my programming language that feel like I'm dynamically
extending the ‚ÑÇ in the Sets^{‚ÑÇ^op} that I live in, but actually I
think I want to be able to `plan ahead' and pick a big enough ‚ÑÇ to
start with, so that my real Sets^{‚ÑÇ^op} is something like the (œÑ : Tp)
‚Üí Set that models ref cells.

Q: What supports the desirability of this?
A: All these other pieces of work that live in presheaves,
Bernardy-Moulin, [RS], [LOPS], [CCHM], [GCTT].

=== 2018.02.08

Q: Does it help much to page back in the proof that slices of toposes
are again toposes?
A: Not particularly at the moment.

Q: Whoa, [OrtonPitts] gets away without an involution?
A: Yeah, apparently! That's really interesting. It means some
macro-ish duplicated effort proving theorems or postulating axioms at
one endpoint and then the other, but that seems worth the trouble if
it becomes apparent how to *drop* some of those axioms/theorems.

Q: What's up with their ax‚Çà? It seems like the presence of B *and* B'
seems redundant somehow. I read it intuitively as saying: if B extends
partial type A, then there exists B' such that B' extends partial type
A, so surely I'm thinking about it wrong, aren't I?
A: ???

Q: What intuition just kicked in about fibrant objects?
A: Fibrations are the well-behaved morphisms that, as weakening
projections, characterize types. Recall that generally a fibrant
object is an object such that the morphism into the terminal object is
a fibration --- through the lens of dependent type semantics, that's a
type that's well-behaved, and which is additionally *closed*, because
it's over empty context.

Q: So does [LOPS] actually yield univalence provably?
A: ???

Q: What's another good couple of older papers to look at?
A:
"Universes in Toposes"
http://www.mathematik.tu-darmstadt.de/~streicher/NOTES/UniTop.pdf
"The intrinsic topology of Martin-L√∂f universes"
https://www.cs.bham.ac.uk/~mhe/papers/universe-indiscrete.pdf

Q: Can I say something like
<<<
a 'b' is a potentially infinite vector of bits
a 's' is a potentially infinite vector of {0, 1, *}
where
 dom s is a 'b', replaces * with 0 and
 cod s is a 'b', replaces * with 1

‚ü¶ cons f : A ‚Üí B ‚üß_0b = ‚ü¶ A ‚üß_b
‚ü¶ cons f : A ‚Üí B ‚üß_1b = ‚ü¶ B ‚üß_b
‚ü¶ cons f : A ‚Üí B ‚üß_0s(x) = ‚ü¶ A ‚üß_s(x)
‚ü¶ cons f : A ‚Üí B ‚üß_1s(x) = ‚ü¶ B ‚üß_s(x)
‚ü¶ cons f : A ‚Üí B ‚üß_*s(x) = ?
>>>
A: Let's try to type check it. I'm assuming
Œì ‚ä¢ f : A ‚Üí B
so (assuming dom s = d and cod s = c)
I need
‚ü¶ Œì ‚üß_0d, x : ‚ü¶ cons f : A ‚Üí B ‚üß_0d ‚ä¢ ‚ü¶ cons f : A ‚Üí B ‚üß_*s(x) : ‚ü¶ Œì ‚üß_1c ‚ü¶ cons f : A ‚Üí B ‚üß_1c
in other words
‚ü¶ Œì ‚üß_0d, x : ‚ü¶ A ‚üß_d ‚ä¢ ‚ü¶ cons f : A ‚Üí B ‚üß_*s(x) : ‚ü¶ Œì ‚üß_1c ‚ü¶ B ‚üß_c
so I observe
‚ü¶ Œì ‚üß_0d ‚ä¢ ‚ü¶ f x ‚üß_0d : ‚ü¶ B ‚üß_0d
oh but hold up I'm getting a discrepancy between d and 0d here hmm.

Q: Maybe say also something like
<<<
‚ü¶ cons f : A ‚Üí B ‚üß_0b = ‚ü¶ cdr A ‚üß_0b
‚ü¶ cons f : A ‚Üí B ‚üß_1b = ‚ü¶ cdr B ‚üß_1b
‚ü¶ cons f : A ‚Üí B ‚üß_0s(x) = ‚ü¶ cdr A ‚üß_0s(x)
‚ü¶ cons f : A ‚Üí B ‚üß_1s(x) = ‚ü¶ cdr B ‚üß_1s(x)
>>>
?
A: Not sure I can figure out what to do with that.

Q: Hey, actually is this where linearity needs to come into play?
A: ???

Q: What even approximately does the presheaf model for n-ary relations
look like? Like, assuming that I make the approximation that unary
relations need just the unmodified cube category.
A: ???

=== 2018.02.09

Q: Is there a reason I don't need a postulate to specifically spell
out what paths in dependent product types look like?
A: ???

=== 2018.02.10

Q: Does Moulin introduce I-sets, I-elements, etc. just so that some
definitional equalities translate to equalities rather than
isomorphisms? Can I validate embu and embf with just the usual
presheaf model?
A: ???

=== 2018.02.11

Q: So what does ùïÄ ‚Üí ùïÄ ‚Üí Set look like, really?
A: A commutative square in set.

=== 2018.02.12

Q: What's the relationship between push and pull?
A: Are they adjoint, maybe?

If I have ‚ôØB ‚Üí X I can push_f along f : ‚ôØA ‚Üí ‚ôØB to get something ‚ôØA ‚Üí X.
Conversely I should be able to pull_f from ‚ôØA ‚Üí X to ‚ôØB ‚Üí X.

I have some intuition that if I push (project out a column, say) and pull it back in,
I go from something like (x ‚àà X = {1,2,3,4,5} and y ‚àà Y = {Œ±, Œ≤, Œ≥})

 x | y     x     x | y
---+---   ---   ---+--------
 3   Œ±     3     3   Œ±, Œ≤, Œ≥
 3   Œ±  ‚Ü¶  3  ‚Ü¶  3   Œ±, Œ≤, Œ≥
 3   Œ≤     3     3   Œ±, Œ≤, Œ≥
 4   Œ≥     4     4   Œ±, Œ≤, Œ≥

and so there's a canonical map from the (4, in this case) rows of the original relation
to the (12, in this case) rows of the final result.

So we have something like

 id ‚Üí pull ‚àò push

and conversely if I pull to filter equals, then push back along the diagonal, like

 x | x'    x     x | x'
---+---   ---   ---+--
 3   3  ‚Ü¶  3  ‚Ü¶  3   3
 5   5     5     5   5
 3   4
 1   5

then I get something smaller, in the sense that I know how to inject
it back. Hence

  push ‚àò pull ‚Üí id

So it smells like push ‚ä£ pull. But how exactly do I think about
morphisms among things of type ‚ôØA ‚Üí X? I reckon it should be a special
kind of ‚ôØ2 ‚Üí (‚ôØA ‚Üí X) but that seems like a clear danger of infinite
regress.

Q: Or is it?
A:
Œµ : push ‚àò pull ‚Üí id_(‚ôØA ‚Üí X)
Œ∑ : id_(‚ôØB ‚Üí X) ‚Üí pull ‚àò push

all this parametrized over f : A ‚Üí B:

Œµ : (‚ôØA ‚Üí X) ‚Üí ‚ôØ2 ‚Üí (‚ôØA ‚Üí X)
Œ∑ : (‚ôØB ‚Üí X) ‚Üí ‚ôØ2 ‚Üí (‚ôØB ‚Üí X)
Œµ g (Œπ 0) ‚â° push (pull g)
Œµ g (Œπ 1) ‚â° g
Œ∑ g (Œπ 0) ‚â° g
Œ∑ g (Œπ 1) ‚â° pull (push g)

but yeah to express the directedness of the morphisms that Œµ and Œ∑ are
kicking out, I seem to need to be able to express a pull from
‚ôØ0 ‚Üí (‚ôØA ‚Üí X) to ‚ôØ1 ‚Üí (‚ôØA ‚Üí X), or at least a pull from
‚ôØ0 ‚Üí X to ‚ôØ1 ‚Üí X even if I sort of commute the ‚ôØA outward. And
the whole point is I'm trying to define what it means for X to have pulls.

=== 2018.02.13

Q: Did I get anything useful out of emailing Guilhem Moulin?
A: Nooope. He's fled to industry and paged out everything.

=== 2018.02.15

Q: Anything essentially different about treating things as *functions* from the context
instead of terms with free variables over a translated context?
A: No, I think everything lines up ok.

=== 2018.02.16

Q: Any progress possible on formalizing these intuitions?
A: ???

=== 2018.02.21

Q: What's my current thoughts?
A: [LOPS] cites
https://github.com/awodey/math/blob/master/Cubical/cubical.pdf which
has a nice summary of sites to take presheaves of.

Q: What's the covariant presentation of the `classical cube category' therein?
A: ???

Q: What else comes from that repo?
A: https://www.andrew.cmu.edu/user/awodey/preprints/stockholm.pdf

Q: What are some other interesting preprints of his?
A:
https://www.andrew.cmu.edu/user/awodey/preprints/tait.pdf
https://www.andrew.cmu.edu/user/awodey/preprints/uapl.pdf
https://www.andrew.cmu.edu/user/awodey/preprints/natural.pdf

Q: Some unrelated quantum fracton nonsense I meant to read at some point?
A: https://quantumfrontiers.com/2018/02/16/fractons-for-real/

Q: Bob harper and jon sterling paper about guarded computational type theory?
A: http://www.jonmsterling.com/pdfs/guarded-ctt.pdf

Q: Where's a handy copy of Hofmann's?
"Syntax and Semantics of Dependent Types"?
A:
http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.36.8985&rep=rep1&type=pdf

Q: What's that tikzcd options for making labels rotate to match the
slope of diagonal arrows?
A: 'sloped'

=== 2018.02.24

Q: What's an interesting prototype implementation of a dependently typed language in rust?
A: https://github.com/brendanzab/pikelet

=== 2018.02.25

Q: Wait, what happens when interval variables sneak into types in the context? Don't you
get the usual problems with linearity and dependency?
A: It seems not to be the case, because ùïÄ-typed things themselves can't depend on
other variables, but this is real fiddly and delicate and surprising.

=== 2018.03.12

Q: What's the analogue of Surj-Fun?
A: I think it's like Œ≤ and Œ∑ laws thinking of case as a tuple.

=== 2018.03.14

Q: What was the thing that the semantics of the shifts collapsed into?
A: Something involving the 'ninja yoneda lemma' from loregian's 'this
is the coend my only cofriend'.

Q: Do I need to keep track of the fact that interpretation of propositions
are not just proarrows but actual morphisms with companion and conjoint?
A: Hm doubtful.

=== 2018.03.16

Q: Interesting paper about algebraic databases I found searching for
the relationship between profunctors and coproducts?
A: https://arxiv.org/pdf/1602.03501.pdf

=== 2018.03.21

Q: Some bookmarks on grungy debruijn stuff:
A:
https://arxiv.org/pdf/1009.2789.pdf
https://www.lri.fr/~keller/Documents-recherche/Stage08/report.pdf
http://www.cse.chalmers.se/~abela/HereditarySubstitutionSTLC.agda
http://www.cse.chalmers.se/~abela/ParallelSubstitution.agda
http://www.cse.chalmers.se/~abela/projects.html
http://www.cs.nott.ac.uk/~psztxa/publ/msfp10.pdf "Normalization by Hereditary Substitutions"
https://arxiv.org/pdf/1111.0085.pdf "A Lambda Term Representation Inspired by Linear Ordered Logic"

=== 2018.03.22

Q: Can I firm up my intuitions about what ought to happen in a modal
dependent type theory where runtime 'low' values can appear in 'high' types?
A:
Like let's suppose I have some typical types at both levels

valid types A ::= UB | ‚Ñï | (x : A) ‚Üí A | (x : A) x A | A + A | ...
 true types B ::= FA | ‚Ñï | (x : B) ‚Üí B | (x : B) x B | B + B | ...

Or if I think of stuff in A as being circuits, then it's more like

   circuits A ::= UB | ùîπ | 1 | A √ó A | A ‚Üí A
 true types B ::= FA | ‚Ñï | (x : B) ‚Üí B | (x : B) x B | B + B | ...

the interpretation of a type

x1 : A, x2 : A, y1 : B, y2: B ‚ä¢ B* : set

is a morphism

‚ü¶ Œì, B* ‚üß ‚Üí ‚ü¶ Œì ‚üß for Œì = x1 : A, x2 : A, y1 : B, y2: B

as usual, but this is taking place in the 'low' category --- how do I interpret
the 'high' types? By applying the semantic version of F to them, somehow, clearly.
Any 'high' context can be hit with F to yield a 'low' context.

of course a term
x1 : A, x2 : A, y1 : B, y2: B ‚ä¢ M : B*

is a section

‚ü¶ Œì ‚üß  ‚Üí ‚ü¶ Œì, B* ‚üß...

How do I think about

    pow : (n : ‚Ñï) ‚Üí Set
    pow 0 = 1
    pow (S n) = ùîπ √ó (pow n)

I have that ùîπ is a 'high' type so I should be saying something like

    pow : (n : ‚Ñï) ‚Üí HighSet
    pow 0 = F 1
    pow (S n) = let F r = (pow n) in F (ùîπ √ó r)

and then we could imagine doing a 'list map' like

    map : (n : ‚Ñï) ‚Üí F (ùîπ ‚Üí ùîπ) ‚Üí F (pow n ‚Üí pow n)
    map 0 f = F (Œª * ‚Üí *)
    map (S n) f = let F r = (map n f) in F (Œª (b, tl) ‚Üí (f b, r tl))

But this use of n inside an F seems suspect!
Maybe what I really want is somehting like the typing

    map : (n : ‚Ñï) ‚Üí F (ùîπ ‚Üí ùîπ) ‚Üí let F t = pow n in F (t ‚Üí t)

?

If I can imagine a more 'applicative elim rule' syntax for these lets
--- something kind of lisp back-quotey -- this all might look like

    pow : (n : ‚Ñï) ‚Üí { Set }
    pow 0 = { 1 }
    pow (S n) = { ùîπ √ó [ pow n ] }

    map : (n : ‚Ñï) ‚Üí { ùîπ ‚Üí ùîπ } ‚Üí { [ pow n ] ‚Üí [ pow n ] }
    map 0 f = { Œª * ‚Üí * }
    map (S n) f = { Œª (b, tl) ‚Üí ( [ f ] b, [ map n f ] tl) }

or, more realistically, I'd want a polymorphic vector

    pow : (n : ‚Ñï) ‚Üí { Set } ‚Üí { Set }
    pow 0 A = { 1 }
    pow (S n) A = { [ A ] √ó [ pow n ] }

    map : (n : ‚Ñï) (A B : {Set}) ‚Üí { [A] ‚Üí [B] } ‚Üí { [pow n A] ‚Üí [pow n B] }
    map 0 f = { Œª * ‚Üí * }
    map (S n) f = { Œª (a, as) ‚Üí ( [f] a, [ map n A B f ] as) }

what would datatype definitions look like?

    data Vec (A : { Set }) : (n : ‚Ñï) ‚Üí { Set } where
      nil : {[ Vec A 0 ]} ‚Üí {[ Vec 0 A ]}
      cons : { [ A ] √ó [ Vec n A ] } ‚Üí {[ Vec (S n) A ]}

    map : (n : ‚Ñï) (A B : {Set}) ‚Üí { [A] ‚Üí [B] } ‚Üí { [Vec n A] ‚Üí [Vec n B] }
    map 0 f = { Œª nil ‚Üí nil }
    map (S n) f = { Œª (cons a as) ‚Üí ( cons ([f] a) ([ map n A B f ] as) }

this seems maybe wrong? Do I actually have datatype definitions at the
circuit level? Maybe not...

Q: Is something wrong about my belief that
‚ñ°(D ‚Üí ùîπ ‚Üí ùîπ) ‚Üí ‚ñ°(D ‚Üí ùîπ)
suffices?
A:
I think I was wrong. Here's some options:

bitwise fix: (basically what my question is about)
Œì, x : ùîπ ‚ä¢ e : ùîπ
----------------
Œì ‚ä¢ bfix x.e : ùîπ

wide fix at C
Œì, x : C ‚ä¢ e : C
--------------------
Œì ‚ä¢ wfix_C x.e : C

medium [generality] fix:
(this is a 'run' for the store monad for specifically ùîπ)
Œì, x : ùîπ ‚ä¢ e : A ‚Ä¢ ùîπ
--------------------
Œì ‚ä¢ mfix x.e : A

general fix at C:
(a 'run' for the store monad at C)
Œì, x : C ‚ä¢ e : A ‚Ä¢ C
--------------------
Œì ‚ä¢ gfix_C x.e : A


I think what I'd convinced myself of was that I could derive
(a) general fix from wide fix.
(b) general fix from medium fix.
(because I convinced myself that if I had gfix at C1 and C2,
I could make gfix at C1 ‚Ä¢ C2)

but I got turned around and thought that somehow bitwise fix implied
anything at all.

Recapitulating:
(a)
    gfix_C x.e = ([(wfix x. e.2)/x]e).1
but this is sort of scary because it duplicates e!
Maybe wide-fix is the wrong abstraction anyhow.

(b) Suppose gfix_C1 and gfix_C2. Then basically

    gfix_{C1 ‚Ä¢ C2} x.e = gfix_C1 x1. gfix_C2 x2. let (v, (c1, c2)) = [(x1,x2)/x]e in ((v, c2), c1)

I could have also said a directly
'pairwise' fix:
Œì, x : C ‚ä¢ e : A
Œì, x : C ‚ä¢ c : C
--------------------
Œì ‚ä¢ pfix_C x.(e, c) : A

but this seems to lead to messier programs with less evident sharing.

So probably 'medium fix' is the right primitive to add.

=== 2018.03.23

Q: What's the deal Bob's talk on CHiTT?
A:
First the usual bedtime story about univalence: it's great,
but you can't just add axioms. What is their computational significance?
We know what the equality elim rule is supposed to do when it encounters
refl, but what about ua? What about loop in the circle?

Type-dependent vs. type-independent identifications.

Cubical accounts. With diagonals? Without diagonals? With demorgan algebra?

Uniform Kan condition. Uniformity ~ naturality. Avoids deciding
degeneracy, which we can't do.

Types describe programs; computation precedes typing. (!)
Types are certain programs.

A ‚â° B type: A and B behave equally as types
M ‚â° N ‚àà A: M and N are equal according to A

Open terms defined extensionally

a : A ‚ü´ B ‚â° B' type if for any M ‚â° M' ‚àà A then [M/a]B ‚â° [M'/a]B' type
a : A ‚ü´ N ‚â° N' ‚àà B if for any M ‚â° M' ‚àà A then [M/a]N ‚â° [M'/a]N' ‚àà B[M/a]

These judgments are *synthetic*, where a proof theory is *analytic*.

There is no privileged proof theory; they just need to be sound.

Cartesian cubes are described by a little term theory with variables
and constants 0, 1, weakening, context, exchange.

Why is the programming language a 'cubical' one? Because some defined
transitions relations are sensitive to the dimension variables'
values.

You don't get any nice coherence/commutativity/stability of
substitution for substitution variables, but this is ok --- executing
programs are untyped! So give them types. Something can *be* a type
or *inhabit* a type if it's suitably coherent.

"Kan composition admits diagonal constraints"

What is this subtle issue about Path types that don't compute vs. the
'Jdentity' type?

Q: What's the deal with cangiuli's talk?
A: Another take on computing univalence. Guillaume's number is 2, but
arises from a pseudo-constructive proof that pi4(s3) is... some
natural number k, but it uses ua, so it can't compute yet.

We also have some untyped preterms, but we do have a sensible
'absolute' notion of equality on them; alpha-equivalence.

Types are PERs again.

Oh, here's ‚â° again --- this is really a recapitulation of Bob's
philosophical commitments after all, this is fine.

This is all just a logical relations argument for
canonicity/termination/consistency.

This is not the initial/syntactic model! You have principles like

M ‚áì true
--------
M ‚àà bool

for *any* crazy program M that just happens to evaluate to true.

degeneracies <-> weakening
diagonals <-> contraction
faces <-> substitution of constants for variables

Q: Is the *meaning* of one of the synthetic judgments extensional over
closed interval-valued things (i.e. enedpoints) or over open things as well?
I think it's open.
A: Right, yes, it is, because

A ‚â° B type [Œ®]

is the actual judgment, whereas Œì --- the assumptions for which we're
quantifying extensionally over closed thingies --- is to the left of
‚ü´.

Q: What's weirding me out about this setup more deeply than the untypedness?
A: The fact that since they lay down a chosen set of what terms are,
there's no concern about category-theoretic evil. Since everything's
PER-refinements of that set, there's nothing hard about demanding
exact equality of sets or terms or whatever.

Q: So you don't have to define glue types with *equivalences* like CCHM does?
A: ???

Q: Path satisfies weak J, can define Jdentity types somehow, how does this work?
A: ???

Q: What's the deal with Anders's talk?
A:
Making HITs compute.

Guillaume's number still fails to compute on a machine with 64G ram and 60 hours of compute...

Divide comp into hcomp (homogeneous --- do kan completion within a fiber)
and generalized transport (across fibers)

Q: What's the deal with ecavallo's talk?
A: HITs again, but this looks like it's treating how we actually
schematize description of HITs in general.

---

Q: What's favonia's talk about?
A: Multiverses.
example: voevodsky's HTS
example: 2-level system (the two levels are non-fibrant and fibrant types)

for instance we can consider

pre <--- kan

because every kan fibration is surely also a pretype
but also if we think of (cumulative) universe levels, then we'd have

pre0 <--- kan0
 |         |
 v         v
pre1 <--- kan1
...       ...

with these arrows indicating both membership (kan0 *is a* type coded
in kan1) and also subsethood (every kan0 is a kan1 by cumulativity,
and every kan_n is a pre_n)

minimum thing we need out of our 'kind algebra' is that it's a meet-semilattice

because we need to show that ‚àß k_i ‚â§ khat and min(‚Ñì_i) ‚â§ lhat then
A ‚àà U^{k_1}_{‚Ñì_1} , ... , A ‚àà U^{k_n}_{‚Ñì_n} ‚ü´ A ‚àà U^khat

Q: What's the deal with jon sterling's talk?
A: The main thing I'm wondering about is that if the operational
semantics is sensitive to dimension-apartness (which they deal with
with a 'nominal abstract machine') which is to say that it's not
compatible with arbitrary *substitution* of dimensions for dimensions,
then how is it compatible with diagonals? Is there some substructural
stuff happening?

---

Q: What alternatives do I have to the sad situation where, when define
a pair of modal levels that are both nonsubstructural, I seem to be pressured
into talking about weakening and contraction explicitly?
A:
Let me first depict the `sad situation' precisely.

I have two modal levels H and L, so I have worlds Œ±H and Œ±L and frames œÜH and œÜL.
I have * and ‚ä∏ at both levels.
I say things like contraction:
    Œ±H * Œ±H ‚â§ Œ±H and Œ±L * Œ±L ‚â§ Œ±L
and weakening
    Œ±H ‚â§ Œ±H * Œ≤H and Œ±L ‚â§ Œ±L * Œ≤L

The alternative is some version of
'Focused Linear Semantics of Modal Logic'
except adjoint-logic-ized, I guess?

‚ÜìN @ Œ±
‚ÜëP

Q: Are polycategories relevant to relation meshes?
A: Mmmmaybe? But they do have two sets of endpoints, not one.

Q: What else is the circuit application a good example of?
A: A situation when I want F and not U, which justifies perhaps having
an F in worlds the mode theory, but leaving out the corresponding U on frames.

=== 2018.03.24

Q: What was the old story about polarizing kripke worlds?
A:
I think what would otherwise be Œ± ‚ñπ œÜ is instead something
I want to think about as
Œ± ~ Œ≤ ‚Üí #(œÜ)
where the erstwhile Œ±-data is just Œ± and the erstwhile œÜ-data is (Œ≤, œÜ)

Actually since I have ‚ñπ at different modes, what it's really going to
be is different things like
    Œ± ~v Œ≤ ‚Üí #(œÜ)
    Œ± ~t Œ≤ ‚Üí #(œÜ)

so
Œì ‚ä¢ [P]
goes to
Œì @ Œ±s ‚ä¢ P @ Œ±

Œì [N] ‚ä¢ Q
goes to
Œì @ Œ±s, Q @ (Œ≤', œÜ') ‚ä¢ N @ (Œ≤, œÜ)

Œì ‚ä¢ Q true
goes to
Œì @ Œ±s, Q @ (Œ≤, œÜ), Œ± ~t Œ≤ ‚ä¢ #(œÜ)

Œì ‚ä¢ Q valid
goes to
Œì @ Œ±s, Q @ (Œ≤, œÜ), Œ± ~v Œ≤ ‚ä¢ #(œÜ)

Under what circumstances can I prove ‚ñ°N ‚ä¢ N?
Polarized, that's trying to prove

¬∑ ‚ä¢ [‚Üì(F‚ÜìUN ‚ä∏ N)]

so we make up a fresh Œ±, and try to prove the progressivley refined sequence of goals

¬∑ ‚ä¢ ‚Üì(F‚ÜìUN ‚ä∏ N) @ Œ±
F‚ÜìUN ‚ä∏ N @ (Œ≤, œÜ), Œ± ~t Œ≤ ‚ä¢ #(œÜ)
F‚ÜìUN @ Œ≤, N @ (Œ≤, œÜ), Œ± ~t Œ≤ ‚ä¢ #(œÜ)

oh wait so I need to reuse the Œ≤-worlds as Œ±-worlds to unpack ‚ä∏! Ok.

‚ÜìUN @ Œ≤, N @ (Œ≤, œÜ), Œ± ~t Œ≤ ‚ä¢ #(œÜ)

‚ÜìUN @ Œ≤ at valid is ‚àÄ(Œ≥, œÜ). N @ (Œ≥, œÜ) ‚Üí Œ≤ ~v Œ≥ ‚Üí #(œÜ)

our choice of œÜ is forced; we have to pick a Œ≥ such that a ~t Œ≤ ‚ä¢ Œ≤ ~v Œ≥.
But we also have to pick the Œ≥ such that N @ (Œ≤, œÜ) ‚ä¢ N @ (Œ≥, œÜ).
So picking Œ≥ = Œ≤ works fine, as long as ~v is reflexive.

How about ‚ñ°N ‚ä¢ ‚ñ°‚ñ°N?

‚ÜëP @ (Œ≤, œÜ) = ‚àÄŒ± . P @ Œ± ‚Üí Œ± ~ Œ≤ ‚Üí #(œÜ)
‚ÜìN @ Œ±      = ‚àÄ(Œ≤,œÜ) . N @ (Œ≤,œÜ) ‚Üí Œ± ~ Œ≤ ‚Üí #(œÜ)

¬∑ ‚ä¢ [‚Üë(F‚ÜìUN ‚ä∏ ‚ÜëF‚ÜìU‚ÜëF‚ÜìUN)]
¬∑ ‚ä¢ ‚Üë(F‚ÜìUN ‚ä∏ ‚ÜëF‚ÜìU‚ÜëF‚ÜìUN) @ Œ±0
(F‚ÜìUN ‚ä∏ ‚ÜëF‚ÜìU‚ÜëF‚ÜìUN) @ (Œ≤1, œÜ1), Œ±0 ~ Œ≤1 ‚ä¢ #(œÜ1)
(F‚ÜìUN) @ Œ≤1, (‚ÜëF‚ÜìU‚ÜëF‚ÜìUN) @ (Œ≤1, œÜ1), Œ±0 ~ Œ≤1 ‚ä¢ #(œÜ1)
[choose Œ± = Œ±0]
(F‚ÜìUN) @ Œ≤1, Œ±0 ~ Œ≤1 ‚ä¢ F‚ÜìU‚ÜëF‚ÜìUN @ Œ±0
(F‚ÜìUN) @ Œ≤1, Œ±0 ~ Œ≤1 ‚ä¢ ‚ÜìU‚ÜëF‚ÜìUN @ Œ±0
Œ≤2, œÜ2, (F‚ÜìUN) @ Œ≤1, Œ±0 ~ Œ≤1, Œ±0 ~v Œ≤2, (U‚ÜëF‚ÜìUN) @ (Œ≤2, œÜ2) ‚ä¢ ...
BAH

this is too fiddly. time to break out the agda.

---

Q: What's the deal with the last talk of the day?
A: Suppose we have a modality I with unit Œ∑ : {A : Set} ‚Üí A ‚Üí I A.

Then the 'formal disc' at a point, sort of like the tangent space at a point, is

D : A ‚Üí Set
D a = (x : A) √ó (Œ∑ x ‚â° Œ∑ a)

The tangent bundle is the total space

T : Set ‚Üí Set
T A = (a : A) √ó D a

Notice that for any f : A ‚Üí B there is an induced map

diff : (f : A ‚Üí B) (a : A) ‚Üí D a ‚Üí D (f a)
diff f a (x , path : Œ∑ x ‚â° Œ∑ a) ‚Üí (f x , ? : Œ∑ (f x) ‚â° Œ∑ (f a))

that implication from Œ∑ x ‚â° Œ∑ a ‚Üíto‚Üí Œ∑ (f x) ‚â° Œ∑ (f a) seems slightly
nonobvious and must be something that uses elimination in book-HoTT
modalities or something.

Nope I'm wrong! It's just naturality of Œ∑!
Œ∑ (f x) ‚â° f (Œ∑ x) ‚â° f (Œ∑ a) ‚â° Œ∑ (f a)
Lovely.

f : X ‚Üí Y is formally etale if the naturality square for the modality

X - f -‚Üí Y
|        |
Œ∑        Œ∑
v        v
IX -If‚Üí IY

happens to be a pullback.

Examples:
- Equivalences
- Inclusions of formal discs D a ‚Ü™ A

etale means something like 'local diffeomorphisms'

if f etale then (x : A) ‚Üí diff x is an equivalence
the converse doesn't quite obtain unless 'the modality has surjective unit' he said, I think?

Suppose V is homogeneous.
The M is a V-manifold if there is a formally etale span

  U
 / \
v   v
V   M

V plays the role of R^n --- homogeneity is getting across the triviality of the tangent spaces
U plays the role of the big coproduct of all your open sets in your chart
M plays the role of the manifold itself

the etaleness of the morphisms in the span explain how M is locally like parts of R^n

thm: the tangent space of a V-manifold a (V √ó D e)-manifold
(e is a basepoint of V coming from homogeneity)

=== 2018.03.25

Q: What did I get from Guillaume's talk?
A:
steve awodey mentioning something about ‚àû-relations as opposed to category?
due to Egbert Rijke?
'methodology of contractible contexts' to sort of get definitional equalities?

Q: Can I think of orientability like
<<<
open import HoTT

postulate
 I : Set ‚Üí Set
 Œ∑ : {A : Set} ‚Üí A ‚Üí I A

z = S¬π

disc : {A : Set} ‚Üí A ‚Üí Set
disc {A} a = Œ£ A (Œª a' ‚Üí Œ∑ a == Œ∑ a')

spins : Set ‚Üí Set
spins A = (s : S¬π) (a : A) ‚Üí disc a ‚Üí disc a
>>>
?
A: ???

Q: What's good about directly describing these semantics as
bisimplicial/bicubical rather than staging it as a merely simplicial/cubical
explanation whose destination is a type theory with univalence or something?
A: ???

=== 2018.03.27

Q: What's a passing thought I had about the meaning of the synthetic
differential geometry stuff?
A:
So when I talk about A and IA and such, one way to think about it is
that the type A 'already contained' the bare points of A and also all
the tangent vectors at the points of A. In this way, IA is just sort
of a Œ£-type-like first projection from the pair
 (point of a, tangent vector at a)
to the raw point of a.

If I think this way, it's almost as if IA is the more 'real' type, but
certainly that can't be entirely correct, as I can continue hitting
the type with I repeatedly. Right? Just because I's a monad and IIA
and IA have morphisms going back and forth doesn't mean they're
isomorphic necessarily. No, I'm wrong --- at least vis-a-vis section
7.7 of the hott book --- the intended definition of a `modality' is
idempotent.

=== 2018.03.30

Q: What really is the deal with an equality between types in a context containing a path variable?
Univalence tells me it's
A: ???

Q: What *could* a diagonal-having cube category mean for relationy things?
A:
I stare at

Œì, x : #, y : # ‚ä¢ M : A
-----------------------
Œì, z : # ‚ä¢ [z/x][z/y]M : [z/x][z/y]A

and I think of the special case

Œì, x : #, y : # ‚ä¢ t : U
-----------------------
Œì, z : # ‚ä¢ [z/x][z/y]t : U

and recall the intent that for sure the bottom line is the same as the choice of n types
and a relation among them, and the top line is something like the choice of n^2 types
and some relations among them, so contraction would require the existence
of some reasonable operation on relations.

Q: Where's the computation I did to feel out what a point in the universe in a context
with two interval variables should look like, concluding that it was a
commutative square after all?
A:
texnotes//2018-02-09.ltx section 1.5

Q: What's notable about that?
A: I am using the #-elim/exchange/Œ¶ principle as given by B-M, so
maybe it has to go out the window if I'm to do anything
nonsubstructural.

=== 2018.03.30

Q: what commit did I have agda-lib at?
A: was 659857f, I think because of circuit stuff, now 9b67f6b1e, which seems ok with agda 2.5.3.

Q: How do I write simple haskell-style code in agda?
A:
<<<
module StringDump where

open import Data.String
open import Data.Unit.Base
open import Agda.Builtin.IO

{-# FOREIGN GHC import qualified Data.Text.IO #-}

postulate
  putStr : String ‚Üí IO ‚ä§
  getLine : IO String
  return : {A : Set} ‚Üí A ‚Üí (IO A)
  _>>=_  : {A B : Set} ‚Üí (IO A) ‚Üí (A ‚Üí (IO B)) ‚Üí (IO B)

{-# COMPILE GHC putStr = Data.Text.IO.putStr #-}
{-# COMPILE GHC _>>=_ = (\ _ _ a f -> a >>= f) #-}
{-# COMPILE GHC return = (\ _ a -> return a) #-}
{-# COMPILE GHC getLine = Data.Text.IO.getLine #-}

main : IO ‚ä§
main = getLine >>= (Œª line ‚Üí putStr line)
>>>
in a directory src a level up from which I have deb.agda-lib containing
<<<
name: deb  -- Comment
depend:
  standard-library
include:
  src
>>>
and then I do
$ agda --compile src/StringDump.agda

Q: Where's a good source of ideas to crib from?
A:
https://github.com/guillaumebrunerie/SmashProduct/blob/master/SmashGenerate.agda

Q: Where's a reflection prelude that does some instances for showing things as strings?
A: https://github.com/UlfNorell/agda-prelude/blob/master/src/Builtin/Reflection.agda
found on
https://stackoverflow.com/questions/36209339/haskell-deriving-mechanism-for-agda

Q: What was an interesting couple of PHOAS-y ekmett posts that I still
couldn't figure out how to implement in agda?
A:
https://www.schoolofhaskell.com/user/edwardk/phoas
https://www.schoolofhaskell.com/user/edwardk/bound
I got as far as
<<<
data ExpF : Set ‚Üí Set ‚Üí Set where
   App : {a b : Set} ‚Üí b ‚Üí b ‚Üí ExpF a b
   Lam : {a b : Set} ‚Üí (a ‚Üí b) ‚Üí ExpF a b

record Profunctor {‚Ñì} (p : Set ‚Ñì ‚Üí Set ‚Ñì ‚Üí Set ‚Ñì) : Set (lsuc ‚Ñì) where
  field
    dimap : {a b c d : Set ‚Ñì} ‚Üí (a ‚Üí b) ‚Üí (c ‚Üí d) ‚Üí p b c ‚Üí p a d

instance
  ExpFProfunctor : Profunctor ExpF
  ExpFProfunctor = record { dimap = dimap } where
    dimap : {a b c d : Set} ‚Üí (a ‚Üí b) ‚Üí (c ‚Üí d) ‚Üí ExpF b c ‚Üí ExpF a d
    dimap f g (App e1 e2) = App (g e1) (g e2)
    dimap f g (Lam e) = Lam Œª x ‚Üí g (e (f x))

data Rec (p : Set ‚Üí Set ‚Üí Set) {{_ : Profunctor p}} : Set ‚Üí Set ‚Üí Set where
  Place : {a b : Set} ‚Üí b ‚Üí Rec p a b
  Roll : {a b : Set} ‚Üí p a (Rec p a b) ‚Üí Rec p a b
>>>
but agda's positivity checker still didn't like the occurrence of Rec in Roll.

=== 2018.03.31

Q: Does it make sense to say
‚óè A = Œ£ (‚ñ° ‚Ñï) (Œª n ‚Üí Vec (unbox n) ùïì ‚Üí Vec (unbox n) ùïì √ó A)
A:
The obstacle that I need to overcome is getting from something like

A ‚Üí ‚ñ°B

to

B

which I just don't think I can do, at least not without substantial
changes to my assumptions. Even if the modality guarantees me that the
function is invariant to different As, I don't know that A isn't ‚ä•!

Q: What kind of mileage can I get out of thinking of substructural types
as not living in Set, but rather in P ‚Üí Set or N ‚Üí Set according to their polarity,
as concerns specifically the mysterious linearity violations in my proof that
witness types + #-elim ‚üπ maps from the interval into the universe are relations?
A: ???

=== 2018.04.09

Q: Actually, I'm being kind of dumb not demanding injectivity of automorphisms of
tangent spaces. How would I do that?
A: Like so:
<<<
{-# OPTIONS --without-K --rewriting #-}

module a where

open import HoTT hiding ( O )

postulate
  I : Set ‚Üí Set
  Œ∑ : {A : Set} ‚Üí A ‚Üí I A
  ind : {A : Set} {B : I A ‚Üí Set} ‚Üí ((a : A) ‚Üí I (B(Œ∑ a))) ‚Üí (z : I A) ‚Üí I (B z)

  I-Œ≤ : {A : Set} {B : I A ‚Üí Set} {f : ((a : A) ‚Üí I (B(Œ∑ a)))} (a : A) ‚Üí
    ind {A} {B} f (Œ∑ a) ‚Ü¶ f a
  {-# REWRITE I-Œ≤ #-}

ùîª : {A : Set} (a : A) ‚Üí Set
ùîª {A} a = Œ£ A (Œª b ‚Üí Œ∑ a == Œ∑ b)

O : {A : Set} (a : A) ‚Üí ùîª a
O {A} a = a , idp

isO : {A : Set} {a : A} ‚Üí ùîª a ‚Üí Set
isO {A} {a} d = d == O a

swirl : {A : Set} (a : A) ‚Üí Set
swirl {A} a = Œ£ (ùîª a ‚Üí ùîª a) (Œª f ‚Üí (x : ùîª a) ‚Üí isO x ‚âÉ isO (f x))
>>>

=== 2018.04.10

Q: Is there a way I can cleverly pick ‚Ñô and ‚Ñï so that the presheafesque semantics
of focused logic turns into the straightforward presheaf semantics on a given ‚ÑÇ?
A: Somehow I keep thinking I ought to be able to pick
    ‚Ñô = ‚ÑÇ and
    ‚Ñï = ‚ÑÇ √ó ùîΩ
for some category ùîΩ of frames that's sufficiently `abstract', but
I don't know what I mean by that.

=== 2018.04.16

Q: So if the dogma is 'different kinds of types go with different judgments',
what is the judgment that corresponds to propositions/types/spaces that have
relational structure?
A:
The simplest, non-nested baby version of Bernardy-Moulin is observing
that, since any presheaf category has all the good stuff to be a topos,
we might as well consider types *over* the arrow category * ‚Üí * .

So let's say an 'atype' is a thing that's a "functor (* ‚Üí *) ‚Üí type".
We don't really have any such object as * ‚Üí * living in our type
system as a type (or an atype!) but we can explicitly formalize what
it means to be such a functor: a choice of two types and a map from
one to the other.

We know that we can interpret and derive things of the form

Œì, x : atype ‚ä¢ B : atype
-----------------------
Œì ‚ä¢ (x : A) ‚Üí B : atype

and

Œì ‚ä¢ A : atype
Œì, x : atype ‚ä¢ B : atype     Œì, x : A ‚ä¢ M : B
---------------------------------------------
Œì ‚ä¢ Œªx.M : (x : A) ‚Üí B

because the presheaf category is lccc, for instance. But this is all
fine when *everything* in sight is an atype. I think the critical
question is: what does it mean to have atype and type judgments in the
same sequent?

=== 2018.04.18

Q: How does the push ‚ä£ pull adjunction play out when I have ‚ôØ types around?
A:
push goes from R[g] to R[gf]
supposing f : A ‚Üí B and g : B ‚Üí C
a function k : ‚ôØB ‚Üí C such that k ‚àò Œ∑_B = g
to a function (push_f k) : ‚ôØA ‚Üí C such that push_f k ‚àò Œ∑_A = g ‚àò f
and the way I obtain this is actually using functoriality
    push_f k = k ‚àò ‚ôØ(f)
so that
    push_f k ‚àò Œ∑_A = k ‚àò ‚ôØ(f) ‚àò Œ∑_A = k ‚àò Œ∑_B ‚àò f = g ‚àò f
so then pull must from R[gf] to R[g]
takes a function
  ‚Ñì : ‚ôØA ‚Üí C
s.t.
  ‚Ñì ‚àò Œ∑_A = g ‚àò f
yields a function
  pull ‚Ñì : ‚ôØB ‚Üí C
s.t.
  pull ‚Ñì ‚àò Œ∑_B = g
I could also express this as
  pull ‚Ñì ‚àò Œ∑_B ‚àò f = ‚Ñì ‚àò Œ∑_A
or
  pull ‚Ñì ‚àò #(f) ‚àò Œ∑_A = ‚Ñì ‚àò Œ∑_A
which means
  push (pull ‚Ñì) ‚àò Œ∑_A = ‚Ñì ‚àò Œ∑_A
even though I don't expect
  push (pull ‚Ñì) = ‚Ñì
but merely some sort of inequality
  push (pull ‚Ñì) ‚â§ ‚Ñì

=== 2018.04.19

Q: What's the first thought I had about cohesion and span categories?
A: A trivial version of Kripke-like thinking goes like so, for
explaining what ‚ô≠ means:

We aim to have two levels of types, high and low.

A *low type* is a type that varies over the type Œ© of worlds œâ. A
'varying' type. A trivial presheaf, because the base category is just
a set.

A *high* type is just a type.

  high = type
  low = Œ© ‚Üí type

The logical connective F takes a type to the non-varying varying type.
  F : high ‚Üí low
  F X œâ = X

The logical connective U takes a varying type to its Pi.
  U : low ‚Üí high
  U Y = (œâ : Œ©) ‚Üí Y œâ

If the morphisms of 'high' are functions, and the morphisms Y1 ‚Üí Y2 of
'low' are natural transformations (œâ : Œ©) ‚Üí Y1 œâ ‚Üí Y2 œâ (with no
naturality requirement since Œ© is a set) then we can check that F ‚ä£ U.

We can also do a dual thing that seems to be towards explaining ‚ôØ, by setting

  high = Œ© ‚Üí type
  low = type

  F : high ‚Üí low
  F X = (œâ : Œ©) √ó X

  U : low ‚Üí high
  U Y œâ = Y

But the problem with both of these as explanations of ‚ô≠ and ‚ôØ is that they aren't
idempotent! We pick up an `extra factor' of Œ© on the round-trip of even a low-type
that *is* a constant function.

Q: So then what?
A:
I could try to think of Œ© as a *pointed* set, with a canonical world œâ‚ÇÄ.
Instead of quantifying over all worlds, U just instantiates at the canonical one.

  high = type
  low = Œ© ‚Üí type

  F : high ‚Üí low
  F X œâ = X

  U : low ‚Üí high
  U Y = Y œâ‚ÇÄ

But the problem here is that F and U are no longer adjoint.
A morphism X ‚ä¢ U Y is
X ‚Üí Y œâ‚ÇÄ
but a morphism F X ‚ä¢ Y is
(œâ : Œ©) ‚Üí X ‚Üí Y œâ
so we'd need a way of getting from œâ‚ÇÄ to an arbitrary œâ.

Q: So then what?
A: Maybe put exactly that in! Œ© needs morphisms from œâ‚ÇÄ to whatever, and
low types are functors out of Œ©. Generally, suppose ‚ÑÇ is a category with initial object 0.

  high = type
  low = ‚ÑÇat(‚ÑÇ, type)

  -- constant functor returning X
  F : high ‚Üí low
  F X c = X
  F X (m : c ‚Üí d) = id_X

  U : low ‚Üí high
  U Y = Y 0

Now a morphism X ‚ä¢ U Y is
X ‚Üí Y 0
but a morphism F X ‚ä¢ Y is a *natural transformation*
(c : ‚ÑÇ) ‚Üí X ‚Üí Y c
and these ought to be equivalent!

And this adjunction is idempotent!
If I start with an arbitrary functor Y ‚àà ‚ÑÇat(‚ÑÇ, type), and
compute FU of it, I get the constant functor returning Y 0.
If I hit it with FU again, I get Y 0 again.

Q: Any mysterious problems with this?
A: Yes, although it appears that (correctly) you can't semantically have
Y ‚ä¢ FUY
because that would require a natural transformation
(c : ‚ÑÇ) ‚Üí Y c ‚Üí F (U Y) c
= (c : ‚ÑÇ) ‚Üí Y c ‚Üí F (Y 0) c
= (c : ‚ÑÇ) ‚Üí Y c ‚Üí Y 0
it does look like you can semantically realize
UFX ‚Üí X
= F X 0 ‚Üí X
= X ‚Üí X

Q: Can I dualize?
A: Let's try this: suppose ‚ÑÇ has a terminal object.

  high = ‚ÑÇat(‚ÑÇ, type)
  low = type

  -- constant functor returning X
  F : high ‚Üí low
  F X = X 1

  U : low ‚Üí high
  U Y c = Y
  U Y (m : c ‚Üí d) = id_Y

=== 2018.04.22

Q: What's a pleasant thought I just had?
A: Suppose I have a f : ‚ôØ2 ‚Üí X. Let 2 = {c, d}.
I know f is functional whenever `restricting f to the ‚ôØ1-shaped part of its domain at d'
(by composing with ‚ôØd : ‚ôØ1 ‚Üí ‚ôØ2) yields a constant function.
I know f is cofunctional whenever `restricting f to the ‚ôØ1-shaped part of its domain at c'
(by composing with ‚ôØc : ‚ôØ1 ‚Üí ‚ôØ2) yields a constant function.

Q: So what's the relationship between these and equality?
A: If f is functional and cofunctional, then f is a path --- that is, f is constant.
So what's really going on is that somehow ‚ôØd and ‚ôØc *cover* ‚ôØ2.

=== 2018.04.28

Q: What's the promising set of thoughts I had this morning?
A:
The things that are special about the simplex category from the point of view
of categorical composition is that

 - each object of it arises as a 'composable situation', a sequence of n composable morphisms

 - the internal structure that we intend for it as 'designers' of the
 simplex category --- even though as an abstract category that
 internal structure is not directly visible, but only visible through
 the available morphisms --- is that it contains *all possible
 compositions* of the composable morphisms.

 - the morphisms in the simplex category give us a way of probing this
 structure. We can map one simplex A into another B in as many ways as
 we can map the 'raw stuff' of A into the 'derived stuff' of B, so
 it's sort of a kleisli map.

This gives me some hope I can repeat this picture for mesh-like
instead of categorical things.

Q: What does that start to look like?
A: A 'composable situation' might be simply a map f : A ‚Üí B between
two finite sets, indicating that we have B distinct hyperedges, each
of whose arity is given by inverse image under f. What we can do to these
edges is copair some group of them together (maybe with repeated multiplicity?)
then do a pull, then do a push.

Q: What's missing from this description?
A: I should only be able to do pulls when the endpoints actually match up, hmm.

Q: What's a separate thought about modalities that seems nice?
A: I do expect that there's a ‚ôØ-like modality that freely 'fills out'
all the composites (i.e. copairs and pulls) of a given premesh. But I
also could ask for a ‚ô≠-like modality that *restricts* to only the
cells that are functional ‚ôØ2-paths. In which case the types ‚ÑÇ such
that ‚ÑÇ ‚â° ‚ôØ‚ô≠‚ÑÇ would be exactly the types that look like categories ---
those that one the one hand *do have* all copairs and pulls (because
they're in the image of ‚ôØ) but also ones for which their pulls and copairs
are *entirely determined* by just the functional ‚ôØ2-paths of ‚ÑÇ.

Q: Ok, so I'm trying to write down this simplex-like category. When did I effectively already do this?
A:
There's one idea in
  texnotes/2017-10-28.ltx
  texnotes/2017-11-01.ltx
that involves big pullback-y diagrams, and another in
  https://twitter.com/jcreed/status/966065395164680192
from february 20 2018, which I'm pretty sure is talking about
  agda/BaseCategory.agda
and at least
  texnotes/2017-02-20.ltx
which definitely mentions that agda file.

Q: In git, how did I find which files were modified in a certain date range?
A:
$ git diff --name-only "@{2018-02-15}" "@{2018-02-21}"
