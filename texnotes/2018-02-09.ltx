\documentclass{article}
\input{theorem}
\input{prooftree}
\usepackage{stmaryrd}
\usepackage{latexsym}
\usepackage{yfonts}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,cd,decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}
\usepackage{tcolorbox}
\tcbuselibrary{breakable}

\def\quote#1{{\ulcorner {#1} \urcorner}}
\def\U{\mathcal{U}}
\def\mor#1#2{#1 \to \underline{#2}}

\def\ridp{\mathsf{idp}}
\def\fc{\mathfrak{C}}
\def\ff{\mathfrak{F}}
\def\ssem#1{\langle\!\langle{#1}\rangle\!\rangle}

\definecolor{cyan}{rgb}{0.80,0.95,0.95}
\definecolor{orange}{rgb}{0.95,0.90,0.80}
\definecolor{lred}{rgb}{0.95,0.8,0.8}
\definecolor{lgray}{gray}{0.9}
\newtcolorbox{declbox}{colframe=lred,colback=lred,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{thmbox}{colframe=cyan,colback=cyan,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{defnbox}{colframe=orange,colback=orange,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{tangentbox}{colframe=lgray,colback=lgray,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}

\input{linear}
\def\rpath#1{[#1]}
\def\rfst{\mathsf{fst}\,}
\def\rsnd{\mathsf{snd}\,}
\def\bunfold{\mathbf{unfold}}
\def\bfold{\mathbf{fold}}
\def\susp#1{\langle {#1} \rangle}
\def\ssusp#1{\langle\!\langle {#1} \rangle\!\rangle}
\def\dto{\mathrel{\dot\to}}
\def\dns{{\downarrow}}
\def\ups{{\uparrow}}
\def\sprov{\Vdash}
\def\signat{{\color{red}\Sigma}}

\def\wat{\mathbin{@}}
\def\wwat{\mathbin{\underline\wat}}
\def\cn{{:}}
\def\dv{{\div}}
\def\ww{{\mathsf w}}
\def\base{{\textfrak b}}

\def\N{{\mathbb N}}
\def\munit{I}
\def\tt{{\mathsf t}}
\def\rr{{\mathsf r}}
\def\ii{{\mathbb I}}
\def\pp{\textsf{\textbf p}}
\def\nn{{\mathsf n}}
\def\PP{\textsf{\textbf P}}
\def\NN{{\mathsf N}}
\def\zz{{\mathsf z}}
\def\sem#1{[\![#1]\!]}
\def\usem#1{\lceil\!\!\lceil{#1}\rceil\!\!\rceil}
\def\zem#1{\langle\!\langle#1\rangle\!\rangle}
\def\col#1{{\mathsf{C}}_{#1}}
\def\lax{\mathop\bigcirc}
\def\rjust{\mathsf{just}}
\def\rcvt{\mathsf{cvt}}
\def\rtype{\mathsf{type}}
\def\rkind{\mathsf{kind}}
\def\rmode{\mathsf{mode}}
\def\rprel{\mathbf{Prel}}
\def\rrfam{\mathbf{Rfam}}
\def\rset{\mathbf{Set}}
\def\rfinset{\mathbf{FinSet}}
\def\rrel{\mathbf{Rel}}
\def\rcat{\mathbf{Cat}}
\def\rfam{\mathbf{Fam}}
\def\binj{\mathbf{inj}}
\def\rid{\mathsf{id}}
\def\rtrue{\mathrel\mathrm{true}}
\def\pbck{\ar[dr, phantom, pos=0, "\lrcorner"]}
\def\bpbck{\ar[ddrr, phantom, pos=0, "\lrcorner"]}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\btwo{\mathbf{2}}
\def\bone{\mathbf{1}}

\newarrow {Equiv} =====
\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\def\mapt{\ar[ddd,mapsto,shorten <=2em, shorten >=2em]}
\def\frommaps{\ar[from=uu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\frommapt{\ar[from=uuu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\C{\mathbf{C}}
\def\S{\mathbf{S}}
\def\D{\mathbf{D}}
\def\E{\mathbf{E}}
\def\M{\mathbf{M}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\tri{\triangleright}
\def\o{\circ}
\def\rctx{\,\mathsf{ctx}}
\def\del{\partial}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\null{\emptyset}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\definecolor{fib}{HTML}{ff7f00}
\definecolor{green}{HTML}{007f00}
\definecolor{red}{HTML}{df3f3f}
\definecolor{opfib}{HTML}{007fff}

% For lightening colors I used
% http://trycolors.com/ 6 parts white to 1 part color
\definecolor{opfibl}{HTML}{DBEDFF}
\definecolor{greenl}{HTML}{DBEDDB}
\definecolor{redl}{HTML}{FAE4E4}
\def\njudge#1{\fcolorbox{opfib}{white}{#1}}
\def\nrule#1{\fcolorbox{white}{opfibl}{#1}}
\def\neqn#1{\fcolorbox{white}{redl}{#1}}



\def\judge#1{\vskip 2em\noindent \njudge{$#1$}\vskip 0.5em\noindent}
\def\rule#1{\vskip 2em \noindent \nrule{$#1$}\vskip 0.5em\noindent}
\def\eqn#1{\vskip 2em \noindent \neqn{$#1$}\vskip 0.5em\noindent}
\def\prof{\nrightarrow}
\def\tensor{\otimes}
\def\htensor{\mathrel{\hat\otimes}}
\def\lol{\multimap}
\def\hlol{\mathrel{\hat\multimap}}
\def\wtf{{\color{red}???}}

\def\re{\mathbf{E}}

\begin{document}

\def\
\tikzset{
   commutative diagrams/.cd,
   arrow style=tikz,
   diagrams={>=stealth}}
% got this from
% https://tex.stackexchange.com/questions/169512/tikz-style-arrow-tips-missing-when-using-tikz-cd-crossing-over
% ???

\section{Bernardy-Moulin's Semantics in my Own Words}

The category $\re_e$ has as objects finite sets and for morphisms has
injections `with exceptions' drawn from the set $e$. That is, a
morphism $n \to m$ is a function $f : n \to m + e$ that is injective
as far as the $m$-part of the domain is concerned; if
$f(n_1) = f(n_2) = \binl m_0$, for $n_1, n_2 < n$
and $m_0 < m$, then $n_1 = n_2$.

The usual notion of cubical set (disallowing diagonals) is an object of $\rset^{\re_2^\op}$.
I might depict the objects $1, 2$ in $\re_2$ as
\[
\begin{tikzcd}
  \bullet\ar[r, "z"]&\bullet
\end{tikzcd}
\qquad
\begin{tikzcd}
  \bullet\ar[d, "y"']\ar[r, "x"]&\bullet\ar[d, "y"]\\
  \bullet\ar[r, "x"']&\bullet
\end{tikzcd}
\]

In which case the (degeneracy) morphisms $1 \to 2$ in $\re_2$ are
$z \mapsto (x, y, 0, 1)$, and the morphisms  $2 \to 1$
are $(x, y) \mapsto$
\[(z, 0) \quad (z, 1)\quad (0, z) \quad (1, z)\]
\[ (0, 0)\quad (0, 1) \quad (1, 0)\quad (1, 1) \]
The morphism $0 \to 1$ is $!$ and the morphisms $1 \to 0$ are $z \mapsto (0,1)$.

So a {\em cubical set} is a functor in $\rset^{\re_2}$. I could say
a {\em rayical set} is a copresheaf in $\rset^{\re_1}$.
Bernardy-Moulin talk about presheaves on $\re_1^\op$.

The yoneda embedding says that $\re_2^\op$ is the thing that embeds
faithfully in cubical sets. So there are two ways that the vertex $0$
embeds into the arrow $1$ because there are two morphisms $0 \to 1$ in
$\re_2^\op$. Ok, fine, everything lines up.

I want to give names to the two dual categories I might be dealing
with: there's the {\em abstract} or {\em interface} or {\em
  operational} side, in which there are two morphisms $1 \to 0$,
because there are two abstract operations $\dom$ and $\cod$. Then
there's the {\em concrete} or {\em implementation} side of the
duality, where each object actually {\em behaves} like the cubey
object, and there are two morphisms $0 \to 1$ because there are two
morphisms that I can visualize from $y0 \to y1$, namely, map the
vertex into the domain or codomain vertex. Which is $\re_2$? It's the
abstract one. Which one do we take functor category into sets of? The abstract one.
We take {\em presheaves} of the {\em concrete} one.

\subsection{Speculation About Mixing Arities}
So what happens if I want to consider a mixture of arities? To choose an object of $\re_1$
is to choose how many rays I want to have, and to choose an object of $\re_2$ is to choose
how many intervals I want to have. I'd like to be able to choose any number of both, and
also how many 0-pointed, 3-pointed, 4-pointed, etc. pseudointervals. Let me depict
`two intervals and one ray' and `one ray and two intervals':
\[
\begin{tikzcd}
&\bullet\ar[dl, "z"']\ar[dd, "y"', near start]\ar[rr, "x"]&&\bullet\ar[dd, "y"]\ar[dl, "z"']\\
  \ &&\ \\
&\bullet\ar[dl, "z"']\ar[rr, "x"', near start]&&\bullet\ar[dl, "z"]\\
\ &&\ %
\end{tikzcd}
\qquad
\begin{tikzcd}
&\bullet\ar[dl, "z"']\ar[dd, "y"', near start]\ar[rr, "x"]&&\bullet\ar[dd, "y"]\ar[dl, "z"']\\
  \ &&\ \\
&\ &&\ %
\end{tikzcd}
\]
Let's call these objects $x^2y^2z^1$ and $x^2y^1z^1$.
And for comparison, here's $x^2y^2z^2$:
\[
\begin{tikzcd}
&\bullet\ar[dl, "z"']\ar[dd, "y"', near start]\ar[rr, "x"]&&\bullet\ar[dd, "y"]\ar[dl, "z"']\\
  \bullet\ar[dd, "y"']\ar[rr, "x", near start, crossing over]&&\bullet\\
&\bullet\ar[dl, "z"']\ar[rr, "x"', near start]&&\bullet\ar[dl, "z"]\\
  \bullet\ar[rr, "x"']&&\bullet\ar[from=uu, "y", near start, crossing over]
\end{tikzcd}
\]

How many ways can a ray $w^1$ go concretely into $x^2y^2z^1$? It's going to be something like
a map $\{x, y, z\} \to w$. Can I map $x$, $y$ into $w$, though? Can I inject a ray into an interval?
Not sure yet. At the very least I certainly can do anything
of the form $x \mapsto (0,1), y \mapsto (0,1), z\mapsto w$.

How many ways can a ray $w^1$ go concretely into $x^2y^1z^1$? I can map $x$ into either $(0,1)$
and my remaining choice looks like picking $(y,z)\mapsto (0,w)$ versus $(w,0)$.

Okay, so if I have a variable of type $x^n$ I can map it to any value $0,\ldots,n-1$ for sure,
and also for sure I can map it to any $y^n$ --- but probably more generally I should be able
to map it to $y^m$ for some map either $n \to m$ or $m \to n$, not sure.

I think a ray should be able to concretely map into an interval, in at
least two different nontrivial ways; by situating it at either vertex.
This is in addition to the two trivial ways it can sit at those
vertices.

So when we abstractly map $x^2$ into $y^1$, we map $x$ to $y$, and pick a function
{\em contra}variantly, I guess, from $1$ to $2$. This means that there is a way of
mapping $y^1$ to $x^2$, also, using the unique map $2 \to 1$.

What's my category, then? The objects are functions between finite sets $f : A \to B$.
For example, $x^2y^2z^1$ is the map $\{x_0,x_1,y_0,y_1,z_0\} \to \{x, y, z\}$.
An (abstract-direction) morphism from $f : A \to B$ to $g : C \to D$ is we have to map
$B$ to something like the sum of $A$ and... $D$?

No, let me write down the earlier thing concretely. An object is a
finite set $X$ and a map $f : X \to \rfinset$. An (abstract) morphism
$(X, f) \to (Y, g)$ is a map from each element $x\in X$ to either $f(x)$ or
$(y \in Y) \x (g(y) \to f(x))$. Oho, that lets me define an operation $Y^+$ that takes
$(Y, g)$ to $(Y + 1, g + (\star \mapsto 1))$, and then a morphism
$(X, f) \to (Y, g)$ is a map $(x : X) \to (y : Y^+) \x g(y) \to f(x)$.

Right, good, let me rephrase this in terms of fibers, then. My category has objects
$f : A \to B$. There's the evident exception-monad map operation $f^+ : A+ 1 \to B + 1$.
A morphism $f \to g$ is map
\[ (x : \cod f) \to (y : \cod g^+) \x (g^+)^*(y) \to f^*(x) \]
or like logically
\[ \forall x : \cod f . \exists y : \cod g^+ . \forall \_ : g^+ . \exists \_ :  f^*(x) \]
or maybe I should demand (what I think is a stronger, more coherent proposition)
\[
\begin{tikzcd}
  A\ar[from=d]\ar[r, "f"]& B\ar[d]\\
C+1 \ar[r, "g+1"'] &D+1
\end{tikzcd}
\]
No, this isn't right; it doesn't allow different things in $B$ to line
up with different things in $A$. Probably want to demand a $\beta, \gamma$
that make
\[
\begin{tikzcd}
  A\ar[from=d, "\gamma"]\ar[dr, "f"]\\
  \bullet\ar[d]\pbck\ar[r]& B\ar[d, "\beta"]\\
C+1 \ar[r, "g+1"'] &D+1
\end{tikzcd}
\]
commute.

Okay, a unary relation in a type $X$ looks like
\[\begin{tikzpicture}
\node at (0,0){
\begin{tikzcd}
    \bullet\ar[r, "x"]&\ %
\end{tikzcd}
};
\node at (2.5,0){$\to$};

\begin{scope}[shift={(5,0)}]
  \node(aa) at (.2,1){};
  \node(bb) at (1,0){};
  \node(cc) at (.5,-1){};
  \node(dd) at (-1,0){};
  \fill [opfibl] plot [smooth cycle, tension=1] coordinates { (cc)   (bb)   (aa)   (dd) };
  \draw [opfib] plot [smooth cycle, tension=1] coordinates { (cc)   (bb)   (aa)   (dd) };
  \node [opfib] at (0,0){$X$};
\end{scope}
\end{tikzpicture}\]
and a binary relation looks like
\[\begin{tikzpicture}
\node at (0,0){
\begin{tikzcd}
    \bullet\ar[r, "x"]&\bullet %
\end{tikzcd}
};
\node at (2.5,0){$\to$};

\begin{scope}[shift={(5,0)}]
  \node(aa) at (.2,1){};
  \node(bb) at (1,0){};
  \node(cc) at (.5,-1){};
  \node(dd) at (-1,0){};
  \fill [opfibl] plot [smooth cycle, tension=1] coordinates { (cc)   (bb)   (aa)   (dd) };
  \draw [opfib] plot [smooth cycle, tension=1] coordinates { (cc)   (bb)   (aa)   (dd) };
  \node [opfib] at (0,0){$X$};
\end{scope}
\end{tikzpicture}\]

So what are `push'-like operations? I know it's a pull when I start with the canonical nullary
relation into $X$ and get a unary relation, so I guess it has to be a pull when I go from
binary to unary. So it's a push when I go from unary to binary along the diagonal. Right?
There's a canonical $2 \to 1$ so a canonical $\sharp 2 \to \sharp 1$ and mere composition
is push, I think. So it should take me from unary to binary. So there should be a canonical
concrete map from $x^2$ to $x^1$, so a canonical abstract map from $x^1$ to $x^2$, so a canonical
map $2 \to 1$. I think that's right, now.

Right, I was thinking that push couldn't possibly impose an equality via
\[\mathsf{push}_{\delta : A \to A \x A} R : A \x A \to \rset = \{ (a, b) \st a = b \land Ra \}\]
And that a pull taking $R : A \x A \to \rset$ and forming
\[\mathsf{pull}_{\delta : A \to A \x A} R: \{ a \st Raa \}\]
is `simpler' but if I think about table rows, the push is the one simply
renaming the tuple $(a)$ to $(a, a)$ and the pull is the one filtering by equality.

\subsection{Found a Problem}

This pullback definition doesn't make sense when I try to think about an abstract map
\[x^2y^2 \to z^4\]
which would correspond to a concrete map
\[\sharp 4 \to \sharp 2 \otimes \sharp 2\]
which would allow me to convert maps
\[(\sharp 2 \otimes \sharp 2 \to X) \to (\sharp 4 \to X)\]
which combined with
\[\mathsf{ pull} : (\sharp 4 \to X) \to (\sharp 3 \to X)\]
\[\mathsf{ push} : (\sharp 3 \to X) \to (\sharp 2 \to X)\]
is the thing that lets me define binary relation composition.

Here's the thing that doesn't make sense: if I independently allow
mapping $x \mapsto z$ and $y\mapsto z$, I have the entirety of the $4$
to choose how to map back to $2$, {\em twice}. This is too much data.
I actually want to split up the $4$ and map it onto both $2$s jointly,
linearly. This makes sense out of the {\em injectivity} in the
Bernardy-Moulin definition; if all my dimensions are $x^1y^1z^1\cdots$
etc., then this linearity (well, affineness, I guess, since I can
throw things away into endpoints) is exactly injectivity.

Ignoring the ability to pick endpoints, a morphism $(f : A \to B) \to (g : C \to D)$ does
seem to want to be something like
\[
\begin{tikzcd}
  A\ar[from=d, "\gamma"]\ar[r, "f"]& B\ar[d, "\beta"]\\
C \ar[r, "g"'] &D
\end{tikzcd}
\]
but the totality of $\gamma$ seems to be slightly too much to ask in
general. What if $\beta$ isn't surjective? So let me then stare at
\[
\begin{tikzcd}
  A+1\ar[from=d, "\gamma"]\ar[r, "f+1"]& B+1\ar[d, "\beta+1"]\\
C \ar[r, "\binl \o g"'] &D+1
\end{tikzcd}
\]
Is this sufficient? Should I be able to do something like an abstract morphism
\[ x^2 \to z^4 \]
where I only use part of the $4$ to cover the $2$? Somehow my gut says no.

I thought for a moment that I wanted to ask for a map, for each $d \in
C$, from $g^*(d)$ to the preimage under {\em the composition of
  $\beta$ and $f$}: a function $g^*(d) \to (\beta\o f)^*(d)$. But if nobody hits
$z^4$ at all, that's asking for a map {\em into} 0, so that's no good. Hrm.


\subsection{Retreating to what I Do Know}

Some abstract maps $x_1^nx_2^n\cdots \to y_1^ny_2^n \cdots$ that I definitely believe
exist are any `sufficiently injective' maps of $X \to Y + n$.

Furthermore for any $x$ that maps to a $y$, I think I can pick a {\em
  permutation} of $n$, to capture permuting vertices.

I'm pretty sure there are canonical abstract maps $x^1 \to y^n$ (push to duplicate columns)
and $x^n \to y^0$ (push to project out all columns). And indeed for any map $n \to m$ there
should exist an abstract push map $x^m \to x^n$.

Actually, {\em is} it perhaps the case that these maps ought to be
surjective on dimensions? No, that doesn't seem right: we can send everything to the $+n$.

Can I say definitively what the sets-and-relations interpretation is for any of these presheaves?
For sure $x^n$ should be a set with an $n$-ary relation. I figure $x^2 y^2$ should be a
relation that's the product of two binary relations? Or is it four arbitrary binary relations?
I know I can yoneda-embed each object and then take sums of them in the presheaf category,
being as it's the free cocompletion. So $x^2 + y^2$ is a thing, and it should work out to asking
for two unrelated binary relations.

When I have just the `cube category' for Benardy-Moulin, what's going on? The objects I have
are $\mathsf{I}, x^1, x^1y^1, x^1y^1z^1$, etc. To map them into an object is to construct something
with $n$ variables of type $\ii$. That $\mathsf{embu}$ is an equivalence is to say
%% embu : ∀ {ℓ} {A : Set ℓ} (p : A ∈ i · Set ℓ)
%%   (a : A) → Set ℓ
%% embu {ℓ} {A} p a = a ∈ i · (p * i)

\[
\begin{prooftree}
   \prov A \in i . \rset
\Justifies
   \prov A \to \rset
\end{prooftree}
\]

So $\ii \to \rset$ is the same as $(A : \rset) \x (A \to \rset)$.
More generally $\sharp n \to \rset$ should be the same as $(A : n \to \rset) \x ((c : n) \to A\ c) \to \rset$. Thus
\[\sharp n \to \sharp m \to \rset\]
\[= \sharp n \to (A : m \to \rset) \x ((c : m) \to A\ c) \to \rset\]
and by the `axiom of constructive choice'
%% {-# OPTIONS --without-K --rewriting #-}
%% module a where
%%
%% open import HoTT
%%
%% thm : {A : Set} {B : A → Set} {P : (x : A) (y : B x) → Set} →
%%   ((x : A) → Σ (B x) (λ y → P x y)) == Σ ((x : A) → B x) (λ f → (x : A) → P x (f x))
%% thm {A} {B} {P} = ua (equiv inj out zig zag) where
%%   inj : ((x : A) → Σ (B x) (P x)) →
%%       Σ ((x : A) → B x) (λ f → (x : A) → P x (f x))
%%   inj g = (λ x → g x .fst) , (λ x → g x .snd)
%%   out : Σ ((x : A) → B x) (λ f → (x : A) → P x (f x)) →
%%       (x : A) → Σ (B x) (P x)
%%   out (f , s) x = f x , s x
%%   zig : (b : Σ ((x : A) → B x) (λ f → (x : A) → P x (f x))) →
%%       inj (out b) == b
%%   zig b = idp
%%   zag : (a : (x : A) → Σ (B x) (P x)) → out (inj a) == a
%%   zag a = idp
\[((x : A) \to (y : B) \x P(x, y)) \equiv (f : (x : A) \to B) \x (x : A) \to P(x, f(x))\]
change this to
\[=  (A : \sharp n \to m \to \rset) \x (x : \sharp n) \to ((c : m) \to A\ x\ c) \to \rset\]
Bah, this is still difficult to massage. Let me first refine the double-horizontal that I have above.


\[
    p : (A \in i . \rset)
\qquad\longleftrightarrow\qquad
    (\lambda a . a \in i . (p * i)) : A \to \rset
\]
\[ (q : \sharp n) \to \rset \equiv (A : \rset) \x ?\]

Bah. The function
\[
\lambda p a . \{ g : \lambda (i : \ii) . p * i \st g\ 0 \equiv a \} :
   \{ f : \ii \to \rset  \st f 0 \equiv A \}\to( A \to \rset)
\]
is an equivalence? No this is also a mess.

\subsection{Trying Again with just $\ii$}

I want to transform $\ii \to \ii \to \rset$ to something reasonable.
I know $\ii \to \rset$ is the same thing as $(A : \rset) \x (A \to \rset)$.
So
\[\ii \to \ii \to \rset = \ii \to (A : \rset) \x (A \to \rset) \eqno(*)\]
\[=   (F : \ii \to \rset) \x (i : \ii) \to F\ i \to \rset\]
First thing I need to do is generalize
% cf. ParametricitySb.agda
\[\ii \to \rset \equiv (A : \rset) \x (A \to \rset)\]
to
\[(F : \ii \to \rset) \to B(F) \equiv  (A : \rset) (P : A \to \rset) \to B(\lambda i . \Psi_A P * i)\]
\[(F : \ii \to \rset) \x B(F) \equiv  (A : \rset) (P : A \to \rset) \x B(\lambda i . \Psi_A P * i)\]
whence
\[(*) =  (A : \rset) (P : A \to \rset)  \x (i : \ii)  (\Psi_A P * i) \to \rset\]

Wait a minute. Isn't it the case that a `diagram' like
\[
\begin{tikzcd}
&\ \\
    \bullet\ar[ur, "y"]\ar[r, "x"']&\ %
\end{tikzcd}
\]
ends up being something like a map from a square
\[
\begin{tikzcd}
\bullet \ar[r]\ar[d] & \ar[d] \bullet\\
\bullet \ar[r] &  \bullet
\end{tikzcd}
\]
into $\rset$ in the presheaf semantics?
This is exploiting the Grothendieck isomorphism
\[ (A \to \rset) \equiv (B : \rset) \x (B \to A)\]
so that
\[ (A : \rset) \x (A \to \rset) \equiv (A\ B : \rset) \x (B \to A)\]
and transitively
\[ (\ii \to \rset) \equiv (A\ B : \rset) \x (B \to A)\]
This is true for unary $\ii$ only.
\[(\sharp n \to \rset) \equiv (A : n \to \rset) \x ((x : n) \to A\ x) \to \rset\]
\[\equiv (A : n \to \rset) (B : \rset) \x (x : n) \to B \to A\ x \]
% or in other words
% \[(\sharp n \to \rset) \equiv (A_1 : \rset)\cdots (A_n : \rset) \x (A_1 \x\cdots\x A_n) \to \rset\]
% \[ \equiv (A_1 : \rset)\cdots (A_n : \rset) \x (B : \rset) \x (B \to A_1 \x\cdots\x A_n)\]
So we get spans instead of single morphisms.
\end{document}

% garbage
If $A : *$ then $\usem A : A \to *$
\[\pi : \Pi A \cn * . \Pi a \cn A .  \usem A\ a\]
\[\sem \pi : \pi \in \sem{\Pi A \cn * . \Pi a \cn A .  \usem A\ a}   \]
\[\sem \pi : \Pi A \cn * .\Pi \dot A \cn A \to * . \pi\ A \in \sem{ \Pi a \cn A .  \dot A\ a}   \]
\[\sem \pi : \Pi A \cn * .\Pi \dot A \cn A \to * .  \Pi a \cn A .  \Pi \dot a \cn \dot A(a) .\pi\ A \in \sem{  \dot A\ a}   \]
\[\sem \pi : \Pi A \cn * .\Pi \dot A \cn A \to * .  \Pi a \cn A .  \Pi \dot a \cn \dot A(a) .  \sem{  \dot A\ a} (\pi\ A)  \]
\[\sem \pi : \Pi A \cn * .\Pi \dot A \cn A \to * .  \Pi a \cn A .  \Pi \dot a \cn \dot A(a) . \sem {\dot A}\ a\ \sem a\ (\pi\ A)\]
\[\sem \pi : \Pi A \cn * .\Pi \dot A \cn A \to * .  \Pi a \cn A .  \Pi \dot a \cn \dot A(a) . \usem {\dot A}\ a\ \dot a\ (\pi\ A)\]
\[\sem{ \dot A} : \dot A \in \sem {A \to *}\]
\[\sem{ \dot A} : \Pi a \cn A . \Pi \dot a \cn \dot A(a) . \dot A(a) \to *\]


\end{document}
