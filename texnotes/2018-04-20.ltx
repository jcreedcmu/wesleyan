\documentclass{article}
\input{theorem}
\input{prooftree}
\usepackage{stmaryrd}
\usepackage{latexsym}
\usepackage{yfonts}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,cd,decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}
\usepackage{tcolorbox}
\tcbuselibrary{breakable}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}

\def\bpush{\mathbf{push}}
\def\bpull{\mathbf{pull}}

\def\wo{\setminus}
\def\fA{\mathsf{A}}
\def\fC{\mathsf{C}}
\def\fX{\mathsf{X}}
\def\ff{\mathsf{f}}
\def\fm{\mathsf{m}}
\def\rspan{\mathsf{Span}}
% \def\El#1{\mathsf{El}({#1})}
\def\El#1{\ulcorner{#1}\urcorner}
\def\quote#1{{\ulcorner {#1} \urcorner}}
\def\U{\mathsf{U}}
\def\uu{\mathsf{u}}
\def\uni{\U}
\def\mor#1#2{#1 \to \underline{#2}}

\def\ridp{\mathsf{idp}}
\def\ssem#1{\langle\!\langle{#1}\rangle\!\rangle}

\definecolor{cyan}{rgb}{0.80,0.95,0.95}
\definecolor{orange}{rgb}{0.95,0.90,0.80}
\definecolor{bluegray}{rgb}{0.6,0.6,0.85}
\definecolor{lgray}{gray}{0.9}
\newtcolorbox{declbox}{colframe=lred,colback=lred,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{thmbox}{colframe=cyan,colback=cyan,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{defnbox}{colframe=orange,colback=orange,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{tangentbox}{colframe=lgray,colback=lgray,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}

\input{linear}
\def\rpath#1{[#1]}
\def\rfst{\mathsf{fst}\,}
\def\rsnd{\mathsf{snd}\,}
\def\bunfold{\mathbf{unfold}}
\def\bfold{\mathbf{fold}}
\def\susp#1{\langle {#1} \rangle}
\def\ssusp#1{\langle\!\langle {#1} \rangle\!\rangle}
\def\dto{\mathrel{\dot\to}}
\def\dns{{\downarrow}}
\def\ups{{\uparrow}}
\def\sprov{\Vdash}
\def\signat{{\color{red}\Sigma}}
\def\ep#1{\underline{#1}}
\def\wat{\mathbin{@}}
\def\wwat{\mathbin{\underline\wat}}
\def\cn{{:}}
\def\dv{{\div}}
\def\ww{{\mathsf w}}
\def\base{{\textfrak b}}

\def\N{{\mathbb N}}
\def\munit{I}
\def\tt{{\mathsf t}}
\def\rr{{\mathsf r}}
\def\ii{{\mathbb I}}
\def\pp{\textsf{\textbf p}}
\def\nn{{\mathsf n}}
\def\PP{\textsf{\textbf P}}
\def\NN{{\mathsf N}}
\def\zz{{\mathsf z}}
\def\sem#1{[\![#1]\!]}
\def\usem#1{\lceil\!\!\lceil{#1}\rceil\!\!\rceil}
\def\zem#1{\langle\!\langle#1\rangle\!\rangle}
\def\col#1{{\mathsf{C}}_{#1}}
\def\lax{\mathop\bigcirc}
\def\rjust{\mathsf{just}}
\def\rcvt{\mathsf{cvt}}
\def\rtype{\mathsf{type}}
\def\rkind{\mathsf{kind}}
\def\rmode{\mathsf{mode}}
\def\rprel{\mathbf{Prel}}
\def\rrfam{\mathbf{Rfam}}
\def\rset{\mathbf{Set}}
\def\rfinset{\mathbf{FinSet}}
\def\rrel{\mathbf{Rel}}
\def\rcat{\mathbf{Cat}}
\def\rfam{\mathbf{Fam}}
\def\binj{\mathbf{inj}}
\def\rid{\mathsf{id}}
\def\rtrue{\mathrel\mathrm{true}}
\def\pbck{\ar[dr, phantom, pos=0, "\lrcorner"]}
\def\bpbck{\ar[ddrr, phantom, pos=0, "\lrcorner"]}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\btwo{\mathbf{2}}
\def\bone{\mathbf{1}}

\newarrow {Equiv} =====
\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\def\mapt{\ar[ddd,mapsto,shorten <=2em, shorten >=2em]}
\def\frommaps{\ar[from=uu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\frommapt{\ar[from=uuu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\C{\mathbf{C}}
\def\W{\mathbf{W}}
\def\S{\mathbf{S}}
\def\D{\mathbf{D}}
\def\E{\mathbf{E}}
\def\M{\mathbf{M}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\tri{\triangleright}
\def\o{\circ}
\def\rctx{\,\mathsf{ctx}}
\def\rdctx{\,\mathsf{dctx}}
\def\del{\partial}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\null{\emptyset}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\definecolor{fib}{HTML}{ff7f00}
\definecolor{green}{HTML}{007f00}
\definecolor{red}{HTML}{df3f3f}
\definecolor{opfib}{HTML}{007fff}

% For lightening colors I used
% http://trycolors.com/ 6 parts white to 1 part color
\definecolor{opfibl}{HTML}{DBEDFF}
\definecolor{greenl}{HTML}{DBEDDB}
\definecolor{redl}{HTML}{FAE4E4}
\def\njudge#1{\fcolorbox{opfib}{white}{#1}}
\def\nrule#1{\fcolorbox{white}{opfibl}{#1}}
\def\neqn#1{\fcolorbox{white}{redl}{#1}}



\def\judge#1{\vskip 2em\noindent \njudge{$#1$}\vskip 0.5em\noindent}
\def\rule#1{\vskip 2em \noindent \nrule{$#1$}\vskip 0.5em\noindent}
\def\eqn#1{\vskip 2em \noindent \neqn{$#1$}\vskip 0.5em\noindent}
\def\prof{\nrightarrow}
\def\tensor{\otimes}
\def\htensor{\mathrel{\hat\otimes}}
\def\lol{\multimap}
\def\hlol{\mathrel{\hat\multimap}}
\def\wtf{{\color{red}???}}

\def\re{\mathbf{E}}
\def\sh{\sharp}
\def\shp{\mathrel{\sharp}}
\def\zero{\texttt{0}}
\begin{document}

\def\
\tikzset{
   commutative diagrams/.cd,
   arrow style=tikz,
   diagrams={>=stealth}}

\section{Models of Cohesive Type Theory}

Trying to explore the space of really-simple-to-describe models of $\sharp$ and $\flat$.
A nice one is, let $\C_*$ be a pointed category where $\C[*,*]=\{\rid_*\}$.
\[\begin{tikzcd}
  \rset\ar[from=d, "U" description]
\ar[d, shift right=10, "\Delta"']
\ar[d, shift right=5, phantom,  "\dashv"]
\ar[d, shift left=5, phantom,  "\dashv"]
\ar[d, shift left=10, "\nabla"]\\
\rset^{\C_*}
\end{tikzcd}\]
where (for $p\in \rset^{\C_*}$ and $S \in \rset$)
\[Up = p(*)\]
\[\Delta S = \C[*, \dash] \x kS\]
\[\nabla S = \C[\dash, *] \imp kS\]
where $kS\in \rset^{\C_*}$ is the constant functor always returning $S$.
The adjunctions can be seen from doing little yoneda calculations:
\[[p, \nabla S] = [p, \C[\dash, *] \imp kS]\]
\[ = [\C[\dash, *], p \imp kS]\]
\[ = (p \imp kS)(*)\]
\[ (?) = [Up , S] \]

\[[\Delta S, p] = [\C[*, \dash] \x kS, p]\]
\[= [\C[*, \dash] , kS \imp p]\]
\[= (kS \imp p)(*) \]
\[(?) = [ S, Up] \]

Whoops, wait, are these adjoint? The (?) equalities don't hold.
Maybe it's not really the standard product and exponential operations on presheaves
that I'm talking about.

What I originally wrote on twitter was
\[Up = p(*)\]
\[\Delta S = \C[*, \dash] \x S\]
\[\nabla S = \C[\dash, *] \to S\]
Let me define these explicitly:
Given a functor $p : \rset^{\C}$ and a set $S$, I define $p\x S : \rset^\C$ to be
\[(p \x S)(c) = p(c) \x S \]
\[ (p \x S)(f) =\lambda (x, s) . (f\ x, s)\]
And given a functor $p : \rset^{\C^\op}$ and a set $S$, I define $p\to S :\rset^\C$ to be
\[(p \to S)(c) = p(c) \to S \]
\[(p \to S)(f : c \to d) =\lambda g : (p(c) \to S) .\lambda x : p(d) . g (p\ f\ x)\]

I should also make the additional auxiliary definition of,
given a functor $p : \rset^{\C}$ and a set $S$, I define $S \to p : \rset^\C$ to be
\[(S \to p)(c) = S \to p(c)\]
\[ (S \to p)(f) =\lambda g : (S \to p(c)). \lambda s : S . p\ f (g s)\]


In this case, the yoneda calculations are
\[[p, \nabla S] = [p, \C[\dash, *] \to S]\]
\[ =\!\!\langle ?\rangle\ [\C[\dash, *], p \to S]\]
\[ =\!\!\langle \hbox{yoneda}\rangle\ (p \to S)(*)\]
\[  = [Up , S] \]

\[[\Delta S, p] = [\C[*, \dash] \x S, p]\]
\[=\!\!\langle ?\rangle\ [\C[*, \dash] , S \to p]\]
\[=\!\!\langle \hbox{yoneda}\rangle\  (S \to  p)(*) \]
\[= [ S, Up] \]

Now the dubious steps have moved up a bit.

Let a covariant functor $q$ be given. Can I show $[q \x S, p]$ is the
same as $[q, S \to p]$? It seems like I shouldn't.

A nat trans in the former goes
\[\begin{tikzcd}
  qC \x S \ar[r, "\alpha_C"]\ar[d, "qf \x \rid_S"'] & p C\ar[d, "pf"]\\
  qD \x S \ar[r, "\alpha_D"'] & p D
\end{tikzcd}\]
and in the latter goes
\[\begin{tikzcd}
  qC  \ar[r, "\beta_C"]\ar[d, "qf"'] & S \to p C\ar[d, "pf \o \dash"]\\
  qD  \ar[r, "\beta_D"'] & S \to p D
\end{tikzcd}\]
It sure seems like the same data, just curried differently. Want to say that both
of them are the same as an $S$-indexed family of natural transformations $[q,p]$.

What about the contravariant one? Let $q : \rset^{\C^\op}$ and try to reason
that $\rset^{\C}[p, q \to S] = \rset^{\C^\op}[q, p \to S]$
Latter looks like
\[\begin{tikzcd}
  qD  \ar[r, "\beta_D"]\ar[d, "qf"'] &  p D \to S \ar[d, "\dash \o pf "]\\
  qC  \ar[r, "\beta_C"'] & p C \to S
\end{tikzcd}\]
and former looks like
\[\begin{tikzcd}
  pC  \ar[r, "\alpha_C"]\ar[d, "qf"'] &  qC \to S \ar[d, "\dash \o qf "]\\
  pD  \ar[r, "\alpha_D"'] & q D \to S
\end{tikzcd}\]
These look like the same data also.

\subsection{When $\Pi$ exists}
Notice that $\Delta$ preserves products iff $\C[*, \dash]$ is always $1$ --- i.e.
if $*$ is initial. So the special case where I'm talking about $\rset^{\C_0}$, I get
\[\begin{tikzcd}
\rset
\ar[from=d, shift right=5, "U" description]
\ar[from=d, shift left=15, "\Pi"]
\ar[d, shift right=5, "\Delta" description]
\ar[d, shift right=10, phantom,  "\dashv"]
\ar[d, shift right=0, phantom,  "\dashv"]
\ar[d, shift left=10, phantom,  "\dashv"]
\ar[d, shift left=15, "\nabla"]\\
\rset^{\C_0}
\end{tikzcd}\]
And it is basically the `connected components' functor I expect; the initial
object of $\C$ gives the `vertices' of the structured object, and every projection
from one type of hyperedge to another forces the identification of the hyperedge
and the resulting domain/codomain/whatever.
\subsection{After Talking To Dan}
Dan says this model shows up in ``Internal Universes in Models of Homotopy Type Theory''
although I don't see it upon skimming right now.

\section{Having Pulls and Copairing as Modality}
Switching gears: Look back at the category I specified in
\texttt{2017-11-14.ltx} and \texttt{2017-02-20.ltx}, namely
(using slightly more recent notation)
\[
\W =\qquad
\begin{tikzcd}
 0\ar[r]\ar[d, "!"']
&  1\ar[d, "!", shift left]\ar[from=d, "\ep 0", shift left]
\ar[r, shift left]\ar[r, shift right]\ar[from=r, shift right=3]
&  2\ar[d, "!", shift left]\ar[from=d, "{\frac{\ep 0}{\ep 1}}" , shift left]
\ar[from=d]
\ar[r, leftrightarrow]\ar[r, shift right, leftrightarrow]\ar[r, shift left, leftrightarrow]
&\cdots
\\
\top \ar[r, equal]
& \top\ar[r, equal]
& \top\ar[r, equal]
& \cdots
\end{tikzcd}
\]
Although I ultimately want to take the free {\em mumble} category over this one,
but let me just think about the `non-nested parametricity' case of just presheaves
$p \in \rset^{\W^\op}$ for now. The structure of $\W$ tells me how to do $\bpush$es in $p$: it's
just restriction along $\W$-morphisms. What I {\em don't} know is:
\begin{enumerate}
\item How to turn, say, an element of $p( n)$ and an element of $p( m)$ into an element
of $p(n + m)$
\item How to do $\bpull$s.
\end{enumerate}
And for all I know this kind of structure is {\em not} expressible by
cleverly picking a different presheaf base category. I went through and thought about
how function types behave with parametricity, and I think they may not satisfy (1) at all?

But a reasonable way to proceed I think is to try to talk about the idempotent monadic modality
that freely {\em adds} this structure to a {\em particular} presheaf, in much the same way
that cohesive $\sharp$ freely (well, codiscretely) adds edges between all vertices.

How to do this for (1) seems pretty clear to me: The modality $C$
(named for `copairing'/`coproducts') takes in a $\hat\W$ and spits out a $\hat\W$.
An element of $C(p)( n)$ is an
 multiset $\{x_1 \in p( m_1), \ldots, x_N \in p( m_N)\}$
such that $m_1 + \cdots + m_N = n$,
\textcolor{red}{but we quotient by saying that for any $a, b$ and $x\in p(a + b)$,
we consider having the two elements $x \adjust_{ a \to  (a + b)}$ and $x \adjust_{ b \to  (a + b)}$
in your multiset the same as having the element $x$. Also having the element $x \in p( 0)$
is the same as having nothing at all, I guess? So I guess this collapses any data that might
have been in $p( 0)$. There is exactly one element of $Cp( 0)$, namely the empty multiset.}

Wait, no, everything in red above is definitely wrong. Doing a $\bpush$ and then reaggreating
is not at all the same relation. If I have a relation $R = \{(a, 1),(b, 2)\}$ the $\bpush$es
to the individual columns give me $\{a, b\}$ and $\{1, 2\}$ and then the product
of those two relations is the larger $R = \{(a, 1),(b, 2),(a,2),(b,1)\}$.

But I'm not convinced that taking all the multisets with no
identification at all yields an idempotent operation. Also, as a useful test case,
I should expect that specifically the universe $\U$ made of sets and
relations `has all copairings', and so $C \U = \U$.

\subsection{Pulls}

Let me defer that thought and see how far I get thinking about $\bpull$s, then.
Recall that if I have an element
 $r \in p(n)$ and a map $f : m \to n$, I can $\bpush$ r to $r\adjust_f : p(m)$.

In the other direction, if I have an element $r\in p(m)$, and I have a map
$g : n \to p(\top)$, and for every $k \in m$ I know $g(f(k)) = r\adjust_{\ep k}$, then
I should have a $\bpull_f r : p(n)$, with the property that
$(\bpull_f r)\adjust_{\ep {f(k)}} = r\adjust_{\ep k}$.
The tantalizingly more general
$(\bpull_f r)\adjust_{f \o h} = r\adjust_{h}$ is I guess not true, since it would imply
(when $h = \rid$) that a $\bpush$ of a $\bpull$ of $r$ is always $r$.

Still, as a first cut, if I'm to make a modality $P$ for `the $\bpull$ closure of a type',
the occupants of $Pp(n)$ can {\em be specified} (but I assume there remains some
quotienting that needs to be done)
by the data of
\begin{itemize}
\item a choice of $m$
\item a map $f : m \to n$
\item a map $g : n \to p(\top)$
\item a choice of $r \in p(m)$
\item for every $k \in m$, that $g(f(k)) = r\adjust_k$
\end{itemize}
I even kind of think that I might already effectively
know how to define presheaf restriction on these data, and that that would consistute
a sort of Beck-Chevalley property.
\subsection{Idempotence}
I think for both copairing and pulls, that in order to make the modality idempotent, I need
some kind of universal-property-smelling {\em something}. Surely at least to make the universe
a fixedpoint of the modality, I need something like this. For otherwise I'm going to
add structure to $\U$, and not be able to determine how to identify the added structure
with the existing structure that's there.

Let's compare this situation to the free-category-on-a-graph
construction. When I go forget from categories to graphs, there's no
trace of the composition structure left for me to tell that the added
edges actually {\em go with} the original pairs of edges, so it's not
idempotent at all. But if I thought about 2-graphs instead of
1-graphs, then there should indeed be an operation that takes a
1-graph with no interesting 1-cells, and adds enough 2-cells to make
it into a category, and then even if you forget back to 2-graphs,
forgetting that those 2-cells `are compositions', they're still there
{\em as data}. If you do the same construction, you should be able to
recognize that the 2-cells are somehow canonically situated in such a
way as to {\em be the compositions}, and not duplicate them when you
iterate the construction.

What's an easy example I can make work? Is there a way of {\em
  idempotently} freely adding, say, a terminal object to a category?
Let's try this: Given a category $\C$, construct the category
$\C^+$ whose objects are $\C_0 \cup \{ \bullet \}$, where the
morphisms $C \to \bullet$ are $\{!\}$, and a morphism
 $\bullet \to C$ is a family of morphisms $\{f_D : D \to C\}_{D \in \C_0}$.

Is composition clearly defined? Composition of $\{f_D : D \to C\}_{D \in \C_0} : \bullet \to C$
with $g : C \to E$ is obviously $\{g \o f_D : D \to E\}_{D \in \C_0} : \bullet \to E$.

Is it associative? Ooh, I think maybe not. Consider
\[\begin{tikzcd}
A \ar[r, "g"] & B \ar[r, "!"] & \bullet \ar[r, "{\{f_D : D \to C\}_D}"]&[5em] C
\end{tikzcd}\]
Then notice $\{f_D : D \to C\}_D \o (!_B \o g) = \{f_D : D \to C\}_D \o !_A = f_A : A \to C$
but
$(\{f_D : D \to C\}_D \o !_B) \o g = f_B \o g : A \to C$.
Oh, but maybe this just means I need to require that a morphism
$\bullet \to C$ is a {\em coherent} family of morphisms $\{f_D : D \to C\}_{D \in \C_0}$
compatible with composition.

Then $\bullet$ is by definition terminal, but also if $\C$ already had a terminal
object, there should be a unique
morphism $\bullet \to 1$ given exactly by $\{! : D \to 1\}_D$.

Here the morphism data of the category is what can {\em effectively}
betray that the terminal object is terminal, even if it's not
advertised as such in the interface I'm dealing with --- i.e. even if
I'm not living in `the category of categories equipped with a terminal
object'.

I guess what I'm currently hoping for is that somehow the {\em higher}
presheaf cell structure of a presheaf over the free {\em something
  like symmetric monoidal cartesian mumble} category on $\W$ is the
data that somehow betrays the universality of the copairing and pull
operations.

\subsection{Duh, Of Course}

Right, the above is just taking the yoneda embedding of a category,
and then also including as an object the constantly-singleton presheaf
$1$, and considering the full subcategory on $\{yC\}_{C \in \C} \cup
\{1\}$. If you already happened to have a terminal object, then one of
those $yC$s is also constantly-one.

This plainly generalizes to all limits; remember from kindergarten
that the yoneda embedding gives you all limits, and they coincide with
any that you already had.

\section{A Relationy Definition of Adjunction}

I'm trying to come up with a definition of adjoint functors in terms of relationy
things such that I can prove reasonable things about it, e.g. adjoints are unique.

Here's an attempt: supposing $F : \C \to \D : G$ an adjunction looks something like
a relation $R : (s : \sharp 2) (t : \sharp 2) \to \rset$ such that things look like
\[
\begin{tikzcd}
  \textcolor{bluegray}{1}\ar[d, <->, "s"', bluegray]
&[-1em]\C \ar[r, "F"]\ar[d, <->, "\hom"']& \D\ar[d, <->, "\hom"]\\
  \textcolor{bluegray}{2}&\C \ar[from=r, "U"]& \D\\[-1em]
  &\textcolor{bluegray}{1} \ar[r, <->, "t"', bluegray]& \textcolor{bluegray}{2}
\end{tikzcd}
\]
or, expanding this out,
\[
\begin{tikzcd}
\textcolor{bluegray}{1}\ar[dd, <->, "s"', bluegray]
  &[-1em]\C
  & F \dns \D \ar[l, "\dom"']\ar[r, "\cod"]
  & \D\\
%
  &\C^\to \ar[u]\ar[d]
  &\forall s t . R \ar[u]\ar[l]\ar[r]\ar[d]
  &\D^\to \ar[u]\ar[d]\\
\textcolor{bluegray}{2}
  &\C
  &\C\dns U \ar[l, "\dom"]\ar[r, "\cod"']
  & \D\\[-1em]
%
  &\textcolor{bluegray}{1} \ar[rr, <->, "t"', bluegray]&& \textcolor{bluegray}{2}
\end{tikzcd}
\]
So $\C^\to$ isn't all of $\sharp 2 \to \C$, it's just the functional subset of that.
We want to require that
\[ \rho : \forall s t . R \prov F(\rho\ 1\ 1) = \rho\ 1 \ 2  \]
\[ \rho : \forall s t . R \prov U(\rho\ 2\ 2) = \rho\ 2 \ 1  \]
\[ s : \sharp 2 \prov R\ s 1 = \hom_\C\ s \]
\[ s : \sharp 2 \prov R\ s 2 = \hom_\D\ s \]
And that the following maps are constant in $q$:
\[ q : \sharp 1,  \rho : \forall s t . R \prov \lambda t . \rho\ \sharp(* \mapsto 1)(q)\ t : \forall t . R\ 1\ t\]
\[ q : \sharp 1,  \rho : \forall s t . R \prov \lambda t . \rho\ \sharp(* \mapsto 2)(q)\ t : \forall t . R\ 2\ t\]

Hm, but I'm not sure this captures that the thing in, for example, the $\C / U$
position in the diagram, which is the type $\forall t . R\ 2\ t$, contains {\em all} the
morphisms $c \to U d$.

In somewhat more generality I want to have two relations that stand in
for the hom-relations, and specify $F$ and $U$'s domain and comdain
directly from interval-variable-substitutions of them. Call them $J, K : \sharp 2 \to \rset$.
Suppose $F : J\ 1 \to K\ 1$ and $U : K\ 2 \to J\ 2$.
\[
\begin{tikzcd}
\textcolor{bluegray}{1}\ar[dd, <->, "s"', bluegray]
  &[-1em]J\ 1
  & F \dns \dash \ar[l, "\dom"']\ar[r, "\cod"]
  & K\ 1\\
%
  &\forall s . J \ar[u]\ar[d]
  &\forall s t . R \ar[u]\ar[l]\ar[r]\ar[d]
  &\forall s . K \ar[u]\ar[d]\\
\textcolor{bluegray}{2}
  &J\ 2
  &\dash \dns U \ar[l, "\dom"]\ar[r, "\cod"']
  & K\ 2\\[-1em]
%
  &\textcolor{bluegray}{1} \ar[rr, <->, "t"', bluegray]&& \textcolor{bluegray}{2}
\end{tikzcd}
\]
Now I want $F \dns \dash$ to be the same thing as the pullback
\[(k : \forall s . K) (j : J\ 1) \x k\ 1 \equiv F\ j \]
and $\dash\dns U$ the same thing as
\[(j : \forall s . J) (k : K\ 2) \x j\ 2 \equiv U\ k \]
\vfil\eject
But wait, why am I giving a separate name to $J$ and $K$? If I swap $R$'s arguments
around so that $t$ comes first, they're just $R\ 1$ and $R\ 2$.

\[
\begin{tikzcd}
\textcolor{bluegray}{1}\ar[dd, <->, "s"', bluegray]
  &[-1em]R\ 1\ 1 \ar[rr, bend left=30, "F"]
  & F \dns \dash \ar[l, "\dom"']\ar[r, "\cod"]
  & R\ 2\ 1\\
%
  &\forall s . R\ 1\ s \ar[u]\ar[d]
  &\forall t s . R\ t\ s \ar[u]\ar[l]\ar[r]\ar[d]
  &\forall s . R\ 2\ s \ar[u]\ar[d]\\
\textcolor{bluegray}{2}
  &R\ 1\ 2
  &\dash \dns U \ar[l, "\dom"]\ar[r, "\cod"']
  & R\ 2\ 2\ar[ll, bend left=30, "U"]\\[1em]
%
  &\textcolor{bluegray}{1} \ar[rr, <->, "t"', bluegray]&& \textcolor{bluegray}{2}
\end{tikzcd}
\]
Now I say $F : R\ 1\ 1 \to R\ 2\ 1$ and $U : R\ 2\ 2 \to R\ 1\ 2$.
and I want $F \dns \dash$ --- which is $\forall t . R\ t\ 1$ ---
to be the same thing as the pullback
\[(k : \forall s . R\ 2\ s) (j : R\ 1\ 1) \x k\ 1 \equiv F\ j \]
and $\dash\dns U$ --- which is $\forall t . R\ t\ 2$ --- the same thing as
\[(j : \forall s . R\ 1\ s) (k : R\ 2\ 2) \x j\ 2 \equiv U\ k \]

So look at the $F$ pullback specifically: one of the pullback projections
is just the $\dom : F \dns \dash \to R\ 1\ 1$, but the other is a function
\[ (\forall t . R\ t\ 1) \to (\forall s. R\ 2\ s)\]
So that's interesting! Similarly, the $U$ pullback gives us
\[ (\forall t . R\ t\ 2) \to (\forall s. R\ 1\ s)\]

Both of these would derive if we had
\[ u : \sharp 2 \prov (\forall t . R\ t\ u) \to (\forall t. R\ \tilde u\ t)\]
And the `functors' $F$ and $U$ seem to come from
\[ u : \sharp 2 \prov  R\ u\ u \to R\ \tilde u\ u\]

\section{Push-Pull Adjunction in $\rset$}
Trying to think about what specifically is going on with relations in $\rset$.
Suppose $I, J$ are sets, and $h : J \to I$ is a reindexing function.
Suppose we have a function $T :  \sharp 2 \to I \to \rset$.
that we write as a span $(C_i, (A_i, B_i))$.
Suppose a $I$-span $K, A_i, f_i$ and a $J$-span $L, B_{hj}, g_j$ are given to us.
I think then that to have an $R : \sharp 2 \to \sharp J \to \rset$
\[
\begin{tikzcd}
\textcolor{bluegray}{1}\ar[dd, <->, "t"', bluegray]
  &[-1em]A_{hj_1}
  & K \ar[l, "f_{hj_1}"']\ar[r, "f_{hj_2}"]
  & A_{hj_2}\\
%
  &C_{hj_1} \ar[u]\ar[d]
  &\forall t j . R\ t\ j \ar[u]\ar[l]\ar[r]\ar[d]
  &C_{hj_2} \ar[u]\ar[d]\\
\textcolor{bluegray}{2}
  &B_{hj_1}
  &L \ar[l, "g_{j_1}"]\ar[r, "g_{j_2}"']
  &B_{hj_2}\\[-1em]
%
  &\textcolor{bluegray}{j_1} \ar[rr, <->, "j"', bluegray]&& \textcolor{bluegray}{j_2}
\end{tikzcd}
\]
is the same thing as having an $S : \sharp 2 \to \sharp I \to \rset$
\[
\begin{tikzcd}
\textcolor{bluegray}{1}\ar[dd, <->, "t"', bluegray]
  &[-1em]A_{i_1}
  & K \ar[l, "f_{i_1}"']\ar[r, "f_{i_2}"]
  & A_{i_2}\\
%
  &C_{i_1} \ar[u]\ar[d]
  &\forall t i . S\ t\ i \ar[u]\ar[l]\ar[r]\ar[d]
  &C_{i_2} \ar[u]\ar[d]\\
\textcolor{bluegray}{2}
  &B_{i_1}
  &\bpull \ar[l, "b\ i_1"]\ar[r, "b\ i_2"']
  &B_{i_2}\\[-1em]
%
  &\textcolor{bluegray}{i_1} \ar[rr, <->, "i"', bluegray]&& \textcolor{bluegray}{i_2}
\end{tikzcd}
\]
where $\bpull = (b : (i : I) \to B_i) (\ell : L) \x (j : J) \to b\ (h\ j)\equiv g_j\ \ell$.
The move from the latter to the former is the easier direction.
Project the $\ell$ out of the $\bpull$.

In the other direction, we have a $\chi : \forall t j . R\ t\ j \to L$, we want to
make a $(\sigma : \forall t i . S\ t\ i) \to \bpull$. We have $R\ t\ j = S\ t\ (h\ j)$
 for endpoints $j : J$. How do we make the $b$ part of the pull?
\[(\lambda i  . \sigma\ 2\ i) : (i : I) \to B_i\]
How do we make the $\ell$ part?
\[\chi\ (\lambda t j . \sigma\ t\ (h\ j)) : L\]
How do we check that $b\ (h\ j) \equiv g_j\ \ell$ for any $j : J$? Just compute
\[g_j \ell \equiv g_j\ (\chi\ (\lambda tj.\sigma\ t\ (h\ j)))  \]
\[ \equiv (\lambda tj.\sigma\ t\ (h\ j))\ 2\ j\]
\[ \equiv \sigma\ 2\ (h\ j)\]
\[ \equiv b\ (h\ j)\]
Wait, this isn't right, where are the horizontal morphisms out of $\forall t i . S\ t\ i$ coming from?

\subsection{Backing Up To the Functional Case}

Suppose $B : I \to \rset$.
Suppose $\kappa : \sharp I \to \rset$.
Suppose $\Lambda : \sharp J \to \rset$, with $\Lambda\ \ep j \equiv B_{hj}$.
I'm going to just give the name $A_i$ to $\kappa\ \ep i$, and $K$ to $\forall i . \kappa\ i$,
and $L$ to $\forall j . \Lambda\ j$. Suppose I have $\phi : (i : I) \to \kappa\ \ep i \to B\ i$.

Can I establish a relationship between
\[
\begin{tikzcd}
A_{hj_1}\ar[d, "\phi_{hj_1}"']
  & K \ar[l, "f_{hj_1}"']\ar[r, "f_{hj_2}"]\ar[d]
  & A_{hj_2}\ar[d, "\phi_{hj_2}"]\\
%
  B_{hj_1}
  &L \ar[l, "g_{j_1}"]\ar[r, "g_{j_2}"']
  &B_{hj_2}\\[-1em]
\textcolor{bluegray}{j_1} \ar[rr, <->, "j"', bluegray]&& \textcolor{bluegray}{j_2}
\end{tikzcd}
\]
and
\[
\begin{tikzcd}
A_{i_1}\ar[d, "\phi_{i_1}"']
  & K \ar[l, "f_{i_1}"']\ar[r, "f_{i_2}"]\ar[d]
  & A_{i_2}\ar[d, "\phi_{i_2}"]\\
%
  B_{i_1}
  &\bpull \ar[l, "b\ i_1"]\ar[r, "b\ i_2"']
  &B_{i_2}\\[-1em]
\textcolor{bluegray}{i_1} \ar[rr, <->, "i"', bluegray]&& \textcolor{bluegray}{i_2}
\end{tikzcd}
\]
That is, between functions
\[ z :  (\nu : \sharp J) \to \kappa (\sharp h (\nu)) \to \Lambda(\nu) \]
such that $z\ \ep j = \phi_{hj}$
and functions
\[ w :  (\nu : \sharp I) \to \kappa (\nu) \to \bpull(\nu) \]
such that $w\ \ep i = \phi_i$.

with $\bpull$ I guess being
\[(b : (i : I) \to B_i) (\ell : L) \x (j : J) \to b\ (h\ j)\equiv g_j\ \ell\]
Or I could phrase this
\[(b : (i : I) \to B_i) (\ell : \forall j . \Lambda\ j) \x (j : J) \to b\ (h\ j)\equiv \ell\ \ep j\]

\subsection{Returning to the Relational Version}

Can we define $S : \sharp 2 \to \sharp I \to \rset$ by saying
that $\forall t i . S\ t\ i$ is, give me a $c : (i : I) \to C_i$,
and give me a $\rho : \forall t j . R\ t\ j$ such that
\[j : J \prov c\ (h\ j) \equiv \lambda t . \rho\ t\ j\]

\vfil\eject
\section{Trying That From the Start, then}
For boundaries, I have $\Gamma : \sharp 2 \to I \to \rset$, and $\kappa : \sharp I \to \rset$
and $\Lambda : \sharp J \to \rset$. I assume $\kappa \o \eta_I = \Gamma\ \ep 1$ and
 $\Lambda \o \eta_J = (\Gamma\ \ep 2) \o h$. As abbreviations, I say $A_i = \Gamma\ \ep 1\ i$
and $B_i = \Gamma\ \ep 2\ i$ and $C_i = \forall \nu . \Gamma\ \nu\ i$.

Supposing that
\[\bpull = (b : (i : I) \to B_i) (\ell : L) \x (j : J) \to b\ (h\ j)\equiv g_j\ \ell\]
we can get from
\[
\begin{tikzcd}
\textcolor{bluegray}{1}\ar[dd, <->, "t"', bluegray]
  &[-1em]A_{i_1}
  & K \ar[l, "f_{i_1}"']\ar[r, "f_{i_2}"]
  & A_{i_2}\\
%
  &C_{i_1} \ar[u]\ar[d]
  &\forall t i . S\ t\ i \ar[u]\ar[l]\ar[r]\ar[d]
  &C_{i_2} \ar[u]\ar[d]\\
\textcolor{bluegray}{2}
  &B_{i_1}
  &\bpull \ar[l, "b\ i_1"]\ar[r, "b\ i_2"']
  &B_{i_2}\\[-1em]
%
  &\textcolor{bluegray}{i_1} \ar[rr, <->, "i"', bluegray]&& \textcolor{bluegray}{i_2}
\end{tikzcd}
\]
that is, a map $\sharp 2 \to \sharp I \to \rset$ from $\kappa$ to $\bpull$,
to
\[
\begin{tikzcd}
\textcolor{bluegray}{1}\ar[dd, <->, "t"', bluegray]
  &[-1em]A_{hj_1}
  & K \ar[l, "f_{hj_1}"']\ar[r, "f_{hj_2}"]
  & A_{hj_2}\\
%
  &C_{hj_1} \ar[u]\ar[d]
  &\forall t j . R\ t\ j \ar[u]\ar[l]\ar[r]\ar[d]
  &C_{hj_2} \ar[u]\ar[d]\\
\textcolor{bluegray}{2}
  &B_{hj_1}
  &L \ar[l, "g_{j_1}"]\ar[r, "g_{j_2}"']
  &B_{hj_2}\\[-1em]
%
  &\textcolor{bluegray}{j_1} \ar[rr, <->, "j"', bluegray]&& \textcolor{bluegray}{j_2}
\end{tikzcd}
\]
But is this an equivalence? It seems pretty clearly surjective, but not as obviously injective.

\end{document}
