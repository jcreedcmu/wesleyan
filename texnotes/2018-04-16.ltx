\documentclass{article}
\input{theorem}
\input{prooftree}
\usepackage{stmaryrd}
\usepackage{latexsym}
\usepackage{yfonts}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,cd,decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}
\usepackage{tcolorbox}
\tcbuselibrary{breakable}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}

\def\bpush{\mathbf{push}}
\def\bpull{\mathbf{pull}}

\def\wo{\setminus}
\def\fA{\mathsf{A}}
\def\fC{\mathsf{C}}
\def\fX{\mathsf{X}}
\def\ff{\mathsf{f}}
\def\fm{\mathsf{m}}
\def\rspan{\mathsf{Span}}
% \def\El#1{\mathsf{El}({#1})}
\def\El#1{\ulcorner{#1}\urcorner}
\def\quote#1{{\ulcorner {#1} \urcorner}}
\def\U{\mathsf{U}}
\def\T{\mathsf{T}}
\def\uu{\mathsf{u}}
\def\uni{\U}
\def\mor#1#2{#1 \to \underline{#2}}

\def\ridp{\mathsf{idp}}
\def\ssem#1{\langle\!\langle{#1}\rangle\!\rangle}

\definecolor{cyan}{rgb}{0.80,0.95,0.95}
\definecolor{orange}{rgb}{0.95,0.90,0.80}
\definecolor{lred}{rgb}{0.95,0.8,0.8}
\definecolor{lgray}{gray}{0.9}
\newtcolorbox{declbox}{colframe=lred,colback=lred,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{thmbox}{colframe=cyan,colback=cyan,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{defnbox}{colframe=orange,colback=orange,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{tangentbox}{colframe=lgray,colback=lgray,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}

\input{linear}
\def\rpath#1{[#1]}
\def\rfst{\mathsf{fst}\,}
\def\rsnd{\mathsf{snd}\,}
\def\bunfold{\mathbf{unfold}}
\def\bfold{\mathbf{fold}}
\def\susp#1{\langle {#1} \rangle}
\def\ssusp#1{\langle\!\langle {#1} \rangle\!\rangle}
\def\dto{\mathrel{\dot\to}}
\def\dns{{\downarrow}}
\def\ups{{\uparrow}}
\def\sprov{\Vdash}
\def\signat{{\color{red}\Sigma}}
\def\ep#1{\underline{#1}}
\def\wat{\mathbin{@}}
\def\wwat{\mathbin{\underline\wat}}
\def\cn{{:}}
\def\dv{{\div}}
\def\ww{{\mathsf w}}
\def\base{{\textfrak b}}

\def\N{{\mathbb N}}
\def\munit{I}
\def\tt{{\mathsf t}}
\def\rr{{\mathsf r}}
\def\ii{{\mathbb I}}
\def\pp{\textsf{\textbf p}}
\def\nn{{\mathsf n}}
\def\PP{\textsf{\textbf P}}
\def\NN{{\mathsf N}}
\def\zz{{\mathsf z}}
\def\sem#1{[\![#1]\!]}
\def\usem#1{\lceil\!\!\lceil{#1}\rceil\!\!\rceil}
\def\zem#1{\langle\!\langle#1\rangle\!\rangle}
\def\col#1{{\mathsf{C}}_{#1}}
\def\lax{\mathop\bigcirc}
\def\rjust{\mathsf{just}}
\def\rcvt{\mathsf{cvt}}
\def\rtype{\mathsf{type}}
\def\ritype{\mathsf{itype}}
\def\rkind{\mathsf{kind}}
\def\rmode{\mathsf{mode}}
\def\rprel{\mathbf{Prel}}
\def\rrfam{\mathbf{Rfam}}
\def\rset{\mathbf{Set}}
\def\rfinset{\mathbf{FinSet}}
\def\rrel{\mathbf{Rel}}
\def\rcat{\mathbf{Cat}}
\def\rfam{\mathbf{Fam}}
\def\binj{\mathbf{inj}}
\def\rid{\mathsf{id}}
\def\rtrue{\mathrel\mathrm{true}}
\def\pbck{\ar[dr, phantom, pos=0, "\lrcorner"]}
\def\bpbck{\ar[ddrr, phantom, pos=0, "\lrcorner"]}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\btwo{\mathbf{2}}
\def\bone{\mathbf{1}}

\newarrow {Equiv} =====
\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\def\mapt{\ar[ddd,mapsto,shorten <=2em, shorten >=2em]}
\def\frommaps{\ar[from=uu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\frommapt{\ar[from=uuu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\C{\mathbf{C}}
\def\W{\mathbf{W}}
\def\S{\mathbf{S}}
\def\D{\mathbf{D}}
\def\E{\mathbf{E}}
\def\M{\mathbf{M}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\tri{\triangleright}
\def\o{\circ}
\def\rctx{\,\mathsf{ctx}}
\def\rdctx{\,\mathsf{dctx}}
\def\del{\partial}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\null{\emptyset}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\definecolor{fib}{HTML}{ff7f00}
\definecolor{green}{HTML}{007f00}
\definecolor{red}{HTML}{df3f3f}
\definecolor{opfib}{HTML}{007fff}

% For lightening colors I used
% http://trycolors.com/ 6 parts white to 1 part color
\definecolor{opfibl}{HTML}{DBEDFF}
\definecolor{greenl}{HTML}{DBEDDB}
\definecolor{redl}{HTML}{FAE4E4}
\def\njudge#1{\fcolorbox{opfib}{white}{#1}}
\def\nrule#1{\fcolorbox{white}{opfibl}{#1}}
\def\neqn#1{\fcolorbox{white}{redl}{#1}}



\def\judge#1{\vskip 2em\noindent \njudge{$#1$}\vskip 0.5em\noindent}
\def\rule#1{\vskip 2em \noindent \nrule{$#1$}\vskip 0.5em\noindent}
\def\eqn#1{\vskip 2em \noindent \neqn{$#1$}\vskip 0.5em\noindent}
\def\prof{\nrightarrow}
\def\tensor{\otimes}
\def\htensor{\mathrel{\hat\otimes}}
\def\lol{\multimap}
\def\hlol{\mathrel{\hat\multimap}}
\def\wtf{{\color{red}???}}

\def\re{\mathbf{E}}
\def\shp{\mathrel{\sharp}}
\def\zero{\texttt{0}}
\begin{document}

\def\
\tikzset{
   commutative diagrams/.cd,
   arrow style=tikz,
   diagrams={>=stealth}}

\section{Modalities Between Presheaf Kinds}


I want to consider contexts consisting of only interval variables
\[\begin{tabular}{lc@{$\quad::=\quad$ }l}
Interval Contexts&$\Delta$&$\cdot \celse \Delta, x : \sharp n$\\
\end{tabular}\]
And talk about $\rtype_\Delta$ as the kind of types which is the functor
category from $\Delta$ to the category of types and functions between them.

Knowledge about the categorical constructions available in presheaf categories
makes me confident that I can declare
\[
\erule
{\Gamma \prov A : \rtype_\Delta \qquad \Gamma, x :_\Delta A \prov B : \rtype_\Delta}
{\Gamma \prov (x : A) \to B : \rtype_\Delta}
\]
At least as long as $\Gamma$ is only full of $x :_\Delta A$, with the formation rule
for contexts being something like
\[
\erule
{\prov \Gamma \rctx \qquad \Gamma\prov A :\rtype_\Delta}
{\prov (\Gamma, x :_\Delta A)\rctx}
\]
But I want to allow mixing of contexts somehow! Modalities like $F$ and $U$ are unary,
but I expect less trivial ways of accessing $\rtype_\Delta$ from $\rtype_{\Delta'}$,
owing to their intended meaning.

\[
\erule
{\Gamma \prov C, A_k : \rtype_\Delta \qquad \Gamma \prov f_k : C \to A_k}
{\Gamma \prov (C, A, f) \star \nu : \rtype_{\Delta, \nu : \sharp n}}
\]

\[
\erule
{\Gamma \prov A : \rtype_{\Delta, \nu : \sharp n} }
{\Gamma \prov \forall \nu . A : \rtype_{\Delta}}
\]

\[
\erule
{\Gamma \prov A : \rtype_{\Delta, \nu : \sharp n} }
{\Gamma \prov [\ep k / \nu] A : \rtype_{\Delta}}
\]

I expect it to be okay to populate the context with hypotheses whose
types are kinded with {\em smaller} $\Delta$s than the $\Delta$ of the
kind of the conclusion type, with a silent weakening going on.

This means the context formation rule might actually be more like
\[
\erule
{\prov \Gamma \rctx_\Delta \qquad \Gamma\prov A :\rtype_{\Delta'} \qquad \Delta' \le \Delta}
{\prov (\Gamma, x :_{\Delta'} A)\rctx_\Delta}
\]
I feel I should probably think of this `smaller than' relationship as being
mediated by a substitution
\[
\erule
{\prov \Gamma \rctx_\Delta \qquad \Gamma\prov A :\rtype_{\Delta'} \qquad  \Delta \prov \theta : \Delta'}
{\prov (\Gamma, x :_{\theta} A)\rctx_\Delta}
\]
is this right? --- $\Gamma$ was `smaller than $\Delta'$' in the premise,
then `smaller than $\Delta$' in the conclusion? Do I need to apply $\theta$ to it somehow?
Do I just want to make weakening explicit for the moment?
\[
\erule
{\prov   \Gamma \rctx_{\Delta} \qquad  \Delta' \prov \theta : \Delta}
{\prov \theta\Gamma  \rctx_{\Delta'}}
\qquad
\erule
{\Gamma\prov A :\rtype_{\Delta} \qquad  \Delta' \prov \theta : \Delta}
{\theta\Gamma \prov \theta A : \rtype_{\Delta'}}
\]
Actually, wait a minute --- this weakening principle already seems like it might be
the sort of `$\Delta$-polymorphism' that is the crux of why parametricity works.

For if I have
\[\Gamma \prov A : \rtype_\Delta\]
\[\Gamma, x :_\Delta A \prov B : \rtype_\Delta\]
\[\Gamma, x :_\Delta A \prov M :_\Delta A\]
which lets me form
\[\Gamma \prov \lambda x . M :_\Delta (x : A) \to B\]
then I should also have
\[\theta\Gamma \prov \theta(\lambda x . M) :_{\Delta'} \theta((x : A) \to B)\]
Actually maybe this isn't really the issue so much as what happens to the universe.
{\em When} a type is polymorphic over $\U$ it should be polymorphic over
coded things that stand for not just types, but $\rtype_\Delta$s in bigger contexts.

So what it feels like is going on is that we're considering the category of all possible
contexts $\Delta$ and the substitutions between them, and we're doing a kripke-ish thing
for functions with respect to that structure, not just with respect to the structure of
the current category $\Delta$.
We say in the syntax
\[
\erule
{}
{\Gamma \prov \U_\Delta : \rtype_\Delta}
\]
But let's think what happens when $\Delta$ is empty. We need to map $\U$ onto a type.
It's not going to be merely $\U$! It's going to be
\[(\Delta' : \rdctx) \x \U_{\Delta'}\]
because there's a unique morphism $\Delta' \prov \theta : \cdot$. In general,
we'd interpret $\U_\Delta$ as something smelling like
\[ \lambda (\delta : \Delta) . (\Delta' : \rdctx) (\Delta' \prov \theta : \Delta) \x \U_\Delta'(\theta \delta)\]
except I'm aware that's not quite type-correct yet.

\section{Equivocating about Syntax of Course}

I think there's not any fundamental difference between writing
things like
\[\Delta;\Gamma \prov M : A : \rtype\]
and
\[\Gamma \prov M :_\Delta A :_\Delta \rtype_\Delta\]
The latter is what I want to keep in mind --- that $\rtype_\Delta$ really is a different
thing from bare $\rtype$, and what it means is a $\Delta$-cube in $\rtype$ --- but
the former seems more lightweight to type in to the emacs buffer, and to read.

Most of the rules I write for ordinary connnectives just consist of
`stick a $\Delta$ out front', not even caring that $\Pi$ duplicates $\Delta$s in
its two branches. Maybe Dan was right that $\Delta$ is sort of... bunchy somehow,
or at least I have to conclude that $\Pi$ is additive.

The thing that occurs to me is that, for the universe, I might not only need
a type of codes for types, but also a type of codes for $\Delta$-shaped contexts.
And/or maybe I need to extend the kind of types that are allowed to appear in $\Delta$
to include products --- or tensors, or whatever.

I also need a type of interval type variables, I guess, $t$? Oof.
That's a lot of contexts, but I think it might make sense of the --- I
don't know how else to put it --- `$\Delta$ polymorphism' of the
universe of types, the fact that when you're polymorphic over a type, it might
be an ordinary type (relative to your current universe) or a larger cube, and that's
what actually gives us the ability to get parametricity free theorems.
\[\begin{tabular}{lc@{$\quad::=\quad$ }l}
Interval Type Variable Contexts&$\Omega$&$ \cdot \celse \Omega, t$\\
Interval Types&$\tau$&$ \sharp n \celse \tau_1 \tensor \tau_2 \celse t$\\
Interval Contexts&$\Delta$&$\cdot \celse \Delta, \nu : \tau$\\
\end{tabular}\]
Ok, so everywhere I don't mention $\Omega$, there's implicit $\Omega$s, maybe, and likewise implicit $\Delta$s.


\[
\erule
{\Omega \prov \tau : \ritype}
{\Omega;\Delta;\Gamma \prov \U_\tau : \rtype}
\]
No, wait, I can't have codes for interval types because recursion from expressions
back into interval contexts makes my head hurt. Maybe an explicit $\Sigma$
for interval types?
\[
\erule
{\Omega, t;\Delta;\Gamma \prov A : \rtype}
{\Omega;\Delta;\Gamma \prov \exists t . A : \rtype}
\qquad
\erule
{\Omega \prov \tau : \ritype \qquad \Omega;\Delta;\Gamma \prov M : [\tau/t]A}
{\Omega;\Delta;\Gamma \prov \pair t M : \exists t . A }
\]
This would let me construct concretely the interval type $\sharp 2$ to get a binary
relation parametricity theorem or something. I think what I mean
by ordinary polymorphism is then quantification over the type $\exists t . \U_t$.

So I think the idea is that $\U_\tau$ represents codes for type-cubes that are
`$\tau$ bigger' than the current $\Delta$. Which means, eek, maybe some duplication
of rules that consume variables from $\Delta$, to give them the ability to consume
{\em either} from the real $\Delta$ or the extension $\tau$? Like, for witness types,
something like
\[
\erule
{\Delta; \Gamma \prov C, A_k : \rtype \qquad \Delta; \Gamma, x : C \prov f_k : A_k}
{\Delta, \nu : \sharp n; \Gamma \prov (C,A,f) \star \nu : \rtype}
\]
becomes something like the pair of rules
\[
\erule
{\Delta; \Gamma \prov C, A_k : \U_{\tau} \qquad \Delta, \mu : \tau; \Gamma, x : \El{C}_{\mu} \prov f_k : \El{A_k}_\mu}
{\Delta, \nu : \sharp n; \Gamma \prov (C,A,f) \star \nu : \U_\tau}
\]
\[
\erule
{\Delta; \Gamma \prov C, A_k : \U_{\tau} \qquad \Delta, \mu : \tau; \Gamma, x : \El{C}_{\mu} \prov f_k : \El{A_k}_\mu}
{\Delta; \Gamma \prov (\_,\mu).(C,A,f) \star \mu : \U_{\tau\tensor \sharp n}}
\]
But this is becoming something of a notational disaster already. The expressions
of type $\U_\tau$ really want to be regarded as binding variables that collectively
have type $\tau$.

So let me try to not be scared of variables standing for contexts (!) and say
\[\begin{tabular}{lc@{$\quad::=\quad$ }l}
Interval Context Variables&$\Omega$&$ \cdot \celse \Omega, \delta : \rdctx$\\
Interval Contexts&$\Delta$&$\cdot \celse \Delta, \nu : \sharp n\celse \Delta, \delta$\\
Interval Substitutions&$\theta$&$\cdot \celse \theta[\ep k / \nu]\celse \theta[\sigma/\delta]$\\
\end{tabular}\]

Then the $\U$ and $\El{}$ formation rules are like
\[
\erule
{\Omega \prov \Delta' : \rdctx}
{\Omega;\Delta;\Gamma\prov \U_{\Delta'} :\rtype}
\qquad
\erule
{\Omega;\Delta;\Gamma \prov e : \U_{\Delta'} }
{\Omega;\Delta, \Delta';\Gamma\prov \El{e} :\rtype}
\]
and the small witness type formation rules go like
\[
\erule
{\Delta; \Gamma \prov C, A_k : \U_{\Delta'} \qquad \Delta, \Delta'; \Gamma, x : \El{C} \prov f_k : \El{A_k}}
{\Delta, \nu : \sharp n; \Gamma \prov (C, A, f) \star \nu : \U_{\Delta'}}
\]
\[
\erule
{\Delta; \Gamma \prov C, A_k : \U_{\Delta'} \qquad \Delta, \Delta'; \Gamma, x : \El{C} \prov f_k : \El{A_k}}
{\Delta; \Gamma \prov (C, A, f) \star \nu : \U_{\Delta', \nu : \sharp n}}
\]
with the understanding that expressions of type $\U_{\Delta'}$ get to refer
to bound variables in $\Delta'$. Could make this explicit by saying
$(|\Delta'|,\nu).(C, A, f)\star\nu$ or something like that.

Now I still intend to have
\[
\erule
{\Omega, \delta;\Delta;\Gamma \prov A : \rtype}
{\Omega;\Delta;\Gamma \prov \exists \delta . A : \rtype}
\qquad
\erule
{\Omega \prov \Delta' : \rdctx \qquad \Omega;\Delta;\Gamma \prov M : [\Delta'/\delta]A}
{\Omega;\Delta;\Gamma \prov \pair {\Delta'} M : \exists \delta . A}
\]

So that the thing I really quantify over to be polymorphic is $\exists \delta . \U_\delta$.

But there's still some risk of bad mutual recursion here, I think.
For I want to give some typing rule to $\bfst$ of such a pair, but how
do I do that? Is the $: \rdctx$ judgment sensitive to $\Gamma$ after all?

What I really need is some element type to exist
\[\Delta; \Gamma, c : \exists \delta. \U_\delta \prov \El{c} : \rtype\]
and I want $\El{c}$ to sort of be... $(\delta : \bfst c) \to \U_\delta$? Ish?
No, more like:
\[
\erule
{\[
{\Omega;\Delta;\Gamma \prov \bsnd c : \U_{\bfst c} }
\justifies
{\Omega;\Delta, \bfst c;\Gamma\prov \El{\bsnd c} :\rtype}
\]}
{\Omega;\Delta;\Gamma\prov \forall (\bfst c) . \El{\bsnd c} :\rtype}
\]
Assuming $c : \exists \delta . \U_\delta \in \Gamma$.

One major problem with this is the `phase separation violation' involving
$c$ appearing to the left of $\Gamma$ in the second line. Also it is interesting/weird
that I seem to want to use $\forall$ --- the kind of thing that depends on the interval
variable types having initial objects.

Anyway maybe the right thing is to characterize $\exists \delta .
\U_\delta$ directly after all? Not sure.

This phase separation issue pressures me back into wanting to interleave
ordinary and interval variables, which I don't like a lot.

\section{Do I really need $\U$ over all future types explicitly?}

Might it be enough to just talk about the $\U$ that doesn't extend
$\Delta$? Is the type --- the honest-to-goodness {\em type}, not a
cube of types --- $\forall \nu . A$ a good enough substitute for the
type $\nu : \sharp n \prov A$ that has a free interval variable?
\[
\erule
{}
{\Delta;\Gamma\prov \U :\rtype}
\qquad
\erule
{\Delta;\Gamma \prov e : \U }
{\Delta;\Gamma\prov \El{e} :\rtype}
\]
Large:
\[
\erule
{\Delta, \nu : \sharp n; \Gamma \prov  A : \rtype}
{\Delta; \Gamma \prov \forall \nu . A : \rtype}
\qquad
\erule
{\Delta, \nu : \sharp n; \Gamma \prov  M : A }
{\Delta; \Gamma \prov \susp \nu M : \forall \nu . A }
\]
\[
\erule
{\Delta;\Gamma \prov M : \forall \nu . A}
{\Delta, \nu : \sharp n;\Gamma \prov M \wat \nu :  A}
\qquad
\erule
{\Delta;\Gamma \prov M : \forall \nu . A}
{\Delta;\Gamma \prov M \wat \ep k :  [\ep k / \nu]A}
\]
Small:
\[
\erule
{\Delta, \nu : \sharp n; \Gamma \prov  A : \U}
{\Delta; \Gamma \prov \forall \nu . A : \U}
\qquad
\erule
{\Delta, \nu : \sharp n; \Gamma \prov  M : \El A }
{\Delta; \Gamma \prov \susp \nu M : \El {\forall \nu . A} }
\]
\[
\erule
{\Delta;\Gamma \prov M : \El{\forall \nu . A}}
{\Delta, \nu : \sharp n;\Gamma \prov M \wat \nu :  \El A}
\qquad
\erule
{\Delta;\Gamma \prov M : \El{\forall \nu . A}}
{\Delta;\Gamma \prov M \wat \ep k :  [\ep k / \nu]\El A}
\]
Witness types go like large:
\[
\erule
{\Delta; \Gamma \prov C, A_k : \rtype \qquad \Delta; \Gamma, x : C \prov f_k : A_k}
{\Delta, \nu : \sharp n ; \Gamma \prov (C, A, f) \star \nu : \rtype}
\]
\[
\erule
{\Delta; \Gamma \prov M : C}
{\Delta, \nu : \sharp n ; \Gamma \prov M \star \nu : (C, A, f) \star \nu}
\]
\[
\erule
{\Delta, \nu : \sharp n ; \Gamma \prov M  : (C, A, f) \star \nu}
{\Delta; \Gamma \prov \ssusp \nu M : C}
\]
and small:
\[
\erule
{\Delta; \Gamma \prov C, A_k : \U \qquad \Delta; \Gamma, x : \El C \prov f_k : \El{A_k}}
{\Delta, \nu : \sharp n ; \Gamma \prov (C, A, f) \star \nu : \U}
\]
\[
\erule
{\Delta; \Gamma \prov M : \El C}
{\Delta, \nu : \sharp n ; \Gamma \prov M \star \nu : \El {(C, A, f) \star \nu}}
\]
\[
\erule
{\Delta, \nu : \sharp n ; \Gamma \prov M  : \El {(C, A, f) \star \nu}}
{\Delta; \Gamma \prov \ssusp \nu M : \El C}
\]
So nothing seems to do anything unexpected yet?
Let's try running through the usual dance.
Suppose we have $g : (\alpha : \U) \to \El \alpha \to \El \alpha$.
Suppose we have $C : \U$ and $A, B : \U$ and $f_1 : \El C \to \El{A}$
and $f_2 : \El C \to \El{B}$.
Further, we have an element $e : \El C$. We want to see that $g\ [A]\ (f_1\ c)$
and $g\ [B]\ (f_2 \ c)$ are related by the relation.

We first notice that $\nu : \sharp n \prov (C, A, f) \star \nu : \U$.
So also $\prov \forall \nu . (C, A, f) \star \nu : \U$.
The element $e : \El C$ gives us $\nu : \sharp n \prov e \star \nu : \El{(C, A, f) \star \nu}$
and then we have $\prov \susp \nu ( e \star \nu) : \El{\forall \nu . (C, A, f) \star \nu}$.

So
\[\prov g\ (\forall \nu . (C, A, f) \star \nu)\ (\susp \nu ( e \star \nu)) : \El{\forall \nu . (C, A, f) \star \nu}\]
and we can eliminate the variable to get
\[\nu : \sharp n \prov g\ (\forall \nu . (C, A, f) \star \nu)\ (\susp \nu ( e \star \nu)) \wat \nu : \El{(C, A, f) \star \nu}\]
and witness-eliminate it again to get
\[ \prov \ssusp \nu (g\ (\forall \nu . (C, A, f) \star \nu)\ (\susp \nu ( e \star \nu)) \wat \nu) : \El{C}\]

So that's our element call it $c_0$, of $\El C$ that supposedly proves that
$g\ [A]\ (f_1\ c)$ and $g\ [B]\ (f_2 \ c)$ are related by the
relation. How do we establish that it's actually them that it relates?

We need to have the equality
\[f_k (\ssusp \nu  e) \equiv [\ep k/\nu] e : A_k\]
but this follows from $\eta$-expanding $e$ in
\[f_k (  e) \equiv [\ep k/\nu] (e \star \nu) : A_k\]
but given that, we find that $f_1\ c_0 = [\ep 1 / \nu](g\ (\forall \nu . (C, A, f) \star \nu)\ (\susp \nu ( e \star \nu)) \wat \nu)$
\[ = g\  (\forall \nu . (C, A, f) \star \nu)\ (\susp \nu ( e \star \nu)) \wat \ep 1\]
and I guess this is where I get stuck. I want to actually deal with the open type
\[  g\  ((C, A, f) \star \nu)\  ( e \star \nu) \]
So I can substitute $\ep 1$ for $\nu$ and get
\[  g\   A\  ( f_1\  e) \]
\subsection{But Is This All Still Ok?}
Maybe I can still get by phase-separating variables like this.

Let me start from the top:
Suppose we have $g : (\alpha : \U) \to \El \alpha \to \El \alpha$.
Suppose we have $C : \U$ and $A, B : \U$ and $f_1 : \El C \to \El{A}$
and $f_2 : \El C \to \El{B}$.
Further, we have an element $e : \El C$. We want to see that $g\ [A]\ (f_1\ c)$
and $g\ [B]\ (f_2 \ c)$ are related by the relation.

I can show
\[\nu : \sharp n \prov  e \star \nu : \El{ (C, A, f) \star \nu}\]
I still have, by weakening, that
$\nu : \sharp n\prov g : (\alpha : \U) \to \El \alpha \to \El \alpha$, so
\[\nu : \sharp n \prov g\ ((C, A, f) \star \nu)\ (e \star \nu) : \El{ (C, A, f) \star \nu}\]
thence
\[ \prov \ssusp \nu (g\ ((C, A, f) \star \nu)\ (e \star \nu)) : \El{ C}\]
Call {\em that} my $c_0$. What then is $f_1(c_0)$? Well, it's
\[ [\ep 1/\nu](g\ ((C, A, f) \star \nu)\ (e \star \nu)) = g\ A\ (f_1\ e) \]
So that looks great!
\subsection{Whatever Happened to $\sharp$-elim?}
If I have a
\[\Delta, \nu : \sharp n; x : A \prov M : B\]
I can derive from it
\[\Delta; x : [\ep k/\nu]A \prov [\ep k/\nu]M : [\ep k/\nu]B\]
and also
\[\Delta, \nu : \sharp n; y : \forall \nu . A \prov [y \wat \nu / x]M : [y \wat \nu / x]B\]
I want to believe that these have essentially exactly all the information
of the original $M$.
\[
\erule
{\begin{tabular}{c}
$\Delta; x : [\ep k / \nu] A \prov M_k : [\ep k / \nu] B$\\
$\Delta, \nu :\sharp n; y : \forall \nu. A \prov N : [y\wat \nu / x] B$\\
$[y \wat \ep k / x]M_k \equiv [\ep k / \nu] N$
\end{tabular}}
{\Delta, \nu :\sharp n; x :  A \prov \bcase \cdots :  B}
\]

\section{Rechecking Semantics with Phase Separation}
So I think I should be able to phrase the `syntactic semantics' in such a way
that it works with $\Delta$-contexts all the way out left.
Not sure how much Kripke-ing I need to do, but it seems like the right
amount in the right places ought to work.

If $\Delta$ is a $\rdctx$, then $\sem\Delta$ is a category and $\delta \in \Delta_\bullet$
 denotes a generic object in that category and $\phi \in \Delta_{\delta \to \delta'}$ a
generic morphism.

We still expect all of
\begin{thmbox}
  If $\Delta\prov  \Gamma: \rctx$ then $ \prov \Gamma_\delta : \rtype$.\\
  If $\Delta\prov  \Gamma: \rctx$ then $\gamma : \Gamma_{\delta} \prov \Gamma_\phi(\gamma) : \Gamma_{\delta'}$.\\
  If $\Delta; \Gamma\prov A: \rtype$ then $ \gamma : \Gamma_\delta \prov A_\delta(\gamma) : \rtype$.\\
  If $\Delta; \Gamma\prov A: \rtype$ then
$ \gamma : \Gamma_\delta, x : A_\delta(\gamma) \prov A_\phi(x) : A_{\delta'}(\Gamma_\phi(\gamma)) $.
  If $\Delta; \Gamma\prov M: A$ then $ \gamma : \Gamma_\delta \prov M_\delta(\gamma) : A_\delta(\gamma)$.\\
  If $\Delta; \Gamma\prov M: A$ then
$\gamma : \Gamma_\delta \prov A_\phi(M_\delta(\gamma)) \equiv M_{\delta'}(\Gamma_\phi(\gamma))$.
\end{thmbox}
\noindent to hold. How do substitutions $\Delta' \prov \theta : \Delta$ interact
with these? Not clear to me yet. But it seems like it might be
essential? For although it's syntactically obvious that weakening (for example) works,
and general $\Delta$-substitutions work, I still need to justify them semantically, don't I?
Or at least show at some point that syntactic substitution is compatible with some semantic
operation.

One important nontrivial thing is that $\forall$ gets interpreted as a $0$-substitution.
\[
\erule
{\Delta, \nu : \sharp n; \Gamma \prov  A : \rtype}
{\Delta; \Gamma \prov \forall \nu . A : \rtype}
\qquad
\erule
{\Delta, \nu : \sharp n; \Gamma \prov  M : A }
{\Delta; \Gamma \prov \susp \nu M : \forall \nu . A }
\]
\[
\erule
{\Delta;\Gamma \prov M : \forall \nu . A}
{\Delta, \nu : \sharp n;\Gamma \prov M \wat \nu :  A}
\qquad
\erule
{\Delta;\Gamma \prov M : \forall \nu . A}
{\Delta;\Gamma \prov M \wat \ep k :  [\ep k / \nu]A}
\]
\begin{defnbox}
  $(\forall \nu . A)_\delta(\gamma) = A_{\delta, \ep 0}(\gamma)$\\
  $(\forall \nu . A)_\phi(x) = A_{\phi, \rid_{\ep 0}}(\gamma)$\\
  $(\susp \nu M)_\delta(\gamma) = M_{\delta, \ep 0}(\gamma)$\\
  $(M \wat \nu)_{\delta,\ep k}(\gamma) = A_{\rid_\delta, !_k}(M_\delta(\gamma))$\\
  $(M \wat \ep k)_{\delta}(\gamma) = A_{\rid_\delta, !_k}(M_\delta(\gamma))$
\end{defnbox}
%% For this to even make sense I already have to have a theorem that
%% \begin{thmbox}
%% $  ([\ep k/\nu]A)_\delta(\gamma) = A_{\delta, \ep k}(\gamma)$
%% \end{thmbox}

Where we are doing some silent weakening of $\gamma : \Gamma_\delta$
to $\gamma : \Gamma_{\delta, \ep 0}$. If we were explicit about this,
then $\Delta, \nu : \sharp n \prov \theta : \Delta$ is
 the weakening substitution, and we're relying on the fact that we can
 convert $\gamma : \Gamma_{\theta(\delta, \ep 0)}$ to
$\sem \theta \gamma : \Gamma_{\delta, \ep 0}$. In general, if
$\Delta' \prov \theta : \Delta$ and $\Delta \prov \Gamma \rctx$
and $\delta'$ is some choice of objects in $\Delta'$,
which we might reasonably think of as a substitution $\cdot \prov \delta' : \Delta'$
out of the empty context,
then we should be able to take $\gamma : \Gamma_{ \delta' \o \theta}$ to
$\sem \theta \gamma : (\theta \Gamma)_{\delta'}$.
\subsection{Getting Away With Less Complexity?}
Can I just define $M_\delta$ only at the $0$-object of the category $\Delta$?
There's some sense in which it feels like I shouldn't need to define how
$M_\delta$ looks for every type, as it ought to follow from what $A_\phi$ is. But
that's... what the theorem about the interaction between $A_\phi$ and $\Gamma_\phi$ says,
after all.

Maybe what I'm conjecturing is that {\em defining $M_{\ep 0}$ never requires recursive
computation of general $M'_\delta$ for subterms $M'$, merely of $M'_{\ep 0}$ }

This would mean the theorems would
be
\begin{thmbox}
  If $\Delta\prov  \Gamma: \rctx$ then $ \prov \Gamma_\delta : \rtype$.\\
  If $\Delta\prov  \Gamma: \rctx$ then $\gamma : \Gamma_{\delta} \prov \Gamma_\phi(\gamma) : \Gamma_{\delta'}$.\\
  If $\Delta; \Gamma\prov A: \rtype$ then $ \gamma : \Gamma_\delta \prov A_\delta(\gamma) : \rtype$.\\
  If $\Delta; \Gamma\prov A: \rtype$ then
$ \gamma : \Gamma_\delta, x : A_\delta(\gamma) \prov A_\phi(x) : A_{\delta'}(\Gamma_\phi(\gamma)) $.
  If $\Delta; \Gamma\prov M: A$ then $ \gamma : \Gamma_0 \prov M_\bullet(\gamma) : A_0(\gamma)$.
\end{thmbox}
Can I recover $M_\delta(\gamma)$ from this setup? I would have
$ \gamma : \Gamma_\delta \prov M_\delta(\gamma) : A_\delta(\gamma)$
and I do have a unique arrow ${!} : 0 \to \delta$, so I can construct
$\gamma : \Gamma_0 \prov A_!(M_\bullet(\gamma)) : A_\delta(\Gamma_!(\gamma))$.
which is strictly weaker.
So maybe this shortcut is no good!

\section{Questioning the Value of Phase Separation}

If I am to be able to state a Segal condition for types that support
all $\bpull$s, I'll need to quantify internally over natural numbers
in a way that's logically prior to hypothesizing interval variables,
which seems to make me want to mix up the context again. I can at
least more clearly see what kind of exchange principles I think I want
now, though. It's mostly the necessary weakening when exchanging in
the other direction that's clear.

When we (on the way up) move an ordinary type {\em into} the scope
of an interval variable, we need to weaken it.
\[
\erule
{\Gamma, \nu : \sharp n, x : A^w \prov J}
{\Gamma, x : A, \nu : \sharp n \prov J }
\]
When we move it {\em out} of the scope of an interval variable, we
are licensed to break it up into its components.
\[
\erule
{\begin{tabular}{c}
$\Gamma, x : [\ep k/ \nu]A \prov M_k : [\ep k/ \nu]B$\\
$\Gamma, y : \forall \nu . A, \nu : \sharp n \prov N : [y\ \nu/x]B$\\
$[y\ \ep k/x]M_k \equiv [\ep k/\nu]N$
\end{tabular}}
{\Gamma, \nu : \sharp n, x : A^w \prov  \bcase \cdots : B}
\]
How can I semantically account for nat variables being depended on?
A context gets interpreted as... a category, maybe? Let's do some
examples.
A context like $\nu: \sharp 2, x : A$ should get interpreted
as three sets for $[\ep 0/\nu]A$ and $[\ep 1/\nu]A$ and $[\ep 2/\nu]A$
and two functions $[\ep 0/\nu]A \to [\ep 1/\nu]A$ and
$[\ep 0/\nu]A \to [\ep 2/\nu]A$. A context like
$n : \N, \nu: \sharp n, x : A$ has an interpretation which looks like
the dependent sum of the interpretations of $\nu : \sharp 0, x : A$
and $\nu : \sharp 1, x : A$ and $\nu : \sharp 2, x : A$ and so on.

\end{document}
%% \[
%% \erule
%% {\Gamma , x : A \prov M : B}
%% {\Gamma \prov \lambda x . M : (x : A) \to B}
%% \]
