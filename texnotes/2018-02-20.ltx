\documentclass{article}
\input{theorem}
\input{prooftree}
\usepackage{stmaryrd}
\usepackage{latexsym}
\usepackage{yfonts}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,cd,decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}
\usepackage{tcolorbox}
\tcbuselibrary{breakable}


\def\El#1{\mathsf{El}({#1})}
\def\quote#1{{\ulcorner {#1} \urcorner}}
\def\U{\mathsf{U}}
\def\uni{\U}
\def\mor#1#2{#1 \to \underline{#2}}

\def\ridp{\mathsf{idp}}
\def\fc{\mathfrak{C}}
\def\ff{\mathfrak{F}}
\def\ssem#1{\langle\!\langle{#1}\rangle\!\rangle}

\definecolor{cyan}{rgb}{0.80,0.95,0.95}
\definecolor{orange}{rgb}{0.95,0.90,0.80}
\definecolor{lred}{rgb}{0.95,0.8,0.8}
\definecolor{lgray}{gray}{0.9}
\newtcolorbox{declbox}{colframe=lred,colback=lred,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{thmbox}{colframe=cyan,colback=cyan,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{defnbox}{colframe=orange,colback=orange,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{tangentbox}{colframe=lgray,colback=lgray,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}

\input{linear}
\def\rpath#1{[#1]}
\def\rfst{\mathsf{fst}\,}
\def\rsnd{\mathsf{snd}\,}
\def\bunfold{\mathbf{unfold}}
\def\bfold{\mathbf{fold}}
\def\susp#1{\langle {#1} \rangle}
\def\ssusp#1{\langle\!\langle {#1} \rangle\!\rangle}
\def\dto{\mathrel{\dot\to}}
\def\dns{{\downarrow}}
\def\ups{{\uparrow}}
\def\sprov{\Vdash}
\def\signat{{\color{red}\Sigma}}

\def\wat{\mathbin{@}}
\def\wwat{\mathbin{\underline\wat}}
\def\cn{{:}}
\def\dv{{\div}}
\def\ww{{\mathsf w}}
\def\base{{\textfrak b}}

\def\N{{\mathbb N}}
\def\munit{I}
\def\tt{{\mathsf t}}
\def\rr{{\mathsf r}}
\def\ii{{\mathbb I}}
\def\pp{\textsf{\textbf p}}
\def\nn{{\mathsf n}}
\def\PP{\textsf{\textbf P}}
\def\NN{{\mathsf N}}
\def\zz{{\mathsf z}}
\def\sem#1{[\![#1]\!]}
\def\usem#1{\lceil\!\!\lceil{#1}\rceil\!\!\rceil}
\def\zem#1{\langle\!\langle#1\rangle\!\rangle}
\def\col#1{{\mathsf{C}}_{#1}}
\def\lax{\mathop\bigcirc}
\def\rjust{\mathsf{just}}
\def\rcvt{\mathsf{cvt}}
\def\rtype{\mathsf{type}}
\def\rkind{\mathsf{kind}}
\def\rmode{\mathsf{mode}}
\def\rprel{\mathbf{Prel}}
\def\rrfam{\mathbf{Rfam}}
\def\rset{\mathbf{Set}}
\def\rfinset{\mathbf{FinSet}}
\def\rrel{\mathbf{Rel}}
\def\rcat{\mathbf{Cat}}
\def\rfam{\mathbf{Fam}}
\def\binj{\mathbf{inj}}
\def\rid{\mathsf{id}}
\def\rtrue{\mathrel\mathrm{true}}
\def\pbck{\ar[dr, phantom, pos=0, "\lrcorner"]}
\def\bpbck{\ar[ddrr, phantom, pos=0, "\lrcorner"]}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\btwo{\mathbf{2}}
\def\bone{\mathbf{1}}

\newarrow {Equiv} =====
\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\def\mapt{\ar[ddd,mapsto,shorten <=2em, shorten >=2em]}
\def\frommaps{\ar[from=uu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\frommapt{\ar[from=uuu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\C{\mathbf{C}}
\def\W{\mathbf{W}}
\def\S{\mathbf{S}}
\def\D{\mathbf{D}}
\def\E{\mathbf{E}}
\def\M{\mathbf{M}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\tri{\triangleright}
\def\o{\circ}
\def\rctx{\,\mathsf{ctx}}
\def\del{\partial}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\null{\emptyset}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\definecolor{fib}{HTML}{ff7f00}
\definecolor{green}{HTML}{007f00}
\definecolor{red}{HTML}{df3f3f}
\definecolor{opfib}{HTML}{007fff}

% For lightening colors I used
% http://trycolors.com/ 6 parts white to 1 part color
\definecolor{opfibl}{HTML}{DBEDFF}
\definecolor{greenl}{HTML}{DBEDDB}
\definecolor{redl}{HTML}{FAE4E4}
\def\njudge#1{\fcolorbox{opfib}{white}{#1}}
\def\nrule#1{\fcolorbox{white}{opfibl}{#1}}
\def\neqn#1{\fcolorbox{white}{redl}{#1}}



\def\judge#1{\vskip 2em\noindent \njudge{$#1$}\vskip 0.5em\noindent}
\def\rule#1{\vskip 2em \noindent \nrule{$#1$}\vskip 0.5em\noindent}
\def\eqn#1{\vskip 2em \noindent \neqn{$#1$}\vskip 0.5em\noindent}
\def\prof{\nrightarrow}
\def\tensor{\otimes}
\def\htensor{\mathrel{\hat\otimes}}
\def\lol{\multimap}
\def\hlol{\mathrel{\hat\multimap}}
\def\wtf{{\color{red}???}}

\def\re{\mathbf{E}}
\def\shp{\mathrel{\sharp}}
\def\zero{\texttt{0}}
\begin{document}

\def\
\tikzset{
   commutative diagrams/.cd,
   arrow style=tikz,
   diagrams={>=stealth}}

\section{What I Currently Think About the Presheaf Category}

An {\em $n$-endpointed interval} (or just {\em $n$-interval})
 in a monoidal category (whose monoidal unit is named $u$) is an object $\ii$ with arrows
$m_1, \ldots, m_n,e$ such that
\[
\begin{tikzcd}
 u \ar[d, "m_i"']\ar[dr, equal]\\
 \ii \ar[r, "e"'] & u
\end{tikzcd}
\]
for every $i \in 1, \ldots n$.

The bag of examples for the choice of $\C$ in $\rset^{\C^\op}$ that
are relevant for cubical-ish type theories are
\begin{itemize}
\item $\C_\bullet$, the free monoidal category on an $n$-interval.
\item $\C_\tensor$, the free symmetric monoidal category on an
  $n$-interval.
\item $\C_\x$, the free finite product category on an $n$-interval.
\end{itemize}
We can characterize these dually as

\begin{itemize}
\item $\C_\bullet^\op$: the
  category whose objects are natural numbers and whose morphisms
  $a \to b$ are {\bf order-preserving partial injections} $a \to b + n$.
\item $\C_\tensor^\op$: the category whose objects are natural
  numbers and whose morphisms $a \to b$ are {\bf partial injections}
  $a \to b + n$.
\item $\C_\x^\op$: the category whose objects are natural numbers and whose
  morphisms $a \to b$ are {\bf functions} $a \to b + n$.
\end{itemize}
What we mean precisely by the `free monoidal category on an $n$-interval' is that
we consider the adjunction
\[
\begin{tikzcd}
\rcat_*\ar[r,shift left=2.3,"F",""{name=A, below}] &
 \mathbf{MonCat}\ar[l,shift left=2.3,"U",""{name=B,above}]
\ar[from=A, to=B, "\dashv", phantom, sloped]
\end{tikzcd}
\]
where $U$ forgets monoidal structure except that it takes the monodial
unit to the distinguished object of its output in $\rcat_*$, and apply
$F$ to the two-object pointed category induced by the above diagram,
such the distinguished object is $u$. Proceed similarly for the other two
categories, substituting the category of symmetric monoidal categories
or finite product categories.


\subsection{Generalization to Multiple Simultaneous Arities}
I want to have not just one $\ii$ of arity $n$, I want to have objects
 $\sharp n$ of all arities at once so I can talk about pushes.

The thing missing from any of the above sites is an arrow $\ii \to \ii$
that permutes the $n$ endpoints. I'm going to implicitly do that below now.

Let $\W$ be the category that I was trying to get at in \texttt{2017-11-04.ltx}.
It looks a lot like $\rfinset$ except with an additional terminal object.
Its objects are $\{\top, 0, 1, 2, 3, \ldots\}$. A morphism $m \to n$
for $m,n\in\N$ is either a function $m\to n$ or an element of $n$, written $( i) !$
for $i< n$. A morphism $\top \to n$ is an element of $n$ written $(i)$. There is
a unique morphism $n \to \top$, written $!$. Composition of functions between
naturals works like normal, and we have $(i) \o ! = (i)!$ and $!(i) = \rid_\top$.
\[
\W =\qquad
\begin{tikzcd}
\sharp 0\ar[r]\ar[d, "!"']
& \sharp 1\ar[d, "!", shift left]\ar[from=d, "(0)", shift left]
\ar[r, shift left]\ar[r, shift right]\ar[from=r, shift right=3]
& \sharp 2\ar[d, "!", shift left]\ar[from=d, "{(0)\atop (1)}" , shift left]
\ar[from=d]
\ar[r, leftrightarrow]\ar[r, shift right, leftrightarrow]\ar[r, shift left, leftrightarrow]
&\cdots
\\
\top \ar[r, equal]
& \top\ar[r, equal]
& \top\ar[r, equal]
& \cdots
\end{tikzcd}
\]

I think I'm interested in considering type theory interpreted into
presheaves over the free (monoidal, symmetric monoidal, finite
product) category on $\W$ with $\top$ as monoidal unit.

\subsection{Is this the same as the pullback definition?}

In \texttt{wes/agda/BaseCategory.agda} I'm describing a category
where the objects are the same as those in $\rset^\to$, but the morphisms
from $f : A_1 \to A_2$ to $g : B_1 \to B_2$ are choices of $h$ and $k$ such that

\[
\begin{tikzcd}
  A_1\ar[from=d, "h"]\ar[dr, "f"]\\
X\pbck\ar[r]\ar[d]&A_2\ar[d, "k"]\\
B_1+1\ar[r, "g+1"'] & B_2+1
\end{tikzcd}
\]
Although in \texttt{module Take2} in there, it's
described as a function
\[(a : A_2) \to (\beta : B_2 + 1) \x \texttt{Out}\ \beta \to f^*(a)\]
where
\[ \texttt{Out}\ \binr = \top \]
\[ \texttt{Out}\ (\binl b) = g^*(b) \]

I think without further restriction, the dual of this category is the
free finite product category on $\W$. If I restrict $k$ to be partial
injective or ordered partial injective, then perhaps it's the free
symmetric monodial or monoidal category on $\W$. Why? All of these
free categories have objects like $\sharp 1, \sharp 2, \sharp 3$, etc.
and let me tensor them together. So I can make morphisms like
\[
\begin{tikzcd}
  \sharp 2 \ar[d]
&[-2em] \tensor
&[-2em] \sharp 2 \ar[d, "\sim"]
&[-2em] \tensor
&[-2em] \sharp 1 \ar[d]
&[-2em] \tensor
&[-2em] \sharp 1 \ar[d]\\
  \sharp 2
&[-2em] \tensor
&[-2em] \sharp 2
&[-2em] \tensor
&[-2em] \sharp 1
&[-2em] \tensor
&[-2em] \sharp 1
\end{tikzcd}
\]
where $\sim$ is $0 \mapsto 1, 1 \mapsto 0$, (and all the rest of the morphisms are identities) and
\[
\begin{tikzcd}
  \sharp 2 \ar[d]
&[-2em] \tensor
&[-2em] \sharp 2 \ar[d]
&[-2em] \tensor
&[-2em] \sharp 1 \ar[d]
&[-2em] \tensor
&[-2em] \sharp 1 \ar[d, "!"]\\
  \sharp 2
&[-2em] \tensor
&[-2em] \sharp 2
&[-2em] \tensor
&[-2em] \sharp 1
&[-2em] \tensor
&[-2em] \top
\end{tikzcd}
\]
which is like a nonsurjective morphism in the dual category, and
\[
\begin{tikzcd}
  \sharp 2 \ar[d]
&[-2em] \tensor
&[-2em] \top \ar[d, "{(5)}"]
&[-2em] \tensor
&[-2em] \sharp 1 \ar[d]
&[-2em] \tensor
&[-2em] \sharp 1 \ar[d]\\
  \sharp 2
&[-2em] \tensor
&[-2em] \sharp 7
&[-2em] \tensor
&[-2em] \sharp 1
&[-2em] \tensor
&[-2em] \sharp 1
\end{tikzcd}
\]
which as a morphism $(A_1 \to A_2) \to (B_1 \to B_2)$ is like
deciding that the element $a \in A_2$ that represents $\sharp 7$ (and so has a 7-element fiber $f^*(a)$ sitting in $A_1$) gets
mapped to $\binr$ in $B_2 + 1$, and $(\binr, a) \in X$ gets mapped to $5 \in f^*(a)$ by $h$.

\section{Revisiting the Semantics with Just Bernardy-Moulin $\ii$}

\subsection{A Relation on $A$}
What's the interpretation of $\sem {A \to \U}^\Gamma_I$ for an arbitrary
$I$ in the abstract category (i.e. the functor category we're
considering is {\em covariant} in this category) of finite sets and
partial injections?

This assumes $\Gamma \prov A : \rtype$. We have
\[ \sem {A \to \U}^\Gamma_I : (\rho : \sem \Gamma_I) \to  \rset\]
and
\[ \sem {A \to \U}^\Gamma_I = \lambda (\rho : \sem \Gamma_I) .  (f : I \to J)  (a : \sem A^\Gamma_J\sem \Gamma_f(\rho))  (g : J \to K) . \U\]

I need to disabuse myself of the notion that $\sem U^\Gamma_I$ is the
same at every $I$ just because it doesn't mention any
`$\ii$-machinery'. Because it works out to be $\forall (J \ge I) . \U$,
the `size' of the family of sets I need to choose depends on the
object I start at. It is still, the case, then, I think, that it's
`the same' at every $\Gamma$, though, because it's a closed type?
I need to be careful about what I mean by that, since $\sem A^{\Gamma_1}_I$
and $\sem A^{\Gamma_2}_I$ have different types. But if $A$ makes sense in the empty context,
and thus $\sem A^{\cdot}_I : (\rho : \sem \cdot_I) \to \rset$ makes sense,
then  $\sem A^{\cdot}_I$ must be of the form $\lambda \_ . \mathcal{A}(I)$
for some presheaf $\mathcal{A}(I) : \rset$. I can apply a weakening substitution
to see that $\Gamma\prov A : \rtype$, but surely some suitable comptability theorem
entails that $\sem A^{\Gamma}_I = \lambda \_ . \mathcal{A}(I)$ also, I think. \textcolor{red}{???}

Might need to nail down what that principle is to actually understand
the isomorphism going on here.
\subsection{Path In the Universe}

Okay, how about $\sem{ \forall i . \U}^\Gamma_I$?
We still have
\[ \sem{ \forall i . \U}^\Gamma_I : (\rho : \sem \Gamma_I) \to \rset \]
so according to the guesses I made earlier in \texttt{2018-02-09.ltx} this should be
\[ \sem{ \forall i . \U}^\Gamma_I = \lambda (\rho : \sem \Gamma_I) .
\sem \U^{\Gamma, i : \ii}_{I, i}(\binr(i \in (I, i), \rho))
\]
recalling that
\[\sem{\Gamma, i:\ii}_I = \sem \Gamma_I + \sum_{k \in I} \sem \Gamma_{I \setminus k}\]
but $\sem\U$ is going to discard that argument, so this is
\[ \sem{ \forall i . \U}^\Gamma_I = \lambda (\rho : \sem \Gamma_I) .
(f : (I,i) \to J) \to \U
\]
Alright, suppose I have one of these things, how do I apply it to the
endpoint $\zero$? Oh, it looks like I didn't consider this case in
\texttt{2018-02-09.ltx}, only the case where you're applying to an
interval-valued variable. Let me do it now.
\subsubsection{Semantically Applying An Expression to $\zero$}
Syntactically, from $\Gamma \prov M : \forall i . A$ we infer
$\Gamma \prov M \wat \zero : [\zero/i]A$.
Semantically, suppose we have
$\sem M^\Gamma_I : (\rho : \sem \Gamma_I) \to \sem{\forall i . A}^\Gamma_I$,
and our goal is to obtain
\[\sem {M\wat\zero}^\Gamma_I : (\rho : \sem \Gamma_I) \to \sem{[\zero/i] A}^\Gamma_I(\rho)\]
Expanding definitions, what we have is
\[\sem M^\Gamma_I : (\rho : \sem \Gamma_I) \to \sem A^{\Gamma, i : \ii}_{I, i}(\binr(i\in (I, i), \rho))\]

and I can take a projection
\[\sem A^{\Delta}_{i : = \zero} : \{ \rho' :\sem \Delta_{I,i} \} \to \sem A^{\Delta}_{I, i}(\rho') \to \sem A^{\Delta}_I(\sem \Delta_{i:=\zero }(\rho')) \]
for $\Delta = \Gamma, i : \ii$ and apply it to what we have, and now we have
\[(\lambda \rho . \sem A^{\Delta}_{i:=\zero} \ \{\binr(i \in I, i), \rho\}\ \sem M^\Gamma_I(\rho))
: (\rho : \sem \Gamma_I) \to \sem A^{\Delta}_I(\binl  \rho)\]
and I totally expect that in general
\[\sem {[\zero/i]A}^\Gamma_I(\rho) \equiv \sem{A}^{\Gamma, i:\ii}_I(\binl \rho)\eqno(1)\]
so I'm pretty much done, I just set
\[ \sem {M \wat \zero}^\Gamma_I(\rho) = \sem A^{\Gamma, i : \ii}_{i:= \zero} \sem M^\Gamma_I(\rho) \eqno(2)\]
except that maybe I should be explicit that $(2)$ involves transport across $(1)$.

\subsubsection{Popping up the Stack}

Ok, suppose we have a $\Gamma \prov M : \forall i . \U$ which means
\[\sem M^\Gamma_I : (\rho : \sem \Gamma_I) \to \sem{\forall i .\U}^\Gamma_I(\rho)\]
\[\sem M^\Gamma_I : (\rho : \sem \Gamma_I) \to (f : (I, i) \to J) \to \U\]
then
\[\sem {M \wat \zero}^\Gamma_I = \sem \U_{i := \zero}^{\Gamma, i:\ii} \sem M^\Gamma_I(\rho) \]
So what we're doing is just taking the big morphism-indexed family of sets that
$\sem M^\Gamma_I$ is, and composing along the morphism $(i := \zero) : (I, i) \to I$.

We're supposed to have the typing
\[\sem {M \wat \zero}^\Gamma_I : (\rho : \sem \Gamma_I) \to (f : I \to J) \to \U\]
So yeah! If we're given a morphism $I \to J$, we compose it with $i  := \zero$ and feed it
to $\sem M^\Gamma_I$.

\subsubsection{How are these isomorphic?}
\section{Totally Unrelated Tangent About Monads}
Compile the language
\[
\erule
{}
{\Gamma \prov_1 \mathsf{some\_prim} :  \mathsf{int}}
\qquad
\erule
{\Gamma \prov_1 e : \bigcirc\tau}
{\Gamma \prov_1 [e] : \tau}
\qquad
\erule
{\Gamma \prov_1 e : \tau}
{\Gamma \prov_0 \{e\} : \tau}
\]
\[
\erule
{\Gamma \prov_i e_1 : \tau_1 \qquad \Gamma \prov_i e_2 : \tau_2}
{\Gamma \prov_i (e_1, e_2) : \tau_1 \x \tau_2}
\]

\begin{lemma}\ \\
If $\Gamma \prov_0 e : \tau$ then $\Gamma \prov \sem e :  \tau$.\\
If $\Gamma \prov_1 e : \tau$ then $\Gamma \prov \sem e : \bigcirc \tau$.
\end{lemma}

\begin{proof}

\cqed
\end{proof}

\end{document}





% garbage
If $A : *$ then $\usem A : A \to *$
\[\pi : \Pi A \cn * . \Pi a \cn A .  \usem A\ a\]
\[\sem \pi : \pi \in \sem{\Pi A \cn * . \Pi a \cn A .  \usem A\ a}   \]
\[\sem \pi : \Pi A \cn * .\Pi \dot A \cn A \to * . \pi\ A \in \sem{ \Pi a \cn A .  \dot A\ a}   \]
\[\sem \pi : \Pi A \cn * .\Pi \dot A \cn A \to * .  \Pi a \cn A .  \Pi \dot a \cn \dot A(a) .\pi\ A \in \sem{  \dot A\ a}   \]
\[\sem \pi : \Pi A \cn * .\Pi \dot A \cn A \to * .  \Pi a \cn A .  \Pi \dot a \cn \dot A(a) .  \sem{  \dot A\ a} (\pi\ A)  \]
\[\sem \pi : \Pi A \cn * .\Pi \dot A \cn A \to * .  \Pi a \cn A .  \Pi \dot a \cn \dot A(a) . \sem {\dot A}\ a\ \sem a\ (\pi\ A)\]
\[\sem \pi : \Pi A \cn * .\Pi \dot A \cn A \to * .  \Pi a \cn A .  \Pi \dot a \cn \dot A(a) . \usem {\dot A}\ a\ \dot a\ (\pi\ A)\]
\[\sem{ \dot A} : \dot A \in \sem {A \to *}\]
\[\sem{ \dot A} : \Pi a \cn A . \Pi \dot a \cn \dot A(a) . \dot A(a) \to *\]


\end{document}
