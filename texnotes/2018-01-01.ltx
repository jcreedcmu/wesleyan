\documentclass{article}
\input{theorem}
\input{prooftree}
\usepackage{stmaryrd}
\usepackage{latexsym}
\usepackage{yfonts}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,cd,decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}
\usepackage{tcolorbox}
\tcbuselibrary{breakable}


\def\fc{\mathfrak{C}}
\def\ff{\mathfrak{F}}
\def\ssem#1{\langle\!\langle{#1}\rangle\!\rangle}

\definecolor{cyan}{rgb}{0.80,0.95,0.95}
\definecolor{orange}{rgb}{0.95,0.90,0.80}
\definecolor{lred}{rgb}{0.95,0.8,0.8}
\definecolor{lgray}{gray}{0.7}
\newtcolorbox{declbox}{colframe=lred,colback=lred,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{thmbox}{colframe=cyan,colback=cyan,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{defnbox}{colframe=orange,colback=orange,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}

\input{linear}
\def\rpath#1{[#1]}
\def\rfst{\mathsf{fst}\,}
\def\rsnd{\mathsf{snd}\,}
\def\bunfold{\mathbf{unfold}}
\def\bfold{\mathbf{fold}}
\def\susp#1{\langle {#1} \rangle}
\def\ssusp#1{\langle\!\langle {#1} \rangle\!\rangle}
\def\dto{\mathrel{\dot\to}}
\def\dns{{\downarrow}}
\def\ups{{\uparrow}}
\def\sprov{\Vdash}
\def\signat{{\color{red}\Sigma}}

\def\wat{\mathbin{@}}
\def\wwat{\mathbin{\underline\wat}}
\def\cn{{:}}
\def\dv{{\div}}
\def\ww{{\mathsf w}}
\def\base{{\textfrak b}}

\def\N{{\mathbb N}}
\def\munit{I}
\def\tt{{\mathsf t}}
\def\rr{{\mathsf r}}
\def\ii{{\mathbb I}}
\def\pp{\textsf{\textbf p}}
\def\nn{{\mathsf n}}
\def\PP{\textsf{\textbf P}}
\def\NN{{\mathsf N}}
\def\zz{{\mathsf z}}
\def\sem#1{[\![#1]\!]}
\def\usem#1{\lceil\!\!\lceil{#1}\rceil\!\!\rceil}
\def\zem#1{\langle\!\langle#1\rangle\!\rangle}
\def\col#1{{\mathsf{C}}_{#1}}
\def\lax{\mathop\bigcirc}
\def\rjust{\mathsf{just}}
\def\rcvt{\mathsf{cvt}}
\def\rtype{\mathsf{type}}
\def\rkind{\mathsf{kind}}
\def\rmode{\mathsf{mode}}
\def\rprel{\mathbf{Prel}}
\def\rrfam{\mathbf{Rfam}}
\def\rset{\mathbf{Set}}
\def\rrel{\mathbf{Rel}}
\def\rcat{\mathbf{Cat}}
\def\rfam{\mathbf{Fam}}
\def\binj{\mathbf{inj}}
\def\rid{\mathsf{id}}
\def\rtrue{\mathrel\mathrm{true}}
\def\pbck{\ar[dr, phantom, pos=0, "\lrcorner"]}
\def\bpbck{\ar[ddrr, phantom, pos=0, "\lrcorner"]}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\btwo{\mathbf{2}}
\def\bone{\mathbf{1}}

\newarrow {Equiv} =====
\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\o{\comp}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\def\mapt{\ar[ddd,mapsto,shorten <=2em, shorten >=2em]}
\def\frommaps{\ar[from=uu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\frommapt{\ar[from=uuu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\C{\mathbf{C}}
\def\S{\mathbf{S}}
\def\D{\mathbf{D}}
\def\E{\mathbf{E}}
\def\M{\mathbf{M}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\tri{\triangleright}
\def\o{\circ}
\def\rctx{\,\mathsf{ctx}}
\def\del{\partial}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\null{\emptyset}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\definecolor{fib}{HTML}{ff7f00}
\definecolor{green}{HTML}{007f00}
\definecolor{red}{HTML}{df3f3f}
\definecolor{opfib}{HTML}{007fff}

% For lightening colors I used
% http://trycolors.com/ 6 parts white to 1 part color
\definecolor{opfibl}{HTML}{DBEDFF}
\definecolor{greenl}{HTML}{DBEDDB}
\definecolor{redl}{HTML}{FAE4E4}
\def\njudge#1{\fcolorbox{opfib}{white}{#1}}
\def\nrule#1{\fcolorbox{white}{opfibl}{#1}}
\def\neqn#1{\fcolorbox{white}{redl}{#1}}



\def\judge#1{\vskip 2em\noindent \njudge{$#1$}\vskip 0.5em\noindent}
\def\rule#1{\vskip 2em \noindent \nrule{$#1$}\vskip 0.5em\noindent}
\def\eqn#1{\vskip 2em \noindent \neqn{$#1$}\vskip 0.5em\noindent}
\def\prof{\nrightarrow}
\def\tensor{\otimes}
\def\htensor{\mathrel{\hat\otimes}}
\def\lol{\multimap}
\def\hlol{\mathrel{\hat\multimap}}
\def\wtf{{\color{red}???}}
\begin{document}

\def\
\tikzset{
   commutative diagrams/.cd,
   arrow style=tikz,
   diagrams={>=stealth}}
% got this from
% https://tex.stackexchange.com/questions/169512/tikz-style-arrow-tips-missing-when-using-tikz-cd-crossing-over
% ???


\section{Syntactic Presheaf Model with Simultaneous Substitutions}
I'm taking a guess that my troubles with defining substitutions might be
reduced if I group together everything that comes {\em before} a categorical substitution
into one big simultaneous substitution.

Thus I have things like
$$
\erule
{\prov \Gamma \rctx}
{\prov (\Gamma, i : \ii) \rctx}
$$

$$
\erule
{\Delta \prov \theta : \Gamma \qquad \Delta \prov M : \theta A}
{\Delta \prov \theta[M/x] : (\Gamma, x : A) }
\qquad
\erule
{\Delta \prov \theta : \Gamma \qquad c \in \ii}
{\Delta \prov \theta[c/i] : (\Gamma, i : \ii) }
$$

and still have a substitution theorem like
\begin{thmbox}
If $\Gamma \prov A : \rtype$ and $\Delta \prov \theta : \Gamma$, then
$\Delta \prov \theta A : \rtype$.\\
If $\Gamma \prov M : A$ and $\Delta \prov \theta : \Gamma$, then
$\Delta \prov \theta M : \theta A$.
\end{thmbox}
The trick, of course, is to define what substitution does.

\begin{declbox}
$\Delta \prov \zeta : \theta_1 \to \theta_2 : \Gamma$
\end{declbox}


\[
\erule
{\Delta \prov \zeta : \theta_1 \to \theta_2 : \Gamma \qquad f : c \to d \in \ii}
{\Delta \prov \zeta [ f/i] : \theta_1[c/i] \to \theta_2[d/i] : (\Gamma, i : \ii)}
\]
\[
\erule
{\Delta \prov \zeta : \theta_1 \to \theta_2 : \Gamma \qquad \Delta \prov M : \theta_1 A}
{\Delta \prov \zeta [M/x] : \theta_1[M/x] \to \theta_2[\zeta_A (M)/x] : (\Gamma, x : A)}
\]

\begin{thmbox}
  If \begin{itemize}
\item[] $\Gamma \prov A : \rtype\qquad \Delta \prov M : \theta_1 A$
\item[] $\Delta \prov \theta_1, \theta_2 : \Gamma \qquad \Delta \prov \zeta : \theta_1 \to \theta_2 : \Gamma$
\end{itemize} then
 $\Delta \prov \zeta_A(M) : \theta_2 A$.
\end{thmbox}

\subsection{Brackets From a Substitution}
I can be {\em less} explicit about the construction of substitution morphisms $\zeta$,
and define merely
\begin{declbox}
$\Delta \prov \zeta : [\theta]$
\end{declbox}
which I pronounce as $\zeta$ is a substitution morphism {\em starting from} (i.e.
whose domain is) $\theta$. Its rules are nice and simple:
\[
\erule
{\Delta \prov \zeta :[ \theta] \qquad f : c \to d \in \ii}
{\Delta \prov \zeta [ f/i] : [ \theta[c/i] ]}
\qquad
\erule
{\Delta \prov \zeta : [\theta] \qquad \Delta \prov M : \theta A}
{\Delta \prov \zeta[M/x] : [\theta[M/x]] }
\]
Subsequently I can simply {\em compute} what the codomain of a substitution morphism is,
call it $\bar \zeta$, defined by
\begin{defnbox}
\begin{tabular}{l@{ }c@{ }l}
$ \overline{\zeta[ f/i]} $&$=$&$\overline \zeta [\cod f / i]$\\
$ \overline{\zeta[ M/x]} $&$=$&$\overline \zeta [\zeta_A(M) / x]$
\end{tabular}
\end{defnbox}
Then my theorems are
\begin{thmbox}
If $\Delta \prov \theta : \Gamma$ and $\Delta \prov \zeta : [\theta]$,
then $\Delta \prov \bar \zeta : \Gamma$.\\
  If \begin{itemize}
\item[] $\Gamma \prov A : \rtype\qquad \Delta \prov M : \theta A$
\item[] $\Delta \prov \theta : \Gamma \qquad \Delta \prov \zeta : [\theta]$
\end{itemize} then
 $\Delta \prov \zeta_A(M) : \bar \zeta A$.
\end{thmbox}

\begin{defnbox}
\begin{tabular}{l@{ }c@{ }l}
$ \theta (( y : A) \to B ) $&$=$&$\{  \omega: (\zeta : [\theta])  (y : \bar \zeta A) \to  \bar\zeta  B,$\\
&&$\ \ \mu :  (\zeta : [\theta])  (\xi : [\bar \zeta])  $\\
&&$\ \   \to (\omega\ \xi\zeta) \o \xi_A =  \xi_B \o (\omega\ \zeta)  \}   $\\
$ \chi_{ (y : A) \to B }(M) $&$=$&$ \{ \omega = \lambda   \zeta . (M.\omega)\ (\zeta \chi) ,  $\\
&&$\ \  \mu =  \lambda \zeta   . (M.\mu)\  (\zeta  \chi)\  \} $\\
%% $ \sem{\lambda y . M}_c  $&$=$&$\{ \omega = \lambda  g y . \ssem M^\Gamma_g $\\
%% &&$\ \ \mu = \lambda  g h  . \mathsf{idp}  \}   $\\
%% $ \sem{M N}_c  $&$=$&$\{ \omega = \lambda  g y . \ssem M^\Gamma_g $\\
%% &&$\ \ \mu = \lambda  g h  . \mathsf{idp}  \}   $
\end{tabular}
\end{defnbox}

\subsection{Naturality Directly?}

I'd like to be able to say more simply something like

$$[c/i] ((y : A) \to B) = (g : [c])  (y : [\bar g/i] A) \to [\bar g /i]B$$
and let the $\mu$ part fall magically out somehow. I surmise this would require
something special about $\Pi$ types over morphisms --- that what I'm really asking
for when I say $(g : [c])$ bakes in the naturality. Ok, so when do I have
$$\Gamma \prov \lambda g . M : (g : [c]) \to A$$?
I must at least have
$$\Gamma, g : [c] \prov M : A$$
but also I expect
$$\Gamma, g : [c], h : [\bar g] \prov [hg / g]M \o ? = ? \o M$$
Nope, that doesn't make sense; I need $A$ to actually be a function type
to state this kind of naturality.

Is it possible to imagine the $\mu$ part falls out as a general theorem?
Like --- can I just carefully define $\xi_A$ in such a way that it's true,
without mudding the definition of $\theta((y : A) \to B)$ too much?

\subsection{Perhaps all these quantifiers exist already?}
Something feels very wrong about the fact that substituting for different categorical variables
in different orders leads to different answers. Seems like a flagrant violation of the kind of
substitution principle I expect to hold. Can this be repaired, maybe, by redefining
what it means to be a valid $\Pi$ type in the first place?


$$
\erule
{\bar \ff ; \Gamma, y : A \prov  B : \rtype}
{\fc;\Gamma \prov (\ff : [\fc])(y : A ) \to B : \rtype}
$$
\[
\begin{tabular}{r@{$\quad$}c@{$\quad::=\quad$ }l}
  Categorical Contexts&$\fc$&$\cdot \celse \fc, c : \ii_0$\\
  Morphism Contexts&$\ff$&$\cdot \celse \ff, f : \ii_1$\\
\end{tabular}
\]
In this case perhaps substitution of objects for categorical context variables
is just straightforward syntactic substitution?

Hm, my head is spinning slightly from the binding conventions going on. I'm tempted
to instead say something like
$$
\erule
{\fc, \fc', \ff : [\fc \to \fc'] ; \Gamma, y : [\fc'/\fc]A \prov  [\fc'/\fc]B : \rtype}
{\fc;\Gamma \prov (\fc')(\ff : [\fc \to \fc'])(y : A ) \to B : \rtype}
$$

Bah, this is very hard to think about clearly. Surely it should make sense to
substitute a variable for a variable? Should even the identity substitution lead to
extra $\Pi$s? Surely not, I'd think.

The point is that, somehow, even when I substitute a {\em concrete}
object for a categorical variable that is free when I defined a $\Pi$
type, that that substitution doesn't clobber the universal
quantification over future worlds; it just changes the base of it.
Just as when I say
$$x : A \prov \lambda y . M : (y : B) \to C$$
and I pick a concrete $k : A$ and substitute, I get
$$ \prov \lambda y . [k/x]M : (y : [k/x]B) \to [k/x]C$$
This is, quite naturally, a `special case' of $\lambda y . M$ obtained by substitution;
it's no different when I take a function that works for all future worlds, and pick
a future world $\omega$, and observe that it works in all future worlds of $\omega$,
because the accessibility relation ought to be transitive.

\subsection{Back to the original syntax maybe? With morphisms?}

$$
\erule{\ff \prov c : \ii \qquad a : \ii \to \rtype \in \Sigma }{\ff ; \Gamma \prov a(c) : \rtype}
\qquad
\erule{f : \ii_1 \in \ff  }{\ff \prov\bar f : \ii_0}
$$
$$
\erule
{ \ff' ; \Gamma, y : A \prov  B : \rtype}
{\ff;\Gamma \prov (\ff' : [\bar \ff])(y : A ) \to B : \rtype}
$$
Aw, heck, this doesn't work at all. If I substitute something in the middle of
$\ff$, I won't have a contiguous set of binders matching up with the remainder
of the substituted left and right halves of $\ff$ nicely. Hmm.

\subsection{Taking Stock of what I Need to Figure Out}
I feel reasonably confident that
\begin{enumerate}
\item I don't really need to think about categorical variables in the middle of the context;
they might as well all be to the left. I don't have any dependencies of categorical variables
{\em on} ordinary ones, just the reverse.
\item I don't need to do any special thinking about multiple categorical variables,
since their meaning is the same as a single variable of the product category.
\item Most of the complexity is embodied in just the one-arrow category.
\end{enumerate}

So, ok, let's just be extremely careful and return to the stuff I was
doing two weeks ago: just one variable, and a simple category. The
easiest form of the theorem I'm after is, if you have an expression in
the language of dependent types --- maybe with some additional stuff,
such as a base type with a chosen presheaf interpretation, but surely
it should work at least for the bare language --- then it admits a
well-typed translation into dependent types that is compatible with
reduction and so on. Specifically, I expect, in order of decreasing certainty:

\begin{thmbox}
If $\prov A : \rtype$, then $\prov \sem A_c : \rtype$.\\
If $\prov A : \rtype$, then $x : \sem A_0 \prov \sem A_\tri(x) : \sem A_1$.\\
If $\prov M : A$, then $\prov \sem M_c : \sem A_c$.
\end{thmbox}
With incomplete definition sketch:
\begin{defnbox}
\begin{tabular}{l@{ }c@{ }l}
 $\sem{\Pi y \cn A . B}_0$&$=$&$(g : (c : \fc) (y : \sem A_c) \to \sem B_c) \x $\\
&&$\quad ((y : \sem A_0) \to \sem B_\tri (g_0\ y) \equiv g_1(\sem A_\tri (y)))$\\
 $\sem{\Pi y \cn A . B}_1$&$=$&$\Pi y \cn \sem A_1 . \sem B_1$\\
 $\sem{\Pi y \cn A . B}_\tri(x)$&$=$&$(\bfst x)_1$\\
 $\sem{\lambda y  . M}_0$&$=$&$ \pair{\lambda c y . \sem M_c }{\mathsf{idp}}$\\
 $\sem{\lambda y . M}_1$&$=$&$\lambda y . \sem M_1$\\
\end{tabular}
\end{defnbox}
I previously thought the induction hypothesis with contexts involved was something like
``If $\Gamma \prov M : A$ then $\sem \Gamma_c \prov \sem M_c : \sem A_c$''. I wonder
if I want something more general, like saying that there is such thing as a {\em path}
$\pi$ which has a bunch of objects and morphisms corresponding to a context.

If the interpretation at object $c$ of a simple function type in the
empty context involves a choice of a morphism from $c$, then the
interpretation of a base type at object $c$ in a context of $n$ things should allow
an arbitrary path of $n$ morphisms starting from $c$.
\[
\begin{tabular}{r@{$\quad$}c@{$\quad::=\quad$ }l}
  Paths&$\pi$&$c \celse \pi \to^f c $\\
\end{tabular}
\]
I can then define what it means to be a valid path in a context, and what the codomain
of a path is.
\begin{declbox}
  $\Gamma \prov \pi : \rpath c$\\
\end{declbox}
\begin{defnbox}
  $$
\erule
{}
{\cdot \prov c : \rpath c}
\qquad
\erule
{\Gamma \prov \pi : \rpath c}
{\Gamma, x : A \prov (\pi \to^f d) : \rpath c}
$$
\end{defnbox}
\begin{declbox}
  $\bar \pi $
\end{declbox}
\begin{defnbox}
\begin{tabular}{l@{ }c@{ }l}
 $\bar c$&$=$&$c$\\
$\overline{ \pi \to_f d}$&$=$&$d$
\end{tabular}
\end{defnbox}
So I expect something like
\begin{thmbox}
  If $\Gamma \prov A : \rtype$ and $\Gamma \prov \pi : [c]$ then $\sem \Gamma_\pi \prov \sem A_{\bar \pi} : \rtype$.\\
  If $\Gamma \prov M : A$ and $\Gamma \prov \pi : [c]$ then $\sem \Gamma_\pi \prov \sem M_{\bar \pi} :\sem A_{\bar \pi}$.
\end{thmbox}
How do I interpret contexts at a path, then?
\begin{declbox}
$  \sem \Gamma_\pi$
\end{declbox}
\begin{defnbox}
\begin{tabular}{l@{ }c@{ }l}
 $\sem \cdot_c$&$=$&$\cdot$\\
$\sem{ \Gamma, x : A}_{\pi \to_f d}$&$=$&$\sem \Gamma_\pi, x : \sem A_{\bar \pi}$
\end{tabular}
\end{defnbox}
Where does the $f$ go, I wonder? Maybe into the variable rule?
I have $\Gamma, x : A, \Gamma' \prov x : A$, so how do I see
that
$$\sem \Gamma_\pi, x : \sem A_{\bar\pi}, \sem{\Gamma'}_{\rho} \prov \sem x_{\bar\rho} : \sem A_{\bar\rho}$$
For some $\Gamma' \prov \rho : [\pi]$? I think probably $\sem x_{\bar \rho} = \sem A_\rho(x)$.
Right? I think this follows from a general observation about how weakening works. For sure I have
$$\sem \Gamma_\pi, x : \sem A_{\bar\pi} \prov  \sem x_{\bar\pi} : \sem A_{\bar\pi}$$
in the case where I have no weakening to worry about.

\vfil\eject
\section{Take Eleventy Billion}
Assume $\Gamma \prov A : \rtype$, $\Gamma \prov M : A$,
 $\Gamma \prov \pi : [c]$, and $f : [\bar\pi]$.
\begin{thmbox}
   $\sem \Gamma_\pi \prov \sem A_{\bar \pi} : \rtype$.\\
   $\sem \Gamma_\pi \prov \sem M_{\bar \pi} :\sem A_{\bar \pi}$.\\
  $ \sem \Gamma_\pi, x : \sem A_{\bar \pi} \prov \sem A_f ( x) : \sem A_{\bar f}$.
\end{thmbox}

\begin{defnbox}
\begin{tabular}{l@{ }c@{ }l}
 $\sem{(y :A) \to B}_c$&$=$&$(\omega : {}_{(g : [c])} (y : \sem A_{\bar g}) \to \sem B_{\bar g}) \x $\\
&&$ ({}_{(g : [c])}(h : [\bar g])(y : \sem A_{\bar g}) \to  $\\
&&$\sem B_h (\omega_{g}\ y) \equiv \omega_{hg}(\sem A_{h} (y)))$\\
 $\sem{(y :A) \to B}_f(x)$&$=$&$\langle \lambda g . (x.1)_{g f}, $\\
&&$\ \lambda g . (x.2)_{g f} \rangle$\\
$\sem{\lambda y . M}_c$&$=$&$\pair{\lambda gy . \sem M_c}{\mathsf{idp}}$\\
$\sem{M\  N}_c$&$=$&$(\sem M_c.1)_{\rid_c}(\sem N_c)$\\
\end{tabular}
\end{defnbox}
\begin{thmbox}
   $\sem \Gamma_\pi \prov \sem A_{\bar \pi} : \rtype$.
\end{thmbox}
We have $\Gamma, y : A \prov B : \rtype$. We can define an operation
$\pi + g$ that takes a path and concatenates on a morphism without
changing its length. We observe that $\sem \Gamma_\pi = \sem \Gamma_{\pi + g}$.
So for any $g : [\bar \pi]$
by induction hypothesis on the path
$\Gamma, y : A \prov ((\pi + g) \to^{\rid_{\bar g}} \bar g) : \rpath c$ we have
$\sem \Gamma_\pi, y : \sem A_{\bar g} \prov \sem B_{\bar g} : \rtype$.
So we know now that ${(g : [\bar \pi])} (y : \sem A_{\bar g}) \to \sem B_{\bar g}) $
is a meaningful type in $\sem \Gamma_\pi$.

How about the other half of the pair? We can get
$$\sem \Gamma_\pi, y : \sem A_{\bar g} \prov \sem A_h (y) : \sem A_{\bar h}$$
out of the $\sem A_f$ theorem on $\pi + g$ and $h$. So $\omega_{hg}$ of that is
$$\sem \Gamma_\pi, y : \sem A_{\bar g} \prov \omega_{hg}(\sem A_h (y)) : [\sem A_h (y)/y]\sem B_{\bar h}$$
On the other side, what type does $\omega_g\ y$ have?
$$\sem \Gamma_\pi, y : \sem A_{\bar g} \prov  : \sem B_{\bar g}$$
We can get
$$\sem \Gamma_\pi, y : \sem A_{\bar g}, z : \sem B_{\bar g} \prov \sem B_h (z) : \sem B_{\bar h}$$
out of the $\sem A_f$ theorem on $\pi + g \to^{\rid_{\bar g}} \bar g$ and $h$. Substituting, we get
$$\sem \Gamma_\pi, y : \sem A_{\bar g} \prov \sem B_h (\omega_g\ y) : \sem B_{\bar h}$$
Oh no these seem like slightly different types up to substitution. What's up? Do
I need to pay attention to the whole path instead of just the endpoint, or something?
\end{document}

% garbage
If $A : *$ then $\usem A : A \to *$
\[\pi : \Pi A \cn * . \Pi a \cn A .  \usem A\ a\]
\[\sem \pi : \pi \in \sem{\Pi A \cn * . \Pi a \cn A .  \usem A\ a}   \]
\[\sem \pi : \Pi A \cn * .\Pi \dot A \cn A \to * . \pi\ A \in \sem{ \Pi a \cn A .  \dot A\ a}   \]
\[\sem \pi : \Pi A \cn * .\Pi \dot A \cn A \to * .  \Pi a \cn A .  \Pi \dot a \cn \dot A(a) .\pi\ A \in \sem{  \dot A\ a}   \]
\[\sem \pi : \Pi A \cn * .\Pi \dot A \cn A \to * .  \Pi a \cn A .  \Pi \dot a \cn \dot A(a) .  \sem{  \dot A\ a} (\pi\ A)  \]
\[\sem \pi : \Pi A \cn * .\Pi \dot A \cn A \to * .  \Pi a \cn A .  \Pi \dot a \cn \dot A(a) . \sem {\dot A}\ a\ \sem a\ (\pi\ A)\]
\[\sem \pi : \Pi A \cn * .\Pi \dot A \cn A \to * .  \Pi a \cn A .  \Pi \dot a \cn \dot A(a) . \usem {\dot A}\ a\ \dot a\ (\pi\ A)\]
\[\sem{ \dot A} : \dot A \in \sem {A \to *}\]
\[\sem{ \dot A} : \Pi a \cn A . \Pi \dot a \cn \dot A(a) . \dot A(a) \to *\]


\end{document}
