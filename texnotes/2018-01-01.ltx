\documentclass{article}
\input{theorem}
\input{prooftree}
\usepackage{stmaryrd}
\usepackage{latexsym}
\usepackage{yfonts}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,cd,decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}
\usepackage{tcolorbox}
\tcbuselibrary{breakable}


\def\fc{\mathfrak{C}}
\def\ff{\mathfrak{F}}
\def\ssem#1{\langle\!\langle{#1}\rangle\!\rangle}

\definecolor{cyan}{rgb}{0.80,0.95,0.95}
\definecolor{orange}{rgb}{0.95,0.90,0.80}
\definecolor{lred}{rgb}{0.95,0.8,0.8}
\definecolor{lgray}{gray}{0.7}
\newtcolorbox{calldefn}{colframe=lred,colback=lred,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{callout}{colframe=cyan,colback=cyan,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{callout2}{colframe=orange,colback=orange,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}

\input{linear}
\def\rfst{\mathsf{fst}\,}
\def\rsnd{\mathsf{snd}\,}
\def\bunfold{\mathbf{unfold}}
\def\bfold{\mathbf{fold}}
\def\susp#1{\langle {#1} \rangle}
\def\ssusp#1{\langle\!\langle {#1} \rangle\!\rangle}
\def\dto{\mathrel{\dot\to}}
\def\dns{{\downarrow}}
\def\ups{{\uparrow}}
\def\sprov{\Vdash}
\def\signat{{\color{red}\Sigma}}

\def\wat{\mathbin{@}}
\def\wwat{\mathbin{\underline\wat}}
\def\cn{{:}}
\def\dv{{\div}}
\def\ww{{\mathsf w}}
\def\base{{\textfrak b}}

\def\N{{\mathbb N}}
\def\munit{I}
\def\tt{{\mathsf t}}
\def\rr{{\mathsf r}}
\def\ii{{\mathbb I}}
\def\pp{\textsf{\textbf p}}
\def\nn{{\mathsf n}}
\def\PP{\textsf{\textbf P}}
\def\NN{{\mathsf N}}
\def\zz{{\mathsf z}}
\def\sem#1{[\![#1]\!]}
\def\usem#1{\lceil\!\!\lceil{#1}\rceil\!\!\rceil}
\def\zem#1{\langle\!\langle#1\rangle\!\rangle}
\def\col#1{{\mathsf{C}}_{#1}}
\def\lax{\mathop\bigcirc}
\def\rjust{\mathsf{just}}
\def\rcvt{\mathsf{cvt}}
\def\rtype{\mathsf{type}}
\def\rkind{\mathsf{kind}}
\def\rmode{\mathsf{mode}}
\def\rprel{\mathbf{Prel}}
\def\rrfam{\mathbf{Rfam}}
\def\rset{\mathbf{Set}}
\def\rrel{\mathbf{Rel}}
\def\rcat{\mathbf{Cat}}
\def\rfam{\mathbf{Fam}}
\def\binj{\mathbf{inj}}
\def\rid{\mathsf{id}}
\def\rtrue{\mathrel\mathrm{true}}
\def\pbck{\ar[dr, phantom, pos=0, "\lrcorner"]}
\def\bpbck{\ar[ddrr, phantom, pos=0, "\lrcorner"]}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\btwo{\mathbf{2}}
\def\bone{\mathbf{1}}

\newarrow {Equiv} =====
\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\o{\comp}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\def\mapt{\ar[ddd,mapsto,shorten <=2em, shorten >=2em]}
\def\frommaps{\ar[from=uu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\frommapt{\ar[from=uuu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\C{\mathbf{C}}
\def\S{\mathbf{S}}
\def\D{\mathbf{D}}
\def\E{\mathbf{E}}
\def\M{\mathbf{M}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\tri{\triangleright}
\def\o{\circ}
\def\rctx{\,\mathsf{ctx}}
\def\del{\partial}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\null{\emptyset}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\definecolor{fib}{HTML}{ff7f00}
\definecolor{green}{HTML}{007f00}
\definecolor{red}{HTML}{df3f3f}
\definecolor{opfib}{HTML}{007fff}

% For lightening colors I used
% http://trycolors.com/ 6 parts white to 1 part color
\definecolor{opfibl}{HTML}{DBEDFF}
\definecolor{greenl}{HTML}{DBEDDB}
\definecolor{redl}{HTML}{FAE4E4}
\def\njudge#1{\fcolorbox{opfib}{white}{#1}}
\def\nrule#1{\fcolorbox{white}{opfibl}{#1}}
\def\neqn#1{\fcolorbox{white}{redl}{#1}}



\def\judge#1{\vskip 2em\noindent \njudge{$#1$}\vskip 0.5em\noindent}
\def\rule#1{\vskip 2em \noindent \nrule{$#1$}\vskip 0.5em\noindent}
\def\eqn#1{\vskip 2em \noindent \neqn{$#1$}\vskip 0.5em\noindent}
\def\prof{\nrightarrow}
\def\tensor{\otimes}
\def\htensor{\mathrel{\hat\otimes}}
\def\lol{\multimap}
\def\hlol{\mathrel{\hat\multimap}}
\def\rpath{\mathsf{Path}}
\def\wtf{{\color{red}???}}
\begin{document}

\def\
\tikzset{
   commutative diagrams/.cd,
   arrow style=tikz,
   diagrams={>=stealth}}
% got this from
% https://tex.stackexchange.com/questions/169512/tikz-style-arrow-tips-missing-when-using-tikz-cd-crossing-over
% ???


\section{Syntactic Presheaf Model with Simultaneous Substitutions}
I'm taking a guess that my troubles with defining substitutions might be
reduced if I group together everything that comes {\em before} a categorical substitution
into one big simultaneous substitution.

Thus I have things like
$$
\erule
{\prov \Gamma \rctx}
{\prov (\Gamma, i : \ii) \rctx}
$$

$$
\erule
{\Delta \prov \theta : \Gamma \qquad \Delta \prov M : \theta A}
{\Delta \prov \theta[M/x] : (\Gamma, x : A) }
\qquad
\erule
{\Delta \prov \theta : \Gamma \qquad c \in \ii}
{\Delta \prov \theta[c/i] : (\Gamma, i : \ii) }
$$

and still have a substitution theorem like
\begin{callout}
If $\Gamma \prov A : \rtype$ and $\Delta \prov \theta : \Gamma$, then
$\Delta \prov \theta A : \rtype$.\\
If $\Gamma \prov M : A$ and $\Delta \prov \theta : \Gamma$, then
$\Delta \prov \theta M : \theta A$.
\end{callout}
The trick, of course, is to define what substitution does.

\begin{calldefn}
$\Delta \prov \zeta : \theta_1 \to \theta_2 : \Gamma$
\end{calldefn}


\[
\erule
{\Delta \prov \zeta : \theta_1 \to \theta_2 : \Gamma \qquad f : c \to d \in \ii}
{\Delta \prov \zeta [ f/i] : \theta_1[c/i] \to \theta_2[d/i] : (\Gamma, i : \ii)}
\]
\[
\erule
{\Delta \prov \zeta : \theta_1 \to \theta_2 : \Gamma \qquad \Delta \prov M : \theta_1 A}
{\Delta \prov \zeta [M/x] : \theta_1[M/x] \to \theta_2[\zeta_A (M)/x] : (\Gamma, x : A)}
\]

\begin{callout}
  If \begin{itemize}
\item[] $\Gamma \prov A : \rtype\qquad \Delta \prov M : \theta_1 A$
\item[] $\Delta \prov \theta_1, \theta_2 : \Gamma \qquad \Delta \prov \zeta : \theta_1 \to \theta_2 : \Gamma$
\end{itemize} then
 $\Delta \prov \zeta_A(M) : \theta_2 A$.
\end{callout}

\subsection{Brackets From a Substitution}
I can be {\em less} explicit about the construction of substitution morphisms $\zeta$,
and define merely
\begin{calldefn}
$\Delta \prov \zeta : [\theta]$
\end{calldefn}
which I pronounce as $\zeta$ is a substitution morphism {\em starting from} (i.e.
whose domain is) $\theta$. Its rules are nice and simple:
\[
\erule
{\Delta \prov \zeta :[ \theta] \qquad f : c \to d \in \ii}
{\Delta \prov \zeta [ f/i] : [ \theta[c/i] ]}
\qquad
\erule
{\Delta \prov \zeta : [\theta] \qquad \Delta \prov M : \theta A}
{\Delta \prov \zeta[M/x] : [\theta[M/x]] }
\]
Subsequently I can simply {\em compute} what the codomain of a substitution morphism is,
call it $\bar \zeta$, defined by
\begin{callout2}
\begin{tabular}{l@{ }c@{ }l}
$ \overline{\zeta[ f/i]} $&$=$&$\overline \zeta [\cod f / i]$\\
$ \overline{\zeta[ M/x]} $&$=$&$\overline \zeta [\zeta_A(M) / x]$
\end{tabular}
\end{callout2}
Then my theorems are
\begin{callout}
If $\Delta \prov \theta : \Gamma$ and $\Delta \prov \zeta : [\theta]$,
then $\Delta \prov \bar \zeta : \Gamma$.\\
  If \begin{itemize}
\item[] $\Gamma \prov A : \rtype\qquad \Delta \prov M : \theta A$
\item[] $\Delta \prov \theta : \Gamma \qquad \Delta \prov \zeta : [\theta]$
\end{itemize} then
 $\Delta \prov \zeta_A(M) : \bar \zeta A$.
\end{callout}

\begin{callout2}
\begin{tabular}{l@{ }c@{ }l}
$ \theta (( y : A) \to B ) $&$=$&$\{  \omega: (\zeta : [\theta])  (y : \bar \zeta A) \to  \bar\zeta  B,$\\
&&$\ \ \mu :  (\zeta : [\theta])  (\xi : [\bar \zeta])  $\\
&&$\ \   \to (\omega\ \xi\zeta) \o \xi_A =  \xi_B \o (\omega\ \zeta)  \}   $\\
$ \chi_{ (y : A) \to B }(M) $&$=$&$ \{ \omega = \lambda   \zeta . (M.\omega)\ (\zeta \chi) ,  $\\
&&$\ \  \mu =  \lambda \zeta   . (M.\mu)\  (\zeta  \chi)\  \} $\\
%% $ \sem{\lambda y . M}_c  $&$=$&$\{ \omega = \lambda  g y . \ssem M^\Gamma_g $\\
%% &&$\ \ \mu = \lambda  g h  . \mathsf{idp}  \}   $\\
%% $ \sem{M N}_c  $&$=$&$\{ \omega = \lambda  g y . \ssem M^\Gamma_g $\\
%% &&$\ \ \mu = \lambda  g h  . \mathsf{idp}  \}   $
\end{tabular}
\end{callout2}

\subsection{Naturality Directly?}

I'd like to be able to say more simply something like

$$[c/i] ((y : A) \to B) = (g : [c])  (y : [\bar g/i] A) \to [\bar g /i]B$$
and let the $\mu$ part fall magically out somehow. I surmise this would require
something special about $\Pi$ types over morphisms --- that what I'm really asking
for when I say $(g : [c])$ bakes in the naturality. Ok, so when do I have
$$\Gamma \prov \lambda g . M : (g : [c]) \to A$$?
I must at least have
$$\Gamma, g : [c] \prov M : A$$
but also I expect
$$\Gamma, g : [c], h : [\bar g] \prov [hg / g]M \o ? = ? \o M$$
Nope, that doesn't make sense; I need $A$ to actually be a function type
to state this kind of naturality.

Is it possible to imagine the $\mu$ part falls out as a general theorem?
Like --- can I just carefully define $\xi_A$ in such a way that it's true,
without mudding the definition of $\theta((y : A) \to B)$ too much?

\subsection{Perhaps all these quantifiers exist already?}
Something feels very wrong about the fact that substituting for different categorical variables
in different orders leads to different answers. Seems like a flagrant violation of the kind of
substitution principle I expect to hold. Can this be repaired, maybe, by redefining
what it means to be a valid $\Pi$ type in the first place?


$$
\erule
{\bar \ff ; \Gamma, y : A \prov  B : \rtype}
{\fc;\Gamma \prov (\ff : [\fc])(y : A ) \to B : \rtype}
$$
\[
\begin{tabular}{r@{$\quad$}c@{$\quad::=\quad$ }l}
  Categorical Contexts&$\fc$&$\cdot \celse \fc, c : \ii_0$\\
  Morphism Contexts&$\ff$&$\cdot \celse \ff, f : \ii_1$\\
\end{tabular}
\]
In this case perhaps substitution of objects for categorical context variables
is just straightforward syntactic substitution?

Hm, my head is spinning slightly from the binding conventions going on. I'm tempted
to instead say something like
$$
\erule
{\fc, \fc', \ff : [\fc \to \fc'] ; \Gamma, y : [\fc'/\fc]A \prov  [\fc'/\fc]B : \rtype}
{\fc;\Gamma \prov (\fc')(\ff : [\fc \to \fc'])(y : A ) \to B : \rtype}
$$

Bah, this is very hard to think about clearly. Surely it should make sense to
substitute a variable for a variable? Should even the identity substitution lead to
extra $\Pi$s? Surely not, I'd think.

The point is that, somehow, even when I substitute a {\em concrete}
object for a categorical variable that is free when I defined a $\Pi$
type, that that substitution doesn't clobber the universal
quantification over future worlds; it just changes the base of it.
Just as when I say
$$x : A \prov \lambda y . M : (y : B) \to C$$
and I pick a concrete $k : A$ and substitute, I get
$$ \prov \lambda y . [k/x]M : (y : [k/x]B) \to [k/x]C$$
This is, quite naturally, a `special case' of $\lambda y . M$ obtained by substitution;
it's no different when I take a function that works for all future worlds, and pick
a future world $\omega$, and observe that it works in all future worlds of $\omega$,
because the accessibility relation ought to be transitive.
\end{document}

% garbage
If $A : *$ then $\usem A : A \to *$
\[\pi : \Pi A \cn * . \Pi a \cn A .  \usem A\ a\]
\[\sem \pi : \pi \in \sem{\Pi A \cn * . \Pi a \cn A .  \usem A\ a}   \]
\[\sem \pi : \Pi A \cn * .\Pi \dot A \cn A \to * . \pi\ A \in \sem{ \Pi a \cn A .  \dot A\ a}   \]
\[\sem \pi : \Pi A \cn * .\Pi \dot A \cn A \to * .  \Pi a \cn A .  \Pi \dot a \cn \dot A(a) .\pi\ A \in \sem{  \dot A\ a}   \]
\[\sem \pi : \Pi A \cn * .\Pi \dot A \cn A \to * .  \Pi a \cn A .  \Pi \dot a \cn \dot A(a) .  \sem{  \dot A\ a} (\pi\ A)  \]
\[\sem \pi : \Pi A \cn * .\Pi \dot A \cn A \to * .  \Pi a \cn A .  \Pi \dot a \cn \dot A(a) . \sem {\dot A}\ a\ \sem a\ (\pi\ A)\]
\[\sem \pi : \Pi A \cn * .\Pi \dot A \cn A \to * .  \Pi a \cn A .  \Pi \dot a \cn \dot A(a) . \usem {\dot A}\ a\ \dot a\ (\pi\ A)\]
\[\sem{ \dot A} : \dot A \in \sem {A \to *}\]
\[\sem{ \dot A} : \Pi a \cn A . \Pi \dot a \cn \dot A(a) . \dot A(a) \to *\]


\end{document}
