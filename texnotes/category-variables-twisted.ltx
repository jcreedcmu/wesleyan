\documentclass{article}
\input{theorem}
\input{prooftree}
\usepackage{stmaryrd}
\usepackage{latexsym}
\usepackage{yfonts}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,cd,decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}
\usepackage{tcolorbox}
\tcbuselibrary{breakable}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}

\def\coe{\mathsf{coe}}
\def\bpush{\mathbf{push}}
\def\bpull{\mathbf{pull}}


\def\wo{\setminus}
\def\fA{\mathsf{A}}
\def\fC{\mathsf{C}}
\def\fX{\mathsf{X}}
\def\ff{\mathsf{f}}
\def\fm{\mathsf{m}}
\def\rspan{\mathsf{Span}}
% \def\El#1{\mathsf{El}({#1})}
\def\El#1{\ulcorner{#1}\urcorner}
\def\quote#1{{\ulcorner {#1} \urcorner}}
\def\U{\mathsf{U}}
\def\uu{\mathsf{u}}
\def\uni{\U}
\def\mor#1#2{#1 \to \underline{#2}}

\def\ridp{\mathsf{idp}}
\def\ssem#1{\langle\!\langle{#1}\rangle\!\rangle}

\definecolor{lred}{rgb}{0.95,0.8,0.8}
\definecolor{cyan}{rgb}{0.80,0.95,0.95}
\definecolor{orange}{rgb}{0.95,0.90,0.80}
\definecolor{bluegray}{rgb}{0.6,0.6,0.85}
\definecolor{lgray}{gray}{0.9}
\newtcolorbox{declbox}{colframe=lred,colback=lred,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{thmbox}{colframe=cyan,colback=cyan,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{defnbox}{colframe=orange,colback=orange,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{tangentbox}{colframe=lgray,colback=lgray,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}

\input{linear}
\def\rpath#1{[#1]}
\def\rfst{\mathsf{fst}\,}
\def\rsnd{\mathsf{snd}\,}
\def\bunfold{\mathbf{unfold}}
\def\bfold{\mathbf{fold}}
\def\susp#1{\langle {#1} \rangle}
\def\ssusp#1{\langle\!\langle {#1} \rangle\!\rangle}
\def\dto{\mathrel{\dot\to}}
\def\dns{{\downarrow}}
\def\ups{{\uparrow}}
\def\sprov{\Vdash}
\def\signat{{\color{red}\Sigma}}
\def\ep#1{\underline{#1}}
\def\wat{\mathbin{@}}
\def\wwat{\mathbin{\underline\wat}}
\def\cn{{:}}
\def\dv{{\div}}
\def\ww{{\mathsf w}}
\def\base{{\textfrak b}}

\def\munit{I}
\def\tt{{\mathsf t}}
\def\rr{{\mathsf r}}
\def\ii{{\mathbb I}}
\def\T{\mathbb{T}}
\def\pp{\textsf{\textbf p}}
\def\nn{{\mathsf n}}
\def\PP{\textsf{\textbf P}}
\def\NN{{\mathsf N}}
\def\zz{{\mathsf z}}
\def\sem#1{[\![#1]\!]}
\def\usem#1{\lceil\!\!\lceil{#1}\rceil\!\!\rceil}
\def\zem#1{\langle\!\langle#1\rangle\!\rangle}
\def\col#1{{\mathsf{C}}_{#1}}
\def\lax{\mathop\bigcirc}
\def\rjust{\mathsf{just}}
\def\rcvt{\mathsf{cvt}}
\def\rtype{\mathsf{type}}
\def\rdtype{\mathsf{disc}}
\def\rkind{\mathsf{kind}}
\def\rmode{\mathsf{mode}}
\def\rprel{\mathbf{Prel}}
\def\rrfam{\mathbf{Rfam}}
\def\rset{\mathbf{Set}}
\def\rfinset{\mathbf{FinSet}}
\def\rrel{\mathbf{Rel}}
\def\rcat{\mathbf{Cat}}
\def\rfam{\mathbf{Fam}}
\def\binj{\mathbf{inj}}
\def\rid{\mathsf{id}}
\def\rtrue{\mathrel\mathrm{true}}
\def\pbck{\ar[dr, phantom, pos=0, "\lrcorner"]}
\def\bpbck{\ar[ddrr, phantom, pos=0, "\lrcorner"]}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\btwo{\mathbf{2}}
\def\bone{\mathbf{1}}

\newarrow {Equiv} =====
\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\def\mapt{\ar[ddd,mapsto,shorten <=2em, shorten >=2em]}
\def\frommaps{\ar[from=uu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\frommapt{\ar[from=uuu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\C{\mathbf{C}}
\def\G{\mathbf{G}}
\def\S{\mathbf{S}}
\def\D{\mathbf{D}}
\def\E{\mathbf{E}}
\def\M{\mathbf{M}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\tri{\triangleright}
\def\ltri{\triangleleft}
\def\o{\circ}
\def\rctx{\,\mathsf{ctx}}
\def\rdctx{\,\mathsf{cat}}
\def\del{\partial}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\definecolor{fib}{HTML}{ff7f00}
\definecolor{green}{HTML}{007f00}
\definecolor{red}{HTML}{df3f3f}
\definecolor{opfib}{HTML}{007fff}

% For lightening colors I used
% http://trycolors.com/ 6 parts white to 1 part color
\definecolor{opfibl}{HTML}{DBEDFF}
\definecolor{greenl}{HTML}{DBEDDB}
\definecolor{redl}{HTML}{FAE4E4}
\def\njudge#1{\fcolorbox{opfib}{white}{#1}}
\def\nrule#1{\fcolorbox{white}{opfibl}{#1}}
\def\neqn#1{\fcolorbox{white}{redl}{#1}}



\def\judge#1{\vskip 2em\noindent \njudge{$#1$}\vskip 0.5em\noindent}
\def\rule#1{\vskip 2em \noindent \nrule{$#1$}\vskip 0.5em\noindent}
\def\eqn#1{\vskip 2em \noindent \neqn{$#1$}\vskip 0.5em\noindent}
\def\prof{\nrightarrow}
\def\tensor{\otimes}
\def\htensor{\mathrel{\hat\otimes}}
\def\lol{\multimap}
\def\hlol{\mathrel{\hat\multimap}}
\def\wtf{{\color{red}???}}

\def\re{\mathbf{E}}
\def\sh{\sharp}
\def\shp{\mathrel{\sharp}}
\def\zero{\texttt{0}}
\begin{document}

\def\
\tikzset{
   commutative diagrams/.cd,
   arrow style=tikz,
   diagrams={>=stealth}}

\section{A Syntax for Category Variables}
Let there be some syntax class
\[\begin{tabular}{rccl}
  Categories&$\C$&$::=$&$\cdots$\\
  Category Contexts&$\Delta$&$::=$&$\cdot\celse \Delta, \alpha : \C$\\
\end{tabular}\]
We suppose that some collection of categories has been prescribed. One
could think of $\C$ as `codes for categories', but we mostly just
pretend that they're literal mathematical objects sitting in the
syntax. The intuitive (and soon to be described formal)
meaning of $\alpha : \C$ is that $\alpha$ has type $\C \x \C^\op$.

There is a notion of definable functor; terms of category type, in category context.
\[\begin{tabular}{rccl}
  Category Terms&$t$&$::=$&$\alpha \celse \bar t \celse F(t, \cdots, t)$\\
\end{tabular}\]
\[
\erule
{\alpha : \C \in\Delta}
{\Delta \prov \alpha : \C}
\qquad
\erule
{\Delta \prov t : \C}
{\Delta \prov \bar t : \C^\op}
\qquad
\erule
{F : \C_1 \x \cdots \C_n \to \C \qquad \Delta \prov t_i : \C_i }
{\Delta \prov F(t_1, \ldots, t_n) : \C}
\]
We have reductions
\[ \overline{\overline t} \mapsto t \]
\[ \overline{F(t_1, \ldots, t_n)} \mapsto F(\bar t_1, \ldots, \bar t_n) \]
We have term-level contexts, with types so far unspecified
\[\begin{tabular}{rccl}
  Contexts&$\Gamma$&$::=$&$\cdot \celse \Gamma, x - A \celse \Gamma, x + A$\\
  Types&$A$&$::=$&$\cdots$\\
\end{tabular}\]
There is a polarity distinction between variables that undergo forward
($+$) and backward ($-$) transport in the semantics.

\subsection{Judgments}

\begin{declbox}
  $ \Delta \prov  \Gamma \rctx $\\
   $\Delta ; \Gamma \prov A : \rtype$\\
   $\Delta ; \Gamma \prov M : A$
\end{declbox}

Context formation is defined by
\[
\erule
{}
{\Delta \prov \cdot \rctx}
\]
\[
\erule
{\Delta \prov \Gamma \rctx \qquad \Delta ; \Gamma \prov A : \rtype}
{\Delta \prov \Gamma, x + A \rctx}
\qquad
\erule
{\Delta \prov \Gamma \rctx \qquad \Delta ; \Gamma^{\op} \prov  A : \rtype}
{\Delta \prov \Gamma, x - A \rctx}
\]
%% There is an operation taking $A$ to $\bar A$, which is the replacement
%% of every context term $t$ appearing in it with its dual $\bar t$. To
%% be clear, not every subterm of that every term hereditarily;
%% merely, when we reach a base type $a(t_1, \ldots, t_n)$ that has some category terms for
%% arguments, we dualize each one of them, yielding $a(\bar t_1, \ldots, \bar t_n)$.

%% I guess I ought to just say that every type $A$ needs to come equipped
%% with a dual $\bar A$, satsifying some lemma to be determined, and what
%% I just said above is the definition of duals for base types. I
%% expect/hope the dualizing clause for function types, pair types, etc. to be mere
%% homomorphisms.

There is an operation $\Gamma^\op$  defined by swapping every $+$ and $-$,
and transposing every type:
\[
\begin{tabular}{rcl}
  ${(\Gamma, x + A)^\op}$&$=$&$\Gamma^\op , x - A$\\
  ${(\Gamma, x - A)^\op}$&$=$&$\Gamma^\op , x + A$\\
\end{tabular}
\]

Well-formedness of contexts is preserved by this operation, which is an involution:
\begin{lemma}
$(\Gamma^\op)^\op = \Gamma$
\end{lemma}

\begin{lemma}
If $\Delta \prov \Gamma \rctx$ then $\Delta \prov \Gamma^\op \rctx$.
\end{lemma}

\begin{proof}
By induction. Suppose
\[\erule
{\Delta \prov \Gamma \rctx \qquad \Delta ; \Gamma \prov A : \rtype}
{\Delta \prov \Gamma, x + A \rctx}\]
We need to show $\Delta \prov \Gamma^\op, x -  A \rctx$. By induction hypothesis,
$\Delta \prov \Gamma^\op \rctx$. So we derive
\[
\erule
{\Delta \prov \Gamma^\op \rctx \qquad \Delta ; \Gamma \prov  A : \rtype}
{\Delta \prov \Gamma^\op, x -  A \rctx}
\]
We're silently using the fact that $(\Gamma^\op)^\op = \Gamma$.

In the other case, we have
\[\erule
{\Delta \prov \Gamma \rctx \qquad \Delta ; \Gamma^\op \prov  A : \rtype}
{\Delta \prov \Gamma, x - A \rctx}\]
and need to show
$\Delta \prov \Gamma^\op, x +  A \rctx$. By induction hypothesis,
$\Delta \prov \Gamma^\op \rctx$. So we derive
\[
\erule
{\Delta \prov \Gamma^\op \rctx \qquad \Delta ; \Gamma^\op \prov  A : \rtype}
{\Delta \prov \Gamma^\op, x +  A \rctx}
\]
\cqed
\end{proof}
\subsection{Semantics of Types}
Before we say what types we have, we'll say what it means to be a
semantically meaningful type in a given pair of contexts.

There are three categories that we want to talk about induced by any $\Delta$.
One is $\ssem \Delta$, and it's just the product of all the categories in it
\[
\begin{tabular}{rcl}
  $\ssem \cdot$&$=$&$\textbf{1}$\\
  $\ssem {\Delta, \alpha : \C}$&$=$&$\ssem \Delta \x \C$\\
\end{tabular}
\]
The second is $\sem \Delta$, and multiplies on a copy of the dual category also:
\[
\sem {\Delta} = \ssem \Delta \x \ssem \Delta^\op
\]
The third is $\T(\Delta)$, which is the twisted arrow category of $\sem \Delta$.
Its objects are morphisms $\psi \in \sem \Delta$, and its morphisms $\psi \to \phi$ are commutative
squares showing how $\psi$ factors through $\phi$:
\[\begin{tikzcd}
  \cdot \ar[r, "\psi"]\ar[d] & \cdot\ar[from=d]\\
  \cdot \ar[r, "\phi"']& \cdot\\
\end{tikzcd}\]
If $\tau : \psi \to \phi$, we can define a morphism $\bar\tau : \bar\psi \to\bar\phi$.

Here's a dictionary of the symbols we'll use for typical members of these categories:
\[\begin{tabular}{rccl}
  Objects of $\ssem \Delta$&$d,e$\\
  Morphisms of $\ssem \Delta$&$f$\\
  Objects of $\sem \Delta$&$\delta, \epsilon$\\
  Morphisms of $\sem \Delta$&$\phi$\\
  \textcolor{gray}{Objects of $\T(\Delta)$}&$\textcolor{gray}{\phi}$\\
  Morphisms of $\T(\Delta)$&$\tau$\\
\end{tabular}\]

We allow writing the pairs that are objects and morphisms
of $\sem \Delta$ without $( , )$ syntax, e.g. $de$ for $(d, e)$.
There is a functor $(\delta \mapsto \bar \delta):  \sem \Delta^\op \to \sem \Delta$ by swapping components.
If $\delta = dd' \in \sem \Delta$, then we define
\[\bar \delta = dd' \in \sem \Delta\]
and when
\[\phi = ff' : \delta \to \epsilon = dd' \to ee'\]
we define
\[ \bar \phi = f'f : \bar \epsilon \to \bar \delta =  e'e \to d'd \]
We freely sometimes write an object of a category in a place where a morphism is required,
intending the identity morphism at that object.

Next, we will declare the functions involved in the semantics of contexts and types.
In general we will write $\rtype$ for the ambient metatheory's notion
of type, and use agda-style syntax for dependent products and sums in
the ambient metatheory, i.e $(x : A) \to B$ and $(x : A) \x B$. We may
be somewhat lax about currying and generally how arguments are
written.

Throughout the following declarations and definitions, we'll assume
 $\Delta \prov \Gamma \rctx$, and $\delta$
is an object in $\sem \Delta$, and $\tau : \psi \to \phi$ is a morphism in $\T(\Delta)$
and $\phi : \delta \to \epsilon$ and $\psi : \delta' \to \epsilon'$ are morphisms in $\sem \Delta$,
arranged like so:
\[\begin{tikzcd}
  \delta' \ar[r, "\psi"]\ar[d, "\tau_1"'] & \epsilon'\ar[from=d, "\tau_2"']\\
  \delta \ar[r, "\phi"']& \epsilon
\end{tikzcd}\]
There are some useful operations on morphisms $\tau \in \T(\Delta)$ that `swing' the side morphisms
around to the codomain.
 \begin{declbox}
   $\ltri \tau : \psi \to \tau_1 \in \T(\Delta)$\\
   $\tri \tau : \psi \to \tau_2 \in \T(\Delta)$
 \end{declbox}
 \begin{defnbox}
   \(
   \ltri \tau  = \begin{tikzcd}
     \delta' \ar[r, "\psi"]\ar[d, equal] & \epsilon'\ar[from=d, "\tau_2 \o \phi"']\\
     \delta' \ar[r, "\tau_1"']& \delta
   \end{tikzcd}
   \qquad
   \tri \tau  = \begin{tikzcd}
     \delta' \ar[r, "\psi"]\ar[d, "\phi \o \tau_1"'] & \epsilon'\ar[from=d, equal]\\
     \epsilon \ar[r, "\tau_2"']& \epsilon'
   \end{tikzcd}
\)
 \end{defnbox}

A notable special case of this falls out when $\tau$ is an identity arrow:
 \begin{thmbox}
   \(
   \ltri \phi  : \phi \to \delta = \begin{tikzcd}
     \delta \ar[r, "\phi"]\ar[d, equal] & \epsilon\ar[from=d, "\phi"']\\
     \delta \ar[r, equal]& \delta
   \end{tikzcd}
\)\\
\(
   \tri \phi : \phi \to \epsilon  = \begin{tikzcd}
     \delta \ar[r, "\phi"]\ar[d, "\phi"'] & \epsilon\ar[from=d, equal]\\
     \epsilon \ar[r, equal]& \epsilon
   \end{tikzcd}
\)
 \end{thmbox}

Ok, now come the real definitions.
And we're going to define them as if contexts were defined inductively by
\[\begin{tabular}{rccl}
  Contexts&$\Gamma$&$::=$&$\cdot \celse \Gamma^\op \celse \Gamma, x + A$\\
\end{tabular}
\]
because we can think of $\Gamma, x - A$ as $(\Gamma^\op, x + A)^\op$.
We declare:
\begin{declbox}
  $\Gamma_\phi : \rtype$.\\
  $\Gamma_\tau : \Gamma_\psi \to \Gamma_\phi $\\
  $A_\delta : \Gamma_\delta \to \rtype$\\
  $A_\phi : (g : \Gamma_\phi) \to A_\delta(\Gamma_{\ltri\phi} g) \to A_\epsilon(\Gamma_{\tri\phi} g)$
\end{declbox}
\begin{defnbox}
 $(\cdot)_\phi = \bone$\\
 $(\Gamma^\op)_\phi = \Gamma_{\bar\phi}$\\
 $(\Gamma, x + A)_\phi = (g : \Gamma_\phi) \x A_\delta( \Gamma_{\ltri\phi} g )$\\
  \\
 $(\cdot)_\tau = {!}$\\
 $(\Gamma^\op)_\tau = \Gamma_{\bar\tau}$\\
 $(\Gamma, x + A)_\tau (g, a) = (\Gamma_\tau g, A_{\tau_1}(\Gamma_{\ltri \tau}g , a) ) $
\end{defnbox}
Here's a blow-by-blow of why the definition of $(\Gamma, x + A)_\tau(g, a)$ is well-typed.
We know we're supposed to make it have type
\[(\Gamma, x + A)_\tau : (g : \Gamma_\psi) \x A_{\delta'}( \Gamma_{\ltri\psi} g ) \to
 (g' : \Gamma_\phi) \x A_\delta( \Gamma_{\ltri\phi} g' )\]
We need $A_{\tau_1}(\Gamma_{\ltri \tau} g, a)$ to have type $A_\delta(\Gamma_{\ltri \phi} \Gamma_\tau g)$.
Plugging $\Gamma_{\ltri \tau}g : \Gamma_{\tau_1}$ into
\[A_{\tau_1} : (x : \Gamma_{\tau_1}) \to A_{\delta'}(\Gamma_{\ltri \tau_1} x) \to A_{\delta}(\Gamma_{\tri \tau_1} x)\]
gives
\[A_{\tau_1}(\Gamma_{\ltri \tau}g ) : A_{\delta'}(\Gamma_{\ltri \tau_1} \Gamma_{\ltri \tau}g )
\to A_{\delta}(\Gamma_{\tri \tau_1} \Gamma_{\ltri \tau}g )\]
In order to apply this to $a$ and be finished, we need
\[\Gamma_{\ltri \tau_1} \Gamma_{\ltri \tau}  = \Gamma_{\ltri\psi} \]
\[\Gamma_{\ltri \phi} \Gamma_\tau = \Gamma_{\tri \tau_1} \Gamma_{\ltri \tau}\]
to make everything match up.
By the functoriality of $\Gamma_\tau$, we merely need to check
\[{\ltri \tau_1} \o {\ltri \tau}  = {\ltri\psi} \qquad
{\ltri \phi} \o \tau = {\tri \tau_1} \o {\ltri \tau}\]
and these are each settled by a diagram chase
\[
\begin{tikzcd}
  \delta' \ar[r, "\psi"]\ar[d, equal] & \epsilon'\ar[from=d, "\tau_2 \o \phi"']\\
  \delta' \ar[r, "\tau_1"']& \delta\\
\delta' \ar[r,equal]\ar[u,equal] & \delta'\ar[u, "\tau_1"']
\end{tikzcd}
\qquad = \qquad
\begin{tikzcd}
  \delta' \ar[r, "\psi"]\ar[d, equal] & \epsilon'\ar[from=d, "\psi"']\\
  \delta' \ar[r, equal]& \delta'
\end{tikzcd}
\]
and
\[\begin{tikzcd}
  \delta' \ar[r, "\psi"]\ar[d, "\tau_1"'] & \epsilon'\ar[from=d, "\tau_2"']\\
  \delta \ar[r, "\phi"']& \epsilon\\
  \delta \ar[r, equal]\ar[u, equal]& \delta\ar[u, "\phi"']
\end{tikzcd}
\qquad = \qquad
\begin{tikzcd}
  \delta' \ar[r, "\psi"]\ar[d, equal] & \epsilon'\ar[from=d, "\tau_2 \o \phi"']\\
  \delta' \ar[r, "\tau_1"']& \delta\\
  \delta \ar[r, equal]\ar[from=u, "\tau_1"']& \delta\ar[u, equal]
\end{tikzcd}\]
\subsection{Semantics of Terms}
We want to define what is required for a judgment
\[\Delta; \Gamma \prov M : A\]
so that in the special case where no type dependency is involved, it reduces to something like
requiring that the interpretation of $M$ belongs to an end
\[\sem M \in \int_{\delta\in\ssem\Delta} \sem\Gamma(\delta) \to \sem A(\delta)\]
Things are a little more involved with dependent types, naturally.

Assume $\Delta ; \Gamma \prov M : A$ and all the well-formedness judgments that presupposes.
Let $f : d \to e$ be a morphism in $\ssem \Delta$. We declare:

\def\fdom{f_0}
\def\fcod{f_1}
\begin{declbox}
  $M_d : (\gamma : \Gamma_{dd}) \to A_{dd}$\\
  $\fdom : ff \to dd \in \T(\Delta)$\\
  $\fcod : ff \to ee \in \T(\Delta)$
\end{declbox}
\begin{defnbox}
\(
   \fdom = \begin{tikzcd}
     de \ar[r, "ff"]\ar[d, "df"'] & ed\ar[from=d, "fd"']\\
     dd \ar[r, equal]& dd
   \end{tikzcd}
\qquad\qquad
   \fcod = \begin{tikzcd}
     de \ar[r, "ff"]\ar[d, "fe"'] & ed\ar[from=d, "ef"']\\
     ee \ar[r, equal]& ee
   \end{tikzcd}
\)
\end{defnbox}
\begin{thmbox}
For any $g : \Gamma_{ff}$, we have
\[ A_{fd}(\Gamma_{\tri \fdom}g, M_d(\Gamma_{\fdom}g )) \equiv A_{ef}(\Gamma_{\tri \fcod} g, M_e( \Gamma_{\fcod} g))\]
\end{thmbox}
Here's an explanation of why the equality in this theorem is well-typed.
 We have first of all
\[ M_d(\Gamma_{\fdom} g) : A_{dd}(\Gamma_{\fdom} g)\qquad
 M_e(\Gamma_{\fcod} g) : A_{ee}(\Gamma_{\fcod} g)\]
and also
\[A_{fd} : (g : \Gamma_{fd}) \to A_{dd}(\Gamma_{\ltri{fd}} g) \to A_{ed}(\Gamma_{\tri{fd}} g)\]
\[A_{ef} : (g : \Gamma_{ef}) \to A_{ee}(\Gamma_{\ltri{ef}} g) \to A_{ed}(\Gamma_{\tri{ef}} g)\]
which means
\[A_{fd}(\Gamma_{\tri \fdom}) :  A_{dd}(\Gamma_{\ltri{fd}}\Gamma_{\tri \fdom} g)
\to A_{ed}(\Gamma_{\tri{fd}} \Gamma_{\tri \fdom} g)\]
\[A_{ef}(\Gamma_{\tri\fcod}) :  A_{ee}(\Gamma_{\ltri{ef}} \Gamma_{\tri\fcod} g)
\to A_{ed}(\Gamma_{\tri{ef}} \Gamma_{\tri\fcod} g)\]
So chase the following diagrams to see
\[ \fdom = \ltri fd \o \tri \fdom \qquad \fcod = \ltri ef \o \tri \fcod\]
(`we're allowed to plug in $M_d$ and $M_e$ where we do') and
\[ \tri fd \o \tri \fdom = \tri ef \o \tri \fcod \]
(`the output types are the same')

\[
\begin{tikzcd}
     de \ar[r, "ff"]\ar[d, "df"'] & ed\ar[from=d, "fd"']\\
     dd \ar[r, equal]& dd
   \end{tikzcd}
\qquad = \qquad
\begin{tikzcd}
     de \ar[r, "ff"]\ar[d, "df"'] & ed\ar[from=d, equal]\\
     dd \ar[r, "fd"']& ed\\
     dd \ar[r, equal]\ar[from=u, equal]&dd\ar[u, "fd"']
\end{tikzcd}
\]
\[
\begin{tikzcd}
     de \ar[r, "ff"]\ar[d, "fe"'] & ed\ar[from=d, "ef"']\\
     ee \ar[r, equal]& ee
   \end{tikzcd}
\qquad = \qquad
\begin{tikzcd}
     de \ar[r, "ff"]\ar[d, "fe"'] & ed\ar[from=d, equal]\\
     ee \ar[r, "ef"']& ed\\
     ee \ar[r, equal]\ar[from=u, equal]&ee\ar[u, "ef"']
\end{tikzcd}
\]
\[\begin{tikzcd}
     de \ar[r, "ff"]\ar[d, "df"'] & ed\ar[from=d, equal]\\
     dd \ar[r, "fd"']& ed\\
     ed \ar[r, equal]\ar[from=u, "fd"']&ed\ar[u, equal]
\end{tikzcd}
\qquad = \qquad
\begin{tikzcd}
     de \ar[r, "ff"]\ar[d, "fe"'] & ed\ar[from=d, equal]\\
     ee \ar[r, "ef"']& ed\\
     ed \ar[r, equal]\ar[from=u, "ef"']&ed\ar[u, equal]
\end{tikzcd}\]

\subsection{Defining Some Types}

Now that I've said what it means to be a type --- or at least the bare
minimum of what's required; I'm probably still missing some
preservation-of-composition lemma declarations --- let's try defining some.

\subsubsection{$\Sigma$ Types}

\[
\erule
{
\Delta; \Gamma \prov A : \rtype \qquad
\Delta; \Gamma, x + A  \prov B : \rtype
}
{\Delta ; \Gamma \prov (x : A) \x B : \rtype}
\]

Observe that the premises of this rule give us all of the following derived functions
to work with:

\[A_\delta : \Gamma_\delta \to \rtype \]
\[B_\delta : (\gamma : \Gamma_\delta) \to A_\delta(\gamma) \to \rtype \]
\[A_\phi : (\psi : \Gamma_\phi) \to A_\delta(\Gamma_\phi^< \psi) \to A_\epsilon(\Gamma_\phi^> \psi)\]
\[B_\phi : (\psi : \Gamma_\phi)(x : A_\delta(\Gamma_\phi^<\psi)) \to B_\delta(\Gamma_\phi^<\psi, x)
\to B_\epsilon(\Gamma_\phi^>\psi, A_\phi(\psi, x))\]

We define the object part of this by
\[((x : A) \x B)_\delta : \Gamma_\delta \to \rtype \]
\[((x : A) \x B)_\delta (\gamma) = (x : A_\delta(\gamma)) \x B_\delta(\gamma, x) \]

and the morphism part needs to be
\[((x:A)\x B)_\phi : (\psi : \Gamma_\phi) \to ((x : A_\delta(\Gamma_\phi^< \psi))
\x B_\delta(\Gamma_\phi^< \psi, x))\]
\[  \to ((x : A_\epsilon(\Gamma_\phi^> \psi)) \x B_\epsilon(\Gamma_\phi^> \psi, x)) \]
and we define it
\[((x:A)\x B)_\phi(\psi, (x, b)) = (A_\phi(\psi, x), B_\phi(\psi, x, b))\]

\vfil\eject
\subsubsection{$\Pi$ Types}

\[
\erule
{
\Delta; \Gamma^\op \prov A : \rtype \qquad
\Delta; \Gamma, x - A  \prov B : \rtype
}
{\Delta ; \Gamma \prov (x : A) \to B : \rtype}
\]

Observe that the premises of this rule give us all of the following derived functions
to work with, for $\phi : \delta \to \epsilon \in \sem \Delta$:

\[A_{\bar \delta} : \Gamma_{ \delta} \to \rtype \]
\[B_\delta : (\gamma : \Gamma_\delta) \to A_{\bar \delta}(\gamma) \to \rtype \]
\[A_{\bar \phi} : (\psi : \Gamma_{ \phi}) \to A_{\bar \epsilon}(\Gamma_\phi^> \psi) \to A_{\bar \delta}(\Gamma_\phi^< \psi) \]
\[B_\phi : (\psi : \Gamma_\phi)(x : A_{\bar \epsilon}(\Gamma_\phi^>\psi)) \to B_\delta(\Gamma_\phi^<\psi, A_{\bar \phi}(\psi, x))
\to B_\epsilon(\Gamma_\phi^>\psi, x)\]

We define the object part of this by
\[((x : A) \to B)_\delta : \Gamma_\delta \to \rtype \]
\[((x : A) \to B)_\delta (\gamma) = (x : A_{\bar \delta}(\gamma)) \to B_\delta(\gamma, x) \]

and the morphism part needs to be
\[((x:A)\to B)_\phi : (\psi : \Gamma_\phi) \to ((x : A_{\bar\delta}(\Gamma_\phi^< \psi))
\to B_\delta(\Gamma_\phi^< \psi, x))\]
\[  \to (x : A_{\bar\epsilon}(\Gamma_\phi^> \psi)) \to B_\epsilon(\Gamma_\phi^> \psi, x) \]
and we define it
\[((x:A)\to B)_\phi(\psi, f, x) = B_\phi(\psi, x, f (A_{\bar \phi}(\psi, x)))\]

\end{document}
