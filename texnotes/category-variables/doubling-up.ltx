\documentclass{article}
\usepackage[tmargin=0.05in, bmargin=0.05in]{geometry}
\input{theorem}
\input{prooftree}
\usepackage{stmaryrd}
\usepackage{latexsym}
\usepackage{yfonts}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,cd,decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}
\usepackage{tcolorbox}
\tcbuselibrary{breakable}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}

\def\sss#1{\noindent{\em{#1}}}
\def\coe{\mathsf{coe}}
\def\bpack{\mathbf{pack}}
\def\bunpack{\mathbf{unpack}}

\def\ltri{{\lhd}}
\def\rtri{{\rhd}}
\def\dtri{{\downarrow}}
\def\wo{\setminus}
\def\fA{\mathsf{A}}
\def\fC{\mathsf{C}}
\def\fX{\mathsf{X}}
\def\ff{\mathsf{f}}
\def\fm{\mathsf{m}}
\def\rspan{\mathsf{Span}}
% \def\El#1{\mathsf{El}({#1})}
\def\El#1{\ulcorner{#1}\urcorner}
\def\quote#1{{\ulcorner {#1} \urcorner}}
\def\U{\mathsf{U}}
\def\uu{\mathsf{u}}
\def\uni{\U}
\def\mor#1#2{#1 \to \underline{#2}}

\def\ridp{\mathsf{idp}}
\def\ssem#1{\langle\!\langle{#1}\rangle\!\rangle}

\definecolor{lred}{rgb}{0.95,0.8,0.8}
\definecolor{cyan}{rgb}{0.80,0.95,0.95}
\definecolor{orange}{rgb}{0.95,0.90,0.80}
\definecolor{bluegray}{rgb}{0.6,0.6,0.85}
\definecolor{lgray}{gray}{0.9}
\newtcolorbox{declbox}{colframe=lred,colback=lred,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{thmbox}{colframe=cyan,colback=cyan,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{defnbox}{colframe=orange,colback=orange,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{tangentbox}{colframe=lgray,colback=lgray,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}

\input{linear}
\def\rpath#1{[#1]}
\def\rfst{\mathsf{fst}\,}
\def\rsnd{\mathsf{snd}\,}
\def\bunfold{\mathbf{unfold}}
\def\bfold{\mathbf{fold}}
\def\susp#1{\langle {#1} \rangle}
\def\ssusp#1{\langle\!\langle {#1} \rangle\!\rangle}
\def\dto{\mathrel{\dot\to}}
\def\dns{{\downarrow}}
\def\ups{{\uparrow}}
\def\sprov{\Vdash}
\def\signat{{\color{red}\Sigma}}
\def\ep#1{\underline{#1}}
\def\wat{\mathbin{@}}
\def\wwat{\mathbin{\underline\wat}}
\def\cn{{:}}
\def\dv{{\div}}
\def\ww{{\mathsf w}}
\def\base{{\textfrak b}}

\def\ll{{<}}
\def\rr{{>}}
\def\cc{\mathsf{c}}
\def\dd{\mathsf{d}}
\def\ii{{\mathbb I}}
\def\T{\mathbb{T}}
\def\pp{\textsf{\textbf p}}
\def\nn{{\mathsf n}}
\def\PP{\textsf{\textbf P}}
\def\NN{{\mathsf N}}
\def\zz{{\mathsf z}}
\def\sem#1{[\![#1]\!]}
\def\usem#1{\lceil\!\!\lceil{#1}\rceil\!\!\rceil}
\def\zem#1{\langle\!\langle#1\rangle\!\rangle}
\def\col#1{{\mathsf{C}}_{#1}}
\def\lax{\mathop\bigcirc}
\def\rjust{\mathsf{just}}
\def\rcvt{\mathsf{cvt}}
\def\rtype{\mathsf{type}}
\def\rdtype{\mathsf{disc}}
\def\rkind{\mathsf{kind}}
\def\rmode{\mathsf{mode}}
\def\rprel{\mathbf{Prel}}
\def\rrfam{\mathbf{Rfam}}
\def\rset{\mathbf{Set}}
\def\rfinset{\mathbf{FinSet}}
\def\rrel{\mathbf{Rel}}
\def\rcat{\mathbf{Cat}}
\def\rfam{\mathbf{Fam}}
\def\binj{\mathbf{inj}}
\def\rid{\mathsf{id}}
\def\rtrue{\mathrel\mathrm{true}}
\def\pbck{\ar[dr, phantom, pos=0, "\lrcorner"]}
\def\bpbck{\ar[ddrr, phantom, pos=0, "\lrcorner"]}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\btwo{\mathbf{2}}
\def\bone{\mathbf{1}}

\newarrow {Equiv} =====
\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\def\mapt{\ar[ddd,mapsto,shorten <=2em, shorten >=2em]}
\def\frommaps{\ar[from=uu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\frommapt{\ar[from=uuu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\I{\mathbf{I}}
\def\C{\mathbf{C}}
\def\G{\mathbf{G}}
\def\S{\mathbf{S}}
\def\D{\mathbf{D}}
\def\E{\mathbf{E}}
\def\M{\mathbf{M}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\o{\circ}
\def\rctx{\,\mathsf{ctx}}
\def\rdctx{\,\mathsf{cat}}
\def\del{\partial}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\definecolor{fib}{HTML}{ff7f00}
\definecolor{green}{HTML}{007f00}
\definecolor{red}{HTML}{df3f3f}
\definecolor{opfib}{HTML}{007fff}

% For lightening colors I used
% http://trycolors.com/ 6 parts white to 1 part color
\definecolor{opfibl}{HTML}{DBEDFF}
\definecolor{greenl}{HTML}{DBEDDB}
\definecolor{redl}{HTML}{FAE4E4}
\def\njudge#1{\fcolorbox{opfib}{white}{#1}}
\def\nrule#1{\fcolorbox{white}{opfibl}{#1}}
\def\neqn#1{\fcolorbox{white}{redl}{#1}}



\def\judge#1{\vskip 2em\noindent \njudge{$#1$}\vskip 0.5em\noindent}
\def\rule#1{\vskip 2em \noindent \nrule{$#1$}\vskip 0.5em\noindent}
\def\eqn#1{\vskip 2em \noindent \neqn{$#1$}\vskip 0.5em\noindent}
\def\prof{\nrightarrow}
\def\tensor{\otimes}
\def\htensor{\mathrel{\hat\otimes}}
\def\lol{\multimap}
\def\hlol{\mathrel{\hat\multimap}}
\def\wtf{{\color{red}???}}

\def\re{\mathbf{E}}
\def\sh{\sharp}
\def\shp{\mathrel{\sharp}}
\def\zero{\texttt{0}}
\begin{document}

\def\
\tikzset{
   commutative diagrams/.cd,
   arrow style=tikz,
   diagrams={>=stealth}}

\section{A Syntax for Category Variables}
Let there be some syntax
\[\begin{tabular}{r@{ }c@{ }c@{ }l}
  Cat. Contexts&$\Delta$&$::=$&$\cdot\celse \Delta, \alpha : \C$\\
  Categories&$\C$&$::=$&$\cdots$\\
  Cat. Terms&$t$&$::=$&$\alpha  \celse \bar \alpha \celse F(t, \ldots, t) $\\
\\
  Term Contexts&$\Gamma$&$::=$&$\cdot \celse \Gamma, x : A$\\
  Types&$A$&$::=$&$(x : A) \to B \celse (x : A) \x B  $\\
&&&$\celse (\alpha : \C) \to B \celse (\alpha : \C) \x B$\\
&&&$\celse \C[t, t] \celse \cdots$\\
  Terms&$M$&$::=$&$x \celse x^* \celse  \lambda x . M \celse M\ M \celse \pair M M \celse \pi_1 M \celse \pi_2 M$\\
&&&$\celse \Lambda \alpha . M \celse M[t] \celse \bpack(M, M) \celse \bunpack(M, \alpha.x.M)$\\
Substitutions&$\theta$&$::=$&$\cdot \celse \theta[M/x]$\\
\\
  Signatures&$\Sigma$&$::=$&$\cdot \celse \Sigma, a : K \celse \Sigma, c : A $\\
  Kinds&$K$&$::=$&$\rtype \celse (x : A) \to K \celse (\alpha : \C) \to K$\\
\end{tabular}\]

We a collection of categories $\C$ and functors $F$ between products of categories
 as an unspecified parameter of the type system.
One could think of them as `codes for
categories (and functors)' the same way a universe is a set of codes for types, but
we mostly just pretend that they're literal mathematical objects
sitting in the syntax.

There are category-variable contexts, and term-level contexts.

We have type-formers for dependent function and product types. We have quantifiers over category variables.
We have a hom-type $\C[t,t]$.
There also may be a collection of base types, which may be thought of as constants $a : K \in \Sigma$
in some signature that tacitly exists in every other definition. The signature can also include
term constants $c : A$.
\subsection{Judgments}

These are the typing judgments; the usual suspects, except we have a $\Delta$ out in front of everything.
\begin{declbox}
  $\Delta \prov  \Gamma \rctx $\\
  $\Delta ; \Gamma \prov A : \rtype$\\
  $\Delta ; \Gamma \prov M : A$\\
  $\Delta ; \Gamma' \prov \theta : \Gamma$
\end{declbox}
There are also some judgments about variable occurrences that I need to define:
\begin{declbox}
  $x \in^+ A$\\
  $x \in^- A$
\end{declbox}
We read $x \in^+ A$ (resp. $\in^-$) as `$x$
{\em only} occurs positively (resp. negatively) in $A$', but it doesn't
actually require any occurrences of $x$.
It might have been more clear to use the notation
 $\not\in^-$, $\not\in^+$ instead of $\in^+$, $\in^-$.

\subsection{Operations}
We define an `inverting' substitution $\theta_\Gamma$. Its intended type
signature is
\begin{declbox}
 $\Gamma \prov  \theta_\Gamma : \Gamma$
\end{declbox}
but we won't be able to prove this until after we give the typing rules,
which use this definition.

The definition of $\theta_\Gamma$ is:
\begin{defnbox}
$  \theta_\cdot = \cdot$\\
$\theta_{\Gamma, x : A} = \theta_\Gamma [x^* / x]$
\end{defnbox}
When  $\Delta ; \Gamma\prov A : \rtype$, we write $\theta_\Gamma A$ as simply $A^*$.
This is used in one of the two variable rules below.

\subsection{Rules}
\subsubsection{Context Formation}
\[
\erule
{}
{\Delta \prov \cdot \rctx}
\qquad
\erule
{\Delta \prov \Gamma \rctx \qquad \Delta ; \Gamma \prov A : \rtype}
{\Delta \prov \Gamma, x : A \rctx}
\]

\subsubsection{Type Formation}

\[
\erule
{
\Delta; \Gamma \prov  A : \rtype \qquad
\Delta; \Gamma, x : A  \prov B : \rtype\qquad x \in^- B
}
{\Delta ; \Gamma \prov (x : A) \to B : \rtype}
\]

\[
\erule
{
\Delta; \Gamma \prov A : \rtype \qquad
\Delta; \Gamma, x : A  \prov B : \rtype\qquad x \in^+ B
}
{\Delta ; \Gamma \prov (x : A) \x B : \rtype}
\]

\[
\erule
{
\Delta, \alpha : \C; \Gamma \prov A : \rtype
}
{\Delta ; \Gamma \prov (\alpha : \C) \to A : \rtype}
\]

\[
\erule
{
\Delta, \alpha : \C; \Gamma \prov A : \rtype
}
{\Delta ; \Gamma \prov (\alpha : \C) \x A : \rtype}
\]

\[
\erule
{
\Delta \prov t_1 : \C^\op \qquad \Delta \prov t_2 : \C
}
{\Delta ; \Gamma \prov \C[t_1,t_2] : \rtype}
\]

\subsubsection{Terms}

\sss{Variables}
\[
\erule
{
x : A \in \Gamma
}
{\Delta ; \Gamma \prov x : A }
\qquad
\erule
{
x :  A \in \Gamma
}
{\Delta ; \Gamma \prov x^* : A^* }
\]

\sss{Functions}
\[
\erule
{
\Delta; \Gamma, x : A  \prov M : B
}
{\Delta ; \Gamma \prov \lambda x . M : (x : A) \to B }
\]
\[
\erule
{
\Delta ; \Gamma \prov M : (x : A) \to B
\qquad
\Delta ; \Gamma \prov N : A
}
{
\Delta ; \Gamma \prov M\ N : [N/x]B
}
\]

\sss{Products}
\[
\erule
{
\Delta; \Gamma \prov M : A
\qquad
\Delta; \Gamma \prov N : [M/x]B
}
{\Delta ; \Gamma \prov \pair M N : (x : A) \x B }
\]
\[
\erule
{
\Delta ; \Gamma \prov M : (x : A) \x B
}
{
\Delta ; \Gamma \prov \pi_1 M : A
}
\qquad
\erule
{
\Delta ; \Gamma \prov M : (x : A) \x B
}
{
\Delta ; \Gamma \prov \pi_2 M : [\pi_1 M/x]B
}
\]

\sss{Forall}
\[
\erule
{
\Delta, \alpha : \C ; \Gamma \prov M : A
}
{\Delta ; \Gamma \prov \Lambda \alpha . M : (\alpha : \C) \to A }
\]
\[
\erule
{
\Delta ; \Gamma \prov M : (\alpha : \C) \to A
\qquad
\Delta \prov t : \C
}
{
\Delta ; \Gamma \prov M[t] : [t/\alpha]A
}
\]


\sss{Exists}
\[
\erule
{
\Delta ; \Gamma \prov t : \C
\qquad
\Delta ; \Gamma \prov M : [t/\alpha]A
}
{\Delta ; \Gamma \prov \bpack(t, M) : (\alpha : \C) \x A }
\]
\[
\erule
{
\Delta ; \Gamma \prov M : (\alpha : \C) \x A
\qquad
\Delta, \alpha : \C; \Gamma, x : A \prov N : B
}
{
\Delta ; \Gamma \prov \bunpack(M, \alpha.x.N) : B
}
\]


\sss{Hom-Types}

\textcolor{red}{The main glaring uncertainty with the
  following is whether the $\alpha$, $\beta$ in $\coe^{\alpha \beta h}$
 and $\coe_{\alpha \beta h}$ count as covariant or
  contravariant occurrences or neither or both or whatever.}
\textcolor{bluegray}{Other than that, I like the notion that there should be one elim rule $\coe^{\alpha \beta h}$
that expresses the Yoneda fact that
\[A(y) = \forall x . \hom(y, x) \to A(x) \]
and another $\coe_{\alpha \beta h}$ that expresses that
\[A(y) = \exists x . \hom(x, y) \x A(x) \]
}
\[
\erule
{
\Delta \prov t : \C
}
{\Delta; \Gamma \prov \rid_t : \C[\bar t, t]}
\]
\[
\erule
{
\Delta; \gamma : \C; \Gamma \prov M : [\bar \gamma/\alpha][\gamma/\beta][\rid_\gamma/h]A \qquad \bar\alpha, \bar \beta \not\in A
}
{\Delta, \alpha : \C^\op, \beta : \C ; \Gamma, h - \C[\bar\alpha,\bar\beta] \prov \coe^{\alpha \beta h}(\gamma.M) : A}
\]

\[
\erule
{
\Delta; \gamma : \C; \Gamma \prov M : [\bar \gamma/\alpha][\gamma/\beta][\rid_\gamma/h]A \qquad \bar\alpha, \bar \beta \not\in A
}
{\Delta, \alpha : \C^\op, \beta : \C ; \Gamma, h + \C[\alpha,\beta] \prov \coe_{\alpha \beta h}(\gamma.M) : A}
\]

\subsubsection{Substitutions}
\[
\erule
{}
{\Delta;\Gamma \prov \cdot : \cdot}
\qquad
\erule
{\Delta;\Gamma \prov \theta : \Gamma'\qquad \Delta ; \Gamma \prov M : \theta A}
{\Delta;\Gamma \prov \theta[M/x] : \Gamma', x : A}
\]

\subsubsection{Category Terms}
\[
\erule
{\alpha : \C \in\Delta}
{\Delta \prov \alpha : \C}
\qquad
\erule
{\alpha : \C \in \Delta}
{\Delta \prov \bar \alpha : \C^\op}
\qquad
\erule
{F : \C_1 \x \cdots \x \C_n \to \C \qquad \Delta \prov t_i : \C_i }
{\Delta \prov F(t_1, \ldots, t_n) : \C}
\]
Recall that we're being lazy and basically taking $\C$ and $F$ seriously as real categories and functors.
For example, the first premise of the last rule above is asking for $F$ to be any functor at all from
 product category $\C_1 \x \cdots \x \C_n$ to the category $\C$. What we should probably do instead
is have a proper syntax for them.

We consider strictly equal, i.e. treat as reductions,
\[ \overline{\overline t} \mapsto t \]
\[ \overline{F(t_1, \ldots, t_n)} \mapsto F^\op(\bar t_1, \ldots, \bar t_n) \]

\subsection{Results}



\begin{theorem}[Substitution]\ %
  \begin{itemize}
  \item If $\Delta ; \Gamma \prov M : A$ and $\Delta ; \Gamma, x : A \prov J$, then
$\Delta ; \Gamma \prov [M/x]J$.
  \item If $\Delta ; \Gamma' \prov \theta : \Gamma$ and $\Delta ; \Gamma \prov J$, then
$\Delta ; \Gamma' \prov \theta J$.
  \item If $\Delta \prov t : \C$ and $\Delta, \alpha : \C \prov J$, then
$\Delta \prov [t/\alpha]J$.
  \end{itemize}
\end{theorem}


We can now check
\begin{thmbox}
 $\Gamma \prov  \theta_\Gamma : \Gamma$
\end{thmbox}
by observing
\[
\erule
{
\[ i.h. \justifies \Delta;\Gamma \prov \theta_\Gamma : \Gamma\]
\[ \justifies \Delta;\Gamma, x : A \prov x^* : \theta_\Gamma A \]}
{\Delta;\Gamma, x : A \prov \theta_\Gamma[x^*/x] : \Gamma, x : A}
\]

\section{Semantics}
\subsection{Types}
We aim here to say what it is to be a
semantically meaningful type in a given pair of contexts $\Delta$ and $\Gamma$.

\subsubsection{Preliminaries}

Given a $\Delta$, there are three categories induced by it that we'll want to talk about.
The simplest is $\ssem \Delta$, and it's just the product of all the categories in it
\[
\begin{tabular}{rcl}
  $\ssem \cdot$&$=$&$\textbf{1}$\\
  $\ssem {\Delta, \alpha : \C}$&$=$&$\ssem \Delta \x \C$\\
\end{tabular}
\]
The second is $\sem \Delta$, and multiplies on a copy of the dual category also:
\[
\sem {\Delta} = \ssem \Delta \x \ssem \Delta^\op
\]
The third is $\T\sem\Delta$, which is the twisted arrow category of $\sem \Delta$.

In general, for any category $\C$, the objects of $\T \C$ are morphisms $\psi \in \C$, and its morphisms $\tau : \psi \to \phi$ are commutative
squares showing how $\psi$ factors through $\phi$:
\[\begin{tikzcd}
  \delta' \ar[r, "\psi"]\ar[d, "\tau_1"'] & \epsilon'\ar[from=d, "\tau_2"']\\
  \delta \ar[r, "\phi"']& \epsilon
\end{tikzcd}\]
We can of course write a $\tau$ as just the pair $(\tau_1, \tau_2)$ that determines it.
To extract the parts of a morphism $\tau$, we define $\ll \tau = \tau_1$
 and $\rr \tau = \tau_2$
and $\cc \tau = \phi$ (`codomain') and $\dd \tau = \psi$ (`domain').
We also write $\ll \phi$ and $\rr \phi$ for the (co)domain of a morphism $\phi \in \sem \Delta$.

Here's a summary of the symbols we'll use for typical members of the above categories:
\[\begin{tabular}{rccl}
  Objects of $\ssem \Delta$&$d,e$\\
  Morphisms of $\ssem \Delta$&$f$\\
  Objects of $\sem \Delta$&$\delta, \epsilon$\\
  Morphisms of $\sem \Delta$&$\phi,\psi$\\
  \textcolor{gray}{Objects of $\T\sem\Delta$}&$\textcolor{gray}{\phi,\psi}$\\
  Morphisms of $\T\sem\Delta$&$\tau,\sigma$\\
\end{tabular}\]

We allow writing the pairs that are objects and morphisms
of $\sem \Delta$ without $(\dash , \dash)$ syntax, e.g. $de$ for $(d, e)$.
We freely sometimes write an object of a category in a place where a morphism is required,
intending the identity morphism at that object.

\subsubsection{Swapping Operations}
There is a functor $(\delta \mapsto \bar \delta):  \sem \Delta^\op \to \sem \Delta$ by swapping components.
If $\delta = dd' \in \sem \Delta$, then we define
\[\bar \delta = dd' \in \sem \Delta\]
We can swap morphisms of $\sem \Delta$ as well. When
\[\phi = ff' : \delta \to \epsilon = dd' \to ee'\]
we define
\[ \bar \phi = f'f : \bar \epsilon \to \bar \delta =  e'e \to d'd \]
We can swap morphisms in the twisted arrow category as well.
Whenever we have $\tau : \psi \to \phi$, we can define a morphism $\bar\tau : \bar\psi \to\bar\phi$ by
$\overline{(\tau_1, \tau_2)} = (\bar \tau_2, \bar\tau_1)$. In a diagram,
\[
\begin{tikzcd}
  \delta' \ar[r, "\psi"]\ar[d, "\tau_1"'] & \epsilon'\ar[from=d, "\tau_2"']\\
  \delta \ar[r, "\phi"']& \epsilon
\end{tikzcd}
\qquad\mapsto\qquad
\begin{tikzcd}
  \bar\delta' \ar[from=r, "\bar\psi"']\ar[from=d, "\bar{\tau_1}"] & \bar\epsilon'\ar[d, "\bar{\tau_2}"]\\
  \bar\delta \ar[from=r, "\bar\phi"]& \bar\epsilon
\end{tikzcd}\]


\subsubsection{Other Operations on the Twisted Arrow Category}

For any category $\C$ (but we will mostly have in mind $\C = \sem \Delta$)
there are various ways we can build up morphisms in $\T\C$ from morphisms in $\C$:
\def\gol{\sqsubset}
\def\gor{\sqsupset}
\begin{declbox}
$\phi \gol \eta : \phi\eta \to \phi$\\
$\phi \gor \eta : \phi\eta \to \eta$
%% \\ $\phi \dtri \eta : \phi\eta \to \rid_\delta$
\end{declbox}
\begin{defnbox}
   \(
   \phi \gol \eta  \quad = \quad \begin{tikzcd}
     \gamma \ar[r, "\phi \o \eta"]\ar[d, "\eta"'] & \epsilon\ar[from=d, equal]\\
     \delta \ar[r, "\phi"']& \epsilon
   \end{tikzcd}
   \qquad
   \phi \gor \eta  \quad = \quad \begin{tikzcd}
     \gamma \ar[r, "\phi \o \eta"]\ar[d, equal] & \epsilon\ar[from=d, " \phi"']\\
     \gamma \ar[r, "\eta"']& \delta
   \end{tikzcd}
\)
%% \\
%% \(
%%    \phi \dtri \eta  \quad = \quad \begin{tikzcd}
%%      \gamma \ar[r, "\phi \o \eta"]\ar[d, "\eta"'] & \epsilon\ar[from=d, "\phi"']\\
%%      \delta \ar[r, equal]& \delta
%%    \end{tikzcd}
%% \)
\end{defnbox}

The next operation we want to define is one that takes a morphisms $\tau \in \T \C$
and `swings' the side morphisms around to the codomain. We say
 \begin{declbox}
   $\ltri \tau : \dd \tau \to \ll \tau $\\
   $\rtri \tau : \dd \tau \to \rr \tau$
 \end{declbox}
\begin{defnbox}
  $\ltri \tau = (\rr \tau \o \cc \tau) \gor \ll \tau$\\
  $\rtri \tau = \rr \tau \gol (\cc \tau \o \ll \tau)$
\end{defnbox}
In a diagram, assuming
\[\tau \quad = \quad \begin{tikzcd}
  \delta' \ar[r, "\psi"]\ar[d, "\tau_1"'] & \epsilon'\ar[from=d, "\tau_2"']\\
  \delta \ar[r, "\phi"']& \epsilon
\end{tikzcd}\]
this looks like
 \begin{thmbox}
   \(
   \ltri \tau  = \begin{tikzcd}
     \delta' \ar[r, "\psi"]\ar[d, equal] & \epsilon'\ar[from=d, "\tau_2 \o \phi"']\\
     \delta' \ar[r, "\tau_1"']& \delta
   \end{tikzcd}
   \qquad
   \rtri \tau  = \begin{tikzcd}
     \delta' \ar[r, "\psi"]\ar[d, "\phi \o \tau_1"'] & \epsilon'\ar[from=d, equal]\\
     \epsilon \ar[r, "\tau_2"']& \epsilon'
   \end{tikzcd}
\)
 \end{thmbox}

A notable special case of this falls out when $\tau$ is an identity arrow:
 \begin{thmbox}
   \(
   \ltri \phi  : \phi \to \delta = \begin{tikzcd}
     \delta \ar[r, "\phi"]\ar[d, equal] & \epsilon\ar[from=d, "\phi"']\\
     \delta \ar[r, equal]& \delta
   \end{tikzcd}
\)\qquad
\(
   \rtri \phi : \phi \to \epsilon  = \begin{tikzcd}
     \delta \ar[r, "\phi"]\ar[d, "\phi"'] & \epsilon\ar[from=d, equal]\\
     \epsilon \ar[r, equal]& \epsilon
   \end{tikzcd}
\)
 \end{thmbox}

%% Also, we could have instead started by defining $\ltri$ and $\rtri$,
%% and defined
%% \[\phi \gol \eta = \rtri(\phi \dtri \eta)\]
%% \[\phi \gor \eta = \ltri(\phi \dtri \eta)\]
%% in terms of them.
\subsubsection{Semantics of Contexts}
Next, we will declare the functions involved in the semantics of contexts and types.
In general we will write $\rtype$ for the ambient metatheory's notion
of type, and use agda-style syntax for dependent products and sums in
the ambient metatheory, i.e $(x : A) \to B$ and $(x : A) \x B$. We may
be somewhat lax about currying and generally how arguments are
written.

Throughout the following declarations and definitions, we'll assume
 $\Delta \prov \Gamma \rctx$, and $\delta$
is an object in $\sem \Delta$, and $\tau : \psi \to \phi$ is a morphism in $\T\sem\Delta$
and $\phi : \delta \to \epsilon$ and $\psi : \delta' \to \epsilon'$ are morphisms in $\sem \Delta$,
arranged like so:
\[\begin{tikzcd}
  \delta' \ar[r, "\psi"]\ar[d, "\tau_1"'] & \epsilon'\ar[from=d, "\tau_2"']\\
  \delta \ar[r, "\phi"']& \epsilon
\end{tikzcd}\]

The declarations come in three mutually recursive groups.
The first is the core semantics of types. These are the functions
that we will be obligated to define for each type constructor farther down
below.
\begin{declbox}
  $A_\delta : \Gamma_\delta \to \rtype$\\
  $A^\phi : (g : \Gamma_\phi) \to A^<_{\phi}(g) \to A^>_{\phi}( g)$
\end{declbox}
The second is some convenience `macros' for the semantics of types.
\begin{declbox}
  $A^<_\phi, A^>_\phi : \Gamma_\phi \to \rtype$\\
  $A_<^\tau : (g : \Gamma_\psi) \to A^<_\psi(g) \to A^<_\phi(\Gamma^\tau g)$\\
  $A_>^\tau :  (g : \Gamma_\psi) \to A^>_\phi(\Gamma^\tau g) \to A^>_\psi(g) $
\end{declbox}
\begin{defnbox}
  $A_\phi^<(g) = A_{\ll \phi}(\Gamma^{\ltri \phi} g)$\\
  $A_\phi^>(g) = A_{\rr \phi}(\Gamma^{\rtri \phi} g)$\\
  $A^\tau_<(g, a) = A^{\ll \tau}(\Gamma^{\ltri \tau} g, a)$\\
  $A^\tau_>(g, a) = A^{\rr \tau}(\Gamma^{\rtri \tau} g, a)$
\end{defnbox}

Finally, the semantics of contexts are given by
\begin{declbox}
  $\Gamma_\phi : \rtype$.\\
  $\Gamma^!_\phi : \Gamma_{\phi} \to \Gamma_{\bar\phi} $\\
  $\Gamma^\tau : \Gamma_{\psi} \to \Gamma_{\phi} $
\end{declbox}
\begin{defnbox}
 $(\cdot)_\phi = \bone$\\
  $(\Gamma, x : A)_\phi = (g : \Gamma_\phi) \x A^<_\phi(g) \x A^<_{\bar\phi}(\bar g)$\\
\\
 $(\cdot)^!_\phi = {!}$\\
  $(\Gamma, x : A)^!_\phi(g, a, a') = (\bar g, a', a)$  \\
\\
 $(\cdot)^\tau = {!}$\\
  $(\Gamma, x : A)^{\tau}(g, a, a') = (\Gamma^{\tau} g, A^\tau_<(g, a), A^{\bar\tau}_<(\bar g, a'))$
\end{defnbox}
Where we abbreviate $\Gamma^!_\phi g$ as $\overline g$.



\subsubsection{Functoriality}
I used functoriality of $\Gamma_\tau$ in the proof of well-typedness
of these definitions. Suppose
\[\begin{tikzcd}
  \gamma \ar[r, "\gamma"] & \delta \ar[r, "\phi"] & \epsilon
\end{tikzcd}\]

We need to establish eventually for all type constructors we actually
introduce
\begin{thmbox}
  $A^{\rid_\delta}(g, a) = a$\\
  $A^{\phi\eta}(g, a) = A^\phi(\Gamma^{\phi \gol \eta}g, A^\eta(\Gamma^{\phi \sqsupset \eta}g, a))$
\end{thmbox}
Alternatively, in terms of the macros we used above, we could have equivalently
asserted
%% \[ A^{\tau \sigma}_<(g, a) = A^{\iota\iota'}(\Gamma^{\ltri (\tau\sigma) } g, a)\]
%% \[ = A^{\iota}(\Gamma^{\ltri \tau}\Gamma^\sigma g ,  A^{\iota'}(\Gamma^{\ltri \sigma}  g, a))\]
%% \[ = A_<^{\tau}(\Gamma^\sigma g ,  A_<^{ \sigma}( g, a))\]
\begin{thmbox}
$A_<^{\tau\sigma} =  A_<^{\tau}(\Gamma^\sigma g ,  A_<^{ \sigma}( g, a))$\\
$A_>^{\tau\sigma} =  A_>^{\tau}(\Gamma^\sigma g ,  A_>^{ \sigma}( g, a))$
\end{thmbox}
Anyway, assuming that's true, we can then prove inductively over the structure of
contexts that
\begin{thmbox}
 $\Gamma^\rid g = g$\\
 $\Gamma^{\tau \o \sigma}g = \Gamma^\tau\Gamma^\sigma g$
\end{thmbox}
\subsection{Terms}
We want to define what is required for a judgment
\[\Delta; \Gamma \prov M : A\]
so that in the special case where no type dependency is involved, it reduces to something like
requiring that the interpretation of $M$ belongs to an end
\[\sem M \in \int_{\delta\in\ssem\Delta} \sem\Gamma(\delta) \to \sem A(\delta)\]
Things are a little more involved with dependent types, naturally.

Assume $\Delta ; \Gamma \prov M : A$ and all the well-formedness judgments that presupposes.
Let $f : d \to e$ be a morphism in $\ssem \Delta$. We declare:

\def\fdom{\mathbf{d}f}
\def\fcod{\mathbf{e}f}

\begin{declbox}
  $M_d : (g : \Gamma_{dd}) \to A_{dd}(g)$\\
  $\fdom : ff \to dd \in \T\sem\Delta$\\
  $\fcod : ff \to ee \in \T\sem\Delta$
\end{declbox}
\begin{defnbox}
\(
   \fdom = \begin{tikzcd}
     de \ar[r, "ff"]\ar[d, "df"'] & ed\ar[from=d, "fd"']\\
     dd \ar[r, equal]& dd
   \end{tikzcd}
\qquad\qquad
   \fcod = \begin{tikzcd}
     de \ar[r, "ff"]\ar[d, "fe"'] & ed\ar[from=d, "ef"']\\
     ee \ar[r, equal]& ee
   \end{tikzcd}
\)
\end{defnbox}
% end condition
\begin{thmbox}
For any $g : \Gamma_{ff}$, we have
\[ A_{fd}(\Gamma_{\rtri \fdom}g, M_d(\Gamma_{\fdom}g )) \equiv A_{ef}(\Gamma_{\rtri \fcod} g, M_e( \Gamma_{\fcod} g))\]
\end{thmbox}


Here's an explanation of why the equality in this theorem is well-typed.
 We have first of all
\[ M_d(\Gamma_{\fdom} g) : A_{dd}(\Gamma_{\fdom} g)\qquad
 M_e(\Gamma_{\fcod} g) : A_{ee}(\Gamma_{\fcod} g)\]
and also
\[A_{fd} : (g : \Gamma_{fd}) \to A_{dd}(\Gamma_{\ltri{fd}} g) \to A_{ed}(\Gamma_{\rtri{fd}} g)\]
\[A_{ef} : (g : \Gamma_{ef}) \to A_{ee}(\Gamma_{\ltri{ef}} g) \to A_{ed}(\Gamma_{\rtri{ef}} g)\]
which means
\[A_{fd}(\Gamma_{\rtri \fdom}) :  A_{dd}(\Gamma_{\ltri{fd}}\Gamma_{\rtri \fdom} g)
\to A_{ed}(\Gamma_{\rtri{fd}} \Gamma_{\rtri \fdom} g)\]
\[A_{ef}(\Gamma_{\rtri\fcod}) :  A_{ee}(\Gamma_{\ltri{ef}} \Gamma_{\rtri\fcod} g)
\to A_{ed}(\Gamma_{\rtri{ef}} \Gamma_{\rtri\fcod} g)\]
So chase the following diagrams to see
\[ \fdom = \ltri fd \o \rtri \fdom \qquad \fcod = \ltri ef \o \rtri \fcod\]
(`we're allowed to plug in $M_d$ and $M_e$ where we do') and
\[ \rtri fd \o \rtri \fdom = \rtri ef \o \rtri \fcod \]
(`the output types are the same')

\[
\begin{tikzcd}
     de \ar[r, "ff"]\ar[d, "df"']\ar[dr, phantom, "\fdom"] & ed\ar[from=d, "fd"']\\
     dd \ar[r, equal]& dd
   \end{tikzcd}
\qquad = \qquad
\begin{tikzcd}
     de \ar[r, "ff"]\ar[d, "df"']\ar[dr, phantom, "\rtri \fdom"] &[1em] ed\ar[from=d, equal]\\
     dd \ar[r, "fd" description]\ar[dr, phantom, "\ltri fd"]& ed\\
     dd \ar[r, equal]\ar[from=u, equal]&dd\ar[u, "fd"']
\end{tikzcd}
\]
\[
\begin{tikzcd}
     de \ar[r, "ff"]\ar[dr, phantom, "\fcod"]\ar[d, "fe"'] & ed\ar[from=d, "ef"']\\
     ee \ar[r, equal]& ee
   \end{tikzcd}
\qquad = \qquad
\begin{tikzcd}
     de \ar[r, "ff"]\ar[d, "fe"']\ar[dr, phantom, "\rtri\fcod"] &[1em] ed\ar[from=d, equal]\\
     ee \ar[r, "ef" description]\ar[dr, phantom, "\ltri ef"] & ed\\
     ee \ar[r, equal]\ar[from=u, equal]&ee\ar[u, "ef"']
\end{tikzcd}
\]
\[\begin{tikzcd}
     de \ar[r, "ff"]\ar[d, "df"'] & ed\ar[from=d, equal]\\
     dd \ar[r, "fd"']& ed\\
     ed \ar[r, equal]\ar[from=u, "fd"']&ed\ar[u, equal]
\end{tikzcd}
\qquad = \qquad
\begin{tikzcd}
     de \ar[r, "ff"]\ar[d, "fe"'] & ed\ar[from=d, equal]\\
     ee \ar[r, "ef"']& ed\\
     ed \ar[r, equal]\ar[from=u, "ef"']&ed\ar[u, equal]
\end{tikzcd}\]

\subsection{Semantics of Types}

\begin{defnbox}
  $((x : A) \x B)_\delta (g) = (x : A_\delta(g)) \x B_\delta(g, x)$\\
  $((x : A) \to B)_\delta (g) = (x : \bar A_{\bar \delta}(g)) \to B_\delta(g, x)$\\
  $((\alpha : \C) \x A)_{\delta}(g) = \int^{d \in \C} A_{\delta dd}(g)$\\
  $((\alpha : \C) \to A)_{\delta}(g) = \int_{d \in \C} A_{\delta dd}(g)$\\
  $(\C[t_1, t_2])_\delta = \C[(t_1)_\delta, (t_2)_\delta]$\\
  \\
  $((x : A)\x B)_\phi(g, (a, b)) = (A_\phi(g, a), B_\phi((g, a), b))$\\
  $((x : A)\to B)_\phi(g, f) = \lambda x . B_\phi((g, x), f (\bar A_{\bar \phi}(g, x)))$\\
%  $((\alpha : \C) \x A)_{\phi}(g, K) = \bunpack(K, d.a.\bpack(d, A_{\phi d d}(g, a)  )) $\\
  $((\alpha : \C) \x A)_{\phi}(g, K) = (K_1, A_{\phi K_1 K_1}(g, K_2))$\\
  $((\alpha : \C) \to A)_{\phi}(g, E) = \lambda d . A_{\phi d d}(g, E(d))$\\
  $(\C[t_1, t_2])_\phi(g, m) = \C[(t_1)_\phi, (t_2)_\phi](m)$
\end{defnbox}

\subsection{Semantics Of Terms}

\begin{defnbox}
  $(\lambda x . M)_d(g) = \lambda x . M_d(g, x)$\\
  $(\Lambda \alpha. A)_d(g) = \lambda c . M_{dc}(g)$\\
  $(M[t])_d(g) = M_d(g)(t(dd))$\\
  $(\rid_t)_d = \rid_{t_{dd}}$
\end{defnbox}

\subsection{Miscellaneous Notes Reasoning Through Semantics}
\subsubsection{$\Sigma$ Types}


Observe that the premises of the formation rule

\[
\erule
{
\Delta; \Gamma \prov A : \rtype \qquad
\Delta; \Gamma, x : A  \prov B : \rtype
}
{\Delta ; \Gamma \prov (x : A) \x B : \rtype}
\]
 give us all of the following derived functions
to work with:

\[A_\delta : \Gamma_\delta \to \rtype \]
\[B_\delta : (g : \Gamma_\delta) \to A_\delta(g) \to \rtype \]
\[A_\phi : (g : \Gamma_\phi) \to A_\delta(\Gamma_{\ltri\phi} g) \to A_\epsilon(\Gamma_{\rtri\phi} g)\]
\[B_\phi : (g : \Gamma_\phi)(x : A_\delta(\Gamma_{\ltri\phi} g)) \to B_\delta(\Gamma_{\ltri\phi}g, x)
\to B_\epsilon(\Gamma_{\rtri\phi}g, A_\phi(g, x))\]

We define the object part of this, of type
  \( ((x : A) \x B)_\delta : \Gamma_\delta \to \rtype \)
as
\begin{defnbox}
  $((x : A) \x B)_\delta (g) = (x : A_\delta(g)) \x B_\delta(g, x)$
\end{defnbox}

and the morphism part needs to be
\[((x+A)\x B)_\phi : (g : \Gamma_\phi) \to ((x : A_\delta(\Gamma_{\ltri\phi} g))
\x B_\delta(\Gamma_{\ltri\phi} g, x))\]
\[  \to ((x : A_\epsilon(\Gamma_{\rtri\phi} g)) \x B_\epsilon(\Gamma_{\rtri\phi} g, x)) \]
and we define it
\begin{defnbox}
  $((x+A)\x B)_\phi(g, (x, b)) = (A_\phi(g, x), B_\phi(g, x, b))$
\end{defnbox}

\subsubsection{$\Pi$ Types}


Observe that the premises of the formation rule
\[
\erule
{
\Delta; \Gamma \prov \bar A : \rtype \qquad
\Delta; \Gamma, x : A  \prov B : \rtype
}
{\Delta ; \Gamma \prov (x : A) \to B : \rtype}
\]
 give us all of the following derived functions
to work with, for $\phi : \delta \to \epsilon \in \sem \Delta$:

\[\bar A_{\bar \delta} : \Gamma_{ \delta} \to \rtype \]
\[B_\delta : (g : \Gamma_\delta) \to \bar A_{\bar \delta}(g) \to \rtype \]
\[\bar A_{\bar \phi} : (g : \Gamma_{ \phi}) \to \bar A_{\bar \epsilon}(\Gamma_{\rtri\phi} g) \to \bar A_{\bar \delta}(\Gamma_{\ltri\phi} g) \]
\[B_\phi : (g : \Gamma_\phi)(x : \bar A_{\bar \epsilon}(\Gamma_{\rtri\phi}g)) \to B_\delta(\Gamma_{\ltri\phi}g, \bar A_{\bar \phi}(g, x))
\to B_\epsilon(\Gamma_{\rtri\phi}g, x)\]

We define the object part of this (of type $((x : A) \to B)_\delta : \Gamma_\delta \to \rtype$) by
\begin{defnbox}
  $((x : A) \to B)_\delta (g) = (x : \bar A_{\bar \delta}(g)) \to B_\delta(g, x) $
\end{defnbox}
and the morphism part needs to be
\[((x-A)\to B)_\phi : (g : \Gamma_\phi) \to ((x : \bar A_{\bar\delta}(\Gamma_{\ltri\phi} g))
\to B_\delta(\Gamma_{\ltri\phi} g, x))\]
\[  \to (x : \bar A_{\bar\epsilon}(\Gamma_{\rtri\phi} g)) \to B_\epsilon(\Gamma_{\rtri\phi} g, x) \]
and we define it
\begin{defnbox}
  $((x-A)\to B)_\phi(g, f, x) = B_\phi(g, x, f (\bar A_{\bar \phi}(g, x)))$
\end{defnbox}

\subsubsection{Lambdas}

\[
\erule
{\Delta ; \Gamma, x : A \prov M : B}
{\Delta ; \Gamma \prov \lambda x . M : (x : A) \to B}
\]

We want to construct the object part
\[(\lambda x . M)_d : (g : \Gamma_{dd}) \to ((x : A) \to B)_{dd}(g)\]
\[ = (g : \Gamma_{dd}) (x : \bar A_{dd}(g)) \to B_{dd}(g, x)\]
We get to assume the object part
\[ M_d : (g : (\Gamma, x : A)_{dd}) \to B_{dd}(g)\]
\[ =  (g : \Gamma_{dd}) (x : \bar A_{dd}( g) ) \to B_{dd}(g, x)\]
So we define
\begin{defnbox}
  $(\lambda x .M)_d(g)( x) = M_d(g, x)$
\end{defnbox}

As for the end-condition, if we turn the crank on either the top or the bottom of the rule, we get
\[(g : \Gamma_{ff})(a : \bar A_{de}(\Gamma_{\rtri ff} g)) \to \]
\[B_{fd}((\Gamma_{\rtri \fdom} g, a), M_d(\Gamma_{\fdom}g, \bar A_{df}(\Gamma_{\rtri \fdom} g, a)))\]
\[\equiv B_{ef}((\Gamma_{\rtri \fcod} g, a), M_e(\Gamma_{\fcod}g, \bar A_{fe}(\Gamma_{\rtri \fcod} g, a)))\]
so the requirement needed for the conclusion is satisfied trivially by yielding to
the requirement satisfied by the premise.
\subsubsection{$\hom$ Types}

We stare at the formation rule
\[
\erule
{
\Delta \prov t_1 : \C^\op \qquad \Delta \prov t_2 : \C
}
{\Delta ; \Gamma \prov \C[t_1,t_2] : \rtype}
\]
The object part should be easy. We just emit the actual homset from the resulting objects:
\begin{defnbox}
  $(\C[t_1, t_2])_\delta = \C[(t_1)_\delta, (t_2)_\delta]$
\end{defnbox}
and the morphism part should follow from the functoriality of $t_1, t_2$ also
\begin{defnbox}
  $(\C[t_1, t_2])_\phi(g) = \lambda m . \C[(t_1)_\phi, (t_2)_\phi](m)$
\end{defnbox}
(we ignore the $g$; the hom-type doesn't depend on any term variables)

\subsubsection{Forall}
\[
\erule
{
\Delta, \alpha : \C; \Gamma \prov A : \rtype
}
{\Delta ; \Gamma \prov (\alpha : \C) \to A : \rtype}
\]
Note that because $\Gamma$ appears in the conclusion independent of $\alpha$, its appearance
in the premise is weakened to include $\alpha$. Therefore we immediately appear to have from the premise
\[A_{\delta d d'} : \Gamma_{\delta d d'}  \to \rtype\]
\[A_{\phi f f'} : (g : \Gamma_{\phi f f'})  \to A_{\delta d d'}(\Gamma_{\ltri (\phi f f')} g) \to
A_{\epsilon e e'}(\Gamma_{\rtri (\phi f f')} g)\]
where $\delta \in \sem \Delta$, $\phi : \delta \to \epsilon \in \sem \Delta$,
 $d,d' \in \C$, $f : d \to e \in \C$, and $f' : e' \to d' \in \C$. However the semantics of $\Gamma$
ignores any dependency on $\alpha$, so this is really
\[A_{\delta d d'} : \Gamma_{\delta}  \to \rtype\]
\[A_{\phi f f'} : (g : \Gamma_{\phi})  \to A_{\delta d d'}(\Gamma_{\ltri \phi} g) \to
A_{\epsilon e e'}(\Gamma_{\rtri\phi} g)\]

We need to construct
\[((\alpha : \C) \to A)_{\delta} : \Gamma_{\delta}  \to \rtype\]
\[((\alpha : \C) \to A)_{\phi} : (g : \Gamma_{\phi})  \to ((\alpha : \C) \to A)_{\delta}(\Gamma_{\ltri \phi} g) \to
((\alpha : \C) \to A)_{\epsilon}(\Gamma_{\rtri \phi} g)\]

So we set

\begin{defnbox}
  $((\alpha : \C) \to A)_{\delta}(g) = \int_{d \in \C} A_{\delta dd}(g)$
\end{defnbox}
observing that for any fixed $g$ and $\delta$,
the expression $(d, d') \mapsto A_{\delta dd'}(g)$ is in fact a functor $\C \x \C^\op \to \rset$, for
\[A_{\phi f f'} : (g : \Gamma_{\phi})  \to A_{\delta d d'}(\Gamma_{\ltri \phi} g) \to
A_{\epsilon e e'}(\Gamma_{\rtri\phi} g)\]
specializes to
\[A_{\rid_\delta f f'} : (g : \Gamma_{\delta})  \to A_{\delta d d'}( g) \to
A_{\delta e e'}( g)\]

Having made this choice, we find that for the morphism part, we need to construct
\[((\alpha : \C) \to A)_{\phi} : (g : \Gamma_{\phi})  \to
\left(\int_{d \in \C} A_{\delta dd}(\Gamma_{\ltri \phi} g)\right)
\to \left( \int_{d \in \C} A_{\epsilon dd}(\Gamma_{\rtri \phi} g) \right)\]
so we set
\begin{defnbox}
  $((\alpha : \C) \to A)_{\phi}(g, E) = \lambda d . A_{\phi d d}(g, E(d))$
\end{defnbox}
(thinking of an inhabitant $E$ of a end $\int^{d\in \C} F(d,d)$ as
given by a function taking an object $d \in \C$ and returning
$F(d, d)$, subject to the end equalizer constraint)

\subsubsection{Exists}
\[
\erule
{
\Delta, \alpha : \C; \Gamma \prov A : \rtype
}
{\Delta ; \Gamma \prov (\alpha : \C) \x A : \rtype}
\]
What we have from the premise and what we need to construct are identical to the forall case, but we take the coend instead of the end.

We have
\[A_{\delta d d'} : \Gamma_{\delta}  \to \rtype\]
\[A_{\phi f f'} : (g : \Gamma_{\phi})  \to A_{\delta d d'}(\Gamma_{\ltri \phi} g) \to
A_{\epsilon e e'}(\Gamma_{\rtri\phi} g)\]
and we set
\begin{defnbox}
  $((\alpha : \C) \x A)_{\delta}(g) = \int^{d \in \C} A_{\delta dd}(g)$
\end{defnbox}
For the morphism part, we must construct
\[((\alpha : \C) \to A)_{\phi} : (g : \Gamma_{\phi})  \to
\left(\int^{d \in \C} A_{\delta dd}(\Gamma_{\ltri \phi} g)\right)
\to \left( \int^{d \in \C} A_{\epsilon dd}(\Gamma_{\rtri \phi} g) \right)\]
so we set
\begin{defnbox}
  $((\alpha : \C) \x A)_{\phi}(g, K) = (K_1, A_{\phi K_1 K_1}(g, K_2)) $
\end{defnbox}
(thinking of an inhabitant $K$ of a coend $\int^{d\in \C} F(d,d)$ as
given by a pair consisting of an object $K_1 \in \C$ and an inhabitant
$K_2 \in F(K_1, K_1)$, quotiented by the coend equivalence relation)

\subsubsection{Forall Intro}
Let's use $\I$ for a category,
with typical morphisms $m : i \to j$, to keep variables from colliding.
From
\[
\erule
{
\Delta, \alpha : \I ; \Gamma \prov M : A
}
{\Delta ; \Gamma \prov \Lambda \alpha . M : (\alpha : \I) \to A }
\]
we have, for any $d \in \ssem\Delta$ and $i\in \I$,
\[M_{di} : (g : \Gamma_{dd}) \to A_{ddii}(g) \]

 we need to construct
\[(\Lambda \alpha : \I . A)_d : ((\alpha : \I) \to A)_{dd} \]
i.e.
\[(\Lambda \alpha : \I . A)_d : \lambda g : \Gamma_{dd} . \int_{i\in \I} A_{ddii}(g) \]
so we set
\begin{defnbox}
  $(\Lambda \alpha : \I . A)_d(g) = \lambda i . M_{di}(g) $
\end{defnbox}
Let's try to validate the end condition. The premise tells us that for any
 $f : d \to e \in \ssem \Delta$  and $m : i \to j \in \I$, we have
\[ (g : \Gamma_{ff}) \to A_{fdmi}(\Gamma_{\rtri \fdom}g, M_{di}(\Gamma_{\fdom}g )) \equiv \]
\[ A_{efjm}(\Gamma_{\rtri \fcod} g, M_{ej}( \Gamma_{\fcod} g))\]
We want to check that for any  $f : d \to e \in \ssem \Delta$, we have
\[ (g : \Gamma_{ff}) \to ((\alpha : \ii) \to A)_{fd}(\Gamma_{\rtri \fdom}g, (\Lambda \alpha . M)_{d}(\Gamma_{\fdom}g )) \equiv \]
\[ ((\alpha : \ii) \to A)_{ef}(\Gamma_{\rtri \fcod} g, (\Lambda \alpha . M)_{e}( \Gamma_{\fcod} g))\]
so let's expand the latter. Expanding the definition of transport at $A$, we get
\[ (g : \Gamma_{ff}) \to \lambda i . A_{fdii} (\Gamma_{\rtri \fdom}g, (\Lambda \alpha . M)_{d}(\Gamma_{\fdom}g )(i))  \equiv \]
\[ \lambda i . A_{efii}(\Gamma_{\rtri \fcod} g, (\Lambda \alpha . M)_{e}( \Gamma_{\fcod} g)(i))\]
and then expanding the meaning of $\Lambda$, we get
\[ (g : \Gamma_{ff}) \to \lambda i . A_{fdii} (\Gamma_{\rtri \fdom}g, M_{di}(\Gamma_{\fdom}g ))  \equiv \]
\[ \lambda i . A_{efii}(\Gamma_{\rtri \fcod} g, M_{ei}( \Gamma_{\fcod} g))\]
Great, this follows from the premise by instantiating at $m = \rid_i$.

\subsubsection{Forall Elim}
\[
\erule
{
\Delta ; \Gamma \prov M : (\alpha : \I) \to A
\qquad
\Delta \prov t : \I
}
{
\Delta ; \Gamma \prov M[t] : [t/\alpha]A
}
\]
We have $M_d : (g : \Gamma_{dd}) \to \int_{i \in \I} A_{ddii}(g)$
and we need to construct
 \[(M[t])_d = (g : \Gamma_{dd}) \to ([t/\alpha] A)_{dd}(g)\]
and I think I'm going to assume that works out to be
 \[(M[t])_d = (g : \Gamma_{dd}) \to A_{ddt(dd)t(dd)}(g)\]
and $\sem t : \sem \Delta \to \I$, so we set
\begin{defnbox}
  $(M[t])_d(g) = M_d(g)(t(dd))$
\end{defnbox}

\subsubsection{$\hom$ intro}

\[
\erule
{
\Delta \prov t : \C
}
{\Delta; \Gamma \prov \rid_t : \C[\bar t, t]}
\]
We have $\sem t : \sem \Delta \to \C$, we need to construct
\[(\rid_t)_d : \C[\bar t_{dd}, t_{dd}]\]
Well surely
\begin{thmbox}
  $\bar t_\delta = t_{\bar\delta}$
\end{thmbox}
so we can get away with
\begin{defnbox}
  $(\rid_t)_d = \rid_{t_{dd}}$
\end{defnbox}
\subsubsection{$\hom$ elim $+$}
\[
\erule
{
\Delta; \gamma : \I; \Gamma \prov M : [\bar \gamma/\alpha][\gamma/\beta][\rid_\gamma/h]A \qquad \bar\alpha, \bar \beta \not\in A
}
{\Delta, \alpha : \I^\op, \beta : \I ; \Gamma, h - \I[\bar\alpha,\bar\beta] \prov \coe^{\alpha \beta h}(\gamma.M) : A}
\]

Let $d\in \ssem\Delta, a \in \I, b \in \I$ be given. From the fact that $\bar \alpha, \bar \beta \not \in A$
we want to conclude that $A$, as a functor, only depends contravariantly on $\I$ through $\alpha$,
 and only covariantly on $\I$ through $\beta$. So we can write its object part as $A_{ddab}$. To be more precise,
it factors through some other semantic functor, which we can write as $A_{ddab}$.
And $\Gamma$ doesn't depend on $\alpha, \beta$ at all. If we allowed stuff after the $h$ in the context,
it'd have to be subject to the same constraint as $A$ is, I suppose. We want to construct
\[(\coe^{\alpha \beta h}(\gamma.M))_{dab} : (g : \Gamma_{dd})(h : \I(a, b)) \to  A_{ddab}(g, h)\]
and what we have from the premise is, for any $d \in \ssem \Delta$ and $i \in \I$, that
\[M_{di} : (g : \Gamma_{dd}) \to  A_{ddii}(g, \rid_i)\]
But aha, this is exactly where end-transport comes in! {\em Because} we have the morphism $h$,
we can take either of $A_{ddaa}(g, \rid_a)$ or $A_{ddbb}(g, \rid_b)$ and transport to
$A_{ddab}(g, h)$ and get the same thing.

Let's see if I can formulate this in real syntax:
\begin{defnbox}
$(\coe^{\alpha \beta h}(\gamma.M))_{dab}(g, h) =  A_{ddah}(M_{da}(g)) = A_{ddhb}(M_{db}(g))$
\end{defnbox}

Something's going slightly wrong with the transport variance, but I think I can fix it.

And it's worth paying careful attention to the fact that because we
substituted the {\em same} variable $\gamma$ for $\alpha$ and $\beta$
in $M$ that we get this end-condition glue. And I think the actual
transport structure of the hom-type itself is making
$\rid$-composed-with-$h$ the thing that goes in the right slot.
\subsubsection{$\hom$ elim $-$}
\[
\erule
{
\Delta; \gamma : \I; \Gamma \prov M : [\bar \gamma/\alpha][\gamma/\beta][\rid_\gamma/h]A \qquad \bar\alpha, \bar \beta \not\in A
}
{\Delta, \alpha : \I^\op, \beta : \I ; \Gamma, h + \I[\alpha,\beta] \prov \coe_{\alpha \beta h}(\gamma.M) : A}
\]

\end{document}
