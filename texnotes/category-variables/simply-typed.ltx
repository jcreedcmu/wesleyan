\documentclass{article}
\input{theorem}
\input{prooftree}
\usepackage{stmaryrd}
\usepackage{latexsym}
\usepackage{yfonts}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,cd,decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}
\usepackage{tcolorbox}
\tcbuselibrary{breakable}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}

\def\sss#1{\noindent{\em{#1}}}
\def\coe{\mathsf{coe}}
\def\bpack{\mathbf{pack}}
\def\bunpack{\mathbf{unpack}}

\def\ltri{{\lhd}}
\def\rtri{{\rhd}}
\def\wo{\setminus}
\def\fA{\mathsf{A}}
\def\fC{\mathsf{C}}
\def\fX{\mathsf{X}}
\def\ff{\mathsf{f}}
\def\fm{\mathsf{m}}
\def\rspan{\mathsf{Span}}
% \def\El#1{\mathsf{El}({#1})}
\def\El#1{\ulcorner{#1}\urcorner}
\def\quote#1{{\ulcorner {#1} \urcorner}}
\def\U{\mathsf{U}}
\def\uu{\mathsf{u}}
\def\uni{\U}
\def\mor#1#2{#1 \to \underline{#2}}

\def\ridp{\mathsf{idp}}
\def\ssem#1{\langle\!\langle{#1}\rangle\!\rangle}

\definecolor{lred}{rgb}{0.95,0.8,0.8}
\definecolor{cyan}{rgb}{0.80,0.95,0.95}
\definecolor{orange}{rgb}{0.95,0.90,0.80}
\definecolor{bluegray}{rgb}{0.6,0.6,0.85}
\definecolor{lgray}{gray}{0.9}
\newtcolorbox{declbox}{colframe=lred,colback=lred,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{thmbox}{colframe=cyan,colback=cyan,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{defnbox}{colframe=orange,colback=orange,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{tangentbox}{colframe=lgray,colback=lgray,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}

\input{linear}
\def\rpath#1{[#1]}
\def\rfst{\mathsf{fst}\,}
\def\rsnd{\mathsf{snd}\,}
\def\bunfold{\mathbf{unfold}}
\def\bfold{\mathbf{fold}}
\def\susp#1{\langle {#1} \rangle}
\def\ssusp#1{\langle\!\langle {#1} \rangle\!\rangle}
\def\dto{\mathrel{\dot\to}}
\def\dns{{\downarrow}}
\def\ups{{\uparrow}}
\def\sprov{\Vdash}
\def\signat{{\color{red}\Sigma}}
\def\ep#1{\underline{#1}}
\def\wat{\mathbin{@}}
\def\wwat{\mathbin{\underline\wat}}
\def\cn{{:}}
\def\dv{{\div}}
\def\ww{{\mathsf w}}
\def\base{{\textfrak b}}

\def\ll{\mathsf{L}}
\def\rr{\mathsf{R}}
\def\cc{\mathsf{c}}
\def\dd{\mathsf{d}}
\def\ii{{\mathbb I}}
\def\T{\mathbb{T}}
\def\pp{\textsf{\textbf p}}
\def\nn{{\mathsf n}}
\def\PP{\textsf{\textbf P}}
\def\NN{{\mathsf N}}
\def\zz{{\mathsf z}}
\def\sem#1{[\![#1]\!]}
\def\usem#1{\lceil\!\!\lceil{#1}\rceil\!\!\rceil}
\def\zem#1{\langle\!\langle#1\rangle\!\rangle}
\def\col#1{{\mathsf{C}}_{#1}}
\def\lax{\mathop\bigcirc}
\def\rjust{\mathsf{just}}
\def\rcvt{\mathsf{cvt}}
\def\rtype{\mathsf{type}}
\def\rdtype{\mathsf{disc}}
\def\rkind{\mathsf{kind}}
\def\rmode{\mathsf{mode}}
\def\rprel{\mathbf{Prel}}
\def\rrfam{\mathbf{Rfam}}
\def\rset{\mathbf{Set}}
\def\rfinset{\mathbf{FinSet}}
\def\rrel{\mathbf{Rel}}
\def\rcat{\mathbf{Cat}}
\def\rfam{\mathbf{Fam}}
\def\binj{\mathbf{inj}}
\def\rid{\mathsf{id}}
\def\rtrue{\mathrel\mathrm{true}}
\def\pbck{\ar[dr, phantom, pos=0, "\lrcorner"]}
\def\bpbck{\ar[ddrr, phantom, pos=0, "\lrcorner"]}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\btwo{\mathbf{2}}
\def\bone{\mathbf{1}}

\newarrow {Equiv} =====
\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\def\mapt{\ar[ddd,mapsto,shorten <=2em, shorten >=2em]}
\def\frommaps{\ar[from=uu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\frommapt{\ar[from=uuu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\I{\mathbf{I}}
\def\C{\mathbf{C}}
\def\G{\mathbf{G}}
\def\S{\mathbf{S}}
\def\D{\mathbf{D}}
\def\E{\mathbf{E}}
\def\M{\mathbf{M}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\o{\circ}
\def\rctx{\,\mathsf{ctx}}
\def\rdctx{\,\mathsf{cat}}
\def\del{\partial}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\definecolor{fib}{HTML}{ff7f00}
\definecolor{green}{HTML}{007f00}
\definecolor{red}{HTML}{df3f3f}
\definecolor{opfib}{HTML}{007fff}

% For lightening colors I used
% http://trycolors.com/ 6 parts white to 1 part color
\definecolor{opfibl}{HTML}{DBEDFF}
\definecolor{greenl}{HTML}{DBEDDB}
\definecolor{redl}{HTML}{FAE4E4}
\def\njudge#1{\fcolorbox{opfib}{white}{#1}}
\def\nrule#1{\fcolorbox{white}{opfibl}{#1}}
\def\neqn#1{\fcolorbox{white}{redl}{#1}}



\def\judge#1{\vskip 2em\noindent \njudge{$#1$}\vskip 0.5em\noindent}
\def\rule#1{\vskip 2em \noindent \nrule{$#1$}\vskip 0.5em\noindent}
\def\eqn#1{\vskip 2em \noindent \neqn{$#1$}\vskip 0.5em\noindent}
\def\prof{\nrightarrow}
\def\tensor{\otimes}
\def\htensor{\mathrel{\hat\otimes}}
\def\lol{\multimap}
\def\hlol{\mathrel{\hat\multimap}}
\def\wtf{{\color{red}???}}

\def\re{\mathbf{E}}
\def\sh{\sharp}
\def\shp{\mathrel{\sharp}}
\def\zero{\texttt{0}}
\begin{document}

\def\
\tikzset{
   commutative diagrams/.cd,
   arrow style=tikz,
   diagrams={>=stealth}}

\section{A Syntax for Category Variables}
Let there be some syntax
\[\begin{tabular}{r@{ }c@{ }c@{ }l}
  Cat. Contexts&$\Delta$&$::=$&$\cdot\celse \Delta, \alpha : \C$\\
  Categories&$\C$&$::=$&$\cdots$\\
  Cat. Terms&$t$&$::=$&$\alpha  \celse \bar \alpha \celse F(t, \ldots, t) $\\
\\
  Term Contexts&$\Gamma$&$::=$&$\cdot \celse \Gamma, x : A$\\
  Types&$A$&$::=$&$A \to B \celse A \x B  $\\
&&&$\celse (\alpha : \C) \to B \celse (\alpha : \C) \x B$\\
&&&$\celse \C[t, t] \celse \cdots$\\
  Terms&$M$&$::=$&$x \celse \lambda x . M \celse M\ M \celse \pair M M \celse \pi_1 M \celse \pi_2 M$\\
&&&$\celse \Lambda \alpha . M \celse M[t] \celse \bpack(M, M) \celse \bunpack(M, \alpha.x.M)$\\
\\
  Signatures&$\Sigma$&$::=$&$\cdot \celse \Sigma, a : K \celse \Sigma, c : A $\\
  Kinds&$K$&$::=$&$\rtype \celse (\alpha : \C) \to K$\\
\end{tabular}\]

We a collection of categories $\C$ and functors $F$ between products of categories
 as an unspecified parameter of the type system.
One could think of them as `codes for
categories (and functors)' the same way a universe is a set of codes for types, but
we mostly just pretend that they're literal mathematical objects
sitting in the syntax.

There are category-variable contexts, and term-level contexts.
There is a polarity distinction between term variables, which has to
do with the direction they undergo transport in the semantics. This polarity
distinction is still a little mysterious to me, but it's something
that seems to make other things work out. A telling fact about it that we can at least foreshadow is
that product types always bind $+$ variables, and functions types always bind $-$ variables.

We have type-formers for function and product types. We have quantifiers over category variables.
We have a hom-type $\C[t,t]$.
There also may be a collection of base types, which may be thought of as constants $a : K \in \Sigma$
in some signature that tacitly exists in every other definition. The signature can also include
term constants $c : A$.
\subsection{Judgments}

These are the typing judgments; the usual suspects, except we have a $\Delta$ out in front of everything.
\begin{declbox}
  $\Delta \prov  \Gamma \rctx $\\
  $\Delta \prov A : \rtype$\\
  $\Delta ; \Gamma \prov M : A$
\end{declbox}

\subsection{Operations}
We define the operation $A \mapsto \bar A$
by saying that $\bar A$ is $A$ except with
every free category variable $\alpha$ in $A$ replaced with $\bar \alpha$.

\subsection{Rules}
\subsubsection{Context Formation}
\[
\erule
{}
{\Delta \prov \cdot \rctx}
\]
\[
\erule
{\Delta \prov \Gamma \rctx \qquad \Delta \prov A : \rtype}
{\Delta \prov \Gamma, x : A \rctx}
\]

\subsubsection{Type Formation}

\[
\erule
{
\Delta \prov A : \rtype \qquad
\Delta  \prov B : \rtype
}
{\Delta \prov A \to B : \rtype}
\]

\[
\erule
{
\Delta \prov A : \rtype \qquad
\Delta  \prov B : \rtype
}
{\Delta  \prov  A \x B : \rtype}
\]

\[
\erule
{
\Delta, \alpha : \C \prov A : \rtype
}
{\Delta  \prov (\alpha : \C) \to A : \rtype}
\]

\[
\erule
{
\Delta, \alpha : \C \prov A : \rtype
}
{\Delta  \prov (\alpha : \C) \x A : \rtype}
\]

\[
\erule
{
\Delta \prov t_1 : \C^\op \qquad \Delta \prov t_2 : \C
}
{\Delta  \prov \C[t_1,t_2] : \rtype}
\]

\subsubsection{Terms}

\sss{Variables}
\[
\erule
{
x : A \in \Gamma
}
{\Delta ; \Gamma \prov x : A }
\]

\sss{Functions}
\[
\erule
{
\Delta; \Gamma, x - A  \prov M : B
}
{\Delta ; \Gamma \prov \lambda x . M : A \to B }
\]
\[
\erule
{
\Delta ; \Gamma \prov M : A \to B
\qquad
\Delta ; \Gamma \prov N :  A
}
{
\Delta ; \Gamma \prov M\ N : B
}
\]

\sss{Products}
\[
\erule
{
\Delta; \Gamma \prov M : A
\qquad
\Delta; \Gamma \prov N : B
}
{\Delta ; \Gamma \prov \pair M N : A \x B }
\]
\[
\erule
{
\Delta ; \Gamma \prov M : A \x B
}
{
\Delta ; \Gamma \prov \pi_1 M :  A
}
\qquad
\erule
{
\Delta ; \Gamma \prov M : A \x B
}
{
\Delta ; \Gamma \prov \pi_2 M : B
}
\]

\sss{Forall}
\[
\erule
{
\Delta, \alpha : \C ; \Gamma \prov M : A
}
{\Delta ; \Gamma \prov \Lambda \alpha . M : (\alpha : \C) \to A }
\]
\[
\erule
{
\Delta ; \Gamma \prov M : (\alpha : \C) \to A
\qquad
\Delta \prov t : \C
}
{
\Delta ; \Gamma \prov M[t] : [t/\alpha]A
}
\]


\sss{Exists}
\[
\erule
{
\Delta ; \Gamma \prov t : \C
\qquad
\Delta ; \Gamma \prov M : [t/\alpha]A
}
{\Delta ; \Gamma \prov \bpack(t, M) : (\alpha : \C) \x A }
\]
\[
\erule
{
\Delta ; \Gamma \prov M : (\alpha : \C) \x A
\qquad
\Delta, \alpha : \C; \Gamma, x : A \prov N : B
}
{
\Delta ; \Gamma \prov \bunpack(M, \alpha.x.N) : B
}
\]


\sss{Hom-Types}

\[
\erule
{
\Delta \prov t : \C
}
{\Delta; \Gamma \prov \rid_t : \C[\bar t, t]}
\]
\[
\erule
{
\Delta; \gamma : \C; \Gamma \prov M : [\bar \gamma/\alpha][\gamma/\beta]A \qquad \bar\alpha, \bar \beta \not\in A
}
{\Delta, \alpha : \C^\op, \beta : \C ; \Gamma, h - \C[\bar\alpha,\bar\beta] \prov \coe^{\alpha \beta h}(\gamma.M) : A}
\]

\[
\erule
{
\Delta; \gamma : \C; \Gamma \prov M : [\bar \gamma/\alpha][\gamma/\beta]A \qquad \bar\alpha, \bar \beta \not\in A
}
{\Delta, \alpha : \C^\op, \beta : \C ; \Gamma, h + \C[\alpha,\beta] \prov \coe_{\alpha \beta h}(\gamma.M) : A}
\]

\subsubsection{Category Terms}
\[
\erule
{\alpha : \C \in\Delta}
{\Delta \prov \alpha : \C}
\qquad
\erule
{\Delta \prov \alpha : \C}
{\Delta \prov \bar \alpha : \C^\op}
\qquad
\erule
{F : \C_1 \x \cdots \x \C_n \to \C \qquad \Delta \prov t_i : \C_i }
{\Delta \prov F(t_1, \ldots, t_n) : \C}
\]
Recall that we're being lazy and basically taking $\C$ and $F$ seriously as real categories and functors.
For example, the first premise of the last rule above is asking for $F$ to be any functor at all from
 product category $\C_1 \x \cdots \x \C_n$ to the category $\C$. What we should probably do instead
is have a proper syntax for them.

%% We consider strictly equal, i.e. treat as reductions,
%% \[ \overline{\overline t} \mapsto t \]
%% \[ \overline{F(t_1, \ldots, t_n)} \mapsto F^\op(\bar t_1, \ldots, \bar t_n) \]

\subsection{Results}

\begin{lemma}
$\overline{\overline A} = A$ and $(\Delta^\op)^\op = \Delta$
\end{lemma}



\begin{theorem}[Substitution]\ %
  \begin{itemize}
  \item If $\Delta \prov J$ then $\Delta^\op \prov \bar J$.
  \item If $\Delta ; \Gamma \prov M : A$ and $\Delta ; \Gamma, x : A \prov J$, then
$\Delta ; \Gamma \prov [M/x]J$.
  \item If $\Delta \prov t : \C$ and $\Delta, \alpha : \C \prov J$, then
$\Delta \prov [t/\alpha]J$.
  \end{itemize}
\end{theorem}


\section{Semantics}
\subsection{Types}
We aim here to say what it is to be a
semantically meaningful type in a given pair of contexts $\Delta$ and $\Gamma$.

\subsubsection{Preliminaries}

Given a $\Delta$, there are two categories induced by it that we'll want to talk about.
The simplest is $\ssem \Delta$, and it's just the product of all the categories in it
\[
\begin{tabular}{rcl}
  $\ssem \cdot$&$=$&$\textbf{1}$\\
  $\ssem {\Delta, \alpha : \C}$&$=$&$\ssem \Delta \x \C$\\
\end{tabular}
\]
The second is $\sem \Delta$, and multiplies on a copy of the dual category also:
\[
\sem {\Delta} = \ssem \Delta \x \ssem \Delta^\op
\]

Here's a summary of the symbols we'll use for typical members of the above categories:
\[\begin{tabular}{rccl}
  Objects of $\ssem \Delta$&$d,e$\\
  Morphisms of $\ssem \Delta$&$f$\\
  Objects of $\sem \Delta$&$\delta, \epsilon$\\
  Morphisms of $\sem \Delta$&$\phi$\\
\end{tabular}\]

We allow writing the pairs that are objects and morphisms
of $\sem \Delta$ without $(\dash , \dash)$ syntax, e.g. $de$ for $(d, e)$.
We freely sometimes write an object of a category in a place where a morphism is required,
intending the identity morphism at that object.

\subsubsection{Swapping Operations}
There is a functor $(\delta \mapsto \bar \delta):  \sem \Delta^\op \to \sem \Delta$ by swapping components.
If $\delta = dd' \in \sem \Delta$, then we define
\[\bar \delta = dd' \in \sem \Delta\]
We can swap morphisms of $\sem \Delta$ as well. When
\[\phi = ff' : \delta \to \epsilon = dd' \to ee'\]
we define
\[ \bar \phi = f'f : \bar \epsilon \to \bar \delta =  e'e \to d'd \]



\subsubsection{Semantics of Contexts}
Next, we will declare the functions involved in the semantics of contexts and types.
In general we will write $\rtype$ for the ambient metatheory's notion
of type.
Throughout the following declarations and definitions, we'll assume
 $\Delta \prov \Gamma \rctx$, and $\delta$
is an object in $\sem \Delta$,
and $\phi : \delta \to \epsilon$ is a morphism in $\sem \Delta$.


We declare:
\begin{declbox}
  $\Gamma_\delta : \rtype$.\\
  $\Gamma_\phi : \Gamma_{\delta} \to \Gamma_{\epsilon} $\\
  $A_\delta : \rtype$\\
  $A_\phi :  A_{\delta} \to A_{\epsilon}$
\end{declbox}
and define:
\begin{defnbox}
 $(\cdot)_\delta = \bone$\\
 $(\Gamma, x : A)_\delta =  \Gamma_\delta \x A_{\delta}$\\
  \\
 $(\cdot)_\phi = {!}$\\
 $(\Gamma, x : A)_\phi (g, a) = (\Gamma_\phi g, A_{ \phi}( a) ) $
\end{defnbox}
Notes on typing:
\[(\Gamma, x : A)_\phi : \Gamma_\delta \x A_{\delta} \to \Gamma_\epsilon \x A_{\epsilon}\]





\subsection{Terms}
What
\[\Delta; \Gamma \prov M : A\]
means is that
\[\sem M \in \int_{\delta\in\ssem\Delta} \sem\Gamma(\delta) \to \sem A(\delta)\]
That is, for any $d \in \ssem \Delta$, and $f : d \to e \in \ssem \Delta$, we have
\begin{declbox}
  $M_d : \Gamma_{dd} \to A_{dd} $
\end{declbox}
\begin{thmbox}
$ (g : \Gamma_{de}) \to A_{fd}(M_d(\Gamma_{df} g )) \equiv A_{ef}(M_e(\Gamma_{fe} g))$
\end{thmbox}



\subsection{Semantics of Types}

\begin{defnbox}
  $(A \x B)_\delta  = A_\delta \x B_\delta$\\
  $(A \to B)_\delta  = A_{\bar \delta} \to B_\delta$\\
  $((\alpha : \C) \x A)_{\delta} = \int^{d \in \C} A_{\delta dd}$\\
  $((\alpha : \C) \to A)_{\delta} = \int_{d \in \C} A_{\delta dd}$\\
  $(\C[t_1, t_2])_\delta = \C[(t_1)_\delta, (t_2)_\delta]$\\
  \\
  $(A\x B)_\phi(a, b) = (A_\phi(a), B_\phi(b)$\\
  $(A\to B)_\phi(f) = \lambda x . B_\phi(f ( A_{\bar \phi}(x)))$\\
%  $((\alpha : \C) \x A)_{\phi}(K) = \bunpack(K, d.a.\bpack(d, A_{\phi d d}(a)  )) $\\
  $((\alpha : \C) \x A)_{\phi}(K) = (K_1, A_{\phi K_1 K_1}(K_2))$\\
  $((\alpha : \C) \to A)_{\phi}(E) = \lambda d . A_{\phi d d}(E(d))$\\
  $(\C[t_1, t_2])_\phi(m) = \C[(t_1)_\phi, (t_2)_\phi](m)$
\end{defnbox}

\subsection{Semantics Of Terms}

\begin{defnbox}
  $(\lambda x . M)_d(g) = \lambda x . M_d(g,x)$\\
  $(\Lambda \alpha. A)_d(g) = \lambda c . M_{dc}(g)$\\
  $(M[t])_d(g) = M_d(g)(t(dd))$\\
  $(\rid_t)_d = \rid_{t_{dd}}$
\end{defnbox}


\end{document}
