\documentclass{article}
\input{theorem}
\input{prooftree}
\usepackage{stmaryrd}
\usepackage{latexsym}
\usepackage{yfonts}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,cd,decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}
\usepackage{tcolorbox}
\tcbuselibrary{breakable}
\input{linear}

\def\rto{\twoheadrightarrow}
\def\lto{\rightarrowtail}
\def\P{\mathbf{P}}
\def\N{\mathbf{N}}
\def\one{\mathbf{1}}
\def\pto{\relbar\joinrel\mapstochar\joinrel\rightarrow}
\def\htensor{\mathrel{\hat\otimes}}
\def\lol{\multimap}
\def\hlol{\mathrel{\hat\multimap}}
\def\quote#1{{\ulcorner {#1} \urcorner}}
\def\U{\mathsf{U}}
\def\fA{\mathsf{A}}
\def\fC{\mathsf{C}}
\def\ff{\mathsf{f}}
\def\B{\mathsf{B}}
\def\uni{\U}
\def\mor#1#2{#1 \to \underline{#2}}
\def\atm#1{\underline{#1}}

\def\ridp{\mathsf{idp}}
\def\ssem#1{\langle\!\langle{#1}\rangle\!\rangle}

\definecolor{cyan}{rgb}{0.80,0.95,0.95}
\definecolor{orange}{rgb}{0.95,0.90,0.80}
\definecolor{lred}{rgb}{0.95,0.8,0.8}
\definecolor{bluegray}{rgb}{0.4,0.4,0.8}
\definecolor{lgray}{gray}{0.9}
\newtcolorbox{declbox}{colframe=lred,colback=lred,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{thmbox}{colframe=cyan,colback=cyan,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{defnbox}{colframe=orange,colback=orange,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt}
\newtcolorbox{tangentbox}{colframe=lgray,colback=lgray,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}


\def\rpath#1{[#1]}
\def\rfst{\mathsf{fst}\,}
\def\rsnd{\mathsf{snd}\,}
\def\bunfold{\mathbf{unfold}}
\def\bfold{\mathbf{fold}}
\def\pbind#1{\langle {#1} \rangle}
\def\ppbind#1{\langle\!\langle {#1} \rangle\!\rangle}
\def\dto{\mathrel{\dot\to}}
\def\dns{{\downarrow}}
\def\ups{{\uparrow}}
\def\sprov{\Vdash}
\def\signat{{\color{red}\Sigma}}

\def\wat{\mathbin{@}}
\def\wwat{\mathbin{\underline\wat}}
\def\cn{{:}}
\def\dv{{\div}}
\def\ww{{\mathsf w}}
\def\base{{\textfrak b}}

\def\munit{I}
\def\tt{{\mathsf t}}
\def\sem#1{[\![#1]\!]}
\def\usem#1{\lceil\!\!\lceil{#1}\rceil\!\!\rceil}
\def\zem#1{\langle\!\langle#1\rangle\!\rangle}
\def\col#1{{\mathsf{C}}_{#1}}
\def\lax{\mathop\bigcirc}
\def\rjust{\mathsf{just}}
\def\rcvt{\mathsf{cvt}}
\def\rtype{\mathsf{type}}
\def\rkind{\mathsf{kind}}
\def\rmode{\mathsf{mode}}
\def\rprel{\mathbf{Prel}}
\def\rrfam{\mathbf{Rfam}}
\def\rset{\mathbf{Set}}
\def\rfinset{\mathbf{FinSet}}
\def\rrel{\mathbf{Rel}}
\def\rcat{\mathbf{Cat}}
\def\rfam{\mathbf{Fam}}
\def\binj{\mathbf{inj}}
\def\rid{\mathsf{id}}
\def\rtrue{\mathrel\mathrm{true}}
\def\pbck{\ar[dr, phantom, pos=0, "\lrcorner"]}
\def\bpbck{\ar[ddrr, phantom, pos=0, "\lrcorner"]}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\btwo{\mathbf{2}}
\def\bone{\mathbf{1}}

\newarrow {Equiv} =====
\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\def\mapt{\ar[ddd,mapsto,shorten <=2em, shorten >=2em]}
\def\frommaps{\ar[from=uu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\frommapt{\ar[from=uuu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\A{\mathbf{A}}
\def\B{\mathbf{B}}
\def\C{\mathbf{C}}
\def\S{\mathbf{S}}
\def\D{\mathbf{D}}
\def\E{\mathbf{E}}
\def\M{\mathbf{M}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\tri{\triangleright}
\def\ltri{\triangleleft}
\def\o{\circ}
\def\rctx{\,\mathsf{ctx}}
\def\del{\partial}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}

\def\null{\emptyset}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\definecolor{fib}{HTML}{ff7f00}
\definecolor{green}{HTML}{007f00}
\definecolor{red}{HTML}{df3f3f}
\definecolor{opfib}{HTML}{007fff}

% For lightening colors I used
% http://trycolors.com/ 6 parts white to 1 part color
\definecolor{opfibl}{HTML}{DBEDFF}
\definecolor{greenl}{HTML}{DBEDDB}
\definecolor{redl}{HTML}{FAE4E4}
\def\njudge#1{\fcolorbox{opfib}{white}{#1}}
\def\nrule#1{\fcolorbox{white}{opfibl}{#1}}
\def\neqn#1{\fcolorbox{white}{redl}{#1}}

\def\judge#1{\vskip 2em\noindent \njudge{$#1$}\vskip 0.5em\noindent}
\def\rule#1{\vskip 2em \noindent \nrule{$#1$}\vskip 0.5em\noindent}
\def\eqn#1{\vskip 2em \noindent \neqn{$#1$}\vskip 0.5em\noindent}

\def\tensor{\otimes}
\def\lol{\multimap}

\def\wtf{{\color{red}???}}

\def\zero{\texttt{0}}
\def\mbox{\square}
\def\bbox{\mathbf{box}\,}
\def\fuse{\bullet}
\begin{document}

Maybe I have
\[
\begin{tabular}{r@{$\quad$}c@{$\quad::=\quad$ }l}
  Value Expressions&$e$&$\mbox( c)\celse \bcase \celse \cdots$\\
  Circuit Expressions&$c$&$\mathsf{nand}\celse c\ c \celse \lambda \sigma . c \celse  \sigma \celse \bfix \sigma.c $\\
  Value Types&$A$&$\mbox C\celse A \to A$\\
  Circuit Types&$C$&$\B \celse C \imp C \celse C \fuse C$\\
\end{tabular}
\]
\[
\erule
{\Gamma\adjust_{C} \prov c : C}
{\Gamma \prov \bbox c : \mbox C}
\]
\[
\erule
{\Gamma \prov e_1 : \mbox C \qquad \Gamma, \sigma : C \prov e_2 : A}
{\Gamma \prov\blet \bbox \sigma = e_1 \bin e_2 : A}
\]
\[
\erule
{\Gamma \prov c_1 : C_2 \imp C_1 \qquad \Gamma \prov c_2 : C_2}
{\Gamma \prov c_1\ c_2 : C_1}
\qquad
\erule
{\Gamma, \sigma : C_1 \prov c : C_2}
{\Gamma \prov \lambda \sigma . c : C_1 \imp C_2}
\]
\[
\erule
{\Gamma \prov c : C_1 \fuse C_2}
{\Gamma \prov \pi_i\ c : C_i}
\qquad
\erule
{\Gamma \prov c_1 : C_1\qquad \Gamma \prov c_2 : C_2}
{\Gamma \prov c : C_1 \fuse C_2}
\]
\[
\erule
{\Gamma, \sigma : \B \prov c : \B}
{\Gamma \prov \bfix \sigma . c : \B}
\]

Can I program up $\bfix$ at products of $\B$?
Suppose I have
\[f_1 : \mbox((C_1 \to C_1) \to C_1)\]
\[f_2 : \mbox((C_2 \to C_2) \to C_2)\]
Can I conjure up
\[f : \mbox((C \to C) \to C)\]
where $C = C_1 \fuse C_2$?
It looks like I can't quite so directly.

How about something that's more like what the inference rule expresses,
something polymorphic over the context
\[f_1 : \mbox(D \to C_1 \to C_1) \to \mbox(D \to  C_1)\]
\[f_2 : \mbox(D \to C_2 \to C_2) \to \mbox(D \to C_2)\]

Actually I first want to check that
\[ \hat f : \mbox(D \to C \to (C' \fuse C)) \to \mbox(D \to  C')\]
can be derived from
\[ f : \mbox(D \to C \to C) \to \mbox(D \to  C )\]
I do this by defining
\begin{tabbing}
\hskip 2em \=\kill
$\hat f\ (k : \mbox(D \to C \to (C' \bullet C))) = $\\
\>$\blet \mbox \rho = k  \bin$\\
\>$\blet \mbox \rho' = f\ \mbox(\lambda d c. \rho\ d\ c .2  )  \bin$\\
\>$\mbox(\lambda d . \rho\ d\ (\rho'\ d).1)$
\end{tabbing}
Yeah, that's fine. So then I have
\[\hat f_1 : \mbox(D \to C_1 \to (C_1' \fuse C_1)) \to \mbox(D \to  C_1')\]
\[\hat f_2 : \mbox(D \to C_2 \to (C_2' \fuse C_2)) \to \mbox(D \to C_2')\]
and if I substitute $C_2' := C' \fuse C_1$  in the type of $\hat f_2$  I get
\[ \mbox(D \to C_2 \to (C' \fuse C_1 \fuse C_2)) \to \mbox(D \to C' \fuse C_1)\]
and then if I substitute $D := D \fuse C_1$ I get
\[\mbox(D \to (C_1 \fuse C_2) \to (C' \fuse C_1 \fuse C_2)) \to \mbox(D \to C_1 \to C' \fuse C_1)\]
and by composing with $\hat f_1$ I get
\[\hat f_2 : \mbox(D \to (C_1 \fuse C_2) \to (C' \fuse (C_1 \fuse C_2))) \to \mbox(D \to C')\]
as desired.


Can $\bfix$ work at higher order types somehow? Probably not.

The difference between sequential circuits and combinatorial circuits
is that sequential circuits are `monadic below' the combinatorial
ones; they use the effect $\bfix$! But all circuits are staged code,
so they're `above' the code that generates them. So this is a nice
naturally occurring situation where there's a nontrivial poset of
modes.

\end{document}
