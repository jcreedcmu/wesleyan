\documentclass{article}
\usepackage[tmargin=0.05in, bmargin=0.05in]{geometry}
\input{theorem}
\input{prooftree}
\usepackage{stmaryrd}
\usepackage{latexsym}
\usepackage{yfonts}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,cd,decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}
\usepackage{tcolorbox}
\tcbuselibrary{breakable}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}

\def\ot{\leftarrow}
\def\prequiv{\dashv\vdash}
\def\fdom{\mathbf{d}f}
\def\fcod{\mathbf{e}f}
\def\thn{\mathrel|}
\def\coe{\mathsf{coe}}
\def\bpush{\mathbf{push}}
\def\bpull{\mathbf{pull}}

\def\wo{\setminus}
\def\fA{\mathsf{A}}
\def\fC{\mathsf{C}}
\def\fX{\mathsf{X}}
\def\ff{\mathsf{f}}
\def\fm{\mathsf{m}}
\def\rspan{\mathsf{Span}}
% \def\El#1{\mathsf{El}({#1})}
\def\El#1{\ulcorner{#1}\urcorner}
\def\U{\mathsf{U}}
\def\uu{\mathsf{u}}
\def\uni{\U}
\def\mor#1#2{#1 \to \underline{#2}}

\def\ridp{\mathsf{idp}}
\def\ssem#1{\langle\!\langle{#1}\rangle\!\rangle}

\definecolor{lred}{rgb}{0.95,0.8,0.8}
\definecolor{cyan}{rgb}{0.80,0.95,0.95}
\definecolor{orange}{rgb}{0.95,0.90,0.80}
\definecolor{bluegray}{rgb}{0.6,0.6,0.85}
\definecolor{lgray}{gray}{0.9}
\newtcolorbox{declbox}{colframe=lred,colback=lred,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{thmbox}{colframe=cyan,colback=cyan,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{defnbox}{colframe=orange,colback=orange,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{tangentbox}{colframe=lgray,colback=lgray,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}

\input{linear}
\def\rpath#1{[#1]}
\def\rfst{\mathsf{fst}\,}
\def\rsnd{\mathsf{snd}\,}
\def\bunfold{\mathbf{unfold}}
\def\bfold{\mathbf{fold}}
\def\susp#1{\langle {#1} \rangle}
\def\ssusp#1{\langle\!\langle {#1} \rangle\!\rangle}
\def\dto{\mathrel{\dot\to}}
\def\dns{{\downarrow}}
\def\ups{{\uparrow}}
\def\sprov{\Vdash}
\def\signat{{\color{red}\Sigma}}
\def\ep#1{\underline{#1}}
\def\wat{\mathbin{@}}
\def\wwat{\mathbin{\underline\wat}}
\def\cn{{:}}
\def\dv{{\div}}
\def\ww{{\mathsf w}}
\def\base{{\textfrak b}}

\def\munit{I}
\def\tt{{\mathsf t}}
\def\ii{{\mathbb I}}
\def\T{\mathbb{T}}
\def\pp{\textsf{\textbf p}}
\def\nn{{\mathsf n}}
\def\PP{\textsf{\textbf P}}
\def\NN{\textsf{\textbf N}}
\def\zz{{\mathsf z}}
\def\sem#1{[\![#1]\!]}
\def\usem#1{\lceil\!\!\lceil{#1}\rceil\!\!\rceil}
\def\zem#1{\langle\!\langle#1\rangle\!\rangle}
\def\col#1{{\mathsf{C}}_{#1}}
\def\lax{\mathop\bigcirc}
\def\rjust{\mathsf{just}}
\def\rcvt{\mathsf{cvt}}
\def\rtype{\mathsf{type}}
\def\rdtype{\mathsf{disc}}
\def\rkind{\mathsf{kind}}
\def\rmode{\mathsf{mode}}
\def\rprel{\mathbf{Prel}}
\def\rrfam{\mathbf{Rfam}}
\def\rset{\mathbf{Set}}
\def\rfinset{\mathbf{FinSet}}
\def\rrel{\mathbf{Rel}}
\def\rcat{\mathbf{Cat}}
\def\rfam{\mathbf{Fam}}
\def\binj{\mathbf{inj}}
\def\rid{\mathsf{id}}
\def\rtrue{\mathrel\mathrm{true}}
\def\pbck{\ar[dr, phantom, pos=0, "\lrcorner"]}
\def\bpbck{\ar[ddrr, phantom, pos=0, "\lrcorner"]}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\btwo{\mathbf{2}}
\def\bone{\mathbf{1}}

\newarrow {Equiv} =====
\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\def\mapt{\ar[ddd,mapsto,shorten <=2em, shorten >=2em]}
\def\frommaps{\ar[from=uu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\frommapt{\ar[from=uuu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\C{\mathbf{C}}
\def\G{\mathbf{G}}
\def\S{\mathbf{S}}
\def\D{\mathbf{D}}
\def\E{\mathbf{E}}
\def\M{\mathbf{M}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\ltri{{\lhd}}
\def\rtri{{\rhd}}
\def\tri{\rhd}
\def\o{\circ}
\def\rctx{\,\mathsf{ctx}}
\def\rdctx{\,\mathsf{dctx}}
\def\del{\partial}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\definecolor{fib}{HTML}{ff7f00}
\definecolor{green}{HTML}{007f00}
\definecolor{red}{HTML}{df3f3f}
\definecolor{opfib}{HTML}{007fff}

% For lightening colors I used
% http://trycolors.com/ 6 parts white to 1 part color
\definecolor{opfibl}{HTML}{DBEDFF}
\definecolor{greenl}{HTML}{DBEDDB}
\definecolor{redl}{HTML}{FAE4E4}
\def\njudge#1{\fcolorbox{opfib}{white}{#1}}
\def\nrule#1{\fcolorbox{white}{opfibl}{#1}}
\def\neqn#1{\fcolorbox{white}{redl}{#1}}



\def\judge#1{\vskip 2em\noindent \njudge{$#1$}\vskip 0.5em\noindent}
\def\rule#1{\vskip 2em \noindent \nrule{$#1$}\vskip 0.5em\noindent}
\def\eqn#1{\vskip 2em \noindent \neqn{$#1$}\vskip 0.5em\noindent}
\def\prof{\nrightarrow}
\def\tensor{\otimes}
\def\htensor{\mathrel{\hat\otimes}}
\def\lol{\multimap}
\def\hlol{\mathrel{\hat\multimap}}
\def\wtf{{\color{red}???}}

\def\re{\mathbf{E}}
\def\sh{\sharp}
\def\shp{\mathrel{\sharp}}
\def\zero{\texttt{0}}
\begin{document}

\def\
\tikzset{
   commutative diagrams/.cd,
   arrow style=tikz,
   diagrams={>=stealth}}

\section{(Co)end Programming}

\subsection{Filling the next gap}

Ok, so I have some agda in \texttt{2018-06-04b.agda} that proves something with
a lot of postulating, and I want to try to de-postulate \texttt{ABq} to some extent.

What I know about something that's ostensibly of type
$(\epsilon : \Delta) \to \epsilon \le \delta \to A(\epsilon)$ is not
merely that a have a function of that type, but that it satisfies the end-condition.
If I have a map $\phi : e \to e'$, and I instantiate it at $ee$ and $e'e'$, the functions
$ee \le \delta \to A(ee)$ and $e'e' \le \delta \to A(e'e')$ that it gives
me are, when transported down to $e'e \le \delta \to A(e'e)$ are the same.

This feels at least consistent with --- if not clearly implying or implied by
--- \texttt{At-$\eta$} --- which says if I feed any
$q: (\epsilon : \Delta) \to \epsilon \le \delta \to A(\epsilon)$
$\delta$ and $\rid_\delta$, then I get... any $a : A(\delta)$? Hold
on a minute, that seems too strong.

Let's examine where this comes from more carefully. The putatitve
equivalence involving $\delta : \Delta \prov A : \rtype$ that says
that $A$ is contravariant is
\[ A(\delta) \equiv \forall \epsilon . \epsilon \le \delta \to A(\epsilon) \]
and specifically that the map
\[\mu :  (\forall \epsilon . \epsilon \le \delta \to A(\epsilon)) \to A(\delta)   \]
\[\mu(t) = t[\delta](\rid_\delta) \]
has an inverse
\[\nu  : A(\delta) \to   \forall \epsilon . \epsilon \le \delta \to A(\epsilon) \]
The $\beta$-reduction says that a round-trip starting at $A(\delta)$ reduces to the
identity:
\[ (a : A(\delta)) \to \mu (\nu a) \equiv a\]
\[ (a : A(\delta)) \to \nu (a) [\delta](\rid_\delta) \equiv a\]

The $\eta$-reduction says that a round-trip starting at
$\forall \epsilon . \epsilon \le \delta \to A(\epsilon)$ reduces to the
identity:
\[(t : \forall \epsilon . \epsilon \le \delta \to A(\epsilon)) \to \nu(\mu t) \equiv t\]
\[(t : \forall \epsilon . \epsilon \le \delta \to A(\epsilon)) \to \nu( t[\delta](\rid_\delta)) \equiv t\]
Oh, looks like I simply wrote down totally the wrong thing in the agda then.
Fixed in \texttt{2018-06-05.agda}

\subsection{\texttt{ABq}}

Ok, so then the wild guess that I had about the
coend-y equivalence I was hoping for for $\Pi$-type
transport goes like this. We suppose
\begin{defnbox}
\begin{tabbing}
\hskip 2em \=\kill
$\mu^A_\epsilon :  (\forall \delta . \delta \le \epsilon \to A_\delta) \to A_\epsilon$\\
$\mu^A_\epsilon(t) = t[\epsilon](\rid_\epsilon)$\\
\\
$\nu^A_\epsilon  : A_\epsilon \to   \forall \delta . \delta \le \epsilon \to A_\delta $\\
$\nu^A_\epsilon = (\mu^A_\epsilon)^{-1}$\\
\\
$\mu^B_\epsilon(a : A_\epsilon) : B_\epsilon(a) \to  (\exists \delta . (p : \delta \le \epsilon) \x B_\delta(\nu^A_\epsilon(a[\delta] p)) $\\
$\mu^B_\epsilon(a, b) = \pair \epsilon {\pair{\rid_\epsilon} b} $\\
\\
$\nu^B_\epsilon(a : A_\epsilon)  : (\exists \delta . (p : \delta \le \epsilon) \x B_\delta(\nu^A_\epsilon(a[\delta] p)) \to B_\epsilon(a) $\\
$\nu^B_\epsilon(a) = (\mu^B_\epsilon(a))^{-1}$\\
\\
\(
\mu^{AB}_\epsilon : ((a : A_\epsilon) \to B_\epsilon) \to
\exists \delta . \delta \le \epsilon \x ((a : A_\delta) \to B_\delta)
\)
\\
$\mu^B_\epsilon(f) = \pair \epsilon {\pair{\rid_\epsilon} f} $\\
\\
\(
\nu^{AB}_\epsilon :
(\exists \delta . \delta \le \epsilon \x ((a : A_\delta) \to B_\delta))
\to ((a : A_\epsilon) \to B_\epsilon)
\)
\\
$\nu^{AB}_\epsilon(t, a) = \blet \pair \delta {\pair p f} = t \bin $\\
\> $\blet a' : A_\delta = \nu^A_\epsilon (a[\delta] p) \bin$\\
\> $\blet b' : B_\delta(\nu^A_\epsilon (a[\delta] p)) = f(a') \bin$\\
\> $\nu^B_\epsilon(a, \pair \delta {\pair p {b'}})$
\end{tabbing}
\end{defnbox}
Ok, let's calculate $\nu^{AB} \mu^{AB}$ now.

\begin{center}
\begin{minipage}{\textwidth}
\begin{tabbing}
\hskip 2em \=\kill
$\nu^{AB}_\epsilon\mu^{AB}_\epsilon(f) = \lambda a . \blet \pair \delta {\pair p f} = \pair \epsilon {\pair {\rid_{\epsilon}} f} \bin $\\
\> $\blet a' : A_\delta = \nu^A_\epsilon (a[\delta] p) \bin$\\
\> $\blet b' : B_\delta(\nu^A_\epsilon (a[\delta] p)) = f(a') \bin$\\
\> $\nu^B_\epsilon(a, \pair \delta {\pair p {b'}})$\\
$= \lambda a . \blet a' : A_\epsilon = \nu^A_\epsilon (a[\epsilon] {\rid_\epsilon}) \bin$\\
\> $\blet b' : B_\epsilon(\nu^A_\epsilon (a[\epsilon] {\rid_\epsilon})) = f(a') \bin$\\
\> $\nu^B_\epsilon(a, \pair \epsilon {\pair {\rid_\epsilon} {b'}})$\\
$= \lambda a . \blet b' : B_\epsilon(\nu^A_\epsilon (a[\epsilon] {\rid_\epsilon})) = f(a) \bin$\\
\> $\nu^B_\epsilon(a, \pair \epsilon {\pair {\rid_\epsilon} {b'}})$\\
$= \lambda a .\nu^B_\epsilon(a, \pair \epsilon {\pair {\rid_\epsilon} {f(a)}})$\\
$= \lambda a .f(a)$
\end{tabbing}
\end{minipage}
\end{center}
Ok, good. That's the easy direction. The harder direction is
$\mu^{AB}\nu^{AB}$.
The thing I start with on this round-trip is $t : \exists \delta . \delta \le \epsilon \x (a : A_\delta) \to B_\delta(a)$.
This turns into $\nu^{AB} t$ which is a big mess of lets. And then I
get $\pair{\epsilon}{\pair{\rid_\epsilon}{\nu^{AB} t}}$ and I'm supposed
to be able to see that
\[\pair{\epsilon}{\pair{\rid_\epsilon}{\nu^{AB} t}} \equiv t\]
Hmm. I do probably know as an $\eta$ principle that for some $u : \exists \epsilon . A$
that
\[u = \blet \pair \epsilon x = u \bin \pair \epsilon x \]
but that doesn't seem to help me much.

I kind of want to focus on the idea that the {\em meaning} of
$(a :A_\delta) \to B_\delta$ as an {\em ambivariant} functor of $\delta$
perhaps already exists prior to establishing it as a
{\em monotone} functor. Which would at least give me some traction and
let me some sort of direct principle about coends, maybe?
It's hard to think of how to formulate it, though.

\subsection{Zig-Zags}
Recall that I want to say that
\[\pair {dd} x \equiv \pair {ee} y : \exists x . F(x)\]
 when there is a map $f : d \to e$ in $\C$ and
$F_{fd}(x) \equiv F_{ef}(y) : F_{ed}$. And more generally that
when there is a zigzag $z : \{d, e\}$ and some filling-in equalities
$[F x y z]$. Let me try to write typing rules for these.

\[
\erule
{\Delta \prov t, u : \C }
{\Delta; \Gamma \prov \{t, u\} : \rtype}
\qquad
\erule
{\Delta \prov t, u : \C \qquad z : \{t, u\} \qquad \alpha : \C \prov F : \rtype}
{\Delta; \Gamma \prov F \wat_{tu} z : \rtype}
\]

Let's just stare a minute at $\{t, u\}$ and think about what it's
supposed to mean. A type in $\Delta$ is supposed to be a functor from
$\sem \Delta$. The category terms $t$ and $u$ pick out an object in
$\C$ for every object of $\sem\Delta$. If we travel along an arrow ---
or co-arrow --- in $\sem \Delta$, we're supposed to be able to do
something to the element in $\{t, u\}$. No problem, we can extend it
along the arrow given by $t$ or $u$.

Actually, we should have been able to ask for either or both of $t, u$
to be $\C^\op$ also up there, unlike $\hom$, which definitely needs
$t$ to be a $\C^\op$ and $u$ to be a $\C$.

What kind of intro/elim rules can I imagine?
\[
\erule
{}
{\Delta; \Gamma \prov \rid :  \{t, t\}}
\qquad
\erule
{\Delta; \Gamma \prov M : F \wat_{tu} z : \rtype}
{\Delta; \Gamma \prov \pi_1 M : F(t) : \rtype}
\qquad
\erule
{\Delta; \Gamma \prov M : F \wat_{tu} z : \rtype}
{\Delta; \Gamma \prov \pi_2 M : F(u) : \rtype}
\]

Huh... actually, does this mean a zigzag is itself kind of like
a domain of quantification for an end/coend?
Is $F \wat_{tu} z$ just a way of saying
$\forall \alpha \in z . F(\alpha)$? And then
we would suppose axiomatically
that $t \in z : \{t, u\}$ and $u \in z : \{t, u\}$?

In that case the thing I'd hope to be true would look like
\[
\erule
{M, N : \exists \alpha . F(\alpha) }
{(M \equiv N) \equiv \exists \alpha \beta . (z : \{\alpha, \beta\}) \x \forall \gamma . \gamma \in z \to F(\gamma)}
\]

I'm quite unsure whether $\gamma \in z$ is a standalone type, or whether the quantifier
$\forall \gamma \in z . A$ is a first-class indecomposable thing.
It seems clear that
$\forall \gamma . \gamma \in \rid_t \to F(\gamma)$
should be the same thing as $F(t)$. Given that, I can at least imagine
the left-to-right direction of this equivalence as going: assume
$M$ and $N$ are literally the same by $\ridp$-induction.
That means we can $\blet$-bind the $\alpha$ and the $x : F(\alpha)$
of that single term. We choose $\alpha$ and $\alpha$ for the two
existentials on the right. We choose $\rid_\alpha$ for $z$. And then
we can plug in $x : F(\alpha)$ to finish.

The right-to-left direction is entirely unclear!

\subsection{Interaction with homs}

I should of course be able to do some kind of injection
\[
\erule
{\Delta \prov M : \C[t, u]}
{\Delta \prov \mathsf{zig} M : \C\{t, u\}}
\]
and I guess this could be definable in terms of transport.
The zigzag-type-constructor should be covariant and contravariant
in both arguments, so I should expect
\[ \{\alpha,  \gamma\} = \exists \beta .  [\beta, \alpha] \x \{\beta, \gamma\} \]
along with many other symmetric versions.

And to be able to express what $\forall \gamma \in \mathsf{zig} f . F(\gamma)$
means, I kind of need to be able to go from
a $\hom$ to an `object of the category'... but I don't want to do that directly.
I want
\[
\erule
{\alpha : \C \prov F :\rtype \qquad f : \C[t, u]}
{F \wat f : \rtype}
\]
to exist, and I want both transports
\[ \binl : F(t) \to F \wat f \qquad \binr : F(u) \to F \wat f \]
to be possible. Then the intuition for $\forall \gamma \in \mathsf{zig} f . F(\gamma)$
when $f : \C[t, u]$ should be like all of
\[ M : F(t) \qquad N : F(u) \qquad \binl M \equiv \binr N \]

Right, and in general, $\forall \gamma \in z . F(\gamma)$ when $z$
is the composite of some $f : \C[t, u]$ and some existing zigzag $\zeta \in \C\{u, v\}$, we should
have something like
\[M : \forall \gamma \in \zeta . F(\gamma)
\qquad N : F(t) \qquad \binl_f \pi_1 M \equiv \binr_f N \]
and again $\forall \gamma \in \rid_t . F(\gamma)$ is just $F(t)$.

\subsection{Is $\wat f$ what I want?}

Maybe not! I think all I really want to do is just specify two {\em objects}.
If I speak carelessly and don't get the variances right, it'd be

\[
\erule
{\Delta \prov t : \C \qquad \Delta \prov u : \C}
{\Delta \prov t \bullet u : \C}
\]
The `average' of $t$ and $u$.
It's kind of a slice-and-splice operation that takes half of $t$ and
half of $u$ and glues them together into a new object of $\C \x \C^\op$.
It should be decisively covariant in one and contravariant in the other.
I'm pretty sure this is somehow a roundtrip around the polarized/unpolarized
context adjunction I was thinking about earlier.

So I don't need a separate {\em type} constructor for $\wat f$, it's just
an operation on two category expressions that yields a category
expression I can plug right into $F$. The injections, however,
need a morphism to make sense:

\[
\erule
{f : \C[t, u]}
{\binl_f : F(t) \to F(u \bullet t)}
\qquad
\erule
{f : \C[t, u]}
{\binr_f : F(u) \to F(u \bullet t)}
\]
So everything else above I said makes sense, just replacing $F \wat f$
with $F(u\bullet t)$. I index by the `middle' of the morphism, not the morphism itself.

Are these injections definable as transport? Seems like they should be.
Other things I expect of it include
$t \bullet t = t$
and  $(a \bullet b) \bullet c = a \bullet (b \bullet c) = a \bullet c$.

I think $\bullet$ is covariant in its first argument, and contravariant in its
second, so if
\[F(\alpha) \equiv \forall \beta . \alpha \le \beta \to F(\beta)\]
then I expect
\[F(\alpha \bullet \gamma) \equiv \forall \beta . \alpha \le \beta \to F(\beta \bullet \gamma)\]
This latter statement would entail
\[F(\alpha) \equiv \forall \beta . \alpha \le \beta \to F(\beta \bullet \alpha)\]

So what kind of condition would I need to show that
\[ \forall \beta . \alpha \le \beta \to F(\beta) \equiv \forall \beta . \alpha \le \beta \to F(\beta \bullet \alpha)\]
unconditionally?

If I start with the goal
\[ \forall \beta . \alpha \le \beta \to F(\beta) \prov \forall \beta . \alpha \le \beta \to F(\beta \bullet \alpha)\]
that leads to
\[ \forall \beta . \alpha \le \beta \to F(\beta), \alpha \le \beta \prov F(\beta \bullet \alpha)\]
so maybe I can choose $\beta = \beta \bullet \alpha$ on the left to get
\[  \alpha \le \beta \prov \alpha \le \beta \bullet \alpha \]
which actually seems maybe provable if I squint and see it as
\[  \alpha \le \beta \prov \alpha \bullet \alpha \le \beta \bullet \alpha \]

If I start with the goal
\[\forall \beta . \alpha \le \beta \to F(\beta \bullet \alpha) \prov \forall \beta . \alpha \le \beta \to F(\beta) \]
that leads to
\[\forall \beta . \alpha \le \beta \to F(\beta \bullet \alpha) , \alpha \le \beta \prov F(\beta) \]
and I can just choose $\beta = \alpha$ on the left to get the goal
\[ F(\alpha) , \alpha \le \beta \prov F(\beta) \]
which can be finished thanks to the assumption that $F$ is monotone.

So I think it's appropriate to ask that we can go
\[
\erule
{\alpha \le \beta \qquad \alpha' \le \beta'}
{\alpha \bullet \beta' \le \alpha' \bullet \beta}
\]

\subsection{What injection equalities mean}

I notice the only way I use the injections is to
assert equalities between left-injections and right-injections.
So more abstractly I could just say that there's a type whose inhabitants
are proofs that a hom $f : \C[t, u]$
relates an $M : F(t)$ and a $N : F(u)$. And this works regardless of whether
the functor $F$ is co/contravariant!
\end{document}
