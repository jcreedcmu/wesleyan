\documentclass{article}
\usepackage[tmargin=0.05in, bmargin=0.05in]{geometry}
\input{theorem}
\input{prooftree}
\usepackage{stmaryrd}
\usepackage{latexsym}
\usepackage{yfonts}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,cd,decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}
\usepackage{tcolorbox}
\tcbuselibrary{breakable}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}

\def\gol{\sqsubset}
\def\gor{\sqsupset}

\def\sp{\bullet}
\def\ot{\leftarrow}
\def\prequiv{\dashv\vdash}
\def\fdom{\mathbf{d}f}
\def\fcod{\mathbf{e}f}
\def\thn{\mathrel|}
\def\coe{\mathsf{coe}}
\def\bpush{\mathbf{push}}
\def\bpull{\mathbf{pull}}

\def\wo{\setminus}
\def\fA{\mathsf{A}}
\def\fC{\mathsf{C}}
\def\fX{\mathsf{X}}
\def\ff{\mathsf{f}}
\def\fm{\mathsf{m}}
\def\rspan{\mathsf{Span}}
% \def\El#1{\mathsf{El}({#1})}
\def\El#1{\ulcorner{#1}\urcorner}
\def\U{\mathsf{U}}
\def\uu{\mathsf{u}}
\def\uni{\U}
\def\mor#1#2{#1 \to \underline{#2}}

\def\ridp{\mathsf{idp}}
\def\ssem#1{\langle\!\langle{#1}\rangle\!\rangle}

\definecolor{lred}{rgb}{0.95,0.8,0.8}
\definecolor{cyan}{rgb}{0.80,0.95,0.95}
\definecolor{orange}{rgb}{0.95,0.90,0.80}
\definecolor{bluegray}{rgb}{0.6,0.6,0.85}
\definecolor{lgray}{gray}{0.9}
\newtcolorbox{declbox}{colframe=lred,colback=lred,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{thmbox}{colframe=cyan,colback=cyan,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{defnbox}{colframe=orange,colback=orange,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{tangentbox}{colframe=lgray,colback=lgray,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}

\input{linear}
\def\rpath#1{[#1]}
\def\rfst{\mathsf{fst}\,}
\def\rsnd{\mathsf{snd}\,}
\def\bunfold{\mathbf{unfold}}
\def\bfold{\mathbf{fold}}
\def\susp#1{\langle {#1} \rangle}
\def\ssusp#1{\langle\!\langle {#1} \rangle\!\rangle}
\def\dto{\mathrel{\dot\to}}
\def\dns{{\downarrow}}
\def\ups{{\uparrow}}
\def\sprov{\Vdash}
\def\signat{{\color{red}\Sigma}}
\def\ep#1{\underline{#1}}
\def\wat{\mathbin{@}}
\def\wwat{\mathbin{\underline\wat}}
\def\cn{{:}}
\def\dv{{\div}}
\def\ww{{\mathsf w}}
\def\base{{\textfrak b}}

\def\munit{I}
\def\tt{{\mathsf t}}
\def\ii{{\mathbb I}}
\def\T{\mathbb{T}}
\def\pp{\textsf{\textbf p}}
\def\nn{{\mathsf n}}
\def\PP{\textsf{\textbf P}}
\def\NN{\textsf{\textbf N}}
\def\zz{{\mathsf z}}
\def\sem#1{[\![#1]\!]}
\def\usem#1{\lceil\!\!\lceil{#1}\rceil\!\!\rceil}
\def\zem#1{\langle\!\langle#1\rangle\!\rangle}
\def\col#1{{\mathsf{C}}_{#1}}
\def\lax{\mathop\bigcirc}
\def\rjust{\mathsf{just}}
\def\rcvt{\mathsf{cvt}}
\def\rtype{\mathsf{type}}
\def\rdtype{\mathsf{disc}}
\def\rkind{\mathsf{kind}}
\def\rmode{\mathsf{mode}}
\def\rprel{\mathbf{Prel}}
\def\rrfam{\mathbf{Rfam}}
\def\rset{\mathbf{Set}}
\def\rfinset{\mathbf{FinSet}}
\def\rrel{\mathbf{Rel}}
\def\rcat{\mathbf{Cat}}
\def\rfam{\mathbf{Fam}}
\def\binj{\mathbf{inj}}
\def\rid{\mathsf{id}}
\def\rtrue{\mathrel\mathrm{true}}
\def\pbck{\ar[dr, phantom, pos=0, "\lrcorner"]}
\def\bpbck{\ar[ddrr, phantom, pos=0, "\lrcorner"]}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\btwo{\mathbf{2}}
\def\bone{\mathbf{1}}

\newarrow {Equiv} =====
\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\def\mapt{\ar[ddd,mapsto,shorten <=2em, shorten >=2em]}
\def\frommaps{\ar[from=uu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\frommapt{\ar[from=uuu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\C{\mathbf{C}}
\def\G{\mathbf{G}}
\def\S{\mathbf{S}}
\def\D{\mathbf{D}}
\def\E{\mathbf{E}}
\def\M{\mathbf{M}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\ltri{{\lhd}}
\def\rtri{{\rhd}}
\def\tri{\rhd}
\def\ll{\mathsf{L}}
\def\rr{\mathsf{R}}
\def\cc{\mathsf{c}}
\def\dd{\mathsf{d}}
\def\o{\circ}
\def\rctx{\,\mathsf{ctx}}
\def\rdctx{\,\mathsf{dctx}}
\def\del{\partial}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\definecolor{fib}{HTML}{ff7f00}
\definecolor{green}{HTML}{007f00}
\definecolor{red}{HTML}{df3f3f}
\definecolor{opfib}{HTML}{007fff}

% For lightening colors I used
% http://trycolors.com/ 6 parts white to 1 part color
\definecolor{opfibl}{HTML}{DBEDFF}
\definecolor{greenl}{HTML}{DBEDDB}
\definecolor{redl}{HTML}{FAE4E4}
\def\njudge#1{\fcolorbox{opfib}{white}{#1}}
\def\nrule#1{\fcolorbox{white}{opfibl}{#1}}
\def\neqn#1{\fcolorbox{white}{redl}{#1}}



\def\judge#1{\vskip 2em\noindent \njudge{$#1$}\vskip 0.5em\noindent}
\def\rule#1{\vskip 2em \noindent \nrule{$#1$}\vskip 0.5em\noindent}
\def\eqn#1{\vskip 2em \noindent \neqn{$#1$}\vskip 0.5em\noindent}
\def\prof{\nrightarrow}
\def\tensor{\otimes}
\def\htensor{\mathrel{\hat\otimes}}
\def\lol{\multimap}
\def\hlol{\mathrel{\hat\multimap}}
\def\wtf{{\color{red}???}}

\def\re{\mathbf{E}}
\def\sh{\sharp}
\def\shp{\mathrel{\sharp}}
\def\zero{\texttt{0}}
\begin{document}

\def\
\tikzset{
   commutative diagrams/.cd,
   arrow style=tikz,
   diagrams={>=stealth}}

\section{(Co)end Programming}

\subsection{Filling the next gap}

Ok, so I have some agda in \texttt{2018-06-04b.agda} that proves something with
a lot of postulating, and I want to try to de-postulate \texttt{ABq} to some extent.

What I know about something that's ostensibly of type
$(\epsilon : \Delta) \to \epsilon \le \delta \to A(\epsilon)$ is not
merely that a have a function of that type, but that it satisfies the end-condition.
If I have a map $\phi : e \to e'$, and I instantiate it at $ee$ and $e'e'$, the functions
$ee \le \delta \to A(ee)$ and $e'e' \le \delta \to A(e'e')$ that it gives
me are, when transported down to $e'e \le \delta \to A(e'e)$ are the same.

This feels at least consistent with --- if not clearly implying or implied by
--- \texttt{At-$\eta$} --- which says if I feed any
$q: (\epsilon : \Delta) \to \epsilon \le \delta \to A(\epsilon)$
$\delta$ and $\rid_\delta$, then I get... any $a : A(\delta)$? Hold
on a minute, that seems too strong.

Let's examine where this comes from more carefully. The putatitve
equivalence involving $\delta : \Delta \prov A : \rtype$ that says
that $A$ is contravariant is
\[ A(\delta) \equiv \forall \epsilon . \epsilon \le \delta \to A(\epsilon) \]
and specifically that the map
\[\mu :  (\forall \epsilon . \epsilon \le \delta \to A(\epsilon)) \to A(\delta)   \]
\[\mu(t) = t[\delta](\rid_\delta) \]
has an inverse
\[\nu  : A(\delta) \to   \forall \epsilon . \epsilon \le \delta \to A(\epsilon) \]
The $\beta$-reduction says that a round-trip starting at $A(\delta)$ reduces to the
identity:
\[ (a : A(\delta)) \to \mu (\nu a) \equiv a\]
\[ (a : A(\delta)) \to \nu (a) [\delta](\rid_\delta) \equiv a\]

The $\eta$-reduction says that a round-trip starting at
$\forall \epsilon . \epsilon \le \delta \to A(\epsilon)$ reduces to the
identity:
\[(t : \forall \epsilon . \epsilon \le \delta \to A(\epsilon)) \to \nu(\mu t) \equiv t\]
\[(t : \forall \epsilon . \epsilon \le \delta \to A(\epsilon)) \to \nu( t[\delta](\rid_\delta)) \equiv t\]
Oh, looks like I simply wrote down totally the wrong thing in the agda then.
Fixed in \texttt{2018-06-05.agda}

\subsection{\texttt{ABq}}

Ok, so then the wild guess that I had about the
coend-y equivalence I was hoping for for $\Pi$-type
transport goes like this. We suppose
\begin{defnbox}
\begin{tabbing}
\hskip 2em \=\kill
$\mu^A_\epsilon :  (\forall \delta . \delta \le \epsilon \to A_\delta) \to A_\epsilon$\\
$\mu^A_\epsilon(t) = t[\epsilon](\rid_\epsilon)$\\
\\
$\nu^A_\epsilon  : A_\epsilon \to   \forall \delta . \delta \le \epsilon \to A_\delta $\\
$\nu^A_\epsilon = (\mu^A_\epsilon)^{-1}$\\
\\
$\mu^B_\epsilon(a : A_\epsilon) : B_\epsilon(a) \to  (\exists \delta . (p : \delta \le \epsilon) \x B_\delta(\nu^A_\epsilon(a[\delta] p)) $\\
$\mu^B_\epsilon(a, b) = \pair \epsilon {\pair{\rid_\epsilon} b} $\\
\\
$\nu^B_\epsilon(a : A_\epsilon)  : (\exists \delta . (p : \delta \le \epsilon) \x B_\delta(\nu^A_\epsilon(a[\delta] p)) \to B_\epsilon(a) $\\
$\nu^B_\epsilon(a) = (\mu^B_\epsilon(a))^{-1}$\\
\\
\(
\mu^{AB}_\epsilon : ((a : A_\epsilon) \to B_\epsilon) \to
\exists \delta . \delta \le \epsilon \x ((a : A_\delta) \to B_\delta)
\)
\\
$\mu^B_\epsilon(f) = \pair \epsilon {\pair{\rid_\epsilon} f} $\\
\\
\(
\nu^{AB}_\epsilon :
(\exists \delta . \delta \le \epsilon \x ((a : A_\delta) \to B_\delta))
\to ((a : A_\epsilon) \to B_\epsilon)
\)
\\
$\nu^{AB}_\epsilon(t, a) = \blet \pair \delta {\pair p f} = t \bin $\\
\> $\blet a' : A_\delta = \nu^A_\epsilon (a[\delta] p) \bin$\\
\> $\blet b' : B_\delta(\nu^A_\epsilon (a[\delta] p)) = f(a') \bin$\\
\> $\nu^B_\epsilon(a, \pair \delta {\pair p {b'}})$
\end{tabbing}
\end{defnbox}
Ok, let's calculate $\nu^{AB} \mu^{AB}$ now.

\begin{center}
\begin{minipage}{\textwidth}
\begin{tabbing}
\hskip 2em \=\kill
$\nu^{AB}_\epsilon\mu^{AB}_\epsilon(f) = \lambda a . \blet \pair \delta {\pair p f} = \pair \epsilon {\pair {\rid_{\epsilon}} f} \bin $\\
\> $\blet a' : A_\delta = \nu^A_\epsilon (a[\delta] p) \bin$\\
\> $\blet b' : B_\delta(\nu^A_\epsilon (a[\delta] p)) = f(a') \bin$\\
\> $\nu^B_\epsilon(a, \pair \delta {\pair p {b'}})$\\
$= \lambda a . \blet a' : A_\epsilon = \nu^A_\epsilon (a[\epsilon] {\rid_\epsilon}) \bin$\\
\> $\blet b' : B_\epsilon(\nu^A_\epsilon (a[\epsilon] {\rid_\epsilon})) = f(a') \bin$\\
\> $\nu^B_\epsilon(a, \pair \epsilon {\pair {\rid_\epsilon} {b'}})$\\
$= \lambda a . \blet b' : B_\epsilon(\nu^A_\epsilon (a[\epsilon] {\rid_\epsilon})) = f(a) \bin$\\
\> $\nu^B_\epsilon(a, \pair \epsilon {\pair {\rid_\epsilon} {b'}})$\\
$= \lambda a .\nu^B_\epsilon(a, \pair \epsilon {\pair {\rid_\epsilon} {f(a)}})$\\
$= \lambda a .f(a)$
\end{tabbing}
\end{minipage}
\end{center}
Ok, good. That's the easy direction. The harder direction is
$\mu^{AB}\nu^{AB}$.
The thing I start with on this round-trip is $t : \exists \delta . \delta \le \epsilon \x (a : A_\delta) \to B_\delta(a)$.
This turns into $\nu^{AB} t$ which is a big mess of lets. And then I
get $\pair{\epsilon}{\pair{\rid_\epsilon}{\nu^{AB} t}}$ and I'm supposed
to be able to see that
\[\pair{\epsilon}{\pair{\rid_\epsilon}{\nu^{AB} t}} \equiv t\]
Hmm. I do probably know as an $\eta$ principle that for some $u : \exists \epsilon . A$
that
\[u = \blet \pair \epsilon x = u \bin \pair \epsilon x \]
but that doesn't seem to help me much.

I kind of want to focus on the idea that the {\em meaning} of
$(a :A_\delta) \to B_\delta$ as an {\em ambivariant} functor of $\delta$
perhaps already exists prior to establishing it as a
{\em monotone} functor. Which would at least give me some traction and
let me some sort of direct principle about coends, maybe?
It's hard to think of how to formulate it, though.

\subsection{Zig-Zags}
Recall that I want to say that
\[\pair {dd} x \equiv \pair {ee} y : \exists x . F(x)\]
 when there is a map $f : d \to e$ in $\C$ and
$F_{fd}(x) \equiv F_{ef}(y) : F_{ed}$. And more generally that
when there is a zigzag $z : \{d, e\}$ and some filling-in equalities
$[F x y z]$. Let me try to write typing rules for these.

\[
\erule
{\Delta \prov t, u : \C }
{\Delta; \Gamma \prov \{t, u\} : \rtype}
\qquad
\erule
{\Delta \prov t, u : \C \qquad z : \{t, u\} \qquad \alpha : \C \prov F : \rtype}
{\Delta; \Gamma \prov F \wat_{tu} z : \rtype}
\]

Let's just stare a minute at $\{t, u\}$ and think about what it's
supposed to mean. A type in $\Delta$ is supposed to be a functor from
$\sem \Delta$. The category terms $t$ and $u$ pick out an object in
$\C$ for every object of $\sem\Delta$. If we travel along an arrow ---
or co-arrow --- in $\sem \Delta$, we're supposed to be able to do
something to the element in $\{t, u\}$. No problem, we can extend it
along the arrow given by $t$ or $u$.

Actually, we should have been able to ask for either or both of $t, u$
to be $\C^\op$ also up there, unlike $\hom$, which definitely needs
$t$ to be a $\C^\op$ and $u$ to be a $\C$.

What kind of intro/elim rules can I imagine?
\[
\erule
{}
{\Delta; \Gamma \prov \rid :  \{t, t\}}
\qquad
\erule
{\Delta; \Gamma \prov M : F \wat_{tu} z : \rtype}
{\Delta; \Gamma \prov \pi_1 M : F(t) : \rtype}
\qquad
\erule
{\Delta; \Gamma \prov M : F \wat_{tu} z : \rtype}
{\Delta; \Gamma \prov \pi_2 M : F(u) : \rtype}
\]

Huh... actually, does this mean a zigzag is itself kind of like
a domain of quantification for an end/coend?
Is $F \wat_{tu} z$ just a way of saying
$\forall \alpha \in z . F(\alpha)$? And then
we would suppose axiomatically
that $t \in z : \{t, u\}$ and $u \in z : \{t, u\}$?

In that case the thing I'd hope to be true would look like
\[
\erule
{M, N : \exists \alpha . F(\alpha) }
{(M \equiv N) \equiv \exists \alpha \beta . (z : \{\alpha, \beta\}) \x \forall \gamma . \gamma \in z \to F(\gamma)}
\]

I'm quite unsure whether $\gamma \in z$ is a standalone type, or whether the quantifier
$\forall \gamma \in z . A$ is a first-class indecomposable thing.
It seems clear that
$\forall \gamma . \gamma \in \rid_t \to F(\gamma)$
should be the same thing as $F(t)$. Given that, I can at least imagine
the left-to-right direction of this equivalence as going: assume
$M$ and $N$ are literally the same by $\ridp$-induction.
That means we can $\blet$-bind the $\alpha$ and the $x : F(\alpha)$
of that single term. We choose $\alpha$ and $\alpha$ for the two
existentials on the right. We choose $\rid_\alpha$ for $z$. And then
we can plug in $x : F(\alpha)$ to finish.

The right-to-left direction is entirely unclear!

\subsection{Interaction with homs}

I should of course be able to do some kind of injection
\[
\erule
{\Delta \prov M : \C[t, u]}
{\Delta \prov \mathsf{zig} M : \C\{t, u\}}
\]
and I guess this could be definable in terms of transport.
The zigzag-type-constructor should be covariant and contravariant
in both arguments, so I should expect
\[ \{\alpha,  \gamma\} = \exists \beta .  [\beta, \alpha] \x \{\beta, \gamma\} \]
along with many other symmetric versions.

And to be able to express what $\forall \gamma \in \mathsf{zig} f . F(\gamma)$
means, I kind of need to be able to go from
a $\hom$ to an `object of the category'... but I don't want to do that directly.
I want
\[
\erule
{\alpha : \C \prov F :\rtype \qquad f : \C[t, u]}
{F \wat f : \rtype}
\]
to exist, and I want both transports
\[ \binl : F(t) \to F \wat f \qquad \binr : F(u) \to F \wat f \]
to be possible. Then the intuition for $\forall \gamma \in \mathsf{zig} f . F(\gamma)$
when $f : \C[t, u]$ should be like all of
\[ M : F(t) \qquad N : F(u) \qquad \binl M \equiv \binr N \]

Right, and in general, $\forall \gamma \in z . F(\gamma)$ when $z$
is the composite of some $f : \C[t, u]$ and some existing zigzag $\zeta \in \C\{u, v\}$, we should
have something like
\[M : \forall \gamma \in \zeta . F(\gamma)
\qquad N : F(t) \qquad \binl_f \pi_1 M \equiv \binr_f N \]
and again $\forall \gamma \in \rid_t . F(\gamma)$ is just $F(t)$.

\subsection{Is $\wat f$ what I want?}

Maybe not! I think all I really want to do is just specify two {\em objects}.
If I speak carelessly and don't get the variances right, it'd be

\[
\erule
{\Delta \prov t : \C \qquad \Delta \prov u : \C}
{\Delta \prov t \sp u : \C}
\]
The `average' of $t$ and $u$.
It's kind of a slice-and-splice operation that takes half of $t$ and
half of $u$ and glues them together into a new object of $\C \x \C^\op$.
It should be decisively covariant in one and contravariant in the other.
I'm pretty sure this is somehow a roundtrip around the polarized/unpolarized
context adjunction I was thinking about earlier.

So I don't need a separate {\em type} constructor for $\wat f$, it's just
an operation on two category expressions that yields a category
expression I can plug right into $F$. The injections, however,
need a morphism to make sense:

\[
\erule
{f : \C[t, u]}
{\binl_f : F(t) \to F(u \sp t)}
\qquad
\erule
{f : \C[t, u]}
{\binr_f : F(u) \to F(u \sp t)}
\]
So everything else above I said makes sense, just replacing $F \wat f$
with $F(u\sp t)$. I index by the `middle' of the morphism, not the morphism itself.

Are these injections definable as transport? Seems like they should be.
Other things I expect of it include
$t \sp t = t$
and  $(a \sp b) \sp c = a \sp (b \sp c) = a \sp c$.

I think $\sp$ is covariant in its first argument, and contravariant in its
second, so if
\[F(\alpha) \equiv \forall \beta . \alpha \le \beta \to F(\beta)\]
then I expect
\[F(\alpha \sp \gamma) \equiv \forall \beta . \alpha \le \beta \to F(\beta \sp \gamma)\]
This latter statement would entail
\[F(\alpha) \equiv \forall \beta . \alpha \le \beta \to F(\beta \sp \alpha)\]

So what kind of condition would I need to show that
\[ \forall \beta . \alpha \le \beta \to F(\beta) \equiv \forall \beta . \alpha \le \beta \to F(\beta \sp \alpha)\]
unconditionally?

If I start with the goal
\[ \forall \beta . \alpha \le \beta \to F(\beta) \prov \forall \beta . \alpha \le \beta \to F(\beta \sp \alpha)\]
that leads to
\[ \forall \beta . \alpha \le \beta \to F(\beta), \alpha \le \beta \prov F(\beta \sp \alpha)\]
so maybe I can choose $\beta = \beta \sp \alpha$ on the left to get
\[  \alpha \le \beta \prov \alpha \le \beta \sp \alpha \]
which actually seems maybe provable if I squint and see it as
\[  \alpha \le \beta \prov \alpha \sp \alpha \le \beta \sp \alpha \]

If I start with the goal
\[\forall \beta . \alpha \le \beta \to F(\beta \sp \alpha) \prov \forall \beta . \alpha \le \beta \to F(\beta) \]
that leads to
\[\forall \beta . \alpha \le \beta \to F(\beta \sp \alpha) , \alpha \le \beta \prov F(\beta) \]
and I can just choose $\beta = \alpha$ on the left to get the goal
\[ F(\alpha) , \alpha \le \beta \prov F(\beta) \]
which can be finished thanks to the assumption that $F$ is monotone.

So I think it's appropriate to ask that we can go
\[
\erule
{\alpha \le \beta \qquad \alpha' \le \beta'}
{\alpha \sp \beta' \le \alpha' \sp \beta}
\]

\subsection{What injection equalities mean}

I notice the only way I use the injections is to
assert equalities between left-injections and right-injections.
So more abstractly I could just say that there's a type whose inhabitants
are proofs that a hom $f : \C[t, u]$
relates an $M : F(t)$ and a $N : F(u)$. And this works regardless of whether
the functor $F$ is co/contravariant!

This kind of reasoning is appropriate for zigzags also.
If we have zigzags $z_1 : \{t, u\}$ and $z_2 : \{u, v\}$, then
we can relate $M : F(t)$ and $P : F(v)$ `over' $z_1;z_2$
precisely when we can find a $N : F(u)$
and we can relate $M \sim N$ over $z_1$ and $N \sim P$ over $z_2$.

Ok, let's write the type constructor
\[
\erule
{z : \{t, u\} \qquad \alpha : \C \prov F : \rtype \qquad M : F(t) \qquad N : F(u)}
{M \sim^F_z N : \rtype}
\]
then the principle I expect to hold is
\[
\erule
{z_1 : \{t, u\} \quad z_2 : \{u, v\}\qquad M : F(t)\quad N : F(u)\quad P: F(v)}
{(M \sim^F_{z_1;z_2} P) \equiv (N : F(u)) \x (M \sim_{z_1}^F N) \x (N \sim_{z_2}^F P)}
\]
and for identities
\[
\erule
{ M, N : F(t)}
{(M \sim^F_{\rid_t} N) \equiv (M \equiv N)}
\]
and converses
\[
\erule
{ z: \{t, u\} \qquad M : F(t) \qquad N : F(u)}
{(M \sim^F_{z} N) \equiv (N \sim^F_{\bar z} M)}
\]
And so far I don't know how yet I'd concretely use the data in a one-morphism
zigzag, but I know it should be
\[
\erule
{ f: [t, u] \qquad M : F(t) \qquad N : F(u)}
{(M \sim^F_{\mathsf{zig} f} N) \equiv (\binl_f M \equiv \binr_f N)}
\]
though I suppose I could derive the identity principle from that.

Anyway, popping way back up, I think now the thing I expect for equality at
coend-type is
\[(M \equiv N) \equiv  \blet \pair \alpha m = M \bin
 \blet \pair \beta n = N \bin
\  (z : \{\alpha, \beta\}) \x m \sim^F_{z} n \]
and then I think with some suitable $\eta$-principle I can go from $\ridp : M \equiv M$
on the left to
\[ \blet \pair \alpha m = M \bin
 \blet \pair \beta n = M \bin
\  (z : \{\alpha, \beta\}) \x m \sim^F_{z} n \]
to
\[ \blet \pair \alpha m = M \bin
\  (z : \{\alpha, \alpha\}) \x m \sim^F_{z} m \]
and then just plop down the identity zigzag and identity path for $m \sim m$.

I ought to be conscious of the fact that I'm doing a large elimination
from the coend type and that's slightly terrifying!

\subsection{Another Equivalent Way of Talking about Variance}

A type constructor $F(\alpha)$ is covariant
iff $F(\alpha \sp \beta) \equiv F(\alpha)$ for any $\beta$.
It's contravariant
iff $F(\alpha \sp \beta) \equiv F(\beta)$ for any $\alpha$.

This means we should have $\alpha \le \beta \equiv \alpha \le \beta \sp \gamma$
and $\gamma \bullet \alpha \le \beta$. Does that hold up?

If we have $\alpha \le \beta$, then certainly we have $\alpha \sp \gamma \le \beta \sp \gamma$. Do we have $\alpha \le \alpha \sp \gamma$? It seems like we need
a morphism $\gamma \to \alpha$ to justify it via $\alpha \sp \alpha \le \alpha \sp \gamma$.

Let's try to think more generally about what's needed to bridge these.
Suppose $F(\alpha \bullet \beta) \equiv F(\alpha)$ for all $\beta$.
We'd then like to show that
$F(\alpha) \equiv \forall \beta . \alpha \le \beta \to F(\beta)$.
Specifically the hard direction is
\[F(\alpha), f : \alpha \le \beta \prov F(\beta)\]
This doesn't seem to be of any help at all. Or wait --- maybe I need to remember that
I can do
\[ \binl_f : F(\alpha) \to F(\beta \bullet \alpha) \]
and that's what gets me to something that's as good as $F(\beta)$.

Huh, so another way of thinking about
 the type $\alpha \le \beta$/$\C[\alpha, \beta]$ is that it's sort of
like a cospan
\[ F(\alpha) + F(\beta)  \to F(\beta \sp \alpha)\]

How does composition work, then? If I have
\[ F(\alpha) + F(\beta)  \to F(\beta \sp \alpha)\]
\[ F(\beta) + F(\gamma)  \to F(\gamma \sp \beta)\]
I'd need to know how to get
\[ F(\beta \sp \alpha) \to F(\gamma \sp \alpha) \]
\[ F(\gamma \sp \beta) \to F(\gamma \sp \alpha) \]
Would it be enough to ask directly for
\[ F(\alpha) + F(\gamma \sp \beta)  \to F(\gamma  \sp \alpha)\]
\[ F(\beta \sp \alpha) + F(\gamma)  \to F(\gamma  \sp \alpha)\]
then?
More perspicuously:
\[ \alpha \le \beta =  F(\alpha) + F(\beta' \sp \beta)  \to F(\beta'  \sp \alpha)\]
\[ \beta \le \gamma = F(\beta \sp \beta') + F(\gamma)  \to F(\gamma  \sp \beta')\]
So perhaps generally:
\[ \delta \le \epsilon = F(\delta \sp \delta') + F(\epsilon' \sp \epsilon)  \to F(\epsilon' \sp \delta')\]
No, that doesn't look right, not even
\[ \delta \le \epsilon = F(\delta \sp w) + F(w \sp \epsilon)  \to F(w)\]
\subsubsection{Equivalence?}
So the injections seem to let us show that
\[\alpha \le \beta \to \zeta \le \alpha \to \zeta \le \beta \sp \alpha\]
but also
\[\alpha \le \beta \to \alpha \le \zeta \to  \beta \sp \alpha \le \zeta\]
What's up with that? If $\alpha = a_1a_2$ and $\beta = b_1b_2$ and $\zeta = z_1z_2$
this is telling us that
\[a_2 \le b_1 \to z_2 \le a_1 \to z_2 \le b_1\]
but also
\[a_2 \le b_1 \to a_2 \le z_1 \to  a_2 \le z_1\]
And things are totally falling apart and I'm not sure I understand $\sp$ at all anymore.
Or $\hom$ types, even.

\subsection{Why I should be skeptical of $\sp$}

If I substituted $\alpha \bullet \beta$ in for a category variable in
a term, wouldn't I have a morphism-independent way of realizing $M_{de}$ at
any $d, e$? That seems bad.

\subsection{What Happens If I don't Fix Endpoints on $\sim$}

Let's return to thinking about
\[
\erule
{z : \{t, u\} \qquad M :  F \wat z}
{\pi_1 M : F(t)}
\qquad
\erule
{z : \{t, u\} \qquad M : F \wat z}
{\pi_2 M : F(u)}
\]
Keep in mind that $\wat$ is actually binding an $\alpha$ in $F$.

The relation-composition property for this type constructor is
\[
\erule
{z_1 : \{t, u\} \quad z_2 : \{u, v\}}
{F \wat z_1;z_2 \equiv ((x_1 : F \wat z_1) (x_2 : F\wat z_2) \x \pi_2 x_1 \equiv \pi_1 x_2)}
\]
The identity property is
\[
\erule
{}
{F \wat \rid_t \equiv F(t)}
\]
And symmetry is the fact that there does exist an equivalence
\[
\erule
{}
{ F \wat z \equiv F \wat \bar z}
\]
\subsection{Is the Zig-zag type really a type?}
Maybe actually it's four different types for all the different arity possibilities.
Can I pass between them freely?
Suppose I have $\{t^+, t^-\},\{t^-, t^+\},\{t^+, t^+\},\{t^-, t^-\}$.
Then I could think about types like
\[ \{\bar\alpha^+ , \beta^-\} \to \{\bar\alpha^-, \bar\beta^-\} \]
which is a meaningful type to ask about. Does the identity function
on zigzags have the appropriate functoriality for all 16 assignments of polarities?
Let's call the polarities $a, b, c, d$.
\[ \alpha, \beta : \C \prov Z_{ab}\{\alpha^{\bar a} , \beta^{\bar b}\} \to Z_{cd}\{\alpha^c, \beta^d\} \]

Oh... I think I see now how this doesn't work.
For a concrete example, picture the diagram
\[\begin{tikzcd}
\{\alpha_1, \beta_1\} \to \{\alpha_1, \beta_1\} \ar[dr] && \{\alpha_2, \beta_2\} \to \{\alpha_2, \beta_2\} \ar[dl]\\
& \{\alpha_1, \beta_2\} \to \{\alpha_1, \beta_1\}
\end{tikzcd}\]
This is meant to depict an end-condition check when we have $f : \alpha_1 \to \alpha_2$
and $g : \beta_1 \to \beta_2$.
If we construct a function $\{\alpha_1, \beta_2\} \to \{\alpha_1, \beta_1\}$
by appealing to the identity $\rid_{\{\alpha_1, \beta_1\} }$, given some $h : \{\alpha_1, \beta_2\}$ we make
\[
\begin{tikzcd}
  \alpha_1 \ar[r, <->, squiggly, "h"] & \beta_2  \ar[from=r, "g"'] & \beta_1
\end{tikzcd}
\]
in order to feed it to the identity, then we do feed it, then we don't have
to adapt it any further and we're done.

But on the other side, we construct
\[
\begin{tikzcd}
\alpha_2 \ar[from=r, "f"'] &  \alpha_1 \ar[r, <->, squiggly, "h"] & \beta_2
\end{tikzcd}
\]
in order to feed it to $\rid_{\{\alpha_2, \beta_2\} }$, and then slap on
extra morphisms
\[
\begin{tikzcd}
\alpha_1 \ar[r, "f"] & \alpha_2 \ar[from=r, "f"'] &  \alpha_1 \ar[r, <->, squiggly, "h"] & \beta_2  \ar[from=r, "g"'] & \beta_1
\end{tikzcd}
\]
to adapt it to $\{\alpha_1, \beta_1\}$. Now this doesn't look like the same thing
at all, is it?


Except it depends on exactly what I mean by the type $\{\alpha, \beta\}$. If it's
really zigzags considered as lists of morphisms without any further quotienting,
then these definitely aren't equal. But if I think of it as isomorphisms in $\C$
after we localize it at every morphism --- i.e. consider $f$ composed
with its reverse to be the identity --- then maybe it is?

But given what we're using this for, it seems odd to quotient that way.
There might be more choices in the $\forall \gamma \in z . F(\gamma)$
when part of $z$ looks like
\[
\begin{tikzcd}
\alpha \ar[r, "f"] & \beta \ar[from=r, "f"'] & \alpha
\end{tikzcd}
\]
than when it's just a single $\alpha$. Because then we'd be trying to fill in

\[
\begin{tikzcd}
aa \ar[rr, "f", dotted] \ar[dr, "fa"'] & & bb \ar[dl, "bf"]\ar[dr, "bf"'] \ar[from=rr, "f"', dotted] && aa\ar[dl, "fa"]\\
& ba && ba
\end{tikzcd}
\]

I don't know, does the end-flexibility in the $\forall$ in
 $\forall \gamma \in z . F(\gamma)$ somehow smooth over this difference? It
feels unlikely at the moment.

\subsection{Feeling pretty stuck}

But here's the shape of an argument I'd like to work.

We aim to prove that if $z : \{\alpha, \beta\}$, and
 $q : \forall \gamma \in z . F(\gamma)$, then
 $\pair \alpha {q[\alpha]} \equiv \pair \beta {q[\beta]}$.
Somehow magically we hope that circumstances are appropriate
for applying $\{\}$-induction, so we get to
substitute a $\delta$ for both $\alpha$ and $\beta$ in what
follows, and $\rid_\delta$ for $z$. We now need to show
that if we have $q : \forall \gamma \in \rid_\delta . F(\gamma)$
--- i.e. $q : F(\delta)$ ---
then $\pair \delta {q[\delta]} \equiv \pair \delta {q[\delta]}$,
and we accomplish that with $\ridp$.

Note that what I'm {\em not} doing is saying that $z$ is, like, a
(relational) path $\ii\to \C$,
and that $q$ is $\forall i : \ii . F(z(i))$. I don't know if this saves
me from anything, but at least on the face of it it saves me from thinking
of data in $\C$ as something that I'm able to {\em make}.

The restriction on where $\alpha$ and $\beta$ can appear and still let me
do induction on $\{\alpha, \beta\}$ is {\em stronger} than the restriction
for $[\alpha, \beta]$. It's almost like requiring zero-ary occurrences, but I'm
not totally confident that's a good analogy. I should look at what Nuyts does.
But at least I feel good about allowing appearances as the end-existential witness
constructing things of type $\exists \alpha . F(\alpha)$, and then I suppose
analogously also the `witness' in $\forall$-elimination for either a general
$\forall$ or the specific $\forall \gamma \in \rid_\delta$ that might be funny
and not an instance of the general $\forall$ after all. Because of the
coequalizer-quotienting, that existential witness should be fairly `wiggly'
in a useful way.

Where I {\em shouldn't} expect to necessarily use a $\{\}$-inductive variable
is directly as an argument in a category-varying type. Which includes homs
$[\alpha, \beta]$, actually.

\subsection{Misc}

Why does characterizing monotonicity as things like
\[ P(\alpha) \equiv \forall \beta . \alpha \le \beta \to P(\beta) \]
feel good? It's because it feels like modalities a la HoTT or the cohesion
papers, only with a parameter. It's a modality on the kind $\C \to \rtype$.
It is idempotent, even. And surely nothing screams
 $\square$ like `for all future worlds'.

Okay, so can I characterize the zero-ary use of a variable by saying
\[ P(\alpha) \equiv \forall \beta . \{\alpha,  \beta\} \to P(\beta) \]
then? Or equivalently
\[ P(\alpha) \equiv \exists \beta . \{\alpha,  \beta\} \x P(\beta) \]
That seems plausible. And of course $\{\alpha, \beta\}$ should use
both of its arguments in this fashion, so that
\[\{\alpha, \gamma\} \equiv \exists \beta . \{\alpha, \beta\} \x \{\beta, \gamma\}\]
But what is even going on when I drop a quantified variable into $\{\alpha, \beta\}$?
Is there some more general construction than a (co)end going on?

\section{Something about $\dag$-categories}

Ok, there certainly is this  weak kind of variable I have in mind,
that can {\em only} be used in certain
kinds of occurrence-locations, including but not limited to the arguments of
$\{\alpha, \beta\}$. I think what I want
to say about it is that
 \[ \zeta \sim  \C \prov F(\zeta) : \rtype \]
corresponds to a functor out of the free $\dagger$-category on $\C$,
or something rather like it. I'm a little unsure whether the free
construction I want makes all invertible morphisms unitary (i.e. when $f$
is invertible, then $f^\dag = f^{-1}$) or whether it makes only the identity
morphisms unitary.

So then given
 \[ \zeta \sim  \C \prov F(\zeta) : \rtype \]
i.e. a functor $F : \dag(\C) \to \rtype$,
can we also regard it as a type
\[ \alpha : \C \prov F(\alpha) \]
i.e. a functor $F : \C \x \C^\op \to \rtype$?
This requires a functor $\C \x \C^\op \to \dag(\C)$. There doesn't
seem to be one canonical one, but surely there are two reasonable symmetric
and equally canonical choices. Surely we can embed $\C \to \dag(\C)$, and
also $\C^\op \to \dag(\C)$. So I guess these correspond
to substitutions $[\alpha / \zeta]$ and $[\bar \alpha / \zeta]$.
If I distinguish these classes of variables, maybe the $\{\}$ induction rule looks like

\[
\erule
{\Delta, \eta \sim \C; \Gamma \prov M : A(\eta, \eta,\rid_\eta)}
{\Delta, \zeta, \xi \sim \C; \Gamma, x : \{\zeta, \xi\} \prov \mathbf{ind}( M) : A(\zeta, \xi, x)}
\]

\subsection{Do I need to dualize again?}

Assuming  $\zeta \sim \C \prov F(\zeta) : \rtype$
and $\zeta \sim \C \prov G(\zeta) : \rtype$
I want to make sense of $\zeta \sim \C \prov F(\zeta) \to G(\zeta)$,
which I think should be a type.

For any object $C\in \C$, we get from $F(C)$ or $G(C)$ a genuine $\rtype$.
We can actually, really, transport along either forward or backward
arrows to some other $F(D)$ or $G(D)$ --- i.e.
along an arbitrary zigzag $z : C \sim D$.

We could say that $(F \to G)(C)$ is $F(C) \to G(C)$, and then we're
left with the obligation to show how we can transport $F(C) \to G(C)$
to $F(D) \to G(D)$. We could try saying that, given a zigzag $z : C \sim D$,
we take our $F(D)$, transport it along $\bar z$ to $F(C)$, plug it into the
function we were given, then transport along $z$ to $F(D)$. But I'm not sure
this is actually functorial unless we impose some equalities or something.

Let's do this carefully.

\begin{lemma}
Suppose $\C$ is a $\dagger$-category.
If $A :  \C \to \rset$ and $B : \C \to \rset$, then
there is a functor $A \to B :  \C \to \rset$ whose object
part is $(A \to B)_C = A_C \to B_C$.
\end{lemma}

\begin{proof}
We need to say (a) what the morphism part is, (b) see that it
preserves composition, and (c) see that it preserves identities. We
aren't claiming that $A \to B$ is a $\dagger$-functor, for there isn't
any $\dag$-structure on $\rset$ that would make that claim meaningful.

The morphism part is defined by, given an $z : C \to D \in \C$,
saying
\[(A \to B)_z(f : A_C \to B_C) = \lambda x : A_D . B_z(f(A_{z^\dag}(x)))\]

Suppose we have $z : C \to D$ and $w : D \to E$. Then we find
\[(A \to B)_{w\o z}(f) = \lambda x . B_{w \o z}(f(A_{(w \o z)^\dag}(x)))\]
\[= \lambda x . B_w (B_z (f(A_{z^\dag}(A_{w^\dag}(x)))))\]
\[= \lambda x . (A \to B)_w ( (A \to B)_z (x))\]
\[=  (A \to B)_w  \o  (A \to B)_z \]

And it preserves identities because
\[(A \to B)_{\rid_C}(f) = \lambda x . B_{\rid_C}(f(A_{\rid_C^\dag}(x)))\]
\[= f\]
What we're relying on is that $(w \o z)^\dag = z^\dag \o w^\dag$
and $\rid_C^\dag = \rid_C$, and that $A$ and $B$ separately are functors.
\cqed
\end{proof}

\subsection{Ok, but is {\em this} `identity' type inhabited?}

Can we make a term

\[\zeta, \xi \sim \C \prov M : \{\zeta, \xi\} \to \{ \zeta, \xi\}\]
with the above definition of $\to$? And what I mean by
term I guess is `global section'?

The object part of this has obviously
got to be the identity function $M_{CD} : \{ C , D \} \to \{ C, D\}$.
I want to see that identity-function-ness is preserved by transport.
If I pick a morphism $q : C \to C' \in \C$, I get a function
$ \{ C' , D \} \to \{ C', D\}$. What it does is, takes your $C' \to D$ zigzag,
plops on $q$ on the front, pushes it through the identity, and plops
on $q^\dag$ on the front. Ooops, that's bad. No longer the identity.

How does the oriented hom work? Maybe that'll help me get my head straight.
Syntactically we write
\[\alpha, \beta : \C \prov M : [\alpha, \bar\beta] \to [ \bar\alpha, \beta]\]

This type is a functor on four arguments
$(\alpha\bar\alpha\beta\bar\beta) : \C \x \C^\op \x \C \x \C^\op$. It
gives the set of ordinary, set-theortic functions from
the homset $[\alpha, \bar\beta]$ to the homset $[\bar \alpha, \beta]$.
The term that is the identity function takes only the two arguments $a$ and
$b$ and yileds the identity function $[a, b] \to [a, b]$. It has the end property
that given functions $f : a_1 \to a_2$ and $g : b_1 \to b_2$,
I get commutativity out of
\[\begin{tikzcd}
{[a_1, b_1] \to [a_1, b_1]} \ar[dr] && {[a_2, b_2] \to [a_2, b_2]} \ar[dl]\\
& {[a_2, b_1] \to [a_1, b_2]}
\end{tikzcd}\]
Which is to say, given an $h : a_2 \to b_1$ I can either compose to
$h f : a_1 \to b_1$, apply identity, then compose to $g h f : a_1 \to b_2$,
or else compose $gh : a_2 \to b_2$, apply identity, compose to $ghf : a_1\to b_2$,
and associativity says they're equal.

\subsection{What Happens if I Double-Dual?}

Let's imagine that in the majority of situations that I want to think
about a $\dagger$ed variable, I actually use $\zeta : \dag\C$ to represent
$\zeta \sim \C$. Which is to say, something with semantics $\dag \C \x \dag \C^\op$.
The meaning of $\{\dash\}$ is now perfectly clear; it's just a special case of $[\dash]$
with the category set to $\dag \C$.

The real thing to assess is whether I can do a $\{\dash\}$-induction rule
\[
\erule
{\Delta, \eta : \dag \C; \Gamma \prov M : A(\eta, \eta,\rid_\eta)}
{\Delta, \zeta, \xi : \dag \C; \Gamma, x : \{\zeta, \xi\} \prov \mathbf{ind}( M) : A(\zeta, \xi, x)}
\]
regardless of the arity with which $\zeta, \xi$ appear in $A$!

\subsection{Internalizing $\dagger$-swap?}

Can I make a term
\[\zeta, \xi : \dag \C \prov [\zeta, \bar \xi] \to [\bar \xi, \zeta]\]
?
The object part is, for every $a, b\in \dag\C$, just actually take the morphism
$f \in [a,b]$ to $f^\dag \in [b,a]$. The end condition is,
given $f : a_1 \to a_2$ and $g : b_1 \to b_2$, stare at
\[\begin{tikzcd}
{[a_1, b_1] \to [b_1, a_1]} \ar[dr] && {[a_2, b_2] \to [b_2, a_2]} \ar[dl]\\
& {[a_2, b_1] \to [b_1, a_2]}
\end{tikzcd}\]
And start with a $h : a_2 \to b_1$, and on the left we make $hf : a_1 \to b_1$
and swap to $f^\dag h^\dag : b_1 \to a_1$ and get to $f f^\dag h^\dag$,
but on the right we make $h^\dag g^\dag g$. So that's no good.

Maybe I do want to think about the free groupoid on a category rather
than the free $\dag$-category?

\section{Doubling Term Variables}

This idea popped into my head in the shower: what if
we need to `double up' term variables in the same way that
category variables are really $\C \x \C^\op$? On the face of
it, this might mean that it would be possible to even {\em express}
an identity type for functions that depend on a term variable,
like
if
\[ \Delta; \Gamma, x + A \prov  B : \rtype \]
then we might be able to say
\[ \Delta; \Gamma, x + A, x^* - A \prov  B(x^*) \to B(x)  : \rtype\]
I'm extremely unsure how likely or unlikely this is to run into
same the problem I was having previously with $x^*$-like variables
leading me into all types' transport needing to be invertible.
It does seem slightly promising in providing a possible way to decouple
term from category variance.

It's {\em extremely} attractive for the possibility that it would
allow me, in the syntax, to eliminate annotations in $\Gamma$, since
every variable would occur with both variances. I wonder if there
might be some restrictions in $\Pi$ and $\Sigma$ formation, however,
saying that I can only use some term variables negatively or positively,
respectively, in type formation.

What is the structure of the semantics, now? I think what-a-context-is
stays pretty much the same, just the clauses might be different?
Recall the old definitions were
\begin{declbox}
  $\Gamma_\phi : \rtype$.\\
  $\Gamma_\tau : \Gamma_{\dd \tau} \to \Gamma_{\cc \tau} $\\
  $A_\delta : \Gamma_\delta \to \rtype$\\
  $A_\phi : (g : \Gamma_\phi) \to A_{\dd \phi}(\Gamma_{\ltri\phi} g) \to A_{\cc \phi}(\Gamma_{\rtri\phi} g)$
\end{declbox}
\begin{defnbox}
 $(\cdot)_\phi = \bone$\\
 $(\Gamma^\op)_\phi = \Gamma_{\bar\phi}$\\
 $(\Gamma, x + A)_\phi = (g : \Gamma_\phi) \x A_{\dd \phi}( \Gamma_{\ltri\phi} g )$\\
  \\
 $(\cdot)_\tau = {!}$\\
 $(\Gamma^\op)_\tau = \Gamma_{\bar\tau}$\\
 $(\Gamma, x + A)_\tau (g, a) = (\Gamma_\tau g, A_{\ll \tau}(\Gamma_{\ltri \tau}g , a) ) $
\end{defnbox}

So I'd expect at least something like
\begin{defnbox}
\(
(\Gamma, x : A)_\phi = (g : \Gamma_\phi) \x A_{\dd \phi}( \Gamma_{\ltri\phi} g )
\x A_{?}( \Gamma_{?} g )
\)
\end{defnbox}
\noindent with two copies of $A$ to show up, but I'm not sure what goes in the `$?$'.

How about a small example. Suppose $\Delta; \cdot \prov A : \rtype$
and $\Delta; x : A \prov B : \rtype$. So this is something like
$\Delta; x + A, x^* - A^* \prov B : \rtype$. In this particular case,
I actually know $A \equiv A^*$ since $A$ has no $\Gamma$-dependencies,
but I'm going to keep writing $A^*$ intensionally where I think it
belongs.

The object part of $A$ is just $A_\delta : \rtype$.
The morphism part of $A$ is, given $\phi : \delta \to \epsilon$,
\[ A_\phi : A_\delta \to A_\epsilon \]
The morphism part of $A^*$ is
\[ A_{\bar\phi} : A_{\bar\epsilon} \to A_{\bar\delta} \]
In the current case, this is not any new data; $A^*_{\bar\phi}$ is just $A_{\bar\phi}$.

The object part of $B$ is
\[ B_\delta : A_\delta \to A^*_{\bar\delta} \to \rtype \]
The morphism part of $B$ is
\[ B_\phi : (a : A_\delta)(a^* : A^*_{\bar\epsilon}) \to
B_\delta(a, A^*_{\bar\phi}(a^*)) \to B_\epsilon(A_\phi(a), a^*)
\]

Ok, good so far. What if we have a further $C$ with the intent of
saying
$x : A, y : B \prov C : \rtype$? I'm going to give up writing $A^*$ now I think
because it's confusing more than it's helping. The object part of $C$ is
\[ C_\delta : (a : A_\delta)(a^* : A_{\bar\delta}) (b : B_\delta(a, a^*))
(b^* : B_{\bar \delta}(a^*, a)) \to \rtype\]
and the morphism part is
\[ C_\phi : (a : A_\delta)(a^* : A_{\bar\epsilon}) (b : B_\delta(a, A_{\bar\phi}(a^*)))
(b^* : B_{\bar \epsilon}(a^*, A_\phi(a))) \to\]
\[ C_\delta(a, A_{\bar \phi}(a), b, B_{\bar\phi}(\cdots ?)) \]
Time to switch to agda.

\subsection{After Agda Excursion}
Now I'm staring at \texttt{2018-06-07.agda}.
It still seems appropriate to say something like,
 when $\Gamma \prov A : \rtype$,
\begin{declbox}
  $\Gamma_\delta : \rtype$\\
  $\Gamma_\phi : \rtype$\\
  $\Gamma^!_\delta : \Gamma_\delta \to \Gamma_{\bar \delta}$\\
  $\Gamma^\ltri_\phi : \Gamma_\phi \to \Gamma_\delta$\\
  $\Gamma^\rtri_\phi : \Gamma_\phi \to \Gamma_\epsilon$\\
\(
A_\delta : (g : \Gamma_\delta) \to A_\delta
\)\\
\(
A_\phi : (g : \Gamma_\phi) \to A_\delta(\Gamma^{\ltri}_{\phi} g)
\to A_\epsilon(\Gamma^{\rtri}_{\phi} g)
\)
\end{declbox}
and I try to extract some definitions like
\begin{defnbox}
  $(\Gamma, x : A)_\delta = (g : \Gamma_\delta) \x A_\delta(g) \x A_{\bar \delta}(\Gamma^!_\delta g)$\\
  \(
  (\Gamma, x : A)_\phi = (g : \Gamma_\phi) \x A_\delta(\Gamma^{\ltri}_\phi g)
  \x A_{\bar\epsilon}(\Gamma^!_\epsilon \Gamma^\rtri_{\phi} g  )
  \)
  \\
  $(\Gamma, x : A)^!_\delta(g, a, a') = (\Gamma^!_\delta g, a', a)$\\
  $(\Gamma, x : A)^\ltri_\phi(g, a, a') = (\Gamma^\ltri_\phi g, a, \textcolor{red}{?_1})$\\
  $(\Gamma, x : A)^\rtri_\phi(g, a, a') = (\Gamma^\rtri_{\phi} g, \textcolor{red}{?_2}, a')$
\end{defnbox}
I leave two holes. They are typed
\[a' : A_{\bar\epsilon}(\Gamma^!_\epsilon \Gamma^\rtri_\phi g) \prov
\textcolor{red}{?_1} : A_{\bar\delta}(\Gamma^!_\delta \Gamma_\phi^\ltri g)\]
\[a: A_{\delta}( \Gamma^\ltri_\phi g) \prov
\textcolor{red}{?_2} : A_{\epsilon}( \Gamma_\phi^\rtri g)\]
Ok, great, we can set
\[\textcolor{red}{?_1} = A_{\bar\phi}(\Gamma_{\phi}^! g, a') \qquad \textcolor{red}{?_2} = A_\phi(g, a)\]
as long as there is such thing as $\Gamma_\phi^!$ with
\begin{thmbox}
  $ \Gamma^!_\epsilon \Gamma^\rtri_\phi g = \Gamma^\ltri_{\bar\phi} \Gamma^!_\phi g $\\
  $ \Gamma^!_\delta \Gamma^\ltri_\phi g = \Gamma^\rtri_{\bar\phi} \Gamma^!_\phi g $
\end{thmbox}
So let's try

\begin{declbox}
  $\Gamma_\delta : \rtype$\\
  $\Gamma_\phi : \rtype$\\
  $\Gamma^!_\delta : \Gamma_\delta \to \Gamma_{\bar \delta}$\\
  $\Gamma^!_\phi : \Gamma_\phi \to \Gamma_{\bar \phi}$\\
  $\Gamma^\ltri_\phi : \Gamma_\phi \to \Gamma_\delta$\\
  $\Gamma^\rtri_\phi : \Gamma_\phi \to \Gamma_\epsilon$\\
\(
A_\delta : (g : \Gamma_\delta) \to A_\delta
\)\\
\(
A_\phi : (g : \Gamma_\phi) \to A_\delta(\Gamma^{\ltri}_{\phi} g)
\to A_\epsilon(\Gamma^{\rtri}_{\phi} g)
\)
\end{declbox}
\begin{defnbox}
  $(\Gamma, x : A)_\delta = (g : \Gamma_\delta) \x A_\delta(g) \x A_{\bar \delta}(\Gamma^!_\delta g)$\\
  \(
  (\Gamma, x : A)_\phi = (g : \Gamma_\phi) \x A_\delta(\Gamma^{\ltri}_\phi g)
  \x A_{\bar\epsilon}(\Gamma^!_\epsilon \Gamma^\rtri_{\phi} g  )
  \)
  \\
  $(\Gamma, x : A)^!_\delta(g, a, a') = (\Gamma^!_\delta g, a', a)$\\
  $(\Gamma, x : A)^!_\phi(g, a, a') = (\Gamma^!_\phi g, a, a')$\\
  $(\Gamma, x : A)^\ltri_\phi(g, a, a') = (\Gamma^\ltri_\phi g, a, A_{\bar\phi}(\Gamma_{\phi}^! g, a'))$\\
  $(\Gamma, x : A)^\rtri_\phi(g, a, a') = (\Gamma^\rtri_{\phi} g, A_\phi(g, a), a')$
\end{defnbox}
Checking that the definition of $(\Gamma, x : A)^!_\phi(g, a, a')$ is well-typed,
we check that
\[A_\delta(\Gamma^{\ltri}_\phi g) =
A_{\delta}(\Gamma^!_{\bar\delta} \Gamma^\rtri_{\bar\phi} \Gamma_\phi^! g  )\]
and
\[A_{\bar\epsilon}(\Gamma^!_\epsilon \Gamma^\rtri_{\phi} g  ) =
A_{\bar\epsilon}(\Gamma^{\ltri}_{\bar \phi} \Gamma^!_\phi g)
\]
which needs merely the easy-to-see idempotence
\begin{thmbox}
  $\Gamma^!_{\bar\delta} \Gamma^!_\delta g = g$
\end{thmbox}

Once again I see the object-interpretation of contexts is just a special case of
the static-morphism-relationy part, and $\ltri$ is definable as $\Gamma^\ltri_\phi = \Gamma^!_{\bar\epsilon} \Gamma^\ltri_{\bar\phi} \Gamma^!_\phi$, so the essential definitions
that determine the rest are

\begin{declbox}
  $\Gamma_\phi : \rtype$\\
  $\Gamma^!_\phi : \Gamma_\phi \to \Gamma_{\bar \phi}$\\
  $\Gamma^\rtri_\phi : \Gamma_\phi \to \Gamma_\epsilon$\\
\(
A_\delta : (g : \Gamma_\delta) \to A_\delta
\)\\
\(
A_\phi : (g : \Gamma_\phi) \to A_\delta(\Gamma^{\ltri}_{\phi} g)
\to A_\epsilon(\Gamma^{\rtri}_{\phi} g)
\)
\end{declbox}
\begin{defnbox}
  \(
  (\Gamma, x : A)_\phi = (g : \Gamma_\phi) \x A_\delta(\Gamma^{\ltri}_\phi g)
  \x A_{\bar\epsilon}(\Gamma^!_\epsilon \Gamma^\rtri_{\phi} g  )
  \)
  \\
  $(\Gamma, x : A)^!_\phi(g, a, a') = (\Gamma^!_\phi g, a, a')$\\
  $(\Gamma, x : A)^\rtri_\phi(g, a, a') = (\Gamma^\rtri_{\phi} g, A_\phi(g, a), a')$
\end{defnbox}

\vfil\eject
\subsection{Twisted Arrow Category}

Recall that we needed to generalize to the twisted arrow category to handle
defining terms. Let's try to do that again.
In a situation like
\(\tau = \begin{tikzcd}
  \delta' \ar[d, "\iota"'] \ar[r, "\psi"] & \epsilon'\ar[from=d, "\omega"']\\
\delta \ar[r,"\phi"'] & \epsilon
\end{tikzcd}\)
we say
\begin{declbox}
  $\Gamma_\phi : \rtype$\\
  $\Gamma^!_\phi : \Gamma_\phi \to \Gamma_{\bar \phi}$\\
  $\Gamma_\tau : \Gamma_\psi \to \Gamma_\phi$\\
  $A_\delta : \Gamma_\delta \to \rtype$\\
\(
A_\phi : (g : \Gamma_\phi) \to A_\delta(\Gamma_{\ltri\phi} g)
\to A_\epsilon(\Gamma_{\rtri\phi} g)
\)
\end{declbox}
\begin{defnbox}
  \(
  (\Gamma, x : A)_\phi = (g : \Gamma_\phi) \x A_\delta(\Gamma_{\ltri\phi} g)
  \x A_{\bar\epsilon}(\Gamma^!_\epsilon \Gamma_{\rtri\phi} g  )
  \)
  \\
  $(\Gamma, x : A)^!_\phi(g, a, a') = (\Gamma^!_\phi g, a, a')$\\
  \((\Gamma, x : A)_{\tau}(g, a, a') = (\Gamma_{\tau} g, A_\iota(\Gamma_{\ltri\tau}g, a),
A_{\bar\omega} (\Gamma_{\omega}^! \Gamma_{\rtri \tau} g, a'))\)
\end{defnbox}
Check that this last line is well-typed.
We have from the context
\[g' : \Gamma_\psi, a : A_{\delta'}(\Gamma_{\ltri\psi} g'),
a' : A_{\bar\epsilon'}(\Gamma^!_{\epsilon'} \Gamma_{\rtri\psi} g')  \]
We need the second and third elements of the output tuple to be
\[G_1 = A_\delta(\Gamma_{\ltri\phi} \Gamma_\tau g')\]
\[G_2 = A_{\bar\epsilon}(\Gamma^!_\epsilon\Gamma_{\rtri\phi} \Gamma_\tau g')\]
respectively.

The transport $A_\iota(\Gamma_{\ltri \tau} g')$ requires
$A_{\delta'}(\Gamma_{\ltri \iota} \Gamma_{\ltri\tau} g')$ and emits
$A_\delta(\Gamma_{\rtri \iota} \Gamma_{\ltri\tau} g')$.

The transport $A_{\bar\omega}(\Gamma^!_\omega \Gamma_{\rtri \tau} g')$ requires
$A_{\bar\epsilon'}(\Gamma_{\ltri \bar\omega} \Gamma^!_\omega \Gamma_{\rtri \tau} g')$ and emits
$A_{\bar\epsilon}(\Gamma_{\rtri \bar\omega} \Gamma^!_\omega \Gamma_{\rtri \tau} g')$.

Let's first posit how $\Gamma^!$ interchanges with things. We conjecture

So the four conditions we need to satisfy come from
matching up the inputs $a, a'$
at $A_{\delta'}$ and $A_{\bar\epsilon'}$, and the outputs at $A_\delta$ and $A_{\bar\epsilon}$.
They are:
\[ \Gamma_{\ltri \iota} \Gamma_{\ltri\tau} g' = \Gamma_{\ltri\psi} g'
\eqno(\delta')
\]
\[ \Gamma_{\ltri \bar\omega} \Gamma^!_\omega \Gamma_{\rtri \tau} g' = \Gamma^!_{\epsilon'} \Gamma_{\rtri\psi} g'
\eqno(\bar\epsilon')
\]
\[\Gamma_{\ltri\phi} \Gamma_\tau g' = \Gamma_{\rtri \iota} \Gamma_{\ltri\tau} g'
\eqno(\delta)\]
\[\Gamma^!_\epsilon\Gamma_{\rtri\phi} \Gamma_\tau g'
= \Gamma_{\rtri \bar\omega} \Gamma^!_\omega \Gamma_{\rtri \tau} g'
\eqno(\bar\epsilon)\]

Then, conjecturing that
\begin{thmbox}
$  \Gamma^!_\phi \Gamma_\tau = \Gamma_{\bar \tau} \Gamma^!_{\psi} : \Gamma_\psi \to \Gamma_{\bar\phi}$\\
$\Gamma_{\sigma \o \tau} = \Gamma_\sigma \Gamma_\tau$
\end{thmbox}
it suffices to check

\[ {\ltri \iota}  \o {\ltri\tau}  = {\ltri\psi} \eqno(\delta') \]
\[ {\rtri \omega}  \o {\rtri \tau}  =  {\rtri\psi} \eqno(\epsilon') \]
\[{\ltri\phi} \o \tau  = {\rtri \iota} \o {\ltri\tau} \eqno(\delta)\]
\[{\rtri\phi} \o \tau = {\ltri \omega} \o {\rtri \tau} \eqno(\epsilon)\]

And, very tidily, every one of these is giving two names for the
canonical map in the twisted arrow category from $\psi$ to some
identity map at some object among $\delta', \epsilon', \delta, \epsilon$.

\subsection{Towards Function Types}
Ok, let's confirm that I can write function types with a suitable variable
restriction. The formation rule would be
\[
\erule
{\Delta;\Gamma\prov A : \rtype\qquad \Delta;\Gamma, x : A \prov B : \rtype \qquad x \not\in_+ B}
{\Delta;\Gamma \prov (x : A) \to B : \rtype}
\]
For some variable occurrence relation $x \not\in_+ B$ that I'd need to define,
which comes with the following sort of guarantee.

Nomrally the semantics of $B$ would be
\[ B_\delta : (\Gamma, x : A)_\delta \to \rtype \]
\[ B_\phi : (g : (\Gamma, x : A)_\phi) \to B_\delta((\Gamma, x : A)_{\ltri \phi} g)
\to B_\epsilon((\Gamma, x : A)_{\rtri \phi} g) \]
which expand to
\[ B_\delta :  (g : \Gamma_\delta) \to  A_\delta( g) \to A_{\bar \delta}(\bar g) \to \rtype \]
\[ B_\phi : (g : \Gamma_\phi) (a : A_\delta(\Gamma_{\ltri\phi} g))
  (a' : A_{\bar\epsilon}( \Gamma_{\ltri\bar\phi} \bar g  ))
\]
\[ \to B_\delta(\Gamma_{\ltri \phi} g,  a, A_{\bar\phi} (\bar g, a')) \]
\[ \to B_\epsilon(\Gamma_{\rtri\phi} g, A_\phi(g, a),  a') \]
(abbreviating $\Gamma^!$ as overline)
The thing we want $x \not\in_+ B$ to guarantee is that these actually factor through
a semantics with fewer arguments, i.e.
\[ B_\delta :  (g : \Gamma_\delta) \to A_{\bar \delta}(\bar g) \to \rtype \]
\[ B_\phi : (g : \Gamma_\phi)
  (a' : A_{\bar\epsilon}( \Gamma_{\ltri\bar\phi} \bar g  ))
 \to B_\delta(\Gamma_{\ltri \phi} g,  A_{\bar\phi} (\bar g, a'))
 \to B_\epsilon(\Gamma_{\rtri\phi} g,  a') \]
And symmetrically, $x \not\in_- B$, which we'd need for $\Sigma$, I think, would guarantee
\[ B_\delta :  (g : \Gamma_\delta) \to  A_\delta( g) \to \rtype \]
\[ B_\phi : (g : \Gamma_\phi) (a : A_\delta(\Gamma_{\ltri\phi} g))
 \to B_\delta(\Gamma_{\ltri \phi} g,  a)
 \to B_\epsilon(\Gamma_{\rtri\phi} g, A_\phi(g, a)) \]

Now I think this is pretty close to the $x - A$ and $x + A$
assumptions that I had before, but the difference is that all of $g :
\Gamma_\phi$ is still around, and I think that'll save me when it
comes to identity types and such. Or maybe the right thing to say,
foreshadowingly, is that the lambda rule {\em won't} have a variable
restriction on the term side, and we'll just say
\[
\erule
{\Delta; \Gamma, x : A \prov M : B}
{\Delta; \Gamma \prov \lambda x . M : (x : A) \to B}
\]
\subsection{Function Types, Actually}
But I'm getting ahead of myself.

The tools I have to construct the $\Pi$ type are
\[A_\delta :  \Gamma_\delta \to \rtype\]
\[A_\phi : (g : \Gamma_\phi) \to A_\delta(\Gamma_{\ltri\phi} g)
\to A_\epsilon(\Gamma_{\rtri\phi} g)\]
\[ B_\delta :  (g : \Gamma_\delta) \to A_{\bar \delta}(\bar g) \to \rtype \]
\[ B_\phi : (g : \Gamma_\phi)
  (a' : A_{\bar\epsilon}( \Gamma_{\ltri\bar\phi} \bar g  ))
 \to B_\delta(\Gamma_{\ltri \phi} g,  A_{\bar\phi} (\bar g, a'))
 \to B_\epsilon(\Gamma_{\rtri\phi} g,  a') \]
and I need to make
\[((x : A) \to B)_\delta :  \Gamma_\delta \to \rtype\]
So I set
\begin{defnbox}
  $ ((x : A) \to B)_\delta(g) = (x : A_{\bar\delta}(\bar g)) \to B_\delta(g, x) $
\end{defnbox}
Then I need to make
\[((x : A) \to B)_\phi : (g : \Gamma_\phi) \]
\[ \to ((x : A_{\bar\delta}(\Gamma_{\rtri\bar\phi} \bar g)) \to B_\delta(\Gamma_{\ltri\phi} g, x))  \]
\[ \to ((x : A_{\bar\epsilon}(\Gamma_{\ltri\bar\phi} \bar g)) \to B_\epsilon(\Gamma_{\rtri\phi} g, x))\]
So I set
\begin{defnbox}
  $ ((x : A) \to B)_\phi(g, h) = \lambda a' . B_{\phi}((g, a'), h(A_{\bar\phi}(\bar g, a'))) $
\end{defnbox}
And proceed to try to typecheck this.
\[ A_{\bar\phi}(\bar g, a') : A_{\bar \delta}(\Gamma_{\rtri \bar\phi}\bar g) \]
\[ h(A_{\bar\phi}(\bar g, a')) : B_\delta(\Gamma_{\ltri \phi} g, A_{\bar\phi}(\bar g, a')) \]
\[B_{\phi}((g, a'), h(A_{\bar\phi}(\bar g, a'))) : B_{\epsilon}(\Gamma_{\rtri \phi} g, a') \]
Easy as pie, no equation-checking in twisted arrows needed, even.
\subsection{Nondependent Functions}
Ok, so now can I convince myself that
\[
\erule
{\Gamma \prov A : \rtype\qquad \Gamma \prov B : \rtype}
{\Gamma \prov A\to B : \rtype}
\]
? I think so; because the variable of type $A$ doesn't appear in $B$ at all.
Nondependent types are recovered with no variable restriction, hooray.
In particular, $B \to B$ is a type whereever $B$ is.
\subsection{Variable Rule}
To make a term in general, for $\Delta ; \Gamma \prov M : A$
I need for every object $d \in \ssem \Delta$ to make
\[ M_d : (g : \Gamma_{dd}) \to A_{dd} \]
such that
\[ (g : \Gamma_{ff}) \to A_{fd}(\Gamma_{\rtri \fdom} g, M_d(\Gamma_{\fdom} g))
 \equiv A_{ef}(\Gamma_{\rtri\fcod} g,M_e(\Gamma_{\fcod} g))\]
So to make
\[
\erule
{}
{\Gamma, x : A \prov x : A}
\]
We need
\[ x_d : (g : \Gamma_{dd}) (a : A_{dd}( g)) (a' : A_{dd}(\bar g)) \to A_{dd}(g) \]
So of course we set
\[ x_d(g, a, a') = a \]
And observe that $x \not\in_- x$. We can check
\[
   (g : \Gamma_{ff}) (a : A_{de}(\Gamma_{\ltri ff} g))
  (a' : A_{de}(\ \Gamma_{\ltri ff} \bar g  )) \]
\[
 \to A_{fd}((\Gamma, x : A)_{\rtri \fdom} (g, a, a'), M_d((\Gamma, x : A)_{\fdom} (g, a, a')))
\]
\[ \equiv A_{ef}((\Gamma, x : A)_{\rtri\fcod} (g, a, a'),M_e((\Gamma, x : A)_{\fcod} (g, a, a')))\]
i.e.
\[
   (g : \Gamma_{ff}) (a : A_{de}(\Gamma_{\ltri ff} g))
  (a' : A_{de}(\ \Gamma_{\ltri ff} \bar g  )) \]
\[
 \to A_{fd}(\Gamma_{\rtri \fdom} g, M_d((\Gamma, x : A)_{\fdom} (g, a, a')))
\]
\[ \equiv A_{ef}(\Gamma_{\rtri\fcod} g,M_e((\Gamma, x : A)_{\fcod} (g, a, a')))\]
because the $A$ on the right doesn't depend on $x$, then using the definition
\begin{defnbox}
  \((\Gamma, x : A)_{\tau}(g, a, a') = (\Gamma_{\tau} g, A_\iota(\Gamma_{\ltri\tau}g, a),
A_{\bar\omega} (\Gamma_{\omega}^! \Gamma_{\rtri \tau} g, a'))\)
\end{defnbox}
this is
\[
   (g : \Gamma_{ff}) (a : A_{de}(\Gamma_{\ltri ff} g))
  (a' : A_{de}(\ \Gamma_{\ltri ff} \bar g  )) \]
\[
 \to A_{fd}(\Gamma_{\rtri \fdom} g, M_d(\Gamma_{\tau} g, A_{df}(\Gamma_{\ltri\fdom }g, a),
A_{df} ( \Gamma_{\ltri \fdom} \bar g, a')))
\]
\[ \equiv A_{ef}(\Gamma_{\rtri\fcod} g,M_e(\Gamma_{\tau} g, A_{fe}(\Gamma_{\ltri \fcod}g, a),
A_{fe} ( \Gamma_{\ltri \fcod} \bar g, a')))\]
and plugging in the definition of $M = x$ we get
\[
   (g : \Gamma_{ff}) (a : A_{de}(\Gamma_{\ltri ff} g))
  (a' : A_{de}(\ \Gamma_{\ltri ff} \bar g  )) \]
\[
 \to A_{fd}(\Gamma_{\rtri \fdom} g,  A_{df}(\Gamma_{\ltri\fdom }g, a))\]
\[ \equiv A_{ef}(\Gamma_{\rtri\fcod} g, A_{fe}(\Gamma_{\ltri \fcod}g, a)) \]
and by functoriality, which should look like before,
\begin{thmbox}
 $\Gamma_\rid g = g$\\
 $\Gamma_{\tau \o \sigma}g = \Gamma_\tau\Gamma_\sigma g$\\
  $A_{\rid_\delta}(g, a) = a$\\
  $A_{\phi\eta}(g, a) = A_\phi(\Gamma_{\phi \gol \eta}g, A_\eta(\Gamma_{\phi \sqsupset \eta}g, a))$
\end{thmbox}
this is established, because by reflexivity
\[
   (g : \Gamma_{ff}) (a : A_{de}(\Gamma_{\ltri ff} g))
 \to A_{ff}( g,  a) \equiv A_{ff}( g,  a) \]


(Remember that these look like so:

\(\fdom = \begin{tikzcd}
  de \ar[d, "df"'] \ar[r, "ff"] & ed\ar[from=d, "fd"']\\
dd \ar[r,equal] & dd
\end{tikzcd}\)
\(\fcod = \begin{tikzcd}
  de \ar[d, "fe"'] \ar[r, "ff"] & ed\ar[from=d, "ef"']\\
ee \ar[r,equal] & ee
\end{tikzcd}\)
\(\rtri\fdom = \begin{tikzcd}
  de \ar[d, "df"'] \ar[r, "ff"] & ed\ar[from=d, equal]\\
dd \ar[r,"fd"'] & ed
\end{tikzcd}\)
\(\rtri\fcod = \begin{tikzcd}
  de \ar[d, "fe"'] \ar[r, "ff"] & ed\ar[from=d, equal]\\
ee \ar[r,"ef"'] & ed
\end{tikzcd}\)
)
\subsection{Lambda Rule}
\[
\erule
{\Delta; \Gamma, x : A \prov M : B}
{\Delta; \Gamma \prov \lambda x . M : (x : A) \to B}
\]
We have
\[(M_d : (g : \Gamma_{dd}) (a : A_{dd}(g)) (a' : A_{dd}(\bar g)) \to B_{dd}(g, a') \]
We need to make
\[(\lambda x . M)_d : (g : \Gamma_{dd}) \to ((x : A) \to B)_{dd}(g)\]
i.e.
\[(\lambda x . M)_d : (g : \Gamma_{dd})  (a' : A_{dd}(\bar g)) \to B_{dd}(g, a')\]
Huh, this doesn't quite work, yet. I cannot always prove that $A \to A$.

\subsection{Backing up}
Given that the semantics of the variable rule look like they have some
extra data that I'm not using, I definitely wonder if it's possible
to recover the sort of $\Gamma, x : A \prov x^* : A^*$ business I was
trying and failing to do before. Which would mean that my identity
theory would be more like the fact that $A$ always proves $A^*$, not $A$.

Anyway let's try to invent a new syntactic judgment, $\Delta ; \Gamma \prov M - A$,
for `anti-terms'. I require that $A$ be a valid type in $\Delta ;\Gamma$.
To be the semantics of an anti-term, you have to provide, for every object $d \in \ssem \Delta$,
\[ M_d : (g : \Gamma_{dd}) \to A_{dd}(\bar g) \]
subject to some condition I'm not sure of yet, so that the variable rule
\[\Delta; \Gamma, x : A \prov x^* - A\]
is validated by saying
\[ x_d : (g : \Gamma_{dd}) (a : A_{dd}( g)) (a' : A_{dd}(\bar g)) \to A_{dd}(\bar g) \]
\[ x_d(g, a, a') = a' \]
What's the dual end condition?
Is it perhaps just
\[
(g : \Gamma_{ff})  \to A_{fd}(\Gamma_{\rtri \fdom} \bar g, M_d(\Gamma_{\fdom} \bar g))
 \equiv A_{ef}(\Gamma_{\rtri\fcod} \bar g,M_e(\Gamma_{\fcod} \bar g))\]
? Because in this symmetric case, $g$ and $\bar g$ both have type $\Gamma_{ff}$.
Oh, but this is compatible with specifically
$ M_d : (g : \Gamma_{dd}) \to A_{dd}(\bar g) $
because we'd look at the second argument to $A_{fd}$ and check that
$M_d(\Gamma_{\fdom} \bar g) : A_{dd}(\Gamma_{\ltri fd} \Gamma_{\ltri \fdom} \bar g)$.
Oh, but wait, this is wrong: Actually

\[ M_d(\Gamma_{\fdom} \bar g) : A_{dd}(\overline {\Gamma_{\fdom} \bar g}) =
A_{dd}( {\Gamma_{\fdom}  g})\]
So maybe what I want is
\begin{thmbox}
\(
  (g : \Gamma_{ff})  \to A_{fd}(\Gamma_{\rtri \fdom}  g, M_d(\Gamma_{\fdom} \bar g))
  \equiv A_{ef}(\Gamma_{\rtri\fcod}  g,M_e(\Gamma_{\fcod}  \bar g))
\)
\end{thmbox}
For then the condition is that
\[ M_d(\Gamma_{\fdom} \bar g) : A_{dd}(\Gamma_{\ltri fd}\Gamma_{\rtri \fdom} \bar g) \]
and indeed $\fdom = \ltri fd \o \rtri \fdom$.

So, ok, that's a definition of an anti-term. Two questions:
\begin{itemize}
\item Is $x^*$ as described above
  actually such a thing?
\item Is there an alternative to the lambda rule that looks something like
\[
\erule
{\Delta; \Gamma, x : A \prov M - B\qquad x \not\in_+ M}
{\Delta; \Gamma \prov \lambda x . M : (x : A) \to B}
\]
?
\end{itemize}
\subsection{Tangent Reorganization}


\begin{declbox}
  $\Gamma_\phi : \rtype$\\
  $\Gamma_\tau : \Gamma_\psi \to \Gamma_\phi$\\
  $\Gamma^!_\phi : \Gamma_\phi \to \Gamma_{\bar \phi}$\\
\\
  $A_\delta : \Gamma_\delta \to \rtype$\\
\(
A_\phi : (g : \Gamma_\phi) \to A_\delta(\Gamma_{\ltri\phi} g)
\to A_\epsilon(\Gamma_{\rtri\phi} g)
\)\\
\\
  $A^2_\phi : \Gamma_\phi \to \rtype$\\
\(
A^2_\tau : (g : \Gamma_\psi) \to A^2_{\psi}(g)
\to A^2_{\phi} (\Gamma_{\tau} g)
\)\\
  $A^!_\phi : (g : \Gamma_\phi) \to A^2_\phi(g) \to A^2_{\bar\phi}(\bar g)$
\end{declbox}
\begin{defnbox}
  $(\Gamma, x : A)_\phi = (g : \Gamma_\phi) \x A^2_\phi( g)$\\
  $(\Gamma, x : A)_{\tau}(g, a) = (\Gamma_{\tau} g, A^2_\tau(g, a))$\\
  $(\Gamma, x : A)^!_\phi(g, a) = (\bar g, \bar a)$\\
  \\
  $A^2_\phi(g) = A_\delta(\Gamma_{\ltri\phi} g) \x A_{\bar\epsilon}(\Gamma_{\ltri\bar\phi}\bar g)$\\
  $A^2_\tau(g, a) =  (A_\iota(\Gamma_{\ltri\tau}g, a), $
  $A_{\bar\omega} (\Gamma_{\omega}^! \Gamma_{\rtri \tau} g, a'))$\\
  $A^!_\phi(g, (a, a')) = (a', a)$
\end{defnbox}
Eh, bah, this is not really simpler.


What I really wanted to say was something more like
\begin{declbox}
  $A^1_\phi :\Gamma_\phi \to \rtype$\\
  $A^1_\tau : (g : \Gamma_\psi) \to A^1_\psi(g) \to A^1_\phi(\Gamma_\tau g)$
\end{declbox}
\begin{defnbox}
  $A^1_\phi(g) = A_\delta(\Gamma_{\ltri \phi} g)$\\
  $A^1_\tau(g, a) = A_{\iota}(\Gamma_{\ltri \tau} g, a)$\\
  $A^2_\phi(g) = A^1_\phi(g) \x A^1_{\bar\phi}(\bar g)$\\
  $A^2_\tau(g, a) = (A^1_\tau(g, a), A^1_{\bar\tau}(\bar g, \bar a))$
\end{defnbox}

So maybe I can package this all up as
\begin{declbox}
  $\Gamma_\phi : \rtype$\\
  $\Gamma_\tau : \Gamma_\psi \to \Gamma_\phi$\\
  $\Gamma^!_\phi : \Gamma_\phi \to \Gamma_{\bar \phi}$\\
\\
  $A_\delta : \Gamma_\delta \to \rtype$\\
\(
A_\phi : (g : \Gamma_\phi) \to A_\delta(\Gamma_{\ltri\phi} g)
\to A_\epsilon(\Gamma_{\rtri\phi} g)
\)\\
\\
  $A^1_\phi :\Gamma_\phi \to \rtype$\\
  $A^1_\tau : (g : \Gamma_\psi) \to A^1_\psi(g) \to A^1_\phi(\Gamma_\tau g)$\\
\\
  $A^2_\phi : \Gamma_\phi \to \rtype$\\
\(
A^2_\tau : (g : \Gamma_\psi) \to A^2_{\psi}(g)
\to A^2_{\phi} (\Gamma_{\tau} g)
\)\\
  $A^!_\phi : \{g : \Gamma_\phi\} \to A^2_\phi(g) \to A^2_{\bar\phi}(\bar g)$
\end{declbox}
\begin{defnbox}
  $(\Gamma, x : A)_\phi = (g : \Gamma_\phi) \x A^2_\phi( g)$\\
  $(\Gamma, x : A)_{\tau}(g, a) = (\Gamma_{\tau} g, A^2_\tau(g, a))$\\
  $(\Gamma, x : A)^!_\phi(g, a) = (\bar g, \bar a)$\\
  \\
  $A^1_\phi(g) = A_\delta(\Gamma_{\ltri \phi} g)$\\
  $A^1_\tau(g, a) = A_{\iota}(\Gamma_{\ltri \tau} g, a)$\\
  \\
  $A^2_\phi(g) = A^1_\phi(g) \x A^1_{\bar\phi}(\bar g)$\\
  $A^2_\tau(g, a) = (A^1_\tau(g, a), A^1_{\bar\tau}(\bar g, \bar a))$
  \\
  $A^!_\phi(a, a') = (a', a)$
\end{defnbox}

Huh, actually this makes me realize that I can move the API surface
for types, and perhaps it might be advantageous to require of
all types that I implement $A^1$ semantics, or even $A^2$?

Or is this really true? Can I derive $A_\phi$ from $A^1_\tau$?
Yes, I observe
\[A_{\rtri \phi}^1(g, a) = A_\phi(\Gamma_{\rtri\ltri\phi} g, a) = A_\phi(g, a)\]
So, yeah, the `$A^1$' description of a type's semantics is equally expressive
with the `$A$' description.

So here's another attempt at making the definitions very compact, taking
$A^1$ as canonical, and inlining $A^2$:
\begin{declbox}
  $\Gamma_\phi : \rtype$\\
  $\Gamma_\tau : \Gamma_\psi \to \Gamma_\phi$\\
  $\Gamma^!_\phi : \Gamma_\phi \to \Gamma_{\bar \phi}$\\
\\
  $A_\phi :\Gamma_\phi \to \rtype$\\
  $A_\tau : (g : \Gamma_\psi) \to A_\psi(g) \to A_\phi(\Gamma_\tau g)$
\end{declbox}
\begin{defnbox}
  $(\Gamma, x : A)_\phi = (g : \Gamma_\phi) \x A_\phi(g) \x A_{\bar\phi}(\bar g)$\\
  $(\Gamma, x : A)_{\tau}(g, a, a') = (\Gamma_{\tau} g, A_\tau(g, a), A_{\bar\tau}(\bar g, a'))$\\
  $(\Gamma, x : A)^!_\phi(g, a, a') = (\bar g, a', a)$
\end{defnbox}


%% \vskip 2em \hrule\vskip 2em
%% \(\fdom = \begin{tikzcd}
%%   de \ar[d, "df"'] \ar[r, "ff"] & ed\ar[from=d, "fd"']\\
%% dd \ar[r,equal] & dd
%% \end{tikzcd}\)
%% \(\fcod = \begin{tikzcd}
%%   de \ar[d, "fe"'] \ar[r, "ff"] & ed\ar[from=d, "ef"']\\
%% ee \ar[r,equal] & ee
%% \end{tikzcd}\)
%% \(\rtri\fdom = \begin{tikzcd}
%%   de \ar[d, "df"'] \ar[r, "ff"] & ed\ar[from=d, equal]\\
%% dd \ar[r,"fd"'] & ed
%% \end{tikzcd}\)
%% \(\rtri\fcod = \begin{tikzcd}
%%   de \ar[d, "fe"'] \ar[r, "ff"] & ed\ar[from=d, equal]\\
%% ee \ar[r,"ef"'] & ed
%% \end{tikzcd}\)
%% \[A_\phi : (g : \Gamma_\phi) \to A_\delta(\Gamma_{\ltri\phi} g)
%% \to A_\epsilon(\Gamma_{\rtri\phi} g)\]

\end{document}
