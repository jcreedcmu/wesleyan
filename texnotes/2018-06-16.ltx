\documentclass{article}
\usepackage[tmargin=0.05in, bmargin=0.05in]{geometry}
\input{theorem}
\input{prooftree}
\usepackage{stmaryrd}
\usepackage{latexsym}
\usepackage{yfonts}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,cd,decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}
\usepackage{tcolorbox}
\tcbuselibrary{breakable}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}

\def\gol{\sqsubset}
\def\gor{\sqsupset}

\def\sp{\bullet}
\def\ot{\leftarrow}
\def\prequiv{\dashv\vdash}
\def\fdom{{\mathbf{d}f}}
\def\fcod{{\mathbf{e}f}}
\def\fidom{\mathbf{\bar d}f}
\def\ficod{\mathbf{\bar e}f}

\def\thn{\mathrel|}
\def\coe{\mathsf{coe}}
\def\bpush{\mathbf{push}}
\def\bpull{\mathbf{pull}}

\def\wo{\setminus}
\def\fA{\mathsf{A}}
\def\fC{\mathsf{C}}
\def\fX{\mathsf{X}}
\def\ff{\mathsf{f}}
\def\fm{\mathsf{m}}
\def\rspan{\mathsf{Span}}
% \def\El#1{\mathsf{El}({#1})}
\def\El#1{\ulcorner{#1}\urcorner}
\def\U{\mathsf{U}}
\def\uu{\mathsf{u}}
\def\uni{\U}
\def\mor#1#2{#1 \to \underline{#2}}

\def\ridp{\mathsf{idp}}
\def\ssem#1{\langle\!\langle{#1}\rangle\!\rangle}

\definecolor{lred}{rgb}{0.95,0.8,0.8}
\definecolor{cyan}{rgb}{0.80,0.95,0.95}
\definecolor{orange}{rgb}{0.95,0.90,0.80}
\definecolor{bluegray}{rgb}{0.6,0.6,0.85}
\definecolor{lgray}{gray}{0.9}
\newtcolorbox{declbox}{colframe=lred,colback=lred,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{thmbox}{colframe=cyan,colback=cyan,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{defnbox}{colframe=orange,colback=orange,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{tangentbox}{colframe=lgray,colback=lgray,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}

\input{linear}
\def\rpath#1{[#1]}
\def\rfst{\mathsf{fst}\,}
\def\rsnd{\mathsf{snd}\,}
\def\bunfold{\mathbf{unfold}}
\def\bfold{\mathbf{fold}}
\def\susp#1{\langle {#1} \rangle}
\def\ssusp#1{\langle\!\langle {#1} \rangle\!\rangle}
\def\dto{\mathrel{\dot\to}}
\def\dns{{\downarrow}}
\def\ups{{\uparrow}}
\def\sprov{\Vdash}
\def\signat{{\color{red}\Sigma}}
\def\ep#1{\underline{#1}}
\def\wat{\mathbin{@}}
\def\wwat{\mathbin{\underline\wat}}
\def\cn{{:}}
\def\dv{{\div}}
\def\ww{{\mathsf w}}
\def\base{{\textfrak b}}

\def\munit{I}
\def\tt{{\mathsf t}}
\def\ii{{\mathbb I}}
\def\T{\mathbb{T}}
\def\TP{\mathbf{TPre}}
\def\pp{\textsf{\textbf p}}
\def\nn{{\mathsf n}}
\def\PP{\textsf{\textbf P}}
\def\NN{\textsf{\textbf N}}
\def\zz{{\mathsf z}}
\def\sem#1{[\![#1]\!]}
\def\usem#1{\lceil\!\!\lceil{#1}\rceil\!\!\rceil}
\def\zem#1{\langle\!\langle#1\rangle\!\rangle}
\def\col#1{{\mathsf{C}}_{#1}}
\def\lax{\mathop\bigcirc}
\def\rjust{\mathsf{just}}
\def\rcvt{\mathsf{cvt}}
\def\rtype{\mathsf{type}}
\def\rdtype{\mathsf{disc}}
\def\rkind{\mathsf{kind}}
\def\rmode{\mathsf{mode}}
\def\rprel{\mathbf{Prel}}
\def\rrfam{\mathbf{Rfam}}
\def\rset{\mathbf{Set}}
\def\rfinset{\mathbf{FinSet}}
\def\rrel{\mathbf{Rel}}
\def\rcat{\mathbf{Cat}}
\def\rfam{\mathbf{Fam}}
\def\binj{\mathbf{inj}}
\def\rid{\mathsf{id}}
\def\rtrue{\mathrel\mathrm{true}}
\def\pbck{\ar[dr, phantom, pos=0, "\lrcorner"]}
\def\bpbck{\ar[ddrr, phantom, pos=0, "\lrcorner"]}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\btwo{\mathbf{2}}
\def\bone{\mathbf{1}}

\newarrow {Equiv} =====
\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\def\mapt{\ar[ddd,mapsto,shorten <=2em, shorten >=2em]}
\def\frommaps{\ar[from=uu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\frommapt{\ar[from=uuu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\C{\mathbf{C}}
\def\G{\mathbf{G}}
\def\D{\mathbf{D}}
\def\DD{\mathbb{D}}
\def\E{\mathbf{E}}
\def\M{\mathbf{M}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\ltri{{\lhd}}
\def\rtri{{\rhd}}
\def\tri{\rhd}
\def\ll{{<}}
\def\rr{{>}}
\def\cc{\mathsf{c}}
\def\dd{\mathsf{d}}
\def\o{\circ}
\def\rctx{\,\mathsf{ctx}}
\def\rdctx{\,\mathsf{dctx}}
\def\del{\partial}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\definecolor{fib}{HTML}{ff7f00}
\definecolor{green}{HTML}{007f00}
\definecolor{red}{HTML}{df3f3f}
\definecolor{opfib}{HTML}{007fff}

% For lightening colors I used
% http://trycolors.com/ 6 parts white to 1 part color
\definecolor{opfibl}{HTML}{DBEDFF}
\definecolor{greenl}{HTML}{DBEDDB}
\definecolor{redl}{HTML}{FAE4E4}
\def\njudge#1{\fcolorbox{opfib}{white}{#1}}
\def\nrule#1{\fcolorbox{white}{opfibl}{#1}}
\def\neqn#1{\fcolorbox{white}{redl}{#1}}



\def\judge#1{\vskip 2em\noindent \njudge{$#1$}\vskip 0.5em\noindent}
\def\rule#1{\vskip 2em \noindent \nrule{$#1$}\vskip 0.5em\noindent}
\def\eqn#1{\vskip 2em \noindent \neqn{$#1$}\vskip 0.5em\noindent}
\def\prof{\nrightarrow}
\def\tensor{\otimes}
\def\htensor{\mathrel{\hat\otimes}}
\def\lol{\multimap}
\def\hlol{\mathrel{\hat\multimap}}
\def\wtf{{\color{red}???}}

\def\re{\mathbf{E}}
\def\sh{\sharp}
\def\shp{\mathrel{\sharp}}
\def\zero{\texttt{0}}
\begin{document}

\def\
\tikzset{
   commutative diagrams/.cd,
   arrow style=tikz,
   diagrams={>=stealth}}

\section{Thinking About A Small Example}

Let's just do some ordinary category theory about the case where
I have just a single-arrow category $f : 0 \to 1$. Then transport
looks like
\[
\begin{tikzcd}
A_{01} \arrow[r, "0f"] \arrow[d, "f1"'] & A_{00} \arrow[d, "f0"] \\
A_{11} \arrow[r, "1f"'] & A_{10}
\end{tikzcd}
\]
where $A : \C \x \C^\op \to \rset$. The type $A \to B$ has object
part $(A \to B)_\delta = A_{\bar\delta} \to B_\delta$ so that transport works at all.
A closed term at a type is a natural transformation from the hom-type
\[
\begin{tikzcd}
0 \arrow[r] \arrow[d] & 1 \arrow[d] \\
1 \arrow[r] & 1
\end{tikzcd}
\]
Products should work pointwise, I should think? Then surely $A \x 1 = A$.
Do I also get that $1 \imp A = A$? Sure. $1_{\bar \delta} \to A_{\delta}$ is still
$A_{\delta}$. But {\em morphisms} from the hom-type are something else.
$H_{\bar\delta} \to A_\delta$ means that we take everything at $A_{10}$ and replace
it with a single unique point. So some kind of non-truthvalue-centric modality?

Consider the type $A \to A$. We can make a term of it by
taking the identity functions  $A_{00} \to A_{00}$ and $A_{11} \to A_{11}$,
and observing that their common transport to $A_{01} \to A_{10}$ is just
either trip around the transport diamond of $A$ itself.

Consider the composition type $(A \to B) \to (B \to C) \to A \to C$.
We can pick
\[(A_{00} \to B_{00}) \to (B_{00} \to C_{00}) \to A_{00} \to C_{00}\]
\[(A_{11} \to B_{11}) \to (B_{11} \to C_{11}) \to A_{11} \to C_{11}\]
to be actual composition, and then from these we derive
\[(A_{10} \to B_{01}) \to (B_{10} \to C_{01}) \to A_{01} \to C_{10}\]
In which an element from $A_{01}$ is transported down (in one of two
equivalent ways) to $A_{10}$, lifted back up to $B_{01}$ by the first
argument, transported back down to $B_{10}$ (in one of two
equivalent ways) lifted back up to $C_{01}$ by the second argument,
then finally transported down to $C_{10}$ (in one of two
equivalent ways). So yeah, composition is definable as a term.

\subsection{Some more generality}

Let's say we have a category $\C$ with an involutive contravariant endofunctor
$\star : \C^\op \to \C$. We aim to define a sort of `twisted presheaf' with
respect to $\star$. The objects of the putative category of twisted presheaves
is just functors $\C \to \rset$, but the morphisms will be nonstandard.

We can define $F \imp G$ to be the objectwise function space from $F \o \star$ to $G$.
That is, for any $C, D$, and $f : C \to D$, we have
\[(F \imp G)_C = F_{\star C} \to G_C\]
and
\[(F \imp G)_f = \lambda h : F_{\star C} \to G_C . \lambda d : F_{\star D} . G_f (h (F_{\star f} d))\]

We want something to play the role of the homfunctor $H : \C \to \C^\op \to \rset$
so that we can say a morphism $F \to G : \TP$ is a natural tranformation
$\rset^\C[H , F \imp G]$.

\subsection{Wait a minute What about composition}

Forget about the generality above for now, go back to the concrete case where I am
talking about $\C^\op \x \C$, not some general case where I have a category-
with-involution. It looks like I can't define normal things like application
or composition across several closed terms, even though I can make closed
terms with fairly rich behavior when application or composition is internalized!
So maybe this is a place where I can see how I need to generalize what a term is,
to get a better-situated induction hypothesis.

Let me expand on what I just said with examples: There is always a closed
term $(A \to B) \to (B \to C) \to A \to C$, as I described farther above.
Even more simply, there is always a closed term at $A \to (A \to B) \to B$.
For I say
\[t_0 : A_{00} \to (A_{00} \to B_{00}) \to B_{00}\]
\[t_1 : A_{11} \to (A_{11} \to B_{11}) \to B_{11}\]
are the application functions at each individual type, and observe that transport
along $f : 0 \to 1$
to
\[A_{01} \to (A_{10} \to B_{01}) \to B_{10}\]
which gives me either
(repeatedly using
$ (A \to B)_{\phi}(h) = \lambda x . B_{\phi} ( h(A_{\bar\phi} x))$)
\[ (A \to (A \to B) \to B)_{f0}(t_0) = \lambda a . ((A \to B) \to B)_{f0} ( t_0(A_{0f} a)) \]
\[= \lambda a . ((A \to B) \to B)_{f0} ( t_0(A_{0f} a)) \]
\[= \lambda a g . B_{f0} ( t_0(A_{0f} a, (A \to B)_{0f} g)) \]
\[= \lambda a g . B_{f0} ( t_0(A_{0f} a, \lambda x . B_{0f} ( g(A_{f0} x))))\]
\[= \lambda a g . B_{f0} (  B_{0f} ( g(A_{f0} A_{0f} a))))\]
\[= \lambda a g . B_{ff} ( g(A_{ff} a))\]
or symmetrically
\[ (A \to (A \to B) \to B)_{1f}(t_1) = \lambda a g . B_{ff} ( g(A_{ff} a))\]

However, suppose I have a closed term $M : A$ and $N : A \to B$.
This means I have all of
\[M_0 : A_{00} \qquad N_0 : A_{00} \to B_{00}\]
\[M_1 : A_{11} \qquad N_1 : A_{11} \to B_{11}\]
\[A_{f0} M_0 = A_{1f} M_1 \qquad
\forall x : A_{01} . B_{f0} ( N_0(A_{0f} x)) = B_{1f} ( N_0(A_{f1} x))\]
So I can make the raw data of a term $L = N M : B$ via
\[L_0 : B_{00} = N_0\ M_0 \qquad L_1 : B_{11} = N_1\ M_1\]
But I don't seem to be able to prove
\[B_{f0} (N_0(M_0)) = B_{1f} (N_1(M_1))\]
Because, on one side of the symmetric coin, $M_0$ is not of the form $A_{f0}$ of something.

Here's a na\"ive conjecture I hope I can refute: that we can get away with thinking
of terms as global sections, which is to say, a term of $A$ is just
picking out an element of $A_{01}$. For is there even an element of
\[(A_{01} \to B_{10}) \to (B_{01} \to C_{10}) \to A_{10} \to C_{01}\]
? It doesn't seem like it! I wouldn't know how to get from $B_{10}$ to $B_{01}$!
So that's a good signal that something interestingly
nontrivial is going on here, but I still don't
know what.

\subsubsection{A Guess}

What if I try to deliberately move away from the closedness of terms, by
saying: a term of type $A$ is a choice, for every type $\Gamma$, of
a closed term of the function type $\Gamma \to A$. Then can I prove
something like cut/substitution? I'd have $\Gamma \to A$ and
$\Gamma \to A \to B$ for every $\Gamma$. I want to prove $\Gamma \to B$
for every $\Gamma$. Is there a clever {\em choice} of $\Gamma$ for
the premises derived from the universal $\Gamma$ in my conclusion?
Hmm, don't see how. Any use of existentially quantifying over the $\Gamma$s?
Nah, that makes a term at every type.

\subsubsection{End Formulation}

The thing I failed to check is simply that if I have

\[M \in \int_{c \in \C} A_{cc} \to B_{cc} \qquad
N \in \int_{c \in \C} A_{cc}\]

it isn't obvious how to get

\[M\ N \in \int_{c \in \C} B_{cc}\]

Because the object part is easy; $(M\ N)_c = M_c\ N_c$.
But I need to check that $B_{fc} (M\ N)_c = B_{df} (M\ N)_d$,
that is, $B_{fc} (M_c\ N_c) = B_{df} (M_d\ N_d)$.
What I know is that $A_{fc} N_c = A_{df} N_d$
and $(A \to B)_{fc} M_c = (A \to B)_{df} M_d$, the latter which means
\[B_{fc} (M_c(A_{cf} x)) = B_{df} (M_d(A_{fd} x))\]

\subsection{Composition With Half-Mute Functors}

Let's reassure myself that things don't unravel all the way back to
last November. If we have {\em covariant} functors $A, B, C$, and ends
\[M \in \int_c A(c) \to B(c) \]
\[N \in \int_c B(c) \to C(c) \]
Then surely there is a composite, yeah? Because $M$ actually is a natural
transformation $A \to B$ and $N$ a natural transformation $B \to C$.
If $\C$ were just a single arrow $f : c \to d$, then the general
diagram of $A \to B$
\[
\begin{tikzcd}
A_{dc} \to B_{cd} \arrow[r, "cf"] \arrow[d, "fd"'] & A_{cc} \to B_{cc} \arrow[d, "fc"] \\
A_{dd}\to B_{dd} \arrow[r, "df"'] & A_{cd} \to B_{dc}
\end{tikzcd}
\]
would degenerate to
\[
\begin{tikzcd}
A_{d} \to B_{c} \arrow[r, "cf"] \arrow[d, "fd"'] & A_{c} \to B_{c} \arrow[d, "fc"] \\
A_{d}\to B_{d} \arrow[r, "df"'] & A_{c} \to B_{d}
\end{tikzcd}
\]

Then how do we form the composite? To get from $A_d \to C_d$ we go $A_d \to B_d \to C_d$,
and same with $c$. What's the condition we need to check? That
$A_c \to A_d \to B_d \to C_d$ is the same as $A_c \to B_c \to C_c \to C_d$.
But we get this one type at a time. It's just chasing the diagram
\[
\begin{tikzcd}
A_{c}  \arrow[r] \arrow[d] & B_{c}  \arrow[d] \ar[r] & C_{c}  \arrow[d] \\
A_{d} \arrow[r] & B_{d} \ar[r] & C_{d}
\end{tikzcd}
\]

Why can't we do
\[
\begin{tikzcd}
A_{cd}  \arrow[r] \arrow[d] & B_{cd}  \arrow[d] \ar[r] & C_{cd}  \arrow[d] \\
A_{dc} \arrow[r] & B_{dc} \ar[r] & C_{dc}
\end{tikzcd}
\]
Because we don't actually have functions $A_{cd} \to B_{cd} \to C_{cd}$.

\subsection{Slightly Less Nontrivial Example?}

It's still weirding me out that dinatural transformations can't be composed, and
yet I don't know of any proposition that can't be realized with a proof term for
its corresponding type.

Like, suppose $A, B, C, D, E, F, Y, Z$ are $\C \x \C^\op \to \rset$. It's meaningful
for me to write
\[ A \to (((A \to B + C) \to (B \to D \x E) \to (C \to F) \to (E + F \to Z) \to Z) \to Y) \to Y\]
where $+$ and $\x$ mean pointwise sum and product, and
$(A \to B)_\delta = A_{\bar\delta} \to B_{\delta}$ with evident transport.
Is there an element of the end of this functor? I think so. For I can surely realize
\[ A_d \to (((A_d \to B_d + C_d) \to (B_d \to D_d \x E_d) \to (C_d \to F_d) \to (E_d + F_d \to Z_d) \to Z_d) \to Y_d) \to Y_d\]
for every symmetric $d$, as
\[ \lambda ak . k (\lambda \alpha\beta\gamma\zeta. \bcase \alpha\ a \bof\]
\[b \to \zeta (\binl (\bsnd \beta\ b) ) \celse c \to  \zeta (\binr (\gamma\ c)))\]
and we'd want to check that transport works out the same either way, which results in
\[ A_{\bar\delta} \to (((A_{\delta} \to B_{\bar\delta} + C_{\bar\delta}) \to (B_{\delta} \to D_{\bar\delta} \x E_{\bar\delta}) \to (C_{\delta} \to F_{\bar\delta}) \to (E_{\delta} + F_{\delta} \to Z_{\bar\delta}) \to Z_{\delta}) \to Y_{\bar\delta}) \to Y_{\delta}\]

which does the same thing with some coercions slipped in. We take in a
$A_{\bar\delta}$, convert it to $A_\delta$, feed it to the function
spitting out the $B_{\bar\delta}+C_{\bar\delta}$, convert its
components, etc. etc.

What's going on here? How is this compositional? It sure looks like
some kind of term/anti-term business going on. I can `prove' $Y \to Y$
because the two ways of going $Y_{\bar\delta} \to Y_\delta$ are the
same, because that functoriality is part of what it means for $Y$ to be a type.

Strawman proposal: variables act like knowledge that global sections of a functor exist,
but what we're proving is merely ends. The substitution theorem says that if we have a natural
transformation
$M_{\delta} : \Gamma_{\delta} \to  A_\delta$ and a term
\[N : \int \Gamma_{\bar\delta} \to A_{\bar \delta} \to B_\delta\] then
we have a term
\[[M/x]N : \int \Gamma_{\bar\delta} \to B_\delta\]
How does this work? We have to come up with
\[([M/x]N)_d :  \Gamma_{dd} \to B_{dd}\]
so we set
\[([M/x]N)_d(g) = N_d(g, M_{dd}(g))\]
Great, what about the end condition? Let a morphism $f : d \to e$ be given.
We want to confirm that
\[(\Gamma \to B)_{fd} ([M/x]N)_d = (\Gamma \to B)_{ef}([M/x]N)_e \]
\[(\Gamma \to B)_{fd} \lambda g . N_d(g, M_{dd}(g)) = (\Gamma \to B)_{ef} \lambda g . N_e(g, M_{ee}(g)) \]
\[(g : \Gamma_{de}) \to  B_{fd}  N_d(\Gamma_{df} g, M_{dd}(\Gamma_{df} g)) =  B_{ef}  N_e(\Gamma_{fe} g, M_{ee}(\Gamma_{fe} g)) : B_{ed}\]
Now: we assumed that $M$ works globally, so $M_{de}$ exists, and moreover
naturality means
\[(g : \Gamma_{de})\to  A_{df} M_{de}(g) = M_{dd}(\Gamma_{df} g) : A_{dd}\]
\[(g : \Gamma_{de})\to  A_{fe} M_{de}(g) = M_{ee}(\Gamma_{fe} g) : A_{ee}\]
so our obligation is now to check
\[(g : \Gamma_{de}) \to  B_{fd}  N_d(\Gamma_{df} g, A_{df} M_{de}(g)) =  B_{ef}  N_e(\Gamma_{fe} g, A_{fe} M_{de}(g)) : B_{ed}\]
but this is just the end condition for the type $N$ and we're done.

\subsection{Thought}

What's a concrete example of why I can't require global sections generally?
How about the identity type? Is there always an
element $A_{\bar \delta} \to A_\delta$ for any $A : \C \x \C^\op \to \rset$ and
$\delta : \C \x \C^\op$? I don't believe so. I might consider
specifically the homtype
\[
\begin{tikzcd}
0 \arrow[r] \arrow[d] & 1 \arrow[d] \\
1 \arrow[r] & 1
\end{tikzcd}
\]
in which there definitely isn't a map $0 \to 1$, even though there is a
term that takes $1 \to 1$ three different ways.

\subsection{If I can't handle cut...}

If my goal is simply to show that if ordinary sequent calculus proves a proposition,
then it's semantically realizable, I shouldn't need to separately worry about cut,
it should just fall out. But I do need to be concerned over particular inference
rules. So I expect ${\imp} L$ to cause the most cut-like obstacles.
\[
\erule
{\Gamma, B \prov C  \qquad \Gamma \prov A}
{\Gamma, A \imp B \prov C}
\]
Let's take even the special case where $\Gamma$ is empty.
Suppose I have $h : B_{dd} \to C_{dd}$, and $a : A_{dd}$,
and I want to make $(A_{dd} \to B_{dd}) \to C_{dd}$. I can certainly form
$\lambda k . h\ (k\ a)$, and then consider transport:
I should require that the two derived ways of doing
$(A_{ed} \to B_{de}) \to C_{ed}$ are the same, given an $f : d \to e$.
They are
\[\lambda k . C_{fd}(h\ (B_{df}(k\ A_{fd} a)))\]
\[\lambda k . C_{ef}(h\ (B_{fe}(k\ A_{ef} a)))\]
Ok, so right off the bat I notice that I {\em want} to be able to identify
$B_{df}(k\ A_{fd} a)$ with $B_{fe}(k\ A_{ef} a)$ but the obstacle is the fact that
I don't know the relationship between $A_{fd} a$ and $A_{ef} a$. Or, rather, I sort
of {\em do}; I know that they've diverged from the peak of the diamond down to the sides,
and I know that {\em if} I made them converge again with... wait, no, I have this wrong.

Both of these have type $(A_{ed} \to B_{de}) \to C_{ed}$:
\[a : A_{dd}, h : B_{dd} \to C_{dd} \prov \lambda k . C_{fd}(h\ (B_{df}(k\ A_{fd} a)))  \]
\[a' : A_{ee}, h' : B_{ee} \to C_{ee} \prov \lambda k . C_{ef}(h'\ (B_{fe}(k\ A_{ef} a')))\]

That means that $A_{fd} a$ and $A_{ef} a'$ {\em are} equal. Let me call them both $\alpha$.
So I'm comparing
\[\alpha : A_{ed}, h : B_{dd} \to C_{dd} \prov \lambda k . C_{fd}(h\ (B_{df}(k\ \alpha)))  \]
\[\alpha : A_{ed}, h' : B_{ee} \to C_{ee} \prov \lambda k . C_{ef}(h'\ (B_{fe}(k\ \alpha)))\]

Now I see it's actually $B$ that's doing the divergent transport,
feeding things to $h$ and $h'$ respectively. But wait, the equality I need
now follows directly from the end-property of $h$, doesn't it?

\subsection{Does It Work For General Contexts?}

Suppose I have terms
$\Gamma \prov M : A$
$\Gamma, x : B \prov N : C$
meaning
\[ M \in \int \Gamma_{\bar\delta} \to A_{\delta}
\qquad N \in \int \Gamma_{\bar\delta} \to B_{\bar\delta} \to C_{\delta}
\]
Then I want to construct a term
\[
P \in \int (A_{\delta} \to B_{\bar\delta}) \to C_{\delta}
\]
by setting $P_d = \lambda k : A_{dd} \to B_{dd} . \ldots$ maybe it's agda time.

Yeah, this checks out in agda. So what's the deal? I can pretty much derive cut from
this and ${\imp}R$, which has to succeed because it's just a mute currying operation.
So do I fail at the step of going from
\[ \int (A_\delta \to A_{\bar \delta}) \to C_\delta \]
to
\[ \int  C_\delta \]
maybe?

Let me focus again on the alleged general failure of getting from
$ M : \int A_{\bar\delta} \to B_{\delta}$ and $N : \int A_{\delta}$
to $P : \int  B_\delta $. We write down that $P_d = M_d(N_d)$.
We want to check that $B_{fd} P_d = B_{ef} P_e$. This means checking
$B_{fd} M_d(N_d) = B_{ef} M_e(N_e)$. We know that
\[A_{fd} N_d = A_{ef} N_e\]
\[(x : A_{de}) \to B_{fd} M_d(A_{df} x) = B_{ef} M_e(A_{fe} x)\]

\subsection{An Interesting Counterexample}

Ok, here's a concrete way in which the semantics is {\em incomplete} with respect to the usual
sequent calculus. It's basically a `yes' to the above question of
\begin{quote}
  Is the essential failure of trying to show cut elimination reducible
  to the specific failure of a cut $\prov A \to A$ against $A \to A
  \prov C$ to get $\prov C$?
\end{quote}

Let $A$ be the homtype
\[
\begin{tikzcd}
0 \arrow[r] \arrow[d] & 1 \arrow[d] \\
1 \arrow[r] & 1
\end{tikzcd}
\]
and let $C$ be the `inconsistent type 2'
\[
\begin{tikzcd}
0 \arrow[r] \arrow[d] & \{b\} \arrow[d] \\
\{a\} \arrow[r] & \{a, b\}
\end{tikzcd}
\]
Note
that $C$ has no closed terms.

However, $(A \to A) \to C$ does have a closed term:
\[
\begin{tikzcd}
  & \lambda \_ . b \arrow[d, mapsto] \\
\lambda \_  . a \arrow[r, mapsto] & !
\end{tikzcd}
\]
The two representatives at each
$((A \to A) \to C)_{dd}$ ignore their argument (the unique function $\{*\} \to \{*\}$) and
produce unique element of $C_{dd}$. Unlike terms of $C$, they {\em do} consistently reconcile
to the same element of $(A_{ed} \to A_{de}) \to C_{ed}$, however, because there
{\em are} no elements of $(A_{ed} \to A_{de})$.

How do I diagnose what the problem is here? Ideally I'd like to say
that, in some way, this exotic term of type $(A \to A) \to C$ is `not
respecting the equality at $A \to A$'.

\subsection{Back to the time when I was thinking about Zig-zags}

So I am stuck pretty hard, aren't I? I'm trying to reconcile the fact that
syntactically it seems like I ought to have
\[ \forall \alpha . A(\alpha) , \forall \alpha . A(\bar\alpha) \to B(\alpha) \prov \forall \alpha . B(\alpha) \]
But generally there doesn't seem to be a function

\[ \left( \int_\delta A_\delta\right) \to \left( \int_\delta A_{\bar\delta} \to B_\delta \right) \to \left( \int_\delta B_\delta\right) \]
the counterexample being when $B$ is the `inconsistent pair' functor $\C \x \C^\op \to \rset$
for $\C$ the one-arrow category, and $A$ is the `homtype'. In this case
$\left( \int_\delta A_\delta\right)$ is singleton, and
$\left( \int_\delta A_{\bar\delta} \to B_\delta \right)$ is singleton, but
$\left( \int_\delta B_\delta\right)$ is empty.

I would try to construct the element of $\int_\delta B_\delta$ from
\[ M \in \int_\delta A_\delta \qquad N \in \int_\delta A_{\bar\delta} \to B_\delta \]

by letting $d$ be given, and constructing $N_d\ M_d : B_{dd}$, and
experiencing the now-familiar failure of verifying the end condition
for this from the end-conditions for $M$ and $N$.

Is $\int_d$ more like $\Diamond \forall$ than a naked $\forall$?
Does
\[ \left( \int_\delta A_\delta\right) \to \left( \int_\delta  B_\delta \right) \to \left( \int_\delta A_\delta \x B_\delta\right) \]
also fail? Here we'd take
\[ M \in \int_\delta A_\delta \qquad N \in \int_\delta  B_\delta \]
and construct $\pair {M_{d}} {N_d} : A_{dd} \x B_{dd}$. We'd want to check that
\[(A \x B)_{fd} \pair {M_{d}} {N_d} = (A \x B)_{ef} \pair {M_{e}} {N_e}\]
\[ \pair{A_{fd}M_{d}}{B_{fd}N_{d}} = \pair{A_{ef}M_{e}}{B_{ef}N_{e}}\]
but this {\em does} follow from the end-properties for $M, N$.
So the real failure must be contained in merely
\[ \left( \int_\delta A_\delta \x  (A_{\bar\delta} \to  B_\delta) \right) \to \left( \int_\delta B_\delta\right) \]
Ok, so again, suppose $A_{de} = \emptyset$ and otherwise $A_\delta = \{*\}$.
Suppose $B_{ed} = \{d, e\}$ and $B_{dd} = \{d\}$ and $B_{ee} = \{e\}$ and $B_{de} = \emptyset$.
We observe that $\int_\delta B_\delta = \emptyset$. We have
\[ A_{de} \x (A_{ed} \to B_{de}) = \emptyset \]
\[ A_{dd} \x (A_{dd} \to B_{dd}) = \{ d \} \]
\[ A_{ee} \x (A_{ee} \to B_{ee}) = \{ e \} \]
\[ A_{ed} \x (A_{de} \to B_{ed}) = \{ * \} \x (\emptyset \to \{d, e\}) = \{ ! \} \]
And there {\em are} terms of this.

Take clear note: the interpretation {\em with quantifiers} is therefore {\em not sound}
even though it seemed like the interpretation with one quantifier at the outside
and a bunch of propositional stuff inside was sound.

How far is it from sound, though? Can I make a term of type
\[\int_\delta \left( \int_\delta A_\delta \x  (A_{\bar\delta} \to  B_\delta) \right) \to  B_\delta \]
which corresponds to the sequent-goal I get after doing ${\imp}R$ and
${\forall} R$ on $(\forall x . A(x) \x (A(x) \to B(x))) \to \forall x.B(x)$?

I only get a change when I actually {\em instantiate} the variable of the inner end.
\[\int_\delta ( A_{\bar\delta} \x  (A_{\delta} \to  B_{\bar\delta}) ) \to  B_\delta \]
is suddenly provable. That's weird, I thought I went through the reasoning for $\forall {L}$.

Let's look at it again.
We have
\[
\erule
{\Delta; \Gamma \prov M : \forall_\C \alpha . A \qquad \Delta \prov t : \C}
{\Delta; \Gamma \prov M[t] : [t/\alpha] A }
\]

which tells us that we have $M_d : (g : \Gamma_{dd}) \to \int_{c} A_{ddcc}$
and $ t_{\delta} : \C$. We need to make
\[(M[t])_d : (g : \Gamma_{dd}) \to  A_{ddt_{dd}t_{dd}}\]
So we do the mere swizzling
\[ (M[t])_d(g) = M_d(g)[t_{dd}] \]
and now we want to check that the end-property holds.
We let some morphism $f : d \to e \in \ssem \Delta$ be given.
We want to check that
\[ (g : \Gamma_{ff}) \to ([t/\alpha]A)_{fd}(\Gamma_{\rtri\fdom}  g, (M[t])_d(\Gamma_{\fdom} g))
\equiv ([t/\alpha]A)_{ef}(\Gamma_{\rtri\fcod}  g, (M[t])_e(\Gamma_{\fcod} g)) \]
wait but what exactly is $([t/\alpha]A)_{\phi}$? I already tacitly assumed
$([t/\alpha]A)_\delta = A_{\delta t_\delta t_{\bar \delta}}$.
So since
\[([t/\alpha]A)_\phi : (g : \Gamma_\phi) \to A_{\delta t_\delta t_{\bar \delta}}(\Gamma_{\ltri \phi} g) \to A_{\epsilon t_\epsilon t_{\bar \epsilon}}(\Gamma_{\rtri \phi} g)\]
and I'm going to assume that $t_\phi : t_\delta \to t_\epsilon$ is a thing. This means I can
make the guess that
\[([t/\alpha]A)_\phi(g, a) = A_{\phi t_\phi t_{\bar \phi}}(g, a)\]
because also $t_{\bar\phi} : t_{\bar\epsilon} \to t_{\bar\delta}$ and $\Gamma$ doesn't depend
on the variable $\alpha$ at all, so we get simplifications like, e.g.
$\Gamma_{\phi t_\phi t_{\bar\phi}} = \Gamma_{\phi}$
and
$\Gamma_{\ltri(\phi t_\phi t_{\bar\phi})} = \Gamma_{\ltri \phi}$.

Okay, plugging in this conjecture, and the definition of the swizzling, I get as a goal
\[ (g : \Gamma_{ff}) \to A_{fd t_{fd} t_{df}}(\Gamma_{\rtri\fdom}  g, M_d(\Gamma_{\fdom} g)[t_{dd}])
\equiv A_{ef t_{ef}t_{fe}}(\Gamma_{\rtri\fcod}  g, M_e(\Gamma_{\fcod} g)[t_{ee}]) \]
Ok, now let's look at the end condition for $M$ itself.
\[ (g : \Gamma_{ff}) \to (\forall \alpha . A)_{fd}(\Gamma_{\rtri\fdom}  g, M_d(\Gamma_{\fdom} g))
\equiv (\forall \alpha . A)_{ef}(\Gamma_{\rtri\fcod}  g, M_e(\Gamma_{\fcod} g)) \]

I look up the semantics I worked out before and see that I got
\[(\forall^\C\alpha . A)_\phi(g, E) = \lambda d . A_{\phi d d}(g, E(d)) \]
and I sort of see that this is enough to see equality along the diagonal, but not in the
full generality that I need for my goal. Bummer.

\subsection{When Do I Expect This To Work?}
\label{expect.work}

The next thing I should try to do is at least figure out where the
boundary between working and not-working is. I think I can bisect from
the focusing semantics.

I do expect to be able to transit
\[\int_\delta ( A_{\bar\delta} \x  (A_{\delta} \to  B_{\bar\delta}) ) \to  \int_\delta B_\delta \]
{\em when I'm in the special case} of $A$ being purely co- or contravariant. I wonder
if this observation gets me closer to seeing how a type could come equipped with some
structure that makes it `as good as' these special cases. But I'm getting ahead
of myself. Let's make sure this is true, first. Let's suppose $A$ is a covariant
functor, and $B$ is $\C \x \C^\op \to \rset$. Then I'm trying to achieve
\[ \int_c A(c) \x (A(\bar c) \to B(c, \bar c)) \to \int_c B(c, \bar c) \]
So I suppose I have
\[ M : \int_c A(c) \x (A(\bar c) \to B(c, \bar c)) \]
and I'm trying to make $ \int_c B(c, \bar c)$. So let $d$ be given. I build
\[P_d = \blet (x, g) = M_d \bin g(x) : B_{dd}\]
(where $x : A_d, g : A_d \to B_{dd}$)
as required. What's the assumed end-condition of $M$? Given an $f : d \to e$, it's
\[
( \blet (x, g) = M_d \bin \pair {A_f x} {B_{fd} \o g})
\equiv
(\blet (x, g) = M_e \bin \pair { x} {B_{ef} \o g \o A_f}): A_{e} \x (A_d \to B_{ed})
\]
What do we need to show? That
\[ B_{fd} P_d \equiv B_{ef} P_e \]
\[ B_{fd} (\blet (x, g) = M_d \bin g(x)) \equiv B_{ef} (\blet (x, g) = M_e \bin g(x)) \]
Let's expand out those $\blet$s in what we know, writing $\bfst$ and $\bsnd$ as superscripts.
We know
\[
\pair  {A_f M_d^1} {B_{fd} \o M_d^2}
\equiv
 \pair { M_e^1} {B_{ef} \o M_e^2 \o A_f}): A_{e} \x (A_d \to B_{ed})
\]
so that's really two equations
\[
  {A_f M_d^1} \equiv { M_e^1} : A_e\]
\[
{B_{fd} \o M_d^2}
\equiv  {B_{ef} \o M_e^2 \o A_f}: A_d \to B_{ed}
\]
and we're trying to show
\[ B_{fd} ( M_d^2(M_d^1) ) \equiv B_{ef} ( M_e^2(M_e^1) )\]
Aha, and this follows directly.

And I'm pretty sure this would work symmetrically if $A$ were purely contravariant
as well.

\subsection{So What Is The Logic of This?}

So somehow the general case of {\em bi}variant types are second-class citizens.
Assuming my guess is right, monovariant (whether co- or contra-) types behave better.
How does this get represented in a logic?

\section{Going over the quantifiers carefully}

Ok, I'm in a simply-typed setting. What is the semantics
of $\forall \alpha . A$ and  $\exists \alpha . A$?
Going to assume that I always mean quantification over $\C$ below.
I'm reasonably confident in the following semantic
definitions and lemmas for types:

\begin{defnbox}
  $(\exists \alpha .  A)_{\delta} = \int^c A_{\delta cc}$\\
  $(\forall \alpha . A)_{\delta} = \int_c A_{\delta cc}$\\
  $(\exists \alpha .  A)_{\phi}( K) = \blet \pair c x = K \bin \pair c  {A_{\phi cc}( x)}$\\
  $(\forall \alpha . A)_{\phi}( E) = \Lambda c . A_{\phi cc}( E[c])$
\end{defnbox}
\begin{thmbox}
  $([t/\alpha] A)_\delta = A_{\delta t_\delta t_{\bar \delta}} =: A_{\delta t^\delta}$\\
  $([t/\alpha] A)_\phi = A_{\phi t_\phi t_{\bar \phi}} =: A_{\phi t^\phi}$
\end{thmbox}
And then for terms:
\begin{defnbox}
  $(\Lambda \alpha. A)_d(g) = \lambda c . M_{dc}(g)$\\
$\cdots$
\end{defnbox}
\subsection{Syntax}
Given a morphism $f : d \to e$ in $\C$ I'm going to say
\begin{defnbox}
$f_< = de$\\
$f_0 = dd$\\
$f_1 = ee$\\
$f_> = ed$\\
$f_0^< : f_< \to f_0 = df$\\
$f_1^< : f_< \to f_1 = fe$\\
$f_0^> : f_0 \to f_> = fd$\\
$f_1^> : f_1 \to f_> = ef$
\end{defnbox}
So that the end condition on $\Delta ; \Gamma \prov M : A$ is
\begin{thmbox}
 \(
 (g : \Gamma_{f_<}) \to A_{f_0^>} (M_d (\Gamma_{f_0^<} g))
\equiv A_{f_1^>} (M_e (\Gamma_{f_1^<} g))
\)
\end{thmbox}
or equivalently
\begin{thmbox}
 \(
 A_{f_0^>} M_d \Gamma_{f_0^<} \equiv A_{f_1^>} M_e \Gamma_{f_1^<}
\)
\end{thmbox}
or maybe more perspicuously in the other order
\begin{thmbox}
 \(
 \Gamma_{f_0^<}; M_d;A_{f_0^>}  \equiv \Gamma_{f_1^<}; M_e;A_{f_1^>}
\)
\end{thmbox}

\subsection{Reasoning}

I want to get throw the existential and forall elim and intro rules, and see what
breaks, and what shape of band-aid can fix it.

\subsubsection{Forall intro}
\[
\erule
{\Delta, \alpha : \C;\Gamma\prov M : A}
{\Delta;\Gamma \prov \Lambda\alpha . M : \forall \alpha . C}
\]

We have $M_{dc} : \Gamma_{ddcc} \to A_{ddcc}$ and
For $f : d \to d'$ and $h : c \to c'$,
\[  (g : \Gamma_{f_<h_<}) \to A_{f_0^>h_0^>} (M_{dc} (\Gamma_{f_0^<h_0^<} g))
\equiv A_{f_1^>h_1^>} (M_{d'c'} (\Gamma_{f_1^<h_1^<} g))
\]
and we want to check that the definition
\[(\Lambda \alpha. A)_d(g) = \lambda c . M_{dc}(g)\]
satisfies
\[(\Lambda \alpha. A)_d : \Gamma_{dd} \to (\forall \alpha . A)_{dd} = \Gamma_{dd} \to \int_c A_{ddcc}\]
and
\[ (g : \Gamma_{f_<}) \to A_{f_0^>} ((\Lambda \alpha. A)_d (\Gamma_{f_0^<} g))
\equiv A_{f_1^>} ((\Lambda \alpha. A)_{d'} (\Gamma_{f_1^<} g))\]
Now for this definition to be in the small, inner end $\int_c A_{ddcc}$, we using the
end property of $M_{dc}$ at the identity on $d$ and
$h : c \to c'$. For it to satisfy the big, outer end, we use the end property of
$M_{dc}$ at $f : d \to d'$ and the identity.

\subsubsection{Forall elim}
\[
\erule
{\Delta;\Gamma\prov M : \forall \alpha . A \qquad \Delta\prov t : \C}
{\Delta;\Gamma \prov  M[t] : [t/\alpha]A}
\]
We have that
\[M_d : \Gamma_{dd} \to (\forall \alpha . A)_{dd} = \Gamma_{dd} \to \int_c A_{ddcc}\]
and
\[  (g : \Gamma_{f_<}) \to (\forall \alpha . A)_{f_0^>} (M_{d} (\Gamma_{f_0^<} g))
\equiv (\forall \alpha . A)_{f_1^>} (M_{d'} (\Gamma_{f_1^<} g))
\]
which means
\[  (g : \Gamma_{f_<}) \to \Lambda c . A_{f_0^>cc} (M_{d} (\Gamma_{f_0^<} g)[c])
\equiv \Lambda c . A_{f_1^>cc} (M_{d'} (\Gamma_{f_1^<} g)[c])
\eqno(*)
\]

and given the definition
\[(M[t])_d(g) = M_d(g)[t_{dd}]\]
we want to check that
\[(M[t])_d : \Gamma_{dd} \to A_{ddt_{dd}t_{dd}}\]
(easy) and, critically
\[    (g : \Gamma_{f_<}) \to ([t/\alpha] A)_{f_0^>} ((M[t])_{d} (\Gamma_{f_0^<} g))
  \equiv ([t/\alpha] A)_{f_1^>} ((M[t])_{d'} (\Gamma_{f_1^<} g))
\]
which is to say
\begin{thmbox}
  \(
(g : \Gamma_{f_<}) \to A_{f_0^> t_{f_0^>}t_{\bar f_0^>}} M_{d}(\Gamma_{f_0^<} g)[t_{dd}]
\equiv  A_{f_1^> t_{f_1^>}t_{\bar f_1^>}} M_{d'}(\Gamma_{f_1^<} g)[t_{d'd'}]
  \)
\end{thmbox}

We also know because of the end property of $\int_c A_{ddcc}$ itself, that
for any object $d\in \C$ and any morphism $h : u \to v \in \C$,
\[A_{dd h^>_0} M_d(g)[u] = A_{dd h^>_1} M_d(g)[v]\]

Ok, so I don't expect to be able to complete this reasoning, but how far can I get?
We can functorially break up the transport as
  \[
(g : \Gamma_{f_<}) \to A_{\rid t_{f_0^>}t_{\bar f_0^>}} A_{f_0^> \rid \rid}  M_{d}(\Gamma_{f_0^<} g)[t_{dd}]
\equiv  A_{f_1^> t_{f_1^>}t_{\bar f_1^>}} M_{d'}(\Gamma_{f_1^<} g)[t_{d'd'}]
  \]
reducing our obligation via $(*)$ to
  \[
(g : \Gamma_{f_<}) \to A_{\rid t_{f_0^>}t_{\bar f_0^>}} A_{f_1^> \rid \rid}  M_{d'}(\Gamma_{f_1^<} g)[t_{dd}]
\equiv  A_{f_1^> t_{f_1^>}t_{\bar f_1^>}} M_{d'}(\Gamma_{f_1^<} g)[t_{d'd'}]
  \]

\subsection{Difficulties}
Hm, this new notation isn't actually helping me see what's going on very well.
Does it make much sense with old?

Goal is
\begin{thmbox}
  \(
(g : \Gamma_{de}) \to A_{fd t_{fd}t_{df}} M_{d}(\Gamma_{df} g)[t_{dd}]
\equiv  A_{ef t_{ef}t_{fe}} M_{e}(\Gamma_{fe} g)[t_{ee}]
  \)
\end{thmbox}
and what's known is
\[  (g : \Gamma_{de}) \to \Lambda c . A_{fdcc} (M_{d} (\Gamma_{df} g)[c])
\equiv \Lambda c . A_{efcc} (M_{e} (\Gamma_{fe} g)[c])
\eqno(*)
\]
\[A_{dd hu} M_d(g)[u] = A_{dd vh} M_d(g)[v] \eqno(**)\]
I can transform the goal first to
\[
(g : \Gamma_{de}) \to  A_{e d t_{fd}t_{df}} A_{fd t_{dd}t_{dd}} M_{d}(\Gamma_{df} g)[t_{dd}]
\equiv  A_{ef t_{ef}t_{fe}} M_{e}(\Gamma_{fe} g)[t_{ee}]
\]
and then via $(*)$ to
\[
(g : \Gamma_{de}) \to  A_{e d t_{fd}t_{df}} A_{ef t_{dd}t_{dd}} M_{e}(\Gamma_{fe} g)[t_{dd}]
\equiv  A_{ef t_{ef}t_{fe}} M_{e}(\Gamma_{fe} g)[t_{ee}]
\]
then perhaps swizzle this around to
\[
(g : \Gamma_{de}) \to   A_{ef t_{ed}t_{de}}A_{e e t_{fd}t_{df}} M_{e}(\Gamma_{fe} g)[t_{dd}]
\equiv  A_{ef t_{ef}t_{fe}} M_{e}(\Gamma_{fe} g)[t_{ee}]
\]
for which it would suffice to show
\[
(g : \Gamma_{de}) \to   A_{e e t_{fd}t_{df}} M_{e}(\Gamma_{fe} g)[t_{dd}]
\equiv  A_{ee t_{ef}t_{fe}} M_{e}(\Gamma_{fe} g)[t_{ee}]
\eqno(\dag)
\]
But crucially this is a little more general than $(**)$, isn't it?

Ok, let's draw some pictures:
\[
\begin{tikzcd}
  t_{de} \ar[r, "t_{fe}"]\ar[d, "t_{df}"']& t_{ee}\ar[d, "t_{ef}"]\\
  t_{dd} \ar[r, "t_{fd}"']& t_{ed}\\
\end{tikzcd}
\]
On the left side of $(\dag)$, we go  $A_{\cdots t_{dd}t_{dd}} \to A_{\cdots t_{ed}t_{de}}$.
On the right side of $(\dag)$, we go  $A_{\cdots t_{ee}t_{ee}} \to A_{\cdots t_{ed}t_{de}}$.
But what does $(*)$ gives us?
\[
\begin{tikzcd}
  uv \ar[r, "{hv}"]\ar[d, "{uh}"']& vv\ar[d, "{vh}"]\\
  uu \ar[r, "{hu}"']& vu\\
\end{tikzcd}
\]

\subsection{Return to Known Counterexample}

Let's think about
$ (\forall x . A_x \x (A_x \to B_x)) \to \forall x . B_x$
again. The syntactic proof would be


\[
\begin{prooftree}
\[
\[
\justifies
 A_x \x (A_x \to B_x) \prov B_x
\]
\justifies
\forall x . A_x \x (A_x \to B_x) \prov B_x
\using {\forall L}
\]
\justifies
\forall x . A_x \x (A_x \to B_x) \prov \forall x . B_x
\end{prooftree}
\]
And I believe there always is an element of the end
\[\int_\delta A_{\bar \delta} \x (A_\delta \to B_{\bar\delta}) \to B_\delta \]
but not always of
\[\int_\delta \left( \int_\epsilon A_{ \epsilon} \x (A_{\bar\epsilon} \to B_{\epsilon}) \right)
\to B_\delta \]
For the special case of $A = \hom$ and $B = 1 \to 2 \leftarrow 1$.

So let's look at the very, very special case of $\forall L$ which is

\[
\erule
{\alpha : \C; x : A(\alpha) \prov M : B(\alpha)}
{\alpha : \C; y : \forall \beta . A(\beta) \prov [y[\alpha]/x]M : B(\alpha)}
\]

and the very, very special case of $\forall E$ which corresponds to it,

\[
\erule
{ }
{\alpha : \C; y : \forall \beta . A(\beta) \prov y[\alpha] : A(\alpha) }
\]

Does this rule by itself fail semantically? I hope so. It would require
me to construct a $P$ such that
$P_d : (\forall \beta . A(\beta))_{dd} \to A_{dd}$, i.e.
\[ P_d : \left(\int_c  A_{cc}\right) \to A_{dd} \]
such that
\[ (g : {\textstyle\int_c A_{cc}}) \to A_{fd} P_d(g) \equiv A_{ef} P_e(g) \]
and clearly I'd want to say
\[ P_d(E) = E[d]\]
and check that
\[ (g : {\textstyle\int_c A_{cc}}) \to A_{fd} g[d] \equiv A_{ef} g[e] \]
oh, but dang, this {\em is} the end-property of $g$. This apparently
doesn't give me the failure I want, and the problem is lurking
somewhere in the substitution theorem or something?

Ok, let's try the left rule instead of the elim rule. We have
$M_d : A_{dd} \to B_{dd}$ with
\[B_{fd} \o M_d \o A_{df} = B_{ef} \o M_e \o A_{fe} \]
We want $P$ with
\[ P_d : ({\textstyle \int_c  A_{cc}}) \to B_{dd} \]
\[B_{fd} \o P_d  = B_{ef} \o P_d  \]
so we set
\[P_d(x) = M_d(x[d])\]
so we need to check
\[B_{fd}(M_d(x[d])) \equiv B_{ef}(M_e(x[e]))\]
and {\em this} is the familiar stuck state where we don't actually know
that $x[d]$ and $x[e]$ are the $A$-transport of anything from $A_{de}$.

\subsection{Special Case of Special Case where it works}

So let $A$ be $C \x (C \to B)$ where $C$ is covariant.

\[
\erule
{\alpha : \C; x : (C \x (C \to B))(\alpha) \prov M : B(\alpha)}
{\alpha : \C; y : \forall \beta . (C \x (C \to B))(\beta) \prov [y[\alpha]/x]M : B(\alpha)}
\]

The known end condition for $M$ says that for all
\[B_{fd} \o M_d \o (C \x (C \to B))_{df} = B_{ef} \o M_e \o (C \x (C \to B))_{fe} \]
\[(x : C_{d}) (h : C_{e} \to B_{de})
\to
B_{fd} ( M_d ( (C \x (C \to B))_{df} (x, h)))= B_{ef} ( M_e ( (C \x (C \to B))_{fe} (x, h)))\]
\[(x : C_{d}) (h : C_{e} \to B_{de})
\to
B_{fd} ( M_d (x, B_{df} \o h \o C_f))= B_{ef} ( M_e  (C_fx, B_{fe} \o h))\]

and we want to construct
\[P_d : \left(\int_c C_{c} \x (C_{c} \to B_{cc})\right) \to B_{dd} \]
\[B_{fd} \o P_d  = B_{ef} \o P_d  \]
so we set
\[P_d(z) = M_d(z[d])\]
and we need to check
\[(z : {\textstyle \int}_c C_c \x (C_c \to B_{cc})) \to  B_{fd}(M_d(z[d])) \equiv B_{ef}(M_e(z[e]))\]
and we seem to still be stuck? What's going on?

\vfil\eject
\subsection{Why Did What I Have Before Work?}

Before, back up in \S\ref{expect.work}, I had a {\em specific} $M$ in
mind for a proof of $x : C \x (C \to B) \prov B$. It was

\[ \blet (y, g) = x \bin g(y) : B_{dd}\]

Or wait, is that the deal? I also notice now that I forgot I have an end-condition for
$z : {\textstyle \int}_c C_c \x (C_c \to B_{cc})$ itself, as an element of an end. It's
\[\blet (y, g) = z[d] \bin (C_f y, C_{fd} \o g) \equiv \blet (y, g) = z[e] \bin (y,  C_{ef} \o g \o C_f)\]

which rewriting with projections is
\[C_f z_d^1 =  z_e^1\]
\[ C_{fd} \o z_d^2 \equiv C_{ef} \o z_e^2 \o C_f\]

Hm, this by itself doesn't get me unstuck. The {\em specific} $M$ is $M_d(q) = q^2(q^1)$,
which makes me check
\[(z : {\textstyle \int}_c C_c \x (C_c \to B_{cc})) \to  B_{fd}(z_d^2(z_d^1)) \equiv B_{ef}(z_e^2(z_e^1))\]
and now I can see that
\[B_{ef}(z_e^2(z_e^1)) = B_{ef}(z_e^2(C_f z_d^1))\]
\[ = B_{ef}(z_e^2(C_f z_d^1))\]

\subsection{What's Special About This Case}
Bah, what the heck is going on. Let's just reconcile notation.
{\em If} I have a term of type \[\int_c C_c \x (C_c \to B_{cc})\], then
I should be able to construct a term of type $\int_c B_{cc}$.
We let $M : \int_c C_c \x (C_c \to B_{cc})$ be given,
set $P_d = M_d^2(M_d^1) : B_{cc}$, and check that the end condition
\[ B_{fd} (M_d^2(M_d^1)) = B_{ef} (M_e^2(M_e^1)) \]
follows from
\[ \pair{ C_f M^1_d} { B_{fd} \o M_d^2 } = \pair {M^1_e} { B_{ef} \o M_e^2 \o C_f} \]

But if I have a term of type
\[( C_d \x (C_d \to B_{dd}) ) \to B_{dd} \]
I'd like to {\em think} that I can $\forall L$ to
\[\left( \int_c  C_c \x (C_c \to B_{cc}) \right) \to B_{dd} \]
but I seem to get stuck.

No, this line of thought isn't helping.

\subsection{What Else To Do?}

With some foreshadowing intent I want to call what I'd ordinarily
think of as a normal proposition instead a {\em pre}proposition in
this context; it's all propositions, which may not be well-behaved
with respect to this semantics. But I can {\em give} an interpretation
as a type to any such preprop, with implication being functions and quantifiers
being (co)ends, and so on. They simply don't follow the usual rules.

Except my language of preprops is a little richer than regular props,
because I mean to syntactically bake into atomic propositions the variance
with which they depend on categorical variables.

Ok, so what rules {\em do} they satisfy? Let me collect some data. What data do I have
already? I believe I know that
\[\models (\forall x . C^+_x \x (C^+_x \to B_{x})) \to \forall x . B_{x}\]
\[\models (\forall x . C^-_x \x (C^-_x \to B_{x})) \to \forall x . B_{x}\]
and that generally
\[\not\models (\forall x . C_x \x (C_x \to B_{x})) \to \forall x . B_{x}\]


\end{document}
