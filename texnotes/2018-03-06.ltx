\documentclass{article}
\input{theorem}
\input{prooftree}
\usepackage{stmaryrd}
\usepackage{latexsym}
\usepackage{yfonts}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,cd,decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}
\usepackage{tcolorbox}
\tcbuselibrary{breakable}

\def\wo{\setminus}
\def\rarm{\mathsf{rarm}}
\def\embu{\mathsf{embu}}
\def\coglue{\mathsf{coglue}}
\def\el#1{\textcolor{bluegray}{\texttt{[}}{#1}\textcolor{bluegray}{\texttt{]}}}
\def\quote#1{{\ulcorner {#1} \urcorner}}
\def\U{\mathsf{U}}
\def\fA{\mathsf{A}}
\def\fC{\mathsf{C}}
\def\ff{\mathsf{f}}
\def\B{\mathsf{B}}
\def\uni{\U}
\def\mor#1#2{#1 \to \underline{#2}}
\def\atm#1{\underline{#1}}

\def\ridp{\mathsf{idp}}
\def\ssem#1{\langle\!\langle{#1}\rangle\!\rangle}

\definecolor{cyan}{rgb}{0.80,0.95,0.95}
\definecolor{orange}{rgb}{0.95,0.90,0.80}
\definecolor{lred}{rgb}{0.95,0.8,0.8}
\definecolor{bluegray}{rgb}{0.4,0.4,0.8}
\definecolor{lgray}{gray}{0.9}
\newtcolorbox{declbox}{colframe=lred,colback=lred,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{thmbox}{colframe=cyan,colback=cyan,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{defnbox}{colframe=orange,colback=orange,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt}
\newtcolorbox{tangentbox}{colframe=lgray,colback=lgray,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}

\input{linear}
\def\rpath#1{[#1]}
\def\rfst{\mathsf{fst}\,}
\def\rsnd{\mathsf{snd}\,}
\def\bunfold{\mathbf{unfold}}
\def\bfold{\mathbf{fold}}
\def\pbind#1{\langle {#1} \rangle}
\def\ppbind#1{\langle\!\langle {#1} \rangle\!\rangle}
\def\dto{\mathrel{\dot\to}}
\def\dns{{\downarrow}}
\def\ups{{\uparrow}}
\def\sprov{\Vdash}
\def\signat{{\color{red}\Sigma}}

\def\wat{\mathbin{@}}
\def\wwat{\mathbin{\underline\wat}}
\def\cn{{:}}
\def\dv{{\div}}
\def\ww{{\mathsf w}}
\def\base{{\textfrak b}}

\def\N{{\mathbb N}}
\def\munit{I}
\def\tt{{\mathsf t}}
\def\rr{{\mathsf r}}
\def\ii{{\mathbb I}}
\def\pp{\textsf{\textbf p}}
\def\nn{{\mathsf n}}
\def\PP{\textsf{\textbf P}}
\def\NN{{\mathsf N}}
\def\zz{{\mathsf z}}
\def\sem#1{[\![#1]\!]}
\def\usem#1{\lceil\!\!\lceil{#1}\rceil\!\!\rceil}
\def\zem#1{\langle\!\langle#1\rangle\!\rangle}
\def\col#1{{\mathsf{C}}_{#1}}
\def\lax{\mathop\bigcirc}
\def\rjust{\mathsf{just}}
\def\rcvt{\mathsf{cvt}}
\def\rtype{\mathsf{type}}
\def\rkind{\mathsf{kind}}
\def\rmode{\mathsf{mode}}
\def\rprel{\mathbf{Prel}}
\def\rrfam{\mathbf{Rfam}}
\def\rset{\mathbf{Set}}
\def\rfinset{\mathbf{FinSet}}
\def\rrel{\mathbf{Rel}}
\def\rcat{\mathbf{Cat}}
\def\rfam{\mathbf{Fam}}
\def\binj{\mathbf{inj}}
\def\rid{\mathsf{id}}
\def\rtrue{\mathrel\mathrm{true}}
\def\pbck{\ar[dr, phantom, pos=0, "\lrcorner"]}
\def\bpbck{\ar[ddrr, phantom, pos=0, "\lrcorner"]}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\btwo{\mathbf{2}}
\def\bone{\mathbf{1}}

\newarrow {Equiv} =====
\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\def\mapt{\ar[ddd,mapsto,shorten <=2em, shorten >=2em]}
\def\frommaps{\ar[from=uu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\frommapt{\ar[from=uuu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\C{\mathbf{C}}
\def\S{\mathbf{S}}
\def\D{\mathbf{D}}
\def\E{\mathbf{E}}
\def\M{\mathbf{M}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\tri{\triangleright}
\def\o{\circ}
\def\rctx{\,\mathsf{ctx}}
\def\del{\partial}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\null{\emptyset}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\definecolor{fib}{HTML}{ff7f00}
\definecolor{green}{HTML}{007f00}
\definecolor{red}{HTML}{df3f3f}
\definecolor{opfib}{HTML}{007fff}

% For lightening colors I used
% http://trycolors.com/ 6 parts white to 1 part color
\definecolor{opfibl}{HTML}{DBEDFF}
\definecolor{greenl}{HTML}{DBEDDB}
\definecolor{redl}{HTML}{FAE4E4}
\def\njudge#1{\fcolorbox{opfib}{white}{#1}}
\def\nrule#1{\fcolorbox{white}{opfibl}{#1}}
\def\neqn#1{\fcolorbox{white}{redl}{#1}}

\def\judge#1{\vskip 2em\noindent \njudge{$#1$}\vskip 0.5em\noindent}
\def\rule#1{\vskip 2em \noindent \nrule{$#1$}\vskip 0.5em\noindent}
\def\eqn#1{\vskip 2em \noindent \neqn{$#1$}\vskip 0.5em\noindent}

\def\tensor{\otimes}
\def\lol{\multimap}

\def\wtf{{\color{red}???}}

\def\zero{\texttt{0}}

\begin{document}

\def\
\tikzset{
   commutative diagrams/.cd,
   arrow style=tikz,
   diagrams={>=stealth}}
% got this from
% https://tex.stackexchange.com/questions/169512/tikz-style-arrow-tips-missing-when-using-tikz-cd-crossing-over
% ???


\section{Introduction}
Here I'm once again trying to reconstruct Moulin's thesis in my own words, with
three improvements:

\begin{enumerate}
\item The notion of $I$-sets is not used, and instead careful attention is paid to
when isomorphism suffices in place of on-the-nose equality of sets.
\item The things that need to be postulated on the syntactic side are
better organized into type formers, introduction, and elimination rules.
\item We generalize to arbitrary arities cohabiting in the same system.
  Eventually I want to get to the generalization where
  relations of different arities can be transformed into one another
  through projections.
\end{enumerate}
\section{Syntax}

\subsection{Sharp Types}
Assume the usual syntactic machinery of a dependent type theory.

We postulate that there is a type operator $\sharp : \rfinset \to \rset$.
It has at least an intro rule

\[
\erule
{n \in \rfinset \qquad k \in n}
{\Gamma \prov \atm k : \sharp n}
\]

These are the {\em endpoints} of the $n$-endpointed `interval' object.
Naturally this most resembles an actual interval when $n = 2$, and
the rays in Moulin's thesis are recovered when $n=1$. Generally
one can picture $\sharp n$ as a type containing $n$ endpoints and some otherwise
abstract `glue' by which the points cohere together, e.g. $\sharp 3$ as

\[\begin{tikzpicture}[dot/.style={fill,circle,minimum size=1.5mm,inner sep=0pt,outer sep=0pt,fill=opfib}]
\begin{scope}[shift={(0,0)}]
  \node(aa) at (.2,1.5){};
  \node(bb) at (1.5,0){};
  \node(cc) at (.5,-1){};
  \node(dd) at (-1.8,0){};
  \fill [opfibl] plot [smooth cycle, tension=1] coordinates { (cc)   (bb)   (aa)   (dd) };
  \draw [opfib] plot [smooth cycle, tension=1] coordinates { (cc)   (bb)   (aa)   (dd) };
\end{scope}
\node[dot,label={[opfib]left:$\atm 0$}] at (0,1){};
\node[dot,label={[opfib]left:$\atm 1$}] at (-1,0){};
\node[dot,label={[opfib]left:$\atm 2$}] at (1,0){};
\end{tikzpicture}\]

The eventual punchline is that the type $\sharp n \to \rset$ should be
equivalent to the type of $n$-ary proof-relevant relations, i.e. spans
of $n$ functions, with the endpoints of the $\sharp n$ giving the codomains
of the $n$ arms of the span.

%% We want $\sharp$ to be functorial: if $g : n_1 \to n_2$ is a function
%% between finite sets, then we expect $\sharp g : \sharp n_1 \to \sharp n_2$ to exist.
%% This can be baked into the rule for how $\sharp$-typed variables can be used:
%% \[
%% \erule
%% {n_1, n_2\in\rfinset\qquad g : n_1 \to n_2}
%% {\Gamma, \nu : \sharp n_1 \prov \sharp g(\nu) : \sharp n_2}
%% \]
%% So the full syntax of expressions of interval type is simply
%% \[\hbox{Interval Expressions }\mu ::= \sharp g(\nu) \celse \atm k\]
%% either variables under a function, or endpoints. We may write simply
%% $\nu$ for $\sharp \rid(\nu)$.
The syntax of expressions of interval type is simply
\[\hbox{Interval Expressions }\mu ::=  \nu \celse \atm k\]

Variables of this type will be treated {\em affinely}.
%% Substitution on interval expressions is defined by
%% \[ [\sharp g'(\nu') / \nu]\sharp g(\nu) = \sharp(g \o g')(\nu') \]
%% \[ [\atm k / \nu]\sharp g(\nu) = \atm{g(k)} \]
%% \[ [\mu / \nu] \atm k  = \atm{k} \]
%% and satisfies
%% \[
%% \erule
%% {\Gamma, \nu : \sharp n \prov J \qquad \Delta \prov \mu : \sharp n}
%% {\Gamma, \Delta \prov [\mu / \nu] J}
%% \]
Because interval variables are affine, we
technically have a function type distinct from ordinary $\Pi$ types that binds
them, but we write them the same as $\Pi$ types, with agda-style syntax:

\[
\erule
{\Gamma, \nu : \sharp n \prov A : \rset}
{\Gamma \prov  (\nu : \sharp n) \to A : \rset}
\]
\[
\erule
{\Gamma, \nu : \sharp n \prov M : A }
{\Gamma \prov \lambda \nu.  M :   (\nu : \sharp n) \to A }
\qquad
\erule
{\Gamma \prov  M :   (\nu : \sharp n) \to A \qquad \Delta \prov \mu : \sharp n}
{\Gamma, \Delta \prov  M \ \mu :   [\mu/\nu] A}
\]
Functions $\sharp n \to X$ are called {\em $n$-paths in $X$} (or just {\em
  paths in $X$} when $n$ is clear) by analogy with the case where $n = 2$, in
which functions from intervals are naturally interpreted as paths.
When $\nu : \sharp n \prov B : \rset$, we sometimes abbreviate
$(\nu : \sharp n) \to B$  as $\forall B$.

\subsection{Spans and Witness Types}
An {\em $n$-span} is a record with fields
\def\rspan{\mathsf{Span}}
\begin{tabbing}
\hspace*{2em}\=\hspace*{2em}\= \kill
\> $\fC : \rset$\\
\> $\fA : n \to \rset$\\
\> $\ff : (k : n) \to \fC \to \fA_k$
\end{tabbing}
The type of these is called $\rspan_n$.
There is a canonical map taking an $n$-path in the universe to a span.
\begin{tabbing}
\hspace*{2em}\=$\ \ff_k\ c $ \= \kill
$\embu : (p : \sharp n \to \rset) \to \rspan_n $  \\
$\embu\ p = $  \\
\> $\langle \fC $\>$ = ( i : \sharp n) \to  p\ i$\\
\> $\ \fA_k $\>$ = p\ \atm k$\\
\> $\ \ff_k\ c $\>$ = c\ \atm k\rangle$
\end{tabbing}

We want this map to be an equivalence. Therefore we postulate that
a type exists, called a {\em witness type}, for lack of a better term, since
it witnesses the invertibility of \textsf{embu}.

\[
\erule
{\Gamma \prov S : \rspan_n}
{\Gamma, \nu : \sharp n \prov S \star \nu : \rset}
\]
%% where $\Gamma \wo \mu$ is defined by cases
%% on $\mu$: If $\mu = \sharp g(\nu)$, then actually remove the
%% variable $\nu$ from $\Gamma$, otherwise do nothing and return $\Gamma$.
%% This is a somewhat nonstandard way of expressing the affineness constraint,
%% but it makes calculations easier later.

We postulate the following reduction so that witness types are
 appropriately compatible with substitution:
%% \[ S \star_g \atm k \equiv S.\fA_{g(k)}
%% \qquad S \star_g  {\sharp g'(\nu)} \equiv S \star_{g\o g'} \nu\]
\[ S \star \atm k \equiv S.\fA_{k}\]
(Actually, since the intro rule for witness types requires a variable, what's
really happening is we're defining what it means to substitute an endpoint
for an interval variable in a witness type: $[\atm k / \nu](S \star \nu) = S.\fA_k$)

There are the following introduction and elimination rules:
%% \[
%% \erule
%% {\Gamma \prov c :S.\fC   \qquad g : m \to n \using \star I}
%% {\Gamma, \nu : \sharp m \prov c \star_g \nu : S\star_g \nu }
%% \qquad
%% \erule
%% {\Gamma, \nu : \sharp n \prov M : S\star_{\rid_n} \nu \using \star E}
%% {\Gamma \prov \pbind \nu M :S.\fC }
%% \]
\[
\erule
{\Gamma \prov c :S.\fC    \using \star I}
{\Gamma, \nu : \sharp n \prov c \star \nu : S\star \nu }
\qquad
\erule
{\Gamma, \nu : \sharp n \prov M : S\star \nu \using \star E}
{\Gamma \prov \pbind \nu M :S.\fC }
\]
and we require the following equivalence laws:
%% \[
%% c \star_g \atm k \equiv S.\ff_{g(k)}\ c\qquad
%% c \star_g  \sharp g'(\nu) \equiv c \star_{g\o g'} \nu
%% \]\[
%% \pbind \nu (c \star_{\rid_n} \nu) \equiv_\beta c \qquad (\pbind \nu M)\star_g \nu' \equiv_\eta [\sharp g(\nu')/\nu]M\]
\[
c \star \atm k \equiv S.\ff_{k}\ c\qquad
\]\[
\pbind \nu (c \star \nu) \equiv_\beta c \qquad (\pbind \nu M)\star \nu' \equiv_\eta [\nu'/\nu]M\]

Notice that the ones labelled $\beta$ and $\eta$ seem exactly backwards from
usual!
They're nonetheless named consistently according to how a typical
$\beta$ redex is an elim applied to an intro form, and an $\eta$ is
conversely an intro applied to an elim.


The goal is now to somehow arrive at the following two equivalences
%% \begin{thmbox}
%% $S : \rspan_n \prov S \equiv \embu(\lambda \nu . S \star_{\rid_n} \nu)$\\
%% $p : \sharp n \to \rset \prov p \equiv \lambda \nu . (\embu\ p)\star_{\rid_n} \nu$
%% \end{thmbox}
\begin{thmbox}
$S : \rspan_n \prov S \equiv \embu(\lambda \nu . S \star \nu)$\\
$p : \sharp n \to \rset \prov p \equiv \lambda \nu . (\embu\ p)\star \nu$
\end{thmbox}
i.e.
\begin{tabbing}
\hspace*{2em}\=$\ f\ k\ c $ \= \kill
$S : \rspan_n \prov  S \equiv$\\
\> $\langle \fC $\>$ = ( \nu : \sharp n) \to  S\star \nu$\\
\> $\ \fA_k $\>$ = S.\fA_k$\\
\> $\ \ff_k\ c $\>$ = c\ \atm k\rangle$
\end{tabbing}
and
\begin{tabbing}
\hspace*{2em}\=$\ f\ k\ c $ \= \kill
$p : \sharp n \to \rset, \nu  :\sharp n \prov  p\ \nu \equiv $\\
\> $\langle \fC $\>$ = ( \nu : \sharp n) \to  p\ \nu$\\
\> $\ \fA_k $\>$ = p\ \atm k$\\
\> $\ \ff_k\ c $\>$ = c\ \atm k\rangle \star \nu$
\end{tabbing}
Toward this goal we add one more rule, which might be reasonable to think of
as an elimination rule for $\sharp$:
\[
\erule
{
\begin{tabular}{c}
$\Gamma, k : n, x :  [\atm k / \nu]B \prov e : [\atm k / \nu]D$\\
$\Gamma, x' : \forall B, \nu' : \sharp n  \prov e' : [\nu'/\nu]D$\\
 $[x'\ \atm k/x]e \equiv [\atm k/\nu']e'$
\end{tabular}
}
{\Gamma, \nu : \sharp n, y : B \prov \bcase (\nu,y) \bof (\atm k,x).e \celse (\nu',x').e' : D}
\]


\section{Semantics}
We're going to describe the category $\C$, and give a semantics in $\rset^\C$.
The objects of $\C$ are contexts of $\sharp$-typed variables:

\[\hbox{Objects }I, J ::= \cdot \celse (I, i : \sharp n) \]
Calculations tend to be clearer if the range of letters
for the `variables' in $\C$-objects differs from the actual variables
in contexts in the type theory, so we use $i, j$ for variables found in
objects of $\C$,
and keep $\nu$ for variables in the type theory.
We also sometimes write a context $I, i : \sharp n, i', \sharp {n'}$ as
simply $I,i,i'$ when the types are clear.

A morphism $I \to J$ in $\C$ is an (affine) substitution $J \prov \sigma : I$.
\[
\erule
{}
{J \prov \cdot : \cdot}
\qquad
\erule
{J \prov \sigma : I \qquad J' \prov \mu : \sharp n }
{J, J' \prov (\sigma, i := \mu) : (I, i : \sharp n)}
\]

The semantics consists of the interpretation functions
\begin{declbox}
  $\sem \Gamma_I : \rset$\\
  $\sem \Gamma_\sigma : \sem \Gamma_I \to \sem \Gamma_J$\\
  $\sem A_I : \sem \Gamma_I \to \rset$\\
  $\sem A_\sigma : \{\rho : \sem \Gamma_I\} \to \sem A_I(\rho) \to \sem A_J(\sem \Gamma_\sigma(\rho))$\\
  $\sem M_I : (\rho : \sem \Gamma_I) \to \sem A_I(\rho)$
\end{declbox}

Which are expected to satisfy
\begin{thmbox}
  $ \sem \Gamma_{\rid} \equiv \rid$\qquad
  $ \sem \Gamma_{\sigma \o \tau} \equiv \sem \Gamma_\sigma \o \sem \Gamma_\tau$\\
  $ \sem A_{\rid} \equiv \rid$\qquad
  $ \sem A_{\sigma \o \tau} \equiv \sem A_\sigma \o \sem A_\tau$\\
  $(\rho : \sem \Gamma_I) \to \sem A_\sigma (\sem M_I(\rho)) \equiv \sem M_J(\sem \Gamma_\sigma(\rho)) $
\end{thmbox}

Also

\begin{thmbox}
  If $\Gamma, \nu : \sharp n \prov A : \rset$ then
$\sem{[\atm k / \nu]A}_I(\rho) \equiv \sem A_I(\rho, \nu := \atm k)$.
\end{thmbox}
\subsection{Definitions}
\subsubsection{Contexts}
The set $\sem \Gamma_I$ is essentially
the set of substitutions $I \prov \rho : \Gamma $.
\begin{defnbox}
\[
\erule
{}
{ \prov \cdot \in \sem \cdot_I}
\qquad\qquad
\erule
{\rho \in \sem \Gamma_I\qquad M \in \sem A_I(\rho) }
{ \prov (\rho, x := M) \in  \sem{\Gamma, x : A}_{I}}
\]
%% \[
%% \erule
%% {\rho \in \sem \Gamma_I  }
%% { \prov (\rho, \nu := \atm k) \in  \sem{\Gamma, \nu : \sharp n}_{I}}
%% \quad
%% \erule
%% {\rho \in \sem \Gamma_{I\wo i} \quad i : \sharp m \in I\quad g : m \to n }
%% { \prov (\rho, \nu := \sharp g(i)) \in  \sem{\Gamma, \nu : \sharp n}_{I}}
%% \]
\[
\erule
{\rho \in \sem \Gamma_{I\wo \mu} \quad I \prov  \mu : \sharp n  }
{ \prov (\rho, \nu := \mu) \in  \sem{\Gamma, \nu : \sharp n}_{I}}
\]
\end{defnbox}
\noindent
and for $J \prov \sigma : I$ the morphism part of the functor $\sem \Gamma$ is
essentially substitution composition:
\begin{defnbox}
\begin{tabular}{lll}
$\sem {\cdot}_\sigma(\cdot)$&$=$&$\cdot$\\
%% $\sem {\Gamma, \nu : \sharp n}_\sigma(\rho, \nu := \atm k)$&$=$&$(\sem{\Gamma}_{\sigma} (\rho), \nu := \sigma(\atm k))$\\
%% $\sem {\Gamma, \nu : \sharp n}_\sigma(\rho, \nu := \sharp g(i))$&$=$&$(\sem{\Gamma}_{\sigma\wo i} (\rho), \nu := \sigma(\sharp g(i)))$\\
$\sem {\Gamma, \nu : \sharp n}_\sigma(\rho, \nu := \mu)$&$=$&$(\sem{\Gamma}_{\sigma\wo \mu} (\rho), \nu := \sigma(\mu))$\\
$\sem {\Gamma, x : A}_\sigma(\rho, x := M)$&$=$&$(\sem{\Gamma}_\sigma (\rho), x := \sigma(M))$
\end{tabular}
\end{defnbox}
\noindent where $I\wo \mu$ (resp. $\sigma\wo \mu$) are defined by cases
on $\mu$: If $\mu = i$, then actually remove the
variable $i$ from $I$ (resp. $\sigma$), otherwise if it's an endpoint, simply
return $I$ (resp. $\sigma$) unchanged.
It is easy to check that $J \prov \sigma : I$ implies
$(J \wo \sigma(\mu)) \prov (\sigma \wo \mu) : (I \wo \mu)$,
which suffices to see that the interval variable clause of functoriality
is well-typed.

\subsubsection{Interval Function Types}
\begin{defnbox}
\begin{tabbing}
\hspace*{2em}\=\hspace*{2em}\= \kill
$\sem {(\nu : \sharp n) \to  A}_I(\rho) = \sem A_{I, i} (\rho, \nu := i)$\\
$\sem {(\nu : \sharp n) \to  A}_\sigma\ \{\rho\}\ (x) = \sem A_{(\sigma,\,\nu := i)}\ \{\rho, \nu := i \}\ (x)$
\end{tabbing}
\end{defnbox}

\subsubsection{Witness Types}
We want to make an interpretation of the type
\[
\erule
{\Gamma \prov S : \rspan_n }
{\Gamma, \nu : \sharp n \prov S \star \nu : \rset}
\]
Suppose $S = \langle \fC, \fA, \ff\rangle$.
Therefore we have
\[ \sem {\fA_k}_I, \sem \fC_I : \sem {\Gamma}_I \to \rset \]
\[  \sem \fC_f : \{\rho : \sem {\Gamma}_I\} \to \sem \fC_I(\rho) \to \sem \fC_I(\sem {\Gamma}_f(\rho)) \]
\[  \sem {\fA_k}_f : \{\rho : \sem {\Gamma}_I\} \to \sem {\fA_k}_I(\rho) \to \sem {\fA_k}_I(\sem {\Gamma}_f(\rho)) \]
\[  \sem {\ff_k}_I : \{\rho : \sem {\Gamma}_I\} \to \sem \fC_I(\rho) \to \sem {\fA_k}_I(\rho) \]
We set
\begin{defnbox}
\begin{tabbing}
\hspace*{2em}\=\kill
$\sem {S \star \nu}_I : \sem {\Gamma, \nu : \sharp n}_I \to \rset$\\
$\sem {S \star \nu}_I(\rho') = \bcase \rho' \bof$\\
\> $\celse (\rho, \nu := \underline k) \mapsto \sem {\fA_{k}}_I(\rho)$\\
\> $\celse (\rho, \nu := i) \mapsto \sem \fC_{I \wo i}(\rho)$
\end{tabbing}
\end{defnbox}
For a $J \prov \sigma : I$ set
\begin{defnbox}
\begin{tabbing}
\hspace*{2em}\=\hspace*{2em}\=\kill
\(\sem {S \star \nu}_\sigma : \{\rho' : \sem {\Gamma, \nu : \sharp n}_I\}
\to \sem {S\star \nu}_I(\rho') \)\\
\> \(  \to \sem {S\star \nu}_J(\sem{\Gamma, \nu : \sharp n}_\sigma(\rho')) \)\\
$\sem {S \star \nu}_\sigma\{\rho'\}(x) = \bcase \rho' \bof$\\
\> $\celse (\rho, \nu := \atm k) \mapsto \sem {\fA_k}_\sigma(x)$\\
\> $\celse (\rho, \nu := i) \mapsto \bcase \sigma(i) \bof$\\
\> \> $\celse \atm{k}  \mapsto \sem{\fA_k}_{\sigma\wo i}(\sem{\ff_k}_{I\wo i}(x))$\\
\> \> $\celse j  \mapsto \sem{\fC}_{\sigma\wo i}(x)$
\end{tabbing}
\end{defnbox}

Let's check the case analysis there because it gets slightly hairy.
When $\rho' = (\rho, \nu := i)$ we know $\rho \in \sem \Gamma_{I \wo i}$
and $x : \sem{\fC}_{I\wo i}(\rho)$.


When $\sigma(i) = \atm k$, then  $\sem {\ff_k}_{I \wo i}(x) : \sem{\fA_k}_{I\wo i}(\rho)$
and so
\[\sem{\fA_k}_{\sigma\wo i}(\sem {\ff_k}_{I \wo i}(x)) :
\sem {\fA_k}_{J \wo \sigma(i)}(\sem{\Gamma}_{\sigma\wo i}(\rho))
\]
\[ \equiv \sem {\fA_k}_J(\sem\Gamma_{\sigma\wo i}(\rho)) \]
\[ \equiv \sem {S\star \nu}_J(\sem\Gamma_{\sigma\wo i}(\rho), \nu := \atm k) \]
\[ \equiv \sem {S\star \nu}_J(\sem\Gamma_{\sigma\wo i}(\rho), \nu := \sigma(i)) \]
\[ \equiv \sem {S\star \nu}_J(\sem{\Gamma, \nu : \sharp n}_\sigma(\rho, \nu := i)) \]
\[ \equiv \sem {S\star \nu}_J(\sem{\Gamma, \nu : \sharp n}_\sigma(\rho')) \]
as required.

When $\sigma(i) = j \in J$, we know
\[ \sem\fC_{\sigma\wo i}(x) : \sem\fC_{J \wo \sigma(i)}(\sem \Gamma_{\sigma\wo i}(\rho))\]
\[ \equiv \sem {C}_{J\setminus j}(\sem\Gamma_{\sigma\wo i}(\rho)) \]
\[ \equiv \sem {S\star \nu}_J(\sem\Gamma_{\sigma\wo i}(\rho), \nu := j) \]
\[ \equiv \sem {S\star \nu}_J(\sem\Gamma_{\sigma\wo i}(\rho), \nu := \sigma(i)) \]
\[ \equiv \sem {S\star \nu}_J(\sem{\Gamma, \nu : \sharp n}_\sigma(\rho, \nu := i)) \]
\[ \equiv \sem {S\star \nu}_J(\sem{\Gamma, \nu : \sharp n}_\sigma(\rho')) \]
as required.


\subsubsection{Witness Elimination}

\[
\erule
{\Gamma, \nu : \sharp n \prov e : S\star \nu \using \star E}
{\Gamma \prov \pbind \nu e : S.\fC}
\]
For any $I$ we have
$\sem e_I : (\rho : \sem {\Gamma, \nu : {\sharp n}}_I) \to \sem {S \star \nu}_I(\rho)$
so we set
\begin{defnbox}
  \begin{tabbing}
    \hspace*{2em}\=\hspace*{2em}\=\kill
    $\sem{\pbind \nu e}_I : (\rho : \sem \Gamma_I) \to \sem {\fC}_I(\rho)$\\
    $\sem{\pbind \nu e}_I (\rho) = \sem e_{I,i}(\rho, \nu := i)$
  \end{tabbing}
\end{defnbox}
The type of
$\sem e_{I,i}(\rho, \nu := i)$ is
$\sem {S \star \nu}_{I,i}(\rho, \nu := i) = \sem \fC_{I,i\wo i}(\rho)$
as required.
\subsubsection{Witness Introduction}
\[
\erule
{\Gamma \prov c : \fC \using \star I}
{\Gamma, \nu : {\sharp n} \prov c \star \nu : S\star \nu }
\]
For any $I$ we have
$\sem{ c}_I : (\rho : \sem \Gamma_I) \to \sem {\fC}_I$
and we set
\begin{defnbox}
  \begin{tabbing}
    \hspace*{2em}\=\hspace*{2em}\=\kill
    $\sem{ c \star \nu}_I :  (\rho : \sem {\Gamma, \nu : {\sharp n}}_I) \to \sem {S \star \nu}_I(\rho)$\\
    $\sem{c \star \nu}_I (\rho, \nu := i) = \sem c_{I\wo i}(\rho)$\\
    $\sem{c \star \nu}_I (\rho, \nu := \atm k) = \sem {\ff_k}_I(\sem c_{I}(\rho))$
  \end{tabbing}
\end{defnbox}
\subsubsection{$\eta$ equivalence}
We want to confirm that
\begin{thmbox}
  \[ (\pbind \nu M)\star \nu' \equiv_\eta [\nu'/\nu]M\]
\end{thmbox}
or semantically that
\[ (\rho' : \sem{\Gamma, \nu' : {\sharp n}}_I) \to \sem { (\pbind \nu M) \star \nu' }_I(\rho') \equiv \sem {[\nu'/\nu] M}_I(\rho')\]
Split cases on $\rho'$.

If $\rho' = (\rho, \nu' := i)$, then we're trying to show
\[\sem { (\pbind \nu M) }_{I\wo i}(\rho) \equiv \sem {[\nu'/\nu]M}_I(\rho, \nu' := i)\]
in other words
\[\sem { M }_{I}(\rho, \nu := i) \equiv \sem {[\nu'/\nu]M}_I(\rho, \nu' := i)\]
which is true by $\alpha$-equivalence.

If $\rho' = (\rho, \nu' := \atm k)$, then we're trying to show
\[\sem {\ff_k}_I(\sem {\pbind \nu M}_I(\rho)) \equiv \sem {[\nu'/\nu]M}_I(\rho, \nu' := \atm k)\]
in other words
\[\sem {\ff_k}_I(\sem { M}_{I,i}(\rho, \nu := i)) \equiv \sem {[\nu'/\nu]M}_I(\rho, \nu' := \atm k)\]
by $\alpha$-equivalence
\[\sem {\ff_k}_I(\sem { M}_{I,i}(\rho, \nu := i)) \equiv \sem {M}_I(\rho, \nu := \atm k)\]
which I suppose ought to be stated on its own as a lemma.
\begin{lemma}
Suppose $\Gamma, \nu : {\sharp n}  \prov e : S \star \nu$.
Then
\[\sem {\ff_k}_I(\sem { e}_{I,i}(\rho, \nu := i)) \equiv \sem {e}_I(\rho, \nu := \atm k)\]
\end{lemma}

\begin{proof}
There is a substitution $I \prov (i := \atm k) : I, i $
which is the identity on the rest of $I$.
So
\[\sem {S\star \nu}_{i := \atm k} : (\rho' : \sem{ \Gamma, \nu: {\sharp n}}_{I,i}) \to \sem {S\star \nu}_{I, i}(\rho') \to \sem {S\star \nu}_I(\sem {\Gamma, \nu:{\sharp n}}_{i := \atm k}(\rho'))\]
and by the general fact that
\[(\rho : \sem \Gamma_I) \to \sem A_\sigma (\sem M_I(\rho)) \equiv \sem M_J(\sem \Gamma_\sigma(\rho)) \]
we specifically have
\[(\rho' : \sem {\Gamma, \nu : \sharp n}_{I,i}) \to \sem {S\star \nu}_{i := \atm k} (\sem e_{I,i}(\rho')) \equiv \sem e_I(\sem {\Gamma, \nu : \sharp n}_{i := \atm k}(\rho')) \]
but then we observe that
\[\sem {\Gamma, \nu : \sharp n}_{i := \atm k}(\rho, \nu := i) \equiv
(\rho, \nu := \atm k)\]
by definition of $i := \atm k$.
From this, the only remaining proof burden is
\[\sem {S\star \nu}_{i := \atm k} (\sem e_{I,i}(\rho, \nu:= i)) \equiv \sem {\ff_k}_I(\sem { e}_{I,i}(\rho, \nu := i))\]
but this follows from unpacking the definition of $\sem {S \star \nu}_{i := \atm k}$. \cqed
\end{proof}


\subsubsection{$\beta$ equivalence}
We want to confirm that
\begin{thmbox}
  \[ \pbind \nu (e \star \nu) \equiv_\beta e \]
\end{thmbox}
i.e. semantically
\[ (\rho : \sem{\Gamma}_I) \to \sem { (\pbind \nu (e \star \nu) }_I(\rho) \equiv \sem { e}_I(\rho)\]
but this is just checking that
\[ \sem {  e \star \nu }_{I,i}(\rho, \nu := i) \equiv \sem { e}_I(\rho)\]
which is true by definition of $\sem{e\star \nu}_{I,i}$.

\subsection{$\sharp$ elim}
We want to interpret
\[
\erule
{
\begin{tabular}{c}
$\Gamma, k : n, x :  [\atm k / \nu]B \prov e : [\atm k / \nu]D$\\
$\Gamma, x' : \forall B, \nu : \sharp n  \prov e' : D$\\
 $[x'\ \atm k/x]e \equiv [\atm k/\nu']e'$
\end{tabular}
}
{\Gamma, \nu : \sharp n, y : B \prov \bcase (\nu,y) \bof (\atm k,x).e \celse (\nu',x').e' : D}
\]
which tacitly assumes
\[\Gamma, \nu : {\sharp n} \prov B : \rset\]
\[\Gamma, \nu : {\sharp n} \prov D : \rset\]
So we get to assume that
\[\sem e_I : (\rho : \sem {\Gamma, k : n, x : [\atm k/\nu]B}_I) \to
\sem D_I(\rho \adjust_\Gamma, \nu := \atm k)
\]
%
\[\sem {e'}_I : (\rho' : \sem {\Gamma, x' : \forall  B, \nu : {\sharp n}}_I)  \to
\sem D_I(\rho'\adjust_{\Gamma,\nu})
\]
%
and that
\[\sem e_I(\rho, k := k, x := x'\ \atm k)  \equiv \sem {e'}_I(\rho, x' := x', \nu := \atm k) \]

\noindent We define
\begin{defnbox}
  \begin{tabbing}
    \hspace*{2em}\=\hspace*{2em}\=\kill
    \(\sem {\bcase \cdots}_I : (\rho' : \sem {\Gamma, \nu : {\sharp n}, y : B}_I) \to
    \sem D_I(\rho')\)\\
    $\sem {\bcase \cdots}_I(\rho, \nu := \atm k, y := y) = \sem e_I(\rho, k := k, x := y)$\\
    $\sem {\bcase \cdots}_I(\rho, \nu := i, y := y) = \sem{e'}_I (\rho, x' := y, \nu := i)$
  \end{tabbing}
\end{defnbox}
Why is this type-correct?
We have in the $\nu := i$ case that $\rho : \sem \Gamma_{I\wo i}$
and  $y : \sem B_I(\rho, \nu := i)$.
We need to check that the thing being substituted for $x'$
 has type $\sem {\forall B}_{I\wo i}(\rho)$.
But by definition
\[\sem {\forall  B}_I (\rho) = \sem {B}_{I, i}(\rho, \nu : i)\]
so indeed $y : \sem{B}_{I\wo i, i}(\rho, \nu := i)$ as required.

For the functoriality part,
\begin{defnbox}
  \begin{tabbing}
    \hspace*{2em}\=\hspace*{2em}\=\kill
    \(\sem {\bcase \cdots}_\sigma : (\rho' : \sem {\Gamma, \nu : {\sharp n}, y : B}_I) \to\)\\
   \> \( \sem D_I(\rho'\adjust_{\Gamma,\nu}) \to \sem D_J(\sem {\Gamma,\nu:\sharp n}_\sigma(\rho'\adjust_{\Gamma,\nu}))\)\\
    $\sem {\bcase \cdots}_\sigma\{\rho, \nu := \atm k, y := y\}(z) = \sem e_\sigma\{\rho, k := k, x := y\}(z)$\\
    $\sem {\bcase \cdots}_\sigma\{\rho, \nu := i, y := y\}(z) = \sem{e'}_\sigma \{\rho, x' := y, \nu := i\}(z)$
  \end{tabbing}
\end{defnbox}
We get to assume generally about $e$ and $e'$ that
\[\sem e_\sigma : (\rho' : \sem {\Gamma, k : n, x : [\atm k/\nu]B}_I)
\to \sem D_I(\rho' \adjust_\Gamma, \nu := \atm k)\]
\[\to \sem {D}_J(\sem {\Gamma}_\sigma(\rho' \adjust_\Gamma), \nu := \atm k)
\]
%
\[\sem {e'}_\sigma : (\rho' : \sem {\Gamma, x' : \forall  B, \nu : {\sharp n}}_I)  \to
\sem D_I(\rho'\adjust_{\Gamma,\nu})
\]
\[ \to \sem D_J(\sem{\Gamma, \nu : \sharp n}_\sigma(\rho'\adjust_{\Gamma,\nu})) \]
%

In the $\nu = \atm k$ case we get to assume $\rho : \sem \Gamma_I$ and $y : \sem B_I(\rho, \nu := \atm k)$ and $z : \sem D_I(\rho, \nu := \atm k)$. The goal type
is $\sem D_J(\sem\Gamma_\sigma(\rho), \nu = \atm k)$ and this is exactly what
$\sem e_\sigma\{\rho, k := k, x := y\}(z)$ gives.

In the $\nu = i$ case we get to assume $\rho : \sem \Gamma_{I\wo i}$ and $y : \sem B(\rho, \nu := i)$ and $z : \sem D_I(\rho, \nu := i)$.
 The goal type is $\sem D_J(\sem \Gamma_{\sigma \wo i}, \nu := \sigma(i))$
and this is exactly what $ \sem{e'}_\sigma \{\rho, x' := y, \nu := i\}(z)$ gives.

\textbf{Why haven't I used the equation premise of the rule yet?}
I expect it is required for a substitution compatibility lemma.

\section{Generalizing to Functorial $\sharp$}
\subsection{Syntax}
We can expand syntax of expressions of interval type to include functions
applied to variables, so that $\sharp$ is a functor.
\[\hbox{Interval Expressions }\mu ::=  \sharp g(\nu) \celse \atm k\]
with variable rule
\[
\erule
{g : m \to n}
{\Gamma, \nu : \sharp m \prov \sharp g(\nu) : \sharp n}
\]
A bare occurrence of a variable $\nu : \sharp n$ is then an abbreviation
for $\sharp \rid_n(\nu)$. The definition of formation, introduction, and elimination
of $\star$ doesn't change, but we need to generalize the definition of substitution
of interval expressions into $\star$-types. Say $\nu' : \sharp n$ and $\nu : \sharp n'$. Then
\begin{tabbing}
\hspace*{2em}\=$\langle$\=\hspace*{1em}\=\kill
$ [\sharp g(\nu) / \nu'](S \star \nu') =$\\
\>$\langle$\> $ \fC $\>$= S.\fC, $\\
\>\> $ \fA $\>$= \lambda k. S.\fA_{g(k)}, $\\
\>\> $ \ff $\>$= \lambda k. S.\ff_{g(k)}  \rangle \star \nu $
\end{tabbing}
For terms of $\star$-type,
\[ [\sharp g(\nu) / \nu'](c \star \nu') = c \star \nu\]

We leave the $\bcase$ rule
\[
\erule
{
\begin{tabular}{c}
$\Gamma, k : n, b :  [\atm k / \nu]B \prov e : [\atm k / \nu]D$\\
$\Gamma, b' : \forall B, \nu : \sharp n  \prov e' : [b'\ \nu/b]D$\\
 $[b'\ \atm k/b]e \equiv [\atm k/\nu]e'$
\end{tabular}
}
{\Gamma, \nu : \sharp n, y : B \prov \bcase (\nu,y) \bof (\atm k,b).e \celse (\nu,b').e' : D}
\]
 as it is, (although I've silently generalized it to the dependent case, \textcolor{red}{XXX go back and fix that in the earlier bits})
 but now we have to say what it means when we substitute in some
$\sharp g(\nu_0)$ for $\nu$ and $g : n_0 \to n$.

\[ [\sharp g(\nu_0) / \nu](\bcase (\nu,y) \bof (\atm k,b).e \celse (\nu,b').e') = \]
\[ \bcase (\nu,y) \bof (\atm k,b).e \celse (\nu,b').e' \]
Let $B_0 = [\sharp g(\nu_0) / \nu]B$
and $D_0 = [\sharp g(\nu_0) / \nu]D$
and $e_0 = [g(k_0)/k]e$
and we can check
\[
\erule
{
\begin{tabular}{c}
$\Gamma, k_0 : n_0, b :  [\atm k / \nu_0]B_0 \prov e_0 : [\atm k / \nu_0]D_0$\\
$\Gamma, b'_0 : \forall B_0, \nu_0 : \sharp n  \prov \textcolor{red}{???} : [b'_0\ \nu_0/b]D_0$
\end{tabular}
}
{\Gamma, \nu_0 : \sharp n, y : B_0 \prov \bcase (\nu_0,y) \bof (\atm k,b).e \celse (\nu_0,b'_0).e' : D_0}
\]

The first premise expands to
$\Gamma, k_0 : n_0, b :  [\atm {g(k_0)} / \nu]B \prov [g(k_0)/k]e : [\atm {g(k_0)} / \nu]D$
which is a substitution instance of the typing of $e$.

The second premise expands to... oh whoops. I can't seem to find anything
to substitute for $b'$ that I can make out of $b'_0$.
The type $(\nu_0 : \sharp n_0) \to [\sharp g(\nu_0)/\nu] B$
is {\em less} general than
$(\nu : \sharp n) \to  B$!
\subsection{A Fix For This Problem}

I think the solution is to generalize the rule slightly. Since
in the semantics there are more possibilities for a `value' of type $\sharp n$,
we have to do a more wide-ranging case analysis.

Maybe the rule goes
\[
\erule
{
\begin{tabular}{c}
$\Gamma, k : n, b :  [\atm k / \nu]B \prov e : [\atm k / \nu]D$\\
$\Gamma, b' : ( \omega : \sharp m) \to [\sharp g(\omega)/\nu]B, \nu : \sharp n  \prov e' : [b'\ \nu/b]D$\\
 $[b'\ \atm k/b]e \equiv [\atm k/\nu]e'$
\end{tabular}
}
{\Gamma, \nu : \sharp n, y : B \prov \bcase (\nu,y) \bof (\atm k,b).e \celse (\nu,b').e' : D}
\]

\end{document}
