\documentclass{article}
\input{theorem}
\input{prooftree}
\usepackage{stmaryrd}
\usepackage{latexsym}
\usepackage{yfonts}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,cd,decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}
\usepackage{tcolorbox}
\tcbuselibrary{breakable}


\def\El#1{\mathsf{El}({#1})}
\def\quote#1{{\ulcorner {#1} \urcorner}}
\def\U{\mathsf{U}}
\def\uni{\U}
\def\mor#1#2{#1 \to \underline{#2}}

\def\ridp{\mathsf{idp}}
\def\fc{\mathfrak{C}}
\def\ff{\mathfrak{F}}
\def\ssem#1{\langle\!\langle{#1}\rangle\!\rangle}

\definecolor{cyan}{rgb}{0.80,0.95,0.95}
\definecolor{orange}{rgb}{0.95,0.90,0.80}
\definecolor{lred}{rgb}{0.95,0.8,0.8}
\definecolor{lgray}{gray}{0.9}
\newtcolorbox{declbox}{colframe=lred,colback=lred,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{thmbox}{colframe=cyan,colback=cyan,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{defnbox}{colframe=orange,colback=orange,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{tangentbox}{colframe=lgray,colback=lgray,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}

\input{linear}
\def\rpath#1{[#1]}
\def\rfst{\mathsf{fst}\,}
\def\rsnd{\mathsf{snd}\,}
\def\bunfold{\mathbf{unfold}}
\def\bfold{\mathbf{fold}}
\def\susp#1{\langle {#1} \rangle}
\def\ssusp#1{\langle\!\langle {#1} \rangle\!\rangle}
\def\dto{\mathrel{\dot\to}}
\def\dns{{\downarrow}}
\def\ups{{\uparrow}}
\def\sprov{\Vdash}
\def\signat{{\color{red}\Sigma}}

\def\wat{\mathbin{@}}
\def\wwat{\mathbin{\underline\wat}}
\def\cn{{:}}
\def\dv{{\div}}
\def\ww{{\mathsf w}}
\def\base{{\textfrak b}}

\def\N{{\mathbb N}}
\def\munit{I}
\def\tt{{\mathsf t}}
\def\rr{{\mathsf r}}
\def\ii{{\mathbb I}}
\def\pp{\textsf{\textbf p}}
\def\nn{{\mathsf n}}
\def\PP{\textsf{\textbf P}}
\def\NN{{\mathsf N}}
\def\zz{{\mathsf z}}
\def\sem#1{[\![#1]\!]}
\def\usem#1{\lceil\!\!\lceil{#1}\rceil\!\!\rceil}
\def\zem#1{\langle\!\langle#1\rangle\!\rangle}
\def\col#1{{\mathsf{C}}_{#1}}
\def\lax{\mathop\bigcirc}
\def\rjust{\mathsf{just}}
\def\rcvt{\mathsf{cvt}}
\def\rtype{\mathsf{type}}
\def\rkind{\mathsf{kind}}
\def\rmode{\mathsf{mode}}
\def\rprel{\mathbf{Prel}}
\def\rrfam{\mathbf{Rfam}}
\def\rset{\mathbf{Set}}
\def\rfinset{\mathbf{FinSet}}
\def\rrel{\mathbf{Rel}}
\def\rcat{\mathbf{Cat}}
\def\rfam{\mathbf{Fam}}
\def\binj{\mathbf{inj}}
\def\rid{\mathsf{id}}
\def\rtrue{\mathrel\mathrm{true}}
\def\pbck{\ar[dr, phantom, pos=0, "\lrcorner"]}
\def\bpbck{\ar[ddrr, phantom, pos=0, "\lrcorner"]}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\btwo{\mathbf{2}}
\def\bone{\mathbf{1}}

\newarrow {Equiv} =====
\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\def\mapt{\ar[ddd,mapsto,shorten <=2em, shorten >=2em]}
\def\frommaps{\ar[from=uu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\frommapt{\ar[from=uuu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\C{\mathbf{C}}
\def\W{\mathbf{W}}
\def\S{\mathbf{S}}
\def\D{\mathbf{D}}
\def\E{\mathbf{E}}
\def\M{\mathbf{M}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\tri{\triangleright}
\def\o{\circ}
\def\rctx{\,\mathsf{ctx}}
\def\del{\partial}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\null{\emptyset}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\definecolor{fib}{HTML}{ff7f00}
\definecolor{green}{HTML}{007f00}
\definecolor{red}{HTML}{df3f3f}
\definecolor{opfib}{HTML}{007fff}

% For lightening colors I used
% http://trycolors.com/ 6 parts white to 1 part color
\definecolor{opfibl}{HTML}{DBEDFF}
\definecolor{greenl}{HTML}{DBEDDB}
\definecolor{redl}{HTML}{FAE4E4}
\def\njudge#1{\fcolorbox{opfib}{white}{#1}}
\def\nrule#1{\fcolorbox{white}{opfibl}{#1}}
\def\neqn#1{\fcolorbox{white}{redl}{#1}}



\def\judge#1{\vskip 2em\noindent \njudge{$#1$}\vskip 0.5em\noindent}
\def\rule#1{\vskip 2em \noindent \nrule{$#1$}\vskip 0.5em\noindent}
\def\eqn#1{\vskip 2em \noindent \neqn{$#1$}\vskip 0.5em\noindent}
\def\prof{\nrightarrow}
\def\tensor{\otimes}
\def\htensor{\mathrel{\hat\otimes}}
\def\lol{\multimap}
\def\hlol{\mathrel{\hat\multimap}}
\def\wtf{{\color{red}???}}

\def\re{\mathbf{E}}
\def\shp{\mathrel{\sharp}}
\def\zero{\texttt{0}}
\begin{document}

\def\
\tikzset{
   commutative diagrams/.cd,
   arrow style=tikz,
   diagrams={>=stealth}}

\section{On Mode Theories}

\def\mode{\mathsf{Mode}}
\def\rty{\mathsf{Ty}}
\def\rtm{\mathsf{Tm}}
\def\res{\mathsf{Res}}
I had written down that rhe nondependent mode theory makes you specify
\begin{tabbing}
\hspace*{2em}\=\hspace*{2em}\= \kill
$\mode : \rset$\\
$\res : (\mode, \pm) \to \rset$\\
$\tri : (\mu : \mode) \to \res(\mu, +) \to \res(\mu, -) \to \rset$\\
$\Omega : \rset$\\
$\iota : \Omega \to [\mode, \pm]$\\
$o : \Omega \to (\mode, \pm)$\\
$R : (\omega : \Omega) \to [\mathsf{map}\ \res\ (\iota\ \omega)] \to \res(o\ \omega) \to \rset$
\end{tabbing}
But what's really going on is that $\mode$ is a set of types and $\res$ is a set of terms.
I could instead write this as
\begin{tabbing}
\hspace*{2em}\=\hspace*{2em}\= \kill
$\rty : \rset$\\
$\rtm : (\rty, \pm) \to \rset$\\
$\tri : (\mu : \rty) \to \rtm(\mu, +) \to \rtm(\mu, -) \to \rset$\\
$\Omega : \rset$\\
$\iota : \Omega \to [\rty, \pm]$\\
$o : \Omega \to (\rty, \pm)$\\
$R : (\omega : \Omega) \to [\mathsf{map}\ \rtm\ (\iota\ \omega)] \to \rtm(o\ \omega) \to \rset$
\end{tabbing}
Or even
\begin{tabbing}
\hspace*{2em}\=\hspace*{2em}\= \kill
$\rty : \rset$\\
$\rtm : (\rty, \pm) \to \rset$\\
$\tri : (\mu : \rty) \to \rtm(\mu, +) \to \rtm(\mu, -) \to \rset$\\
$\Omega : [\rty, \pm] \to (\rty, \pm) \to \rset$\\
$R : (\iota : [\rty, \pm]) (o : (\rty, \pm)) \to \Omega\ \iota\ o \to  [\mathsf{map}\ \rtm\ \iota] \to \rtm(o) \to \rset$
\end{tabbing}

So what am I doing? I'm giving a little (polarized) type theory, I'm giving a bunch of (typed) function
symbols $\Omega$, and I say how they induce relations on terms of their arguments. I also give a relation
between the positive and negative variants of a type.

This induces a propositional language where for each function symbol in $\Omega$ I get a propositional
connective, and also I get shifts.

One level of generality up, I sort of project out the shift-multiplicative distinction,
and say that I have like
\begin{tabbing}
\hspace*{2em}\=\hspace*{2em}\= \kill
$\rty : \rset$\\
$\rtm : \rty \to \rset$\\
$\Omega : \Pi \to [\rty] \to \rty \to \rset$\\
$R : (\pi : \Pi) (\iota : [\rty]) (o : \rty) \to \Omega\ \pi\ \iota\ o \to  [\mathsf{map}\ \rtm\ \iota] \to \rtm(o) \to \rset$
\end{tabbing}
where $\Pi = \{\mathbf{m}, \mathbf{s}\}$, the set of `postures', multiplicative or shift-like.

\vfil\eject

So like what's the dependent case? Someone tells me what
mode types and terms exist in what contexts.
\[
\begin{tabular}{r@{$\quad$}c@{$\quad::=\quad$ }l}
  Mode Contexts&$\Delta$&$\cdot \celse \Delta, x: \alpha$\\
  Mode Types&$\alpha$&$\cdots $\\
  Mode Terms&$\mu$&$\cdots $
\end{tabular}
\]
For linear logic (including a modal zone of unrestrictedly true assumptions) this is like
\[
\begin{tabular}{r@{$\quad$}c@{$\quad::=\quad$ }l}
  Mode Types&$\alpha$&$\ell^+ \celse \ell^- \celse t^- \celse t^+ $\\
  Mode Terms&$\mu$&$x \celse \mu \lol \mu \celse {\mu \tensor \mu} \celse F \mu \celse U \mu$
\end{tabular}
\]
The mode terms valid in a context would be given by some typing rules, e.g.
\[
\erule
{\Gamma \prov \mu : \ell^+ \qquad \Gamma \prov \mu' : \ell^-}
{\Gamma \prov \mu \lol \mu' : \ell^-}
\]

I then have a collection of term constructors, which generate the syntax of propositions
\[
\begin{tabular}{r@{$\quad$}c@{$\quad::=\quad$ }l}
  Connectives&$c$&${\lol} \celse {\tensor} \celse F \celse U$
\end{tabular}
\]
These are typed. An example typing axiom would be
\[
\erule
{}
{x : \ell^+, y : \ell^- \prov {\lol} : \ell^-}
\]

The mode theory is
 also supposed to supply a relation $R_c$ for each $\Delta \prov c : \alpha$.
\[
\erule
{}
{R_c : \rset}
\]
If I give a (`closed'?) substitution $\sigma$ of terms for $\Gamma$, and
a term of type $\sigma\mu$, then $R_f$ gives me a truth-value/set/whatever.

I'm going to call the original set of terms the `hard' terms, and
things built out of only the $f$s `soft' terms. For each closed soft term I can
produce a proposition indexed by hard terms of the same type.

I'm really building a relation between hard terms and soft terms:
we say $f[\sigma]$ is related to a hard term $t$
\begin{enumerate}
\item  (if $f$ has posture $\mathbf{m}$)
  when there {\bf exists} a vector of hard terms $\eta$ related to $\sigma$
  such that $f$'s builtin relation relates $\eta$ to $t$.

\item  (if $f$ has posture $\mathbf{s}$)
  when for {\bf all} vectors of hard terms $\eta$ related to $\sigma$, we have
  that
  $f$'s builtin relation relates $\eta$ to $t$.
\end{enumerate}
\end{document}
