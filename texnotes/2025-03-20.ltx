\documentclass{article}
\usepackage[tmargin=0.15in, bmargin=0.15in]{geometry}
\input{theorem}
\input{prooftree}
\usepackage{relsize}
\usepackage{latexsym}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,cd,decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}
\usepackage{tcolorbox}
\usepackage{stackengine}
\newcommand\oast{\stackMath\mathbin{\stackinset{c}{0ex}{c}{0ex}{\ast}{\bigcirc}}}

\tcbuselibrary{breakable}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}

\def\wt{\widetilde}
\def\tel{\mathsf{T}}
\def\bdot{\mathrel{\bar\cdot}}
\def\bodot{\mathrel{\bar\odot}}
\def\dec{\mathsf{\downarrow}}
\def\enc{\mathsf{\uparrow}}
\def\I{\mathbb{I}}
\def\bget{\mathop{\mathbf{get}}\nolimits}
\def\bGel{\mathop{\mathbf{Gel}}\nolimits}
\def\bgel{\mathop{\mathbf{gel}}\nolimits}
\def\bgbound{\mathop{\mathbf{gbound}}\nolimits}
\def\bgpath{\mathop{\mathbf{gpath}}\nolimits}
\def\bungel{\mathop{\mathbf{ungel}}\nolimits}
\def\bGet{\mathop\mathbf{Get}}
\def\dapt#1#2{#1[\![#2]\!]}
\def\dap#1#2{#1\{#2\}}
\def\ll{\langle\!\langle}
\def\rr{\rangle\!\rangle}
\def\rshape{\ {\mathsf{shape}}}
\def\rrefl{{\mathsf{refl}}}
\def\bd{\mathsf{Bd}}
\def\bdd{\mathsf{Bdd}}
\def\rset{\mathsf{U}}
\def\rid{\mathsf{id}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\prequiv{\dashv\vdash}

\definecolor{blu}{rgb}{0.1,0.5,1}
\definecolor{orng}{rgb}{1,0.5,0.3}

\def\nameof#1{\ulcorner{#1}\urcorner}
\def\U{\mathsf{U}}
\def\uu{\mathsf{u}}
\def\uni{\U}



\definecolor{lred}{rgb}{0.95,0.8,0.8}
\definecolor{cyan}{rgb}{0.80,0.95,0.95}
\definecolor{lorange}{rgb}{0.95,0.90,0.80}
\definecolor{bluegray}{rgb}{0.6,0.6,0.85}
\definecolor{lgray}{gray}{0.8}
\newtcolorbox{declbox}{colframe=lred,colback=lred,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{thmbox}{colframe=cyan,colback=cyan,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{defnbox}{colframe=lorange,colback=lorange,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{tangentbox}{colframe=lgray,colback=lgray,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}

\input{linear}
\def\J{\mathbb{J}}
\def\R{\mathcal{R}}
\def\rpath#1{[#1]}
\def\rfst{\mathsf{fst}\,}
\def\rsnd{\mathsf{snd}\,}
\def\bunfold{\mathbf{unfold}}
\def\bfold{\mathbf{fold}}
\def\susp#1{\langle {#1} \rangle}
\def\ssusp#1{\langle\!\langle {#1} \rangle\!\rangle}
\def\dto{\mathrel{\dot\to}}
\def\dns{{\downarrow}}
\def\ups{{\uparrow}}
\def\sprov{\Vdash}
\def\signat{{\color{red}\Sigma}}
\def\ep#1{\underline{#1}}
\def\wat{{@}}
\def\wwat{\mathbin{\underline\wat}}
\def\cn{{:}}
\def\dv{{\div}}
\def\ww{{\mathsf w}}
\def\base{{\textfrak b}}

\def\N{{\mathbb N}}
\def\Z{{\mathbb Z}}
\def\munit{I}
\def\tt{{\mathsf t}}
\def\ii{{\mathbb I}}
\def\T{\mathbb{T}}
\def\tw{\mathsf{Tw}}
\def\sw#1{^{#1}_{#1}}
\def\TP{\mathbf{TPre}}
\def\pp{\textsf{\textbf p}}
\def\nn{{\mathsf n}}
\def\PP{\textsf{\textbf P}}
\def\NN{\textsf{\textbf N}}
\def\zz{{\mathsf z}}
\def\sem#1{[\![#1]\!]}
\def\usem#1{\lceil\!\!\lceil{#1}\rceil\!\!\rceil}
\def\zem#1{\langle\!\langle#1\rangle\!\rangle}
\def\col#1{{\mathsf{C}}_{#1}}
\def\lax{\mathop\bigcirc}
\def\rjust{\mathsf{just}}
\def\rcvt{\mathsf{cvt}}
\def\rtype{\mathsf{type}}
\def\rdtype{\mathsf{disc}}
\def\rkind{\mathsf{kind}}
\def\rmode{\mathsf{mode}}
\def\rprel{\mathbf{Prel}}
\def\rrfam{\mathbf{Rfam}}
%\def\rset{\mathbf{Set}}
\def\rfinset{\mathbf{FinSet}}
\def\rrel{\mathbf{Rel}}
\def\rcat{\mathbf{Cat}}
\def\rfam{\mathbf{Fam}}
\def\binj{\mathbf{inj}}
\def\rtrue{\mathrel\mathrm{true}}
\def\pbck{\ar[dr, phantom, pos=0, "\lrcorner"]}
\def\bpbck{\ar[ddrr, phantom, pos=0, "\lrcorner"]}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\btwo{\mathbf{2}}
\def\bone{\mathbf{1}}

\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\def\mapt{\ar[ddd,mapsto,shorten <=2em, shorten >=2em]}
\def\A{\mathbf{A}}
\def\B{\mathbf{B}}
\def\C{\mathbf{C}}
\def\S{\mathbf{S}}
\def\G{\mathbf{G}}
\def\D{\mathbf{D}}
\def\DD{\mathbb{D}}
\def\E{\mathcal{E}}
\def\M{\mathbf{M}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\ltri{{\lhd}}
\def\rtri{{\rhd}}
\def\tri{\rhd}
\def\cc{\mathsf{c}}
\def\dd{\mathsf{d}}
\def\o{\circ}
\def\rctx{\,\mathsf{ctx}}
\def\rdctx{\,\mathsf{dctx}}
\def\del{\partial}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\definecolor{fib}{HTML}{ff7f00}
\definecolor{green}{HTML}{007f00}
\definecolor{red}{HTML}{df3f3f}
\definecolor{opfib}{HTML}{007fff}

% For lightening colors I used
% http://trycolors.com/ 6 parts white to 1 part color
\definecolor{opfibl}{HTML}{DBEDFF}
\definecolor{greenl}{HTML}{DBEDDB}
\definecolor{redl}{HTML}{FAE4E4}

% https://tex.stackexchange.com/questions/716631/curved-arrows-from-tikz-cd-do-not-work
\tikzset{
  curve/.style={
    settings={#1},
    to path={
      (\tikztostart)
      .. controls ($(\tikztostart)!\pv{pos}!(\tikztotarget)!\pv{height}!270:(\tikztotarget)$)
      and ($(\tikztostart)!1-\pv{pos}!(\tikztotarget)!\pv{height}!270:(\tikztotarget)$)
      .. (\tikztotarget)\tikztonodes
    },
  },
  settings/.code={%
    \tikzset{quiver/.cd,#1}%
    \def\pv##1{\pgfkeysvalueof{/tikz/quiver/##1}}%
  },
  quiver/.cd,
  pos/.initial=0.35,
  height/.initial=0,
}

\begin{document}

\def\
\tikzset{
   commutative diagrams/.cd,
   arrow style=tikz,
   diagrams={>=stealth}}
\tikzset{shorten <>/.style={shorten >=#1,shorten <=#1}}


\def\bj{\bar\jmath}
\section{Parametricity via Parametricity}
Fix a shape type $S$. For example, $S$ could be $2$ for binary parametricity.
Let $\J$ be the dependent record type
\[\{\I : \rset, \eta : S \to \I, i : \I\}\]
There are some particular elements of $\J$ that are of interest. They are
\[j_\star : \J\]
\[j_\star = \{\I = S + 1, \eta = \binl, i = \binr \star\}\]
and
\[\bj : S \to \J\]
\[\bj\ s = \{\I = S , \eta = \rid, i = s\}\]
There's an evident notion of $\J$-homomorphism, and, for each $s \in S$, an evident $\J$-homomorphism
 $j_\star \to \bj\ s$. It is the unique map $f : S + 1 \to S$ which has  $f \o \binl \equiv \rid$ and $f (\binr \star) = s$.


We can define
\[\bGel :  \I \to \rset\]
parameterized by
\[(R : \rset)\ ( A : S \to \rset)\ ( p : (s : S) \to R \to A\ s)\ (\I : \rset)\ (\eta : S \to \I)\]
with the constructors
\[ \begin{array}{r@{\ }l}
\bgel &: (r : R)(i : \I) \to \bGel\ i\\
\bgbound &: (s : S) (a : A\ s) \to \bGel\ (\eta\ s)\\
\bgpath &: (s : S) (r : R) \to \bgel\ r\ (\eta\ s) \equiv \bgbound\ s\ (p\ s\ r)\\
\end{array}\]

Now we can let $\R$ be the record type
\[\{R : \rset, A : S \to \rset, p : (s : S) \to R \to A\ s\} \]
And it should be clear what we mean by $\bGel_\rho\ j$ for $\rho : \R$ and $j : \J$.

Important claim:
\[ \bGel_\rho\ j_\star \cong R \]
\[ \bGel_\rho\ (\bj\ s) \cong A\ s \]

We proceed by acting as if $\J$ and $\bGel$ are primitive types where these isomorphisms hold definitionally.

Binary parametricity tells us that for any closed type $A$ we should have a binary relation
\[\sem A : A \to A \to \rset\]
and we should have for any closed $a : A$ that
\[\sem A\ a\ a\]
For example, if
\[M : (j : \J) \to A\ j \to B\ j\]
we should find
\[\sem{(j : \J) \to A\ j \to B\ j}\ M\ M \]

What is the relation for a $\Pi$-type? We get stuck at the definition
\[\sem{ (a : A) \to B\ a} : ((a : A) \to B\ a) \to ((a : A) \to B\ a) \to \rset\]
\[\sem{ (a : A) \to B\ a}\ f_1\ f_2 = (a_1\ a_2 : A) \to \sem A\ a_1\ a_2 \to \sem {?}\ (f_1\ a_1)\ (f_2\ a_2)\]
because there is no common type that $(f_1\ a_1), (f_2\ a_2)$ have. We must generalize to open types.
If $\Gamma \prov A$ is a type, then
\[ \sem{\Gamma \prov A} : (\theta_1\ \theta_2 : \Gamma) \to [\theta_1]A \to [\theta_2]A \to \rset \]
Then we can define
\[\begin{array}{l}
\sem{ \Gamma \prov (a : A) \to B\ a}\ \theta_1\ \theta_2\ f_1\ f_2 = (a_1\ a_2 : A) \\
\qquad\to \sem A\ \theta_1\ \theta_2\ a_1\ a_2 \\
\qquad\to  \sem {\Gamma, a : A \prov B\ a}\ \theta_1[a_1/a]\ \theta_2[a_2/a]\ (f_1\ a_1)\ (f_2\ a_2)
\end{array}\]
Instantiating with $(j : \J) \to A\ j$, we get that if
\[ M : (j : \J) \to A\ j\]
then there is some inhabitant of
\[\sem{\cdot \prov  (j : \J) \to A\ j}\ \cdot\ \cdot\ M\ M\]
which means we have an inhabitant of
\[\begin{array}{l}
 (j_1\ j_2 : \J) \\
\qquad\to \sem \J\ \cdot\ \cdot\ j_1\ j_2 \\
\qquad\to  \sem {\Gamma, j : \J \prov A\ j}\ [j_1/j]\ [j_2/j]\ (M\ j_1)\ (M\ j_2)
\end{array}\]
In particular, picking values for $j_1, j_2$ gives us
\[\begin{array}{l}
 \sem \J\ \cdot\ \cdot\ j_\star\ (\bj\ s) \\
\qquad\to  \sem {\Gamma, j : \J \prov A\ j}\ [j_\star/j]\ [\bj s/j]\ (M\ j_\star)\ (M\ (\bj\ s))
\end{array}\]

Wait I made an error in the definition. I need relations from sets in the substitution.
\subsection{Starting Over}
If $\Gamma$ is a context, then
\[\sem\Gamma : (\theta_1\ \theta_2 : \Gamma) \to \rset \]
is a relation over closed substitutions for $\Gamma$.
If $\Gamma \prov A$ is a type, then
\[ \sem{\Gamma \prov A} : (\theta_1\ \theta_2 : \Gamma) \to \sem \Gamma\ \theta_1\ \theta_2 \to [\theta_1]A \to [\theta_2]A \to \rset \]


$\sem \cdot$ is the trivial relation that does relate the two empty substitutions.
The cons case for contexts is
\[\sem {\Gamma, x : A}\ (\theta_1[M_1/x])\ (\theta_2[M_2/x]) = \]
\[(p : \sem\Gamma\ \theta_1\ \theta_2) \x  \sem{\Gamma \prov A}\ \theta_1\ \theta_2\ p\ M_1\ M_2\]
The universe case is
\[ \sem{\Gamma \prov \rset}\ \theta_1\ \theta_2\ p\ A_1\ A_2 = A_1 \to A_2 \to \rset\]
The variable case is
\[ \sem{\Gamma , \alpha : \rset, \Gamma' \prov \alpha}\ (\theta_1 [A_1/\alpha]\theta_1')\ (\theta_2 [A_2/\alpha]\theta_2')\ \langle \cdots, R,\cdots \rangle\ a_1\ a_2 = R\ a_1\ a_2\]
The function case is
\[\begin{array}{l}
\sem{ \Gamma \prov (a : A) \to B\ a}\ \theta_1\ \theta_2\ p\ f_1\ f_2 = \\
\qquad  (a_1 : \theta_1 A)\ (a_2 : \theta_2 A)\ (a_\star : \sem {\Gamma \prov A}\ \theta_1\ \theta_2\ p\ a_1\ a_2) \\
\qquad\to  \sem {\Gamma, a : A \prov B\ a}\ \theta_1[a_1/a]\ \theta_2[a_2/a]\ \langle p, a_\star\rangle\  (f_1\ a_1)\ (f_2\ a_2)
\end{array}\]
\subsection{Instantiating}
If we have
\[ \cdot \prov M : (j : \J) \to A\ j\]
then we have some $\sem M$ such that
\[  \sem {\cdot \prov (j : \J) \to A\ j}\ \cdot\ \cdot\ \cdot\ M\ M\]
which means
\[\begin{array}{l}
  (j_1 :  \J)\ (j_2 :  \J)\ (j' : \sem {\cdot \prov \J}\ \cdot\ \cdot\ \cdot\ j_1\ j_2) \\
\to  \sem { j : \J \prov A\ j}\ [j_1/j]\ [j_2/j]\ \langle  j'\rangle\  (M\ j_1)\ (M\ j_2)
\end{array}\]
which means --- since we can make a proof $j'$ of
\[  \sem {\cdot \prov \J}\ \cdot\ \cdot\ \cdot\ j_\star\ (\bj\ s) \]
that
\[
  \sem { j : \J \prov A\ j}\ [j_\star/j]\ [\bj\ s/j]\ \langle  j'\rangle\  (M\ j_\star)\ (M\ (\bj\ s)) \]



\end{document}
