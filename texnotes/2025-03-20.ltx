\documentclass{article}
\usepackage[tmargin=0.15in, bmargin=0.15in]{geometry}
\input{theorem}
\input{prooftree}
\usepackage{relsize}
\usepackage{latexsym}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,cd,decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}
\usepackage{tcolorbox}
\usepackage{stackengine}
\newcommand\oast{\stackMath\mathbin{\stackinset{c}{0ex}{c}{0ex}{\ast}{\bigcirc}}}

\tcbuselibrary{breakable}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}

\def\sssection#1{\vskip1em \hrule\vskip 0.5em \noindent $\triangleright$ {\bf #1} \vskip0.5em \hrule\vskip 1em }
\def\I{\mathbb{I}}
\def\bget{\mathop{\mathbf{get}}\nolimits}
\def\bGel{\mathop{\mathbf{Gel}}\nolimits}
\def\bgel{\mathop{\mathbf{gel}}\nolimits}
\def\bgbound{\mathop{\mathbf{gbound}}\nolimits}
\def\bgpath{\mathop{\mathbf{gpath}}\nolimits}
\def\bungel{\mathop{\mathbf{ungel}}\nolimits}
\def\bGet{\mathop\mathbf{Get}}
\def\dapt#1#2{#1[\![#2]\!]}
\def\dap#1#2{#1\{#2\}}
\def\ll{\langle\!\langle}
\def\rr{\rangle\!\rangle}
\def\rshape{\ {\mathsf{shape}}}
\def\rrefl{{\mathsf{refl}}}
\def\bd{\mathsf{Bd}}
\def\bdd{\mathsf{Bdd}}
\def\rset{\mathsf{U}}
\def\rid{\mathsf{id}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\prequiv{\dashv\vdash}

\definecolor{blu}{rgb}{0.1,0.5,1}
\definecolor{orng}{rgb}{1,0.5,0.3}

\def\nameof#1{\ulcorner{#1}\urcorner}
\def\U{\mathsf{U}}
\def\uu{\mathsf{u}}
\def\uni{\U}



\definecolor{lred}{rgb}{0.95,0.8,0.8}
\definecolor{cyan}{rgb}{0.80,0.95,0.95}
\definecolor{lorange}{rgb}{0.95,0.90,0.80}
\definecolor{bluegray}{rgb}{0.6,0.6,0.85}
\definecolor{lgray}{gray}{0.8}
\newtcolorbox{declbox}{colframe=lred,colback=lred,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{thmbox}{colframe=cyan,colback=cyan,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{defnbox}{colframe=lorange,colback=lorange,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{tangentbox}{colframe=lgray,colback=lgray,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}

\input{linear}
\def\J{\mathbb{J}}
\def\R{\mathcal{R}}
\def\rpath#1{[#1]}
\def\rfst{\mathsf{fst}\,}
\def\rsnd{\mathsf{snd}\,}
\def\bunfold{\mathbf{unfold}}
\def\bfold{\mathbf{fold}}
\def\susp#1{\langle {#1} \rangle}
\def\ssusp#1{\langle\!\langle {#1} \rangle\!\rangle}
\def\dto{\mathrel{\dot\to}}
\def\dns{{\downarrow}}
\def\ups{{\uparrow}}
\def\sprov{\Vdash}
\def\signat{{\color{red}\Sigma}}
\def\ep#1{\underline{#1}}
\def\wat{{@}}
\def\wwat{\mathbin{\underline\wat}}
\def\cn{{:}}
\def\dv{{\div}}
\def\ww{{\mathsf w}}
\def\base{{\textfrak b}}

\def\N{{\mathbb N}}
\def\Z{{\mathbb Z}}
\def\munit{I}
\def\tt{{\mathsf t}}
\def\ii{{\mathbb I}}
\def\T{\mathbb{T}}
\def\tw{\mathsf{Tw}}
\def\sw#1{^{#1}_{#1}}
\def\TP{\mathbf{TPre}}
\def\pp{\textsf{\textbf p}}
\def\nn{{\mathsf n}}
\def\PP{\textsf{\textbf P}}
\def\NN{\textsf{\textbf N}}
\def\zz{{\mathsf z}}
\def\sem#1{[\![#1]\!]}
\def\usem#1{\lceil\!\!\lceil{#1}\rceil\!\!\rceil}
\def\zem#1{\langle\!\langle#1\rangle\!\rangle}
\def\col#1{{\mathsf{C}}_{#1}}
\def\lax{\mathop\bigcirc}
\def\rjust{\mathsf{just}}
\def\rcvt{\mathsf{cvt}}
\def\rtype{\mathsf{type}}
\def\rdtype{\mathsf{disc}}
\def\rkind{\mathsf{kind}}
\def\rmode{\mathsf{mode}}
\def\rprel{\mathbf{Prel}}
\def\rrfam{\mathbf{Rfam}}
%\def\rset{\mathbf{Set}}
\def\rfinset{\mathbf{FinSet}}
\def\rrel{\mathbf{Rel}}
\def\rcat{\mathbf{Cat}}
\def\rfam{\mathbf{Fam}}
\def\binj{\mathbf{inj}}
\def\rtrue{\mathrel\mathrm{true}}
\def\pbck{\ar[dr, phantom, pos=0, "\lrcorner"]}
\def\bpbck{\ar[ddrr, phantom, pos=0, "\lrcorner"]}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\btwo{\mathbf{2}}
\def\bone{\mathbf{1}}

\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\def\mapt{\ar[ddd,mapsto,shorten <=2em, shorten >=2em]}
\def\A{\mathbf{A}}
\def\B{\mathbf{B}}
\def\C{\mathbb{C}}
\def\S{\mathbf{S}}
\def\G{\mathbf{G}}
\def\D{\mathbf{D}}
\def\DD{\mathbb{D}}
\def\E{\mathcal{E}}
\def\M{\mathbf{M}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\ltri{{\lhd}}
\def\rtri{{\rhd}}
\def\tri{\rhd}
\def\cc{\mathsf{c}}
\def\dd{\mathsf{d}}
\def\o{\circ}
\def\rctx{\,\mathsf{ctx}}
\def\rdctx{\,\mathsf{dctx}}
\def\del{\partial}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\definecolor{fib}{HTML}{ff7f00}
\definecolor{green}{HTML}{007f00}
\definecolor{red}{HTML}{df3f3f}
\definecolor{opfib}{HTML}{007fff}

% For lightening colors I used
% http://trycolors.com/ 6 parts white to 1 part color
\definecolor{opfibl}{HTML}{DBEDFF}
\definecolor{greenl}{HTML}{DBEDDB}
\definecolor{redl}{HTML}{FAE4E4}

% https://tex.stackexchange.com/questions/716631/curved-arrows-from-tikz-cd-do-not-work
\tikzset{
  curve/.style={
    settings={#1},
    to path={
      (\tikztostart)
      .. controls ($(\tikztostart)!\pv{pos}!(\tikztotarget)!\pv{height}!270:(\tikztotarget)$)
      and ($(\tikztostart)!1-\pv{pos}!(\tikztotarget)!\pv{height}!270:(\tikztotarget)$)
      .. (\tikztotarget)\tikztonodes
    },
  },
  settings/.code={%
    \tikzset{quiver/.cd,#1}%
    \def\pv##1{\pgfkeysvalueof{/tikz/quiver/##1}}%
  },
  quiver/.cd,
  pos/.initial=0.35,
  height/.initial=0,
}

\begin{document}

\def\
\tikzset{
   commutative diagrams/.cd,
   arrow style=tikz,
   diagrams={>=stealth}}
\tikzset{shorten <>/.style={shorten >=#1,shorten <=#1}}


\def\bj{\bar\jmath}
\section{Parametricity via Parametricity}
Fix a shape type $S$. For example, $S$ could be $2$ for binary parametricity.
Let $\J$ be the dependent record type
\[\{\I : \rset, \eta : S \to \I, i : \I\}\]
There are some particular elements of $\J$ that are of interest. They are
\[j_\star : \J\]
\[j_\star = \{\I = S + 1, \eta = \binl, i = \binr \star\}\]
and
\[\bj : S \to \J\]
\[\bj\ s = \{\I = S , \eta = \rid, i = s\}\]
There's an evident notion of $\J$-homomorphism, and, for each $s \in S$, an evident $\J$-homomorphism
 $j_\star \to \bj\ s$. It is the unique map $f : S + 1 \to S$ which has  $f \o \binl \equiv \rid$ and $f (\binr \star) = s$.


We can define
\[\bGel :  \I \to \rset\]
parameterized by
\[(R : \rset)\ ( A : S \to \rset)\ ( p : (s : S) \to R \to A\ s)\ (\I : \rset)\ (\eta : S \to \I)\]
with the constructors
\[ \begin{array}{r@{\ }l}
\bgel &: (r : R)(i : \I) \to \bGel\ i\\
\bgbound &: (s : S) (a : A\ s) \to \bGel\ (\eta\ s)\\
\bgpath &: (s : S) (r : R) \to \bgel\ r\ (\eta\ s) \equiv \bgbound\ s\ (p\ s\ r)\\
\end{array}\]

Now we can let $\R$ be the record type
\[\{R : \rset, A : S \to \rset, p : (s : S) \to R \to A\ s\} \]
And it should be clear what we mean by $\bGel_\rho\ j$ for $\rho : \R$ and $j : \J$.

Important claim:
\[ \bGel_\rho\ j_\star \cong R \]
\[ \bGel_\rho\ (\bj\ s) \cong A\ s \]

We proceed by acting as if $\J$ and $\bGel$ are primitive types where these isomorphisms hold definitionally.

Binary parametricity tells us that for any closed type $A$ we should have a binary relation
\[\sem A : A \to A \to \rset\]
and we should have for any closed $a : A$ that
\[\sem A\ a\ a\]
For example, if
\[M : (j : \J) \to A\ j \to B\ j\]
we should find
\[\sem{(j : \J) \to A\ j \to B\ j}\ M\ M \]

What is the relation for a $\Pi$-type? We get stuck at the definition
\[\sem{ (a : A) \to B\ a} : ((a : A) \to B\ a) \to ((a : A) \to B\ a) \to \rset\]
\[\sem{ (a : A) \to B\ a}\ f_1\ f_2 = (a_1\ a_2 : A) \to \sem A\ a_1\ a_2 \to \sem {?}\ (f_1\ a_1)\ (f_2\ a_2)\]
because there is no common type that $(f_1\ a_1), (f_2\ a_2)$ have. We must generalize to open types.
If $\Gamma \prov A$ is a type, then
\[ \sem{\Gamma \prov A} : (\theta_1\ \theta_2 : \Gamma) \to [\theta_1]A \to [\theta_2]A \to \rset \]
Then we can define
\[\begin{array}{l}
\sem{ \Gamma \prov (a : A) \to B\ a}\ \theta_1\ \theta_2\ f_1\ f_2 = (a_1\ a_2 : A) \\
\qquad\to \sem A\ \theta_1\ \theta_2\ a_1\ a_2 \\
\qquad\to  \sem {\Gamma, a : A \prov B\ a}\ \theta_1[a_1/a]\ \theta_2[a_2/a]\ (f_1\ a_1)\ (f_2\ a_2)
\end{array}\]
Instantiating with $(j : \J) \to A\ j$, we get that if
\[ M : (j : \J) \to A\ j\]
then there is some inhabitant of
\[\sem{\cdot \prov  (j : \J) \to A\ j}\ \cdot\ \cdot\ M\ M\]
which means we have an inhabitant of
\[\begin{array}{l}
 (j_1\ j_2 : \J) \\
\qquad\to \sem \J\ \cdot\ \cdot\ j_1\ j_2 \\
\qquad\to  \sem {\Gamma, j : \J \prov A\ j}\ [j_1/j]\ [j_2/j]\ (M\ j_1)\ (M\ j_2)
\end{array}\]
In particular, picking values for $j_1, j_2$ gives us
\[\begin{array}{l}
 \sem \J\ \cdot\ \cdot\ j_\star\ (\bj\ s) \\
\qquad\to  \sem {\Gamma, j : \J \prov A\ j}\ [j_\star/j]\ [\bj s/j]\ (M\ j_\star)\ (M\ (\bj\ s))
\end{array}\]

Wait I made an error in the definition. I need relations from sets in the substitution.
\subsection{Starting Over}
If $\Gamma$ is a context, then
\[\sem\Gamma : (\theta_1\ \theta_2 : \Gamma) \to \rset \]
is a relation over closed substitutions for $\Gamma$.
If $\Gamma \prov A$ is a type, then
\[ \sem{\Gamma \prov A} : (\theta_1\ \theta_2 : \Gamma) \to \sem \Gamma\ \theta_1\ \theta_2 \to [\theta_1]A \to [\theta_2]A \to \rset \]


$\sem \cdot$ is the trivial relation that does relate the two empty substitutions.
The cons case for contexts is
\[\sem {\Gamma, x : A}\ (\theta_1[M_1/x])\ (\theta_2[M_2/x]) = \]
\[(p : \sem\Gamma\ \theta_1\ \theta_2) \x  \sem{\Gamma \prov A}\ \theta_1\ \theta_2\ p\ M_1\ M_2\]
The universe case is
\[ \sem{\Gamma \prov \rset}\ \theta_1\ \theta_2\ p\ A_1\ A_2 = A_1 \to A_2 \to \rset\]
The variable case is
\[ \sem{\Gamma , \alpha : \rset, \Gamma' \prov \alpha}\ (\theta_1 [A_1/\alpha]\theta_1')\ (\theta_2 [A_2/\alpha]\theta_2')\ \langle \cdots, R,\cdots \rangle\ a_1\ a_2 = R\ a_1\ a_2\]
The function case is
\[\begin{array}{l}
\sem{ \Gamma \prov (a : A) \to B\ a}\ \theta_1\ \theta_2\ p\ f_1\ f_2 = \\
\qquad  (a_1 : \theta_1 A)\ (a_2 : \theta_2 A)\ (a_\star : \sem {\Gamma \prov A}\ \theta_1\ \theta_2\ p\ a_1\ a_2) \\
\qquad\to  \sem {\Gamma, a : A \prov B\ a}\ \theta_1[a_1/a]\ \theta_2[a_2/a]\ \langle p, a_\star\rangle\  (f_1\ a_1)\ (f_2\ a_2)
\end{array}\]
\subsection{Instantiating}
If we have
\[ \cdot \prov M : (j : \J) \to A\ j\]
then we have some $\sem M$ such that
\[  \sem {\cdot \prov (j : \J) \to A\ j}\ \cdot\ \cdot\ \cdot\ M\ M\]
which means
\[\begin{array}{l}
  (j_1 :  \J)\ (j_2 :  \J)\ (j' : \sem {\cdot \prov \J}\ \cdot\ \cdot\ \cdot\ j_1\ j_2) \\
\to  \sem { j : \J \prov A\ j}\ [j_1/j]\ [j_2/j]\ \langle  j'\rangle\  (M\ j_1)\ (M\ j_2)
\end{array}\]
which means --- since we can make a proof $j'$ of
\[  \sem {\cdot \prov \J}\ \cdot\ \cdot\ \cdot\ j_\star\ (\bj\ s) \]
that
\[
  \sem { j : \J \prov A\ j}\ [j_\star/j]\ [\bj\ s/j]\ \langle  j'\rangle\  (M\ j_\star)\ (M\ (\bj\ s)) \]
\vfil\eject

\section{Categories via Parametricity}
\def\rset{\mathbf{Set}}

Fix a category $\C$. Given a presheaf $P : \rset^{\C^\op}$ and a
copresheaf $L : \rset^\C$, recall their tensor product $P \otimes L$ (for the
cartesian tensor product structure on $\rset$)
 is the coend
\[ \int^{C\in\C} P(C) \x L(C) \]
The encoding of a presheaf $P$ as a $\bar\C$ is simply partial
application of this operation.
\[ e : \rset^{\C^\op} \to \bar \C
\qquad
 e P = \lambda L . P \otimes L \]
If we only have our hands on a $\bar\C$,
but we know it came from $e$, then we can recover the object data at an object
$C_0$ by instantiating
at the yoneda embedding
\[y : \C^\op \to \C \to \rset  \qquad yC_0 = \hom(C_0, \dash)\]
then we calculate
\[ (e P)(yC_0) = P \otimes \hom(C_0, \dash)\]
\[ = \int^{C\in\C} P(C) \x \hom(C_0, C) \]
\[ =  P(C_0)  \]
To get the morphism data, we need to use parametricity. I think in general,
given a $\bar \C$, I can extract a functor living in $ \rrel^{\C^\op}$,
and my hope is that for the particular case of $eP$, the round trip actually lands
in $\rset^{\C^\op}$.

Let's expand out the coend above as the coequalizer
\[ \coprod_{f : C \to D \in \C} P(D) \x L(C) \rightrightarrows
\coprod_{C \in \C} P(C) \x L(C) \to P \otimes L \]
So binary relational parametricity applied to any old
\[ \tau : \bar \C\]
would let us pick $L_1, L_2 : \rset^\C$ and a relation carrier $M : \rset^\C$ and  natural transformation projections $\pi_i : M \to L_i$. But specifically if we have
a polymorphic term
\[ q : (L : \rset^\C) \to P \tensor L\]
then we find
\[\sem q : (L_1, L_2, M : \rset^\C) (\pi_i : M \to L_i) \to \sem {P \tensor L}\ (q\ L_1)\ (q\ L_2)\]
The $L_1$ and $L_2$ we're going to be interested in plugging in will be $yC_0$ and $yD_0$ for
the endpoints of some fixed morphism $m : D_0 \to C_0 \in \C$.
Also, since $m : D_0 \to C_0$ leads to $ym : yC_0 \to yD_0$, I'll be plugging in $M = yC_0$ as well,
which means $\pi_1 = \rid$, and $\pi_2 = ym$. This gives me ``the functional relation''
for $m$ between $L_1$ and $L_2$. So then by types alone I know that

\[ q\ L_1 = q\ yC_0 : P \otimes yC_0 \cong P(C_0) \]
\[ q\ L_2 = q\ yD_0 : P \otimes yD_0  \cong P(D_0) \]
\[ q\ M = q\ yC_0 : P \otimes yC_0 \cong P(C_0) \]

So I know
\[ q\ L_1 :  \coprod_{f : C \to D \in \C} P(D) \x [C_0,C] \rightrightarrows
\coprod_{C \in \C} P(C) \x [C_0,C] \to P (C_0) \]
\[ q\ L_2 :  \coprod_{f : C \to D \in \C} P(D) \x [D_0,C] \rightrightarrows
\coprod_{C \in \C} P(C) \x [D_0,C] \to P (D_0) \]

and parametricity is telling me that these two values are related according to the
relation induced by my choice of $L_1, L_2, M, \pi_1, \pi_2$. This feels right.
It gives me vertical arrows between the $L$'s, saying that I must propagate
by composition. Then the UMP of the coequalizer tells me how to get from
$P(C_0)$ tp $P(D_0)$.

\section{The Grothendieck Move}

I still don't think I can get functor exponential semantics out of
what's above without some other cleverness. Let's really try to understand
what happens with unary parametricity first, understood as presheaf semantics
over the arrow category.

As an example, let's conemplate unary parametricity over
\[\tau = \forall a . ((a \to a) \to a) \to (a \to a \to a) \to a\]
If we have $t : \tau$, then parametricity tells us that for any $A : \rset$
and $\sem A : A \to \rset$, that $t A$ is in `the relation', i.e.
there is some term
\[\sem{t\ A} : \sem{((A \to A) \to A) \to (A \to A \to A) \to A}\ (t\ A)  \]
equiv
\[\sem{t\ A} : (\ell : (A \to A) \to A) (\sem \ell : \sem{(A \to A) \to A}\ \ell) \to
 \sem{(A \to A \to A) \to A}\ (t\ A\ \ell)  \]
equiv
\[\sem{t\ A} : (\ell : (A \to A) \to A) (\sem \ell : (b : A \to A) (\sem b : \sem{A \to A}\ b) \to \sem{A}\ (\ell\  b)) \]
\[\to (p : A \to A \to A) (\sem p : \sem{A \to A \to A}\ p) \to \sem{A}\ (t\ A\ \ell\ p)  \]
equiv
\[\sem{t\ A} : (\ell : (A \to A) \to A) (\sem \ell : (b : A \to A) (\sem b : (x : A) (\sem x : \sem A\ x) \to \sem{A}\ (b\ x)) \to \sem{A}\ (\ell\  b)) \]
\[\to (p : A \to A \to A) (\sem p : (x\ y : A) (\sem x : \sem A\ x) (\sem y: \sem A\ y) \to \sem{A}\ (p\ x\ y)) \to \sem{A}\ (t\ A\ \ell\ p)  \]
Ok let me replace $\sem A$ with $R$ and rename $b$ to $d$:
\[
\begin{array}{ll}
\sem{t \ A} : & (\ell : (A \to A) \to A)\\
& (\sem \ell : (d : A \to A) (\sem d : (x : A) (\sem x : R\ x) \to R\ (d\ x)) \to R\ (\ell\  d)) \\
& (p : A \to A \to A) \\
& (\sem p : (x\ y : A) (\sem x : R\ x) (\sem y: R\ y) \to R\ (p\ x\ y))\\
& \to R\ (t\ A\ \ell\ p)
\end{array}\]
Ok now I want to replace $A : \rset, R : A \to \rset$ with $A\ B : \rset, f : B \to A$.
The relation $R$ is $R\ a = (b : B) \x f\ b = a$. Let's do this one bit at a time.
Replace $\sem x : R x$ with $(b : B) (\_ : f\ b = a)$.
\[
\begin{array}{ll}
\sem{t \ A} : & (\ell : (A \to A) \to A)\\
& (\sem \ell : (d : A \to A) (\sem d : (b : B) \to R\ (d\ (f\ b))) \to R\ (\ell\  d)) \\
& (p : A \to A \to A) \\
& (\sem p : (x\ y : A) (\sem x : R\ x) (\sem y: R\ y) \to R\ (p\ x\ y))\\
& \to R\ (t\ A\ \ell\ p)
\end{array}\]
I can do this with the app arguments too.
\[
\begin{array}{ll}
\sem{t \ A} : & (\ell : (A \to A) \to A)\\
& (\sem \ell : (d : A \to A) (\sem d : (b : B) \to R\ (d\ (f\ b))) \to R\ (\ell\  d)) \\
& (p : A \to A \to A) \\
& (\sem p : (x\ y : B)  \to R\ (p\ (f\  x)\ (f\ y)))\\
& \to R\ (t\ A\ \ell\ p)
\end{array}\]
This actually means app breaks up as two functions
\[
\begin{array}{ll}
\sem{t \ A} : & (\ell : (A \to A) \to A)\\
& (\sem \ell : (d : A \to A) (\sem d : (b : B) \to R\ (d\ (f\ b))) \to R\ (\ell\  d)) \\
& (p : A \to A \to A) \\
& (p' : B \to B \to B) \\
& (\_ : (x\ y : B) \to f\ (p'\ x\ y) \equiv p\ (f\  x)\ (f\ y))\\
& \to R\ (t\ A\ \ell\ p)
\end{array}\]
Let's invent some ad-hoc notation for what's going on with application
Say
\[p : \forall n \ge 0. B_n \to B_n \to B_n = \]
\[\Sigma (p_0 : B_0 \to B_0 \to B_0) (p_1 : B_1 \to B_1 \to B_1) \]
\[(\_ : (x\ y : B_0) \to f\ (p_0\ x\ y) \equiv p_1\ (f\  x)\ (f\ y))\]
where I'm identifying $B_0 = B$ and $B_1 = A$. Then I have
\[
\begin{array}{ll}
\sem{t \ A} : & (\ell : (A \to A) \to A)\\
& (\sem \ell : (d : A \to A) (\sem d : (b : B) \to R\ (d\ (f\ b))) \to R\ (\ell\  d)) \\
& (p : \forall n \ge 0. B_n \to B_n \to B_n )\\
& \to R\ (t\ A\ \ell\ p_1)
\end{array}\]
Let's split $\sem d$ now as
\[
\begin{array}{ll}
\sem{t \ A} : & (\ell : (A \to A) \to A)\\
& (\sem \ell : (d : A \to A) (d_0 : B \to B) (d_\star : (b : B) \to f(d_0\ b)) = d(f\ b)) \to R\ (\ell\  d)) \\
& (p : \forall n \ge 0. B_n \to B_n \to B_n )\\
& \to R\ (t\ A\ \ell\ p_1)
\end{array}\]
and reconsider it as
\[
\begin{array}{ll}
\sem{t \ A} : & (\ell : (A \to A) \to A)\\
& (\sem \ell : (d_1 : B_1 \to B_1) (d_0 : B_0 \to B_0) (d_\star : (b : B_0) \to f(d_0\ b) = d_1(f\ b)) \to R\ (\ell\  d_1)) \\
& (p : \forall n \ge 0. B_n \to B_n \to B_n )\\
& \to R\ (t\ A\ \ell\ p_1)
\end{array}\]
and subsequently as
\[
\begin{array}{ll}
\sem{t \ A} : & (\ell : (A \to A) \to A)\\
& (\sem \ell : (d : \forall n \ge 0 . B_n \to B_n)  \to R\ (\ell\  d_1)) \\
& (p : \forall n \ge 0. B_n \to B_n \to B_n )\\
& \to R\ (t\ A\ \ell\ p_1)
\end{array}\]
Let's split $\sem l$ now.
\[
\begin{array}{ll}
\sem{t \ A} : & (\ell : (A \to A) \to A)\\
& ( \ell' : (d : \forall n \ge 0 . B_n \to B_n)  \to B) \\
& ( \ell_\star : (d : \forall n \ge 0 . B_n \to B_n)  \to f (\ell'\ d) = \ell\  d_1)) \\
& (p : \forall n \ge 0. B_n \to B_n \to B_n )\\
& \to R\ (t\ A\ \ell\ p_1)
\end{array}\]
Do some renaming:
\[
\begin{array}{ll}
\sem{t \ A} : & (\ell : (B_1 \to B_1) \to B_1)\\
& ( \ell' : (d : \forall n \ge 0 . B_n \to B_n)  \to B_0) \\
& ( \ell_\star : (d : \forall n \ge 0 . B_n \to B_n)  \to f (\ell'\ d) = \ell\  d_1)) \\
& (p : \forall n \ge 0. B_n \to B_n \to B_n )\\
& \to R\ (t\ A\ \ell\ p_1)
\end{array}\]
Now I can see the equivalence of this to
\[
\begin{array}{ll}
\sem{t \ A} : & ( \ell : (d : \forall n \ge 1 . B_n \to B_n) \to B_1)\\
& ( \ell' : (d : \forall n \ge 0 . B_n \to B_n)  \to B_0) \\
& ( \ell_\star : (d : \forall n \ge 0 . B_n \to B_n)  \to f (\ell'\ d) = \ell\  d_1)) \\
& (p : \forall n \ge 0. B_n \to B_n \to B_n )\\
& \to R\ (t\ A\ \ell\ p_1)
\end{array}\]
So my aim is to compress the first three arguments notationally to
\[
\begin{array}{ll}
\sem{t \ A} : & ( \ell : \forall m \ge 0 . ( \forall n \ge m . B_n \to B_n) \to B_m)\\
& (p : \forall n \ge 0. B_n \to B_n \to B_n )\\
& \to R\ (t\ A\ \ell_1\ p_1)
\end{array}\]
Now I want to split the conclusion. I'm claiming that from $t\ A$ I can derive
two terms, call them $m_0$ and $m_\star$:
\[
\begin{array}{ll}
m_0 : & ( \ell : \forall m \ge 0 . ( \forall n \ge m . B_n \to B_n) \to B_m)\\
& (p : \forall n \ge 0. B_n \to B_n \to B_n )\\
& \to B_0\\
m_\star : & ( \ell : \forall m \ge 0 . ( \forall n \ge m . B_n \to B_n) \to B_m)\\
& (p : \forall n \ge 0. B_n \to B_n \to B_n )\\
& \to f\ (m_1\ \ell\ p) \equiv t\ B_1\ \ell_1\ p_1
\end{array}\]
And anyhow I can also get
\[
\begin{array}{ll}
m_1 : & ( \ell : \forall m \ge 1 . ( \forall n \ge m . B_n \to B_n) \to B_m)\\
& (p : \forall n \ge 1. B_n \to B_n \to B_n )\\
& \to B_1
\end{array}
\]
because that's just $\lambda \ell p . t\ B_1\ \ell\ p$. So $m_\star$ is just
asserting compatibility between $m_0$ and $m_1$.

\section{Am I Confused About The Representable Encoding?}
Assume we're trying to encode binary relational parametricity.




\subsection{Fibered}
Here we write the flat type $R$ for the total space of the relation.
Assume we've chosen
\[\mathbf{module}\ \_\  (A\ B\ R: \rset)(f : R \to A)(g: R\to B)\ \mathbf{where}\]

\subsubsection{Interval Encoding}
Define
\[\begin{array}{l}
\mathbf{data}\ \mathsf{Gel}\ (\I : \rset)(\eta : 2 \to \I) :  (i: \I) \to \rset\ \mathbf{where}\\
\qquad \mathsf{gel} : (r : R) (i : \I) \to \mathsf{Gel}\ i\\
\qquad \mathsf{bound_a} : A \to \mathsf{Gel}\ (\eta\ 0)\\
\qquad \mathsf{bound_b} : B \to \mathsf{Gel}\ (\eta\ 1)\\
\qquad \mathsf{path_a} : (r: R) \to \mathsf{gel}\ r\ (\eta\ 0) \equiv \mathsf{path_a}\ (f\ r)\\
\qquad \mathsf{path_b} : (r: R) \to \mathsf{gel}\ r\ (\eta\ 1) \equiv \mathsf{path_b}\ (g\ r)\\
\end{array}
\]
and conclude
\[
\begin{array}{lcl}
 \mathsf{Gel}\ (2+1)\ \binl\ (\binr\ *) &\cong&  R\\
 \mathsf{Gel}\ 2\ \rid\ 0 &\cong& A\\
 \mathsf{Gel}\ 2\ \rid\ 1 &\cong& B
\end{array}
\]
\subsubsection{Representable Encoding}
\[\begin{array}{l}
\mathbf{data}\ \mathsf{Gel}\ (L^a\ L^b : \rset) :   \rset\ \mathbf{where}\\
\qquad \mathsf{inj_a} : A \to L^a \to \mathsf{Gel}\\
\qquad \mathsf{inj_b} : B \to L^b \to \mathsf{Gel}\\
\qquad \mathsf{mid} : R \to \mathsf{Gel}\\
\qquad \mathsf{path_a} : (r: R) (\ell : L^a) \to \mathsf{inj_a}\ (f\ r)\ \ell \equiv \mathsf{mid}\ r \\
\qquad \mathsf{path_b} : (r: R) (\ell : L^b) \to \mathsf{inj_b}\ (g\ r)\ \ell \equiv \mathsf{mid}\ r \\
\end{array}
\]
and conclude
\[
\begin{array}{lcl}
 \mathsf{Gel}\ 0\ 0 &\cong&  R\\
 \mathsf{Gel}\ 1\ 0 &\cong& A\\
 \mathsf{Gel}\ 0\ 1 &\cong& B
\end{array}
\]
\sssection{Singleton}
Parametricity says that if I have
\[ t :  {(L^a\ L^b : \rset) \to \mathsf{Gel}\ L^a\ L^b}\]
then there is a $\sem t$ of type
\[(L^a_1\ L^a_2\ : \rset) (\sem{L^a} : L^a_1 \to L^a_2 \to  \rset) \]
\[(L^b_1\ L^b_2\ : \rset) (\sem{L^b} : L^b_1 \to L^b_2 \to  \rset) \]
\[\to \sem{ \mathsf{Gel}\ L^a\ L^b}\ (t\ L^a_1\ L^b_1)\ (t\ L^a_2\ L^b_2) \]
In particular if I set
\[(L^a_1 = 0)( L^a_2 = 1) (\sem{L^a} = {! : 0 \to 1}) \]
\[(L^b_1 = 0)( L^b_2 = 0) (\sem{L^b} = {! : 0 \to 0}) \]
then I get a guarantee that
\[\sem{ \mathsf{Gel}\ L^a\ L^b}\ (t\ 0\ 0)\ (t\ 1\ 0) \]
What does this really mean? It's telling us
$(t\ 0\ 0)$ and $(t\ 1\ 0)$ are related by the action of (what is in this case) functoriality,
where we lift some maps to maps between $\mathsf{Gel}$ types. The only
thing $(t\ 0\ 0)$ can be is a $\mathsf{mid}$ of an $r : R$, and so it is carried
by this functoriality to the same $\mathsf{mid}\ r$. But $\mathsf{path_a}$ in the type
$\mathsf{Gel}\ 1\ 0$ guarantees this is the same thing as $\mathsf{inj\_a}\ (f\ r)\ *$.
So taking into account the isomorphisms above, we're finding out that from
$t$ we can extract a {\em consistent} interpretation in the span $A \leftarrow R \to B$.

\sssection{Function}

What about the case of $\forall\alpha.\alpha \to \alpha$? Then we have a term of type
\[ t :  {(L^a\ L^b : \rset) \to \mathsf{Gel}\ L^a\ L^b \to \mathsf{Gel}\ L^a\ L^b}\]
So by instantiation we can get
\[ t\ 0\ 0 :  R \to R\]
\[ t\ 1\ 0 :  A \to A\]
\[ t\ 0\ 1 :  B \to B\]
and by parametricity we know $\sem{\mathsf{Gel}}\ r\ a \iff f(r) \equiv a$
and $\sem{\mathsf{Gel}}\ r\ b \iff g(r) \equiv b$, taking shortcuts by identifying
$t\ 0\ 0$ with $R$. And likewise, if $h : R \to R = t\ 0\ 0 \to t\ 0 \0$ and
$k : A \to A = t\ 1\ 0 \to t\ 1\ 0$, then $\sem{\mathsf{Gel} \to \mathsf {Gel}}\ h\ k$
if they map related arguments to related arguments. That is, for any $r$ and $a$,
if $f(r) \equiv a$, then $h(r)$ is related to $k(a)$, i.e. $f(h(r)) = k(a)$.
But this is just saying that $f(h(r)) = k(f(r))$.
\subsection{Indexed}
Here we write $R$ as indexed over $A$ and $B$.
Assume we've chosen
\[\mathbf{module}\ \_\  (A\ B : \rset)(R: A \to B \to \rset)\ \mathbf{where}\]

\subsubsection{Interval Encoding}
Define
\[\begin{array}{l}
\mathbf{data}\ \mathsf{Gel}\ (\I : \rset)(\eta : 2 \to \I) :  (i: \I) \to \rset\ \mathbf{where}\\
\qquad \mathsf{gel} : (a:A)(b:B)(r : R\ a\ b) (i : \I) \to \mathsf{Gel}\ i\\
\qquad \mathsf{bound_a} : (a:A) \to \mathsf{Gel}\ (\eta\ 0)\\
\qquad \mathsf{bound_b} : (b:B) \to \mathsf{Gel}\ (\eta\ 1)\\
\qquad \mathsf{path_a} : (a:A)(b:B)(r: R\ a\ b) \to \mathsf{gel}\ a\ b\ r\ (\eta\ 0) \equiv \mathsf{path_a}\ a\\
\qquad \mathsf{path_b} : (a:A)(b:B)(r: R\ a\ b) \to \mathsf{gel}\ a\ b\ r\ (\eta\ 1) \equiv \mathsf{path_b}\ b\\
\end{array}
\]
and conclude
\[
\begin{array}{lcl}
 \mathsf{Gel}\ (2+1)\ \binl\ (\binr\ *) &\cong& (a:A)(b:B) \x R\ a\ b\\
 \mathsf{Gel}\ 2\ \rid\ 0 &\cong& A\\
 \mathsf{Gel}\ 2\ \rid\ 1 &\cong& B
\end{array}
\]

% \[t : (\I : \rset)(\eta : 2 \to \I)(i: \I) \to \mathsf{Gel}\ \I\ \eta\ i\]
\subsubsection{Representable Encoding}
?
\section{Playing around with Involutions}
I could assume
\[\mathbf{module}\ \_\  (M: \rset) (\mu : M \to M) (\_ : \mu \o \mu = \rid)\ \mathbf{where}\]
and define
\[\begin{array}{l}
\mathbf{data}\ \mathsf{Gel}\ (L : \rset) (z : L \to L) (\_ : z \o z = \rid) :   \rset\ \mathbf{where}\\
\qquad \mathsf{inj_0} : M \to L \to \mathsf{Gel}\\
\qquad \mathsf{inj_1} : M \to L \to \mathsf{Gel}\\
\qquad \mathsf{path} : (m : M) (\ell : L) \to \mathsf{inj_0}(m, \ell) = \mathsf{inj_1}(\mu\ m, z\ \ell) \\
\end{array}
\]
We can recover the underlying set of $M$ by setting $L$ to 2 (which is the yoneda embedding of the
single object of the involution category) with the expected $z$.

\section{What Theorem Am I Hoping For?}

I'm hoping that somehow, given a category $\C$, and a presheaf $P : \C^\op \to \rset$,
when we encode $P$ as a type {\em in the context} of a copresheaf $L : \C \to \rset$, via
\[P^\star : (\C \to \rset) \to \rset\]
\[P^\star(L) =   P \otimes L  \]
that we could, using parametricity, extract presehaf-semantic information out of terms at types like
\[(L : \C \to \rset) \to ((P^\star(L) \to P^\star(L)) \to P^\star(L)) \to (P^\star(L) \to P^\star(L)  \to P^\star(L) ) \to P^\star(L) \]
which would be derivable if we had a polymorphic term
\[\forall \alpha.  ((\alpha \to \alpha) \to \alpha) \to (\alpha \to \alpha  \to \alpha ) \to \alpha \]

So I suppose a foundational part of this is that, also, given a
particularly well-behaved function $Q : (\C \to \rset) \to \rset$, I might hope to extract a
presheaf $Q^\dag$ from it. The object part of this is pretty clear. Given a $Q$ and a $C \in \C$, I can
consider $Q(yC) : \rset$. This even round-trips correctly, in the ``first do $*$ then do $\dag$'' direction.
For
\[P^\star(yC') =  P \otimes yC' = \int^{C\in\C} P(C) \otimes [C',C] = P(C')  \]
as required. Let's imagine that we have presheaves $P_1, P_2 : \C^\op\to\rset$. Given
a $L : \C \to \rset$, we can construct
\[P_1^\star(L) =  \int^{C\in\C} P_1(C) \x L(C)  \]
\[P_2^\star(L) =  \int^{C\in\C} P_2(C) \x L(C)  \]
\[P_1^\star(L) \to P_2^\star(L) =  \left(\int^{C\in\C} P_1(C) \x L(C)\right) \to \left(\int^{C\in\C} P_2(C) \x L(C)\right)  \eqno(*)\]

\[(P_1 \imp P_2)^\star(L) =  \int^{C\in\C} (P_1 \imp P_2)(C) \x L(C)  \]
\[(P_1 \imp P_2)^\star(L) =  \int^{C\in\C} [\rset^{\C^\op}](yC, P_1 \imp P_2) \x L(C)  \]
\[(P_1 \imp P_2)^\star(L) =  \int^{C\in\C} [\rset^{\C^\op}](yC \x  P_1, P_2) \x L(C)  \eqno(**)\]
It doesn't seem possible that $(*)$ and $(**)$ would be equal. In fact, let's substitute $yC'$ for the $L$'s in
each case. We'd be comparing

\[ P_1(C') \to P_2(C') \mathrel{\stackrel ? \equiv} (P_1 \imp P_2)(C') \]

which clearly can't be right. The left side throws away all the functorial cohesion that the right side knows about.

\section{Quantifying over Categories}
Let me return to a previous idea and see what extra uniformity
principles I might need to make it go. Maybe it's not as
question-begging as I think.

The idea is: why not be explicit about which category we're working in?
Let $\rset$ (in addition to universe-indexing) be indexed by an expression $C$
\[\begin{array}{lcr}
\hbox{Category Expression }C&::=&c \celse \rho(C)
\end{array}\]
In fact, let all term and type constructors be indexed by a $C$. For most term
and type constructors, we require agreement of all components.
We have a quantifier
\[
\begin{prooftree}
 c \ge C \prov_c  A: \rset
\justifies
\prov_C (c  \ge C) \to A : \rset
\end{prooftree}
\]
with terms
\[
\begin{prooftree}
 c \ge C \prov_c  M : A
\justifies
\prov_C \lambda c . M : (c  \ge C) \to A
\end{prooftree}
\qquad
\begin{prooftree}
\prov_C  M : (c  \ge C) \to A \qquad C' \ge C
\justifies
\prov_C M[C'] : [C'/C]A
\end{prooftree}

\]
and we have $C \le \rho(C)$. We can give some reductions specific to the intent that $\rho$
constructs the category $( \bullet \leftarrow \bullet \rightarrow \bullet) \to \C$ from $\C$.
We say
\[\rset_{\rho(C)} \mapsto_\beta \{ A\ B : \rset_C, R : A \to B \to \rset_C \}\]
\[\begin{array}{l}
(X \to_{\rho(C)} Y) \mapsto_\beta \{\\
\qquad A := X.A \to_C Y.A,\\
\qquad B := X.B \to_C Y.B,\\
\qquad R\ f_a\ f_b :=  (x_a : X.A) (x_b : X.B) \to \\
\qquad \qquad X.R\ x_a\ x_b \to Y.R\ (f_a\ x_a)\ (f_b\ x_b)\\
\}
\end{array}
\]
What does $\lambda x . M : X \to_{\rho(C)} Y$ become?
Well, what does a term judgment at a $\rho(C)$ type become in general?
A closed term should be a global section of the presheaf. An open term
is a natural transformation.
\[\begin{array}{l}
(X \to_{\rho(C)} Y) \mapsto_\beta \{\\
\qquad A := X.A \to_C Y.A,\\
\qquad B := X.B \to_C Y.B,\\
\qquad R\ f_a\ f_b :=  (x_a : X.A) (x_b : X.B) \to \\
\qquad \qquad X.R\ x_a\ x_b \to Y.R\ (f_a\ x_a)\ (f_b\ x_b)\\
\}
\end{array}
\]
This impedance mismatch is interesting.
I think what I'm perceiving is that when I write something like
\[\forall\alpha.(\alpha \to \alpha) \to (\alpha \to \alpha)\]
I can parse it as if I meant
\[(\C : \mathsf{\rcat}) ( \alpha : \C \to \rset) (C : \C) \to ((\alpha \imp \alpha) \imp (\alpha \imp \alpha))@ C\]
where $\imp$ really is carrying out the presheaf exponential with respect to presheaves $\C \to \rset$.
Also the quantifier $(C : \C)$ probably entails some functorial coherence. But the payoff ought to be that I
can write my proofs of this type using ordinary term (de)constructors for
$(\alpha \to \alpha) \to (\alpha \to \alpha)$. Hmm. Actually what's happening is something like
if $P, Q : \C \to \rset$, then
\[
\begin{prooftree}
\Gamma, D : \C, f : \C[C, D], x : P @ D \prov M : Q @ D
\justifies
\Gamma \prov \lambda_f^D x . M :  (P \imp Q) @ C
\end{prooftree}
\]
but this monotonicity is invisible normally.

\subsection{Where is Coherence Needed?}

Let's say I have $t : \all\alpha.(\alpha \to \alpha) \to (\alpha \to \alpha)$
and I want to apply it to a pair of types $A$, $B$ and a relation $A \leftarrow R \rightarrow B$.
I'm somehow allowed to prove
\[ \prov \mathsf{Rel} := \bullet_1 \leftarrow \bullet_0 \rightarrow \bullet_2 : \rcat\]
\[ \mathcal{R} := \prov A \leftarrow R \rightarrow B : ( \bullet_1 \leftarrow \bullet_0 \rightarrow \bullet_2) \to \rset \]
\[ \prov \bullet_0 : ( \bullet_1 \leftarrow \bullet_0 \rightarrow \bullet_2)\]
So if I infer that secretly actually
\[ t : (\C : \mathsf{\rcat}) ( \alpha : \C \to \rset) (C : \C) \to ((\alpha \imp \alpha) \imp (\alpha \imp \alpha))@ C\]
Then I can apply things to get
\[ \prov t\ \mathsf{Rel}\ \mathcal{R}\ \bullet_0 : ((\mathcal{R} \imp \mathcal{R}) \imp (\mathcal{R} \imp \mathcal{R}))@ \bullet_0\]
Now what is the presheaf $\mathcal{R} \imp \mathcal{R}$? At $\bullet_1$ it consists of functions $A \to A$,
and at $\bullet_2$ it consists of functions $B\to B$, and at $\bullet_0$ it consists of
consistent triples $(R\to R)\x (A \to A) \x (B \to B)$.
Now because of the happy accident that $\bullet_0$ is the initial object of $\mathsf{Rel}$, it distributes over $\imp$.

Likewise we can ask, what's in the presheaf $(\mathcal{R} \imp \mathcal{R}) \imp (\mathcal{R} \imp \mathcal{R})$?
At $\bullet_1$ it has $(A \to A) \to (A \to A) $.
At $\bullet_0$ it has consistent triples of
\begin{itemize}
\item $(A \to A) \to (A \to A)$
\item $(B \to B) \to (B \to B)$
\item maps from the type of consistent triples $(R\to R)\x (A \to A) \x (B \to B)$ to itself
\end{itemize}

So in short, the type of
\[ \prov t\ \mathsf{Rel}\ \mathcal{R}\ \bullet_0 : ((\mathcal{R} \imp \mathcal{R}) \imp (\mathcal{R} \imp \mathcal{R}))@ \bullet_0\]
is ``pair of functions in the relation''. Note that this is different from saying
\[\textcolor{red}{ \prov t\ \mathsf{Rel}\ \mathcal{R}\ \bullet_0 : (R \to R) \to (R \to R)}\]
This would permit incoherent maps from $R$ to itself, that don't obey any particular rules of mapping $A \to A$ and $B \to B$.

On the other hand, since $\bullet_1, \bullet_2$ are terminal, we have up to isomorphism
\[ \prov t\ \mathsf{Rel}\ \mathcal{R}\ \bullet_1 : (A \to A) \to (A \to A)\]
\[ \prov t\ \mathsf{Rel}\ \mathcal{R}\ \bullet_2 : (B \to B) \to (B \to B)\]
and we ought to have some functorial transport principle that says (if $f : \bullet_0 \to \bullet_1$ and $g : \bullet_0 \to \bullet_2$)
\[ \prov t\ \mathsf{Rel}\ \mathcal{R}\ f : ((\mathcal{R} \imp \mathcal{R}) \imp (\mathcal{R} \imp \mathcal{R}))@ \bullet_0\]
\[\to (A \to A) \to (A \to A)\]
from a general principle that
\[
\begin{prooftree}
C : \C \prov A : \rset \qquad f : C_1 \to C_2 \in \C \qquad N : [C_1/C]A
\justifies
\mathrel\mathbf{trans}_{C.A} N \mathrel\mathbf{along} f  : [C_2/C] A
\end{prooftree}
\]
and we want
\[( t\ \mathsf{Rel}\ \mathcal{R}\ f) ( t\ \mathsf{Rel}\ \mathcal{R}\ \bullet_0)
\equiv  t\ \mathsf{Rel}\ \mathcal{R}\ \bullet_1\]
So I think I want to impose
\[{
C : \C \prov  M : A
\over
\mathrel\mathbf{trans}_{C.A} [C_1/C]M \mathrel\mathbf{along} f  \equiv [C_2/C] M
}\]
So every use of $C$ must be covariant! No contravariance!

If $P, Q : \C \to \rset$, then
\[ (P \imp Q) @ C = (D : \C) (f : \C[C, D]) \to P @ D \to Q @ D\]

\subsection{The Relevance of Polarity and Focusing}
Negative connectives ought to be the ones that need ``shielding'' by
quantifiers to ensure monotonicity.
\subsection{Interpretation}
If $P, Q : \C \to \rset$ are a covariant
functors, then the naive interpretation of $(P \imp Q) @ C = P @ C \to Q \to C$
doesn't work; it isn't monotone. But
\[ (D : \C) (f : \C[C, D]) \to P @ D \to Q @ D\]
should be monotone in $C$. For if we have
\[t : (D : \C) (f : \C[C, D]) \to P @ D \to Q @ D\]
and $g : C \to C'$, then we can construct a term
\[t' : (D' : \C) (f' : \C[C', D']) \to P @ D' \to Q @ D'\]
by setting
\[t' = \lambda D'\ f'\ p \to t\ D\ (f' \o g)\ p \]
The obvious problem now however is that $D,D'$ are not consistently covariant.
\subsection{An Example}
Let's try building a term of type
\[ (\C : \mathsf{\rcat}) ( \alpha : \C \to \rset) (C : \C) \to ((\alpha \imp \alpha) \imp (\alpha \imp \alpha))@ C\]
that represents the church numeral 2.

\[
\begin{prooftree}
\[
\[
\[
\[
\justifies
 \prov  z : \alpha\ [C_2]
\]
\justifies
 \prov s\ g\ z : \alpha\ [C_2]
\]
\justifies
g : C_2 \leftarrow C_1,  z :   \alpha\ [C_2] \prov s\ g\ (s\ g\ z) : \alpha\ [C_2]
\]
\justifies
f : C_1 \leftarrow C,  s :  \alpha \to \alpha\ [C_1] \prov \lambda g z . s\ g\ (s\ g\ z) :  \alpha \to \alpha\ [C_1]
\]
\justifies
 \C : \mathsf{\rcat}, \alpha : \C \to \rset, C : \C^+\prov \lambda f s . \lambda g z . s\ g\ (s\ g\ z) : (\alpha \to \alpha) \to \alpha \to \alpha\ [C]
\end{prooftree}
\]
What are these lines saying semantically?
The construction of $s\ g\ z$ at $C_2$ says that:

If $\alpha$ is a covariant presheaf $\C \to \rset$, and
 we pick a morphism $g : C_1 \to C_2$ and an element
$s$ of $(\alpha \imp \alpha)(C_1)$ and an element $z$ of
$(\alpha)(C_2)$, then there will be a determinate element $s\ g\ z$
of $(\alpha)(C_2)$.

\subsection{Multiple Variables}
What happens with
\[\forall\alpha_1, \alpha_2. F(\alpha_1, \alpha_2)\]
? It should turn into something starting with
\[(\C_1\ \C_2 :\rcat)(\alpha_1 : \C_1 \to \rset)(\alpha_2 : \C_2 \to \rset)(C_1 : \C_1)(C_2:\C_2)\]
but in the expression $F$ I need to lift both of $\alpha_1, \alpha_2$ to
$\ups\alpha_1, \ups\alpha_2: (\C_1 \x \C_2) \to \rset$.
That's fine, I can do that by projection. Then I have
\[t : (\C_1\ \C_2 :\rcat)(\alpha_1 : \C_1 \to \rset)(\alpha_2 : \C_2 \to \rset)(C_1 : \C_1)(C_2:\C_2)\]
\[\to F(\ups\alpha_1, \ups\alpha_2) @ (C_1, C_2)\]
If I have such a $t$, then I could derive by appropriate substitutions
\[t : (\C :\rcat)(\alpha_1 : \C \to \rset)(\alpha_2 : \C \to \rset)(C : \C)\]
\[\to F(\ups\alpha_1, \ups\alpha_2) @ (C, C)\]
interpreting $\ups\alpha_1, \ups\alpha_2$ in the category $\rset^{\C \x \C}$. By composing with
the diagonal functor, there is a map $\rset^{\C \x \C} \to \rset^{\C}$. Hmm. What's going on here.
Given $\alpha_1, \alpha_2 : \C \to \rset$, we can construct for example
the functor
 $\ups\alpha_1 \imp \ups\alpha_2 : \C \x \C \to \rset$
and evaluate at some particular $(C, C)$ to get
\[ (\ups\alpha_1 \imp \ups\alpha_2)(C, C) : \rset\]
We could even think of this as a composite with the diagonal to get the functor
\[ (\ups\alpha_1 \imp \ups\alpha_2) \o \Delta : \C \to \rset\]
I think I'm posing the question of: is this related to
\[ (\alpha_1 \imp \alpha_2) : \C \to \rset\]
I don't necessarily expect an isomorphism, but I'm curious whether there at least exists
a natural transformation in the direction
\[\begin{tikzcd}
 \C\ar[d,equal] \ar[r,"{\Delta}"]&\C \x \C\ar[d, "{\ups\alpha_1 \imp \ups\alpha_2}"]
\ar[dl,shorten <>=10pt,Rightarrow]\\
\C\ar[r,"{\alpha_1\imp \alpha_2}"'] &\rset
\end{tikzcd}\]
Ok, such a natural transformation would need as data the original thing I was thinking about,
for each $C$ a map
\[ (\ups\alpha_1 \imp \ups\alpha_2)(C, C) \to  (\alpha_1 \imp \alpha_2)(C) \]
On the left, this is going to be a thing that is $\forall (f_1, f_2) : (C, C) \to (D_1, D_2)$
a map from $\ups\alpha_1(D_1,D_2)$ to  $\ups\alpha_2(D_1,D_2)$ which is to say a map
$\alpha_1(D_1)$ to $\alpha_2(D_2)$. And on the right, we need something that for all $f : C \to D$
gives a map from $\alpha_1(D)$ to $\alpha_2(D)$. The thing on the left is strictly more general,
so yeah, I think there is such a natural transformation, and I think it's not an isomorphism.

I'm a little anxious that this means something funny happens with deeper contravariance.
Suppose I have presheaves $P, Q, R : \C \to \rset$. I suppose I have an element of
\[ ((\ups P \imp \ups Q) \imp \ups R) (C, C) \eqno(*)\]
where I'm deliberately leaving unknown which direction each of the $\ups$ is projecting.
$P, Q, R$ could all be independently $\alpha_1$ or $\alpha_2$. My goal
is to get an element of
\[ ((P \imp Q) \imp  R) (C) \eqno(**) \]
Now an element of $(*)$ is a map from a choice $(f_1, f_2) : (C, C) \to (D_1, D_2)$ to a map
$(\ups P \imp \ups Q)(D_1, D_2)$ to $\ups R(D_1, D_2)$.
An element of $(**)$ is a map from a choice of $f : C \to D$ to a map
$(P \imp  Q)(D)$ to $R(D)$.
I can pick $f_1 := f$ and $f_2 := f$ and my remaining task is that I have
a map $(\ups P \imp \ups Q)(D, D)$ to $R(D)$ and I need a map
$(P \imp  Q)(D)$ to $R(D)$. So I have a $(P \imp  Q)(D)$ and I need a $(\ups P \imp \ups Q)(D, D)$.
Variance has reversed, and this may now actually be problematic.

What is the nature of the problem, in terms of the ``User Experience'' of the imagined term language?
It's an expressivity gap. I'd like to be able to say both:
\begin{enumerate}
\item For these two type variables, where they might get instantiated in different categories...
\item For these two type variables, where they are in fact instantiated in the same different categories...
\end{enumerate}
and I thought the latter would just arise by contraction from the former. But now I'm not sure that's valid.

\subsubsection{Syntax}
The feeling I'm getting is that for clarity I want to bind variables around the expression in which I use
presheaf-building operations. Call the binder $\omega$, I guess. Like an example might be
\[(\C : \rcat) (P\ Q\ R : \C \to \rset) \prov \omega (c_1:\C, c_2 : \C) . (P\ c_1 \to Q\ c_2) \to R\ c_1  : (\C \x \C) \to \rset\]
Hm, written out this way it seems just like a $\lambda$, really. The subtle thing to notice
here is that although this {\em is} a covariant functor $\C \x \C \to \rset$, and although I {\em can}
compose with the diagonal semantically, I don't get the expected syntactic reduction, if my calculation
above is correct.
I don't have that
\[\lambda (c_1:\C, c_2 : \C) . (P\ c_1 \to Q\ c_2) \to R\ c_1  : (\C \x \C) \to \rset\]
``applied to'' the argument $(c, c) : \C \x \C$ is the same thing as
\[ (P\ c \to Q\ c) \to R\ c\]
So that's weird. I don't know how to think about that. Actually let me be more specific.
If $\omega$ is the binder under which the meaning of $\to$ is actually changed from
``mere function type constructor'' to ``presheaf exponential'', then what I'm saying is that
\[\lambda c . (\omega (c_1:\C, c_2 : \C) . (P\ c_1 \to Q\ c_2) \to R\ c_1)(c, c)  : \C \to \rset\]
is not the same object as
\[ \omega c : \C . (P\ c \to Q\ c) \to R\ c : \C \to \rset\]
assuming the $\lambda c$ and construction of $(c,c)$ are valid concepts.
Maybe this makes it less of a surprise.

Maybe $\omega$ is a construct that `knows how to reduce' against the types in its body,
rather than $\beta$-reduction. Then again, I definitely want to throw the $\omega$-bound
variables and continue decomposing syntax in its body. That's sort of the whole point.
So I don't want to eagerly definitionally reduce them.

\section{Yoneda Types}
\[
\begin{prooftree}
C : \C
\justifies
\phi(C) : \rset
\end{prooftree}
\qquad
\begin{prooftree}
M : \phi(C)
\justifies
\dns M : \C
\end{prooftree}
\qquad
\begin{prooftree}
M : \phi(C)
\justifies
\mu M : C \to \dns M
\end{prooftree}
\qquad
\begin{prooftree}
M : \phi(C)\qquad N : \phi(\dns M)
\justifies
M+ N : \phi(C)
\end{prooftree}
\]
\[
\begin{prooftree}
\justifies
\dns (M + N) = \dns N
\end{prooftree}
\qquad
\begin{prooftree}
\justifies
 (M + N) + P = M + (N + P)
\end{prooftree}
\]
\section{Semantics of Judgments}
The basic judgment is
\[ \Gamma \prov M : A \]
which `means what it means'. $\Gamma$ can only have ordinary type variables.
I can imagine some extension
\[ c : \C ; \cdot \prov M : A(c) \]
where $A$ is a copresheaf over $\C$, a functor $\C \to \rset$.
$M$ is a global section of this; a consistent choice of an element of $A(c)$
for each object $c \in \C$, such that restriction preserves the choice.
I can also imagine
\[ c : \C ; x_1 : P_1(c), \ldots, x_n : P_n(c) \prov M : A(c) \]
Here I think $M$ is a natural transformation from $P_1 \x \cdots \x P_n$ to $A$.
We observe that of course a global section of a copresheaf is the same thing as a
natural transformation from the constant copresheaf.

But is this the right generalization? What if we are to make an exponential of copresheaves,
\[ c : \C ; \cdot \prov {?} : (A \imp B)(c) \]
This should come from something like
\[ c : \C, d : \C, f : c \to d ;  x : A(d) \prov   M :  B(d) \]
shouldn't it? Or I could just consider the situation with a concrete object $C$ of $\C$.
Then a judgment
\[  \cdot \prov {?} : (A \imp B)(C) \]
means not a natural transformation, but simply an element of the function space at object $C$.
And yet this should come from something quantified over an object:
\[ d : \C, f : C \to d ; x : A(d) \prov M : B(d) \]
This is directly from yoneda.
\[ (A \imp B)(C) = \hom(yC, A \imp B) = \hom(yC \x A, B)\]
So we could even try to package this up as
\[ z : yC ; x : A(\dns z) \prov M : B(\dns z) \]

\section{Categories}

Remember that relational parametricity worked like
\begin{center}
\begin{tabular}{l}
If $\Gamma : \rctx$, then $\sem{\Gamma} : \rset$.\\
If $\Gamma \prov A: \rset$, then $\sem{\Gamma.A} : (\theta : \sem\Gamma) \to (\Delta \to \theta A) \to \rset$.\\
If $\Gamma \prov M : A$, then $\sem{\Gamma.M} : (\theta : \sem\Gamma) \to \sem{\Gamma.A}\ \theta\ \theta M$.
\end{tabular}
\end{center}
As for universes:
If $\Gamma \prov \rset: \rset_1$, then $\sem{\Gamma.\rset} : (\theta : \sem\Gamma) \to (\Delta \to  \rset) \to \rset_1$.
So we infer that in some sense
\[\sem{\rset}\ \bullet\  A = (\Delta \to  A) \to \rset\]
The interpretation of $\rset$ requires a $\Delta$-tuple of types $A$; and its interpretation
is a $\Delta$-ary relation on the endpoints $A$.

How would we generalize this to arbitrary categories?
\begin{center}
\begin{tabular}{lll}
&If $C\in \C\ldots$&If $f : C \to D\in \C\ldots$\\
\\[-0.9em]\hline\\[-0.9em]
%%  \textcolor{gray}{If $\cdot \prov A: \rset\ldots$}
%% &\textcolor{gray}{   $\sem{A}_C :  \rset$}
%% &\textcolor{gray}{   $\sem{A}_f :  \sem{A}_C \to \sem{A}_D$}\\
%%  \textcolor{gray}{If $\cdot \prov M :  A\ldots$}
%% &\textcolor{gray}{   $\sem{M}_C :  \sem{A}_C$}
%% &\textcolor{gray}{   $\sem{M}_f : \sem{A}_f(\sem{M}_C) \equiv \sem{M}_D$}\\
If $ \prov \Gamma: \rctx\ldots$&  $\sem{\Gamma}_C :  \rset$&
  $\sem{\Gamma}_f :  \sem{\Gamma}_C \to \sem{\Gamma}_D$\\
 If $\Gamma \prov A: \rset\ldots$&  $\sem{\Gamma.A}_C : \sem{\Gamma}_C \to   \rset$&
  $\sem{\Gamma.A}_f :  (\theta : \sem{\Gamma}_C) \to \sem{\Gamma.A}_C\ \theta $\\
&&$\qquad\to \sem{\Gamma.A}_D\ (\sem{\Gamma}_f\ \theta)$\\
If $\Gamma \prov M :  A\ldots$&  $\sem{\Gamma.M}_C : (\theta : \sem{\Gamma}_C) \to  \sem{A}_C\ \theta$&
  $\sem{M}_f :  (\theta : \sem{\Gamma}_C) $\\
&&$\ \to \sem{\Gamma.A}_f\ \theta\ (\sem{\Gamma.M}_C\ \theta)$\\
&&$\ \equiv \sem{\Gamma.M}_D\ (\sem{\Gamma}_f\ \theta)$\\
\end{tabular}
\end{center}
These preserve composition. If $g : B \to C$ and $f : C \to D$ in $\C$, then
\[(\theta : \sem{\Gamma}_{B}) \to \sem{\Gamma}_{fg}\ \theta \equiv \sem{\Gamma}_f\ (\sem{\Gamma}_g\ \theta)  \]
\[(\theta : \sem{\Gamma}_{B}) (x : \sem{\Gamma.A}_B\ \theta) \to  \sem{\Gamma.A}_{fg}\ \theta\ x \equiv
\sem{\Gamma.A}_f\ (\sem{\Gamma}_g\ \theta)\ (\sem{\Gamma.A}_g\ \theta\ x)
\]
These preserve identities.
\[(\theta : \sem{\Gamma}_{C}) \to   \sem{\Gamma}_{\rid_C}\ \theta \equiv \theta \]
\[(\theta : \sem{\Gamma}_{C}) (x : \sem{\Gamma.A}_C\ \theta) \to  \sem{\Gamma.A}_{\rid_C}\ \theta\ x \equiv x
\]
\subsection{Contexts}
\[\sem{\cdot}_C = \top\]
\[\sem{\Gamma, x : A}_C = (  \theta : \sem{\Gamma}_C) \x \sem{\Gamma.A}_C\ \theta\]
We can use the syntax
\[
\begin{prooftree}
  \theta : \sem{\Gamma}_C \qquad M : \sem{\Gamma.A}_C\ \theta
\justifies
\theta[M/x] : \sem{\Gamma, x : A}_C
\end{prooftree}
\]

\subsection{Function Types}
I want to define $\sem{\Gamma.A \to B}_C$ and $\sem{\Gamma.A \to B}_f$.
\subsubsection{Object Part}
\[\begin{array}{rcl}
\sem{\Gamma.A \to B}_C\ \theta &:=& (k : (D : \C) (f : C \to D) (x_0 : \sem{\Gamma.A}_D\ (\sem{\Gamma}_f\ \theta)) \to \\
&&\qquad  \sem{(\Gamma, x:A).B}_D\ ((\sem{\Gamma}_f\ \theta)[x_0/x])) \x \mathsf{natural}\ \theta\ k
\end{array}\]
The naturality requirement is defined as
\[\mathsf{natural} : \sem\Gamma_C \to (k : \cdots) \to \rset\]
\[\mathsf{natural}\ \theta\ k := (D\ D' : \C) (f : C \to D)(g : D \to D')(x_0 : \sem{\Gamma.A}_D\ (\sem\Gamma_f\ \theta)) \to \]
\[ \sem{(\Gamma, x:A).B}_g\ ((\sem{\Gamma}_f\ \theta)[x_0/x])\ (k\ D\ f\ x_0)\]
\[\equiv k\ D'\ (gf)\ (\sem {\Gamma.A}_g\ (\sem\Gamma_f\ \theta)\ x_0 )\]
To see that this is well-typed I might need a lemma about transport commuting with substitution cons appropriately.
I could factor this as
\[\mathsf{natural} : \sem\Gamma_C \to (k : \cdots) \to \rset\]
\[\mathsf{natural}\ \theta\ k = (D : \C) (f : C \to D) \to \mathsf{naturalf}\ D\ f\ (\sem{\Gamma}_f\ \theta)\]
\[\mathsf{naturalf} : (D : \C) (f : C \to D) \to \sem\Gamma_D \to (k : \cdots) \to \rset\]
\[\mathsf{naturalf}\ D\ f\ \theta\ k := (D' : \C) (g : D \to D')(x_0 : \sem{\Gamma.A}_D\ \theta) \to \]
\[ \sem{(\Gamma, x:A).B}_g\ (\theta[x_0/x])\ (k\ D\ f\ x_0)
\equiv k\ D'\ (gf)\ (\sem {\Gamma.A}_g\ \theta\ x_0 )\]
but I don't know if that's any clearer, really.
%%%% Notice that
%% \[
%% \begin{prooftree}
%%   \sem{\Gamma}_f\ \theta : \sem{\Gamma}_D \qquad x_0 : \sem{\Gamma.A}_D\ (\sem{\Gamma}_f\ \theta)
%% \justifies
%% (\sem{\Gamma}_f\ \theta)[x_0/x] : \sem{\Gamma, x : A}_D
%% \end{prooftree}
%% \]
%%%% is an instance of the above rule
\subsubsection{Morphism Part}
Going to temporarily ignore naturality.
\[\begin{array}{rcl}
\sem{\Gamma.A \to B}_f &:&   (\theta : \sem{\Gamma}_C) \to \sem{\Gamma.A \to B}_C\ \theta \\
&&\qquad \to \sem{\Gamma.A\to B}_D\ (\sem{\Gamma}_f\ \theta)
\end{array}\]
which expands to
\[\begin{array}{rcl}
\sem{\Gamma.A \to B}_f &:&    (\theta : \sem{\Gamma}_C) \\
&&(z:  (D' : \C) (f' : C \to D') (x_0 : \sem{\Gamma.A}_{D'}\ (\sem{\Gamma}_{f'}\ \theta)) \to\\
&&\qquad  \sem{(\Gamma, x:A).B}_{D'}\ ((\sem{\Gamma}_{f'}\  \theta)[x_0/x]))\\
&&  (D' : \C) (g : D \to D') (x_0 : \sem{\Gamma.A}_{D'}\ (\sem{\Gamma}_{gf}\  \theta)) \to\\
&&\qquad  \sem{(\Gamma, x:A).B}_{D'}\ ((\sem{\Gamma}_{gf}\ \theta)[x_0/x]))\\
\end{array}\]
So we define
\[\sem{\Gamma.A \to B}_f\ \theta\ z\ D'\ g\ x_0 = z\ D'\ (gf)\ x_0 \]

\end{document}
