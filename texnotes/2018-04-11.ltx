\documentclass{article}
\input{theorem}
\input{prooftree}
\usepackage{stmaryrd}
\usepackage{latexsym}
\usepackage{yfonts}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,cd,decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}
\usepackage{tcolorbox}
\tcbuselibrary{breakable}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}

\def\bpush{\mathbf{push}}
\def\bpull{\mathbf{pull}}

\def\wo{\setminus}
\def\fA{\mathsf{A}}
\def\fC{\mathsf{C}}
\def\fX{\mathsf{X}}
\def\ff{\mathsf{f}}
\def\fm{\mathsf{m}}
\def\rspan{\mathsf{Span}}
% \def\El#1{\mathsf{El}({#1})}
\def\El#1{\ulcorner{#1}\urcorner}
\def\quote#1{{\ulcorner {#1} \urcorner}}
\def\U{\mathsf{U}}
\def\uni{\U}
\def\mor#1#2{#1 \to \underline{#2}}

\def\ridp{\mathsf{idp}}
\def\ssem#1{\langle\!\langle{#1}\rangle\!\rangle}

\definecolor{cyan}{rgb}{0.80,0.95,0.95}
\definecolor{orange}{rgb}{0.95,0.90,0.80}
\definecolor{lred}{rgb}{0.95,0.8,0.8}
\definecolor{lgray}{gray}{0.9}
\newtcolorbox{declbox}{colframe=lred,colback=lred,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{thmbox}{colframe=cyan,colback=cyan,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{defnbox}{colframe=orange,colback=orange,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{tangentbox}{colframe=lgray,colback=lgray,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}

\input{linear}
\def\rpath#1{[#1]}
\def\rfst{\mathsf{fst}\,}
\def\rsnd{\mathsf{snd}\,}
\def\bunfold{\mathbf{unfold}}
\def\bfold{\mathbf{fold}}
\def\susp#1{\langle {#1} \rangle}
\def\ssusp#1{\langle\!\langle {#1} \rangle\!\rangle}
\def\dto{\mathrel{\dot\to}}
\def\dns{{\downarrow}}
\def\ups{{\uparrow}}
\def\sprov{\Vdash}
\def\signat{{\color{red}\Sigma}}
\def\ep#1{\underline{#1}}
\def\wat{\mathbin{@}}
\def\wwat{\mathbin{\underline\wat}}
\def\cn{{:}}
\def\dv{{\div}}
\def\ww{{\mathsf w}}
\def\base{{\textfrak b}}

\def\N{{\mathbb N}}
\def\munit{I}
\def\tt{{\mathsf t}}
\def\rr{{\mathsf r}}
\def\ii{{\mathbb I}}
\def\pp{\textsf{\textbf p}}
\def\nn{{\mathsf n}}
\def\PP{\textsf{\textbf P}}
\def\NN{{\mathsf N}}
\def\zz{{\mathsf z}}
\def\sem#1{[\![#1]\!]}
\def\usem#1{\lceil\!\!\lceil{#1}\rceil\!\!\rceil}
\def\zem#1{\langle\!\langle#1\rangle\!\rangle}
\def\col#1{{\mathsf{C}}_{#1}}
\def\lax{\mathop\bigcirc}
\def\rjust{\mathsf{just}}
\def\rcvt{\mathsf{cvt}}
\def\rtype{\mathsf{type}}
\def\rkind{\mathsf{kind}}
\def\rmode{\mathsf{mode}}
\def\rprel{\mathbf{Prel}}
\def\rrfam{\mathbf{Rfam}}
\def\rset{\mathbf{Set}}
\def\rfinset{\mathbf{FinSet}}
\def\rrel{\mathbf{Rel}}
\def\rcat{\mathbf{Cat}}
\def\rfam{\mathbf{Fam}}
\def\binj{\mathbf{inj}}
\def\rid{\mathsf{id}}
\def\rtrue{\mathrel\mathrm{true}}
\def\pbck{\ar[dr, phantom, pos=0, "\lrcorner"]}
\def\bpbck{\ar[ddrr, phantom, pos=0, "\lrcorner"]}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\btwo{\mathbf{2}}
\def\bone{\mathbf{1}}

\newarrow {Equiv} =====
\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\def\mapt{\ar[ddd,mapsto,shorten <=2em, shorten >=2em]}
\def\frommaps{\ar[from=uu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\frommapt{\ar[from=uuu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\C{\mathbf{C}}
\def\W{\mathbf{W}}
\def\S{\mathbf{S}}
\def\D{\mathbf{D}}
\def\E{\mathbf{E}}
\def\M{\mathbf{M}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\tri{\triangleright}
\def\o{\circ}
\def\rctx{\,\mathsf{ctx}}
\def\rdctx{\,\mathsf{dctx}}
\def\del{\partial}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\null{\emptyset}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\definecolor{fib}{HTML}{ff7f00}
\definecolor{green}{HTML}{007f00}
\definecolor{red}{HTML}{df3f3f}
\definecolor{opfib}{HTML}{007fff}

% For lightening colors I used
% http://trycolors.com/ 6 parts white to 1 part color
\definecolor{opfibl}{HTML}{DBEDFF}
\definecolor{greenl}{HTML}{DBEDDB}
\definecolor{redl}{HTML}{FAE4E4}
\def\njudge#1{\fcolorbox{opfib}{white}{#1}}
\def\nrule#1{\fcolorbox{white}{opfibl}{#1}}
\def\neqn#1{\fcolorbox{white}{redl}{#1}}



\def\judge#1{\vskip 2em\noindent \njudge{$#1$}\vskip 0.5em\noindent}
\def\rule#1{\vskip 2em \noindent \nrule{$#1$}\vskip 0.5em\noindent}
\def\eqn#1{\vskip 2em \noindent \neqn{$#1$}\vskip 0.5em\noindent}
\def\prof{\nrightarrow}
\def\tensor{\otimes}
\def\htensor{\mathrel{\hat\otimes}}
\def\lol{\multimap}
\def\hlol{\mathrel{\hat\multimap}}
\def\wtf{{\color{red}???}}

\def\re{\mathbf{E}}
\def\shp{\mathrel{\sharp}}
\def\zero{\texttt{0}}
\begin{document}

\def\
\tikzset{
   commutative diagrams/.cd,
   arrow style=tikz,
   diagrams={>=stealth}}

\section{Recovering Literally Kripke Semantics}

Think about the polarized proposition $\dns (P_1 \lol \ups P_2)$ in a world where
`every proposition is positive'. How does this translate?
\[\dns (P_1 \lol \ups P_2) \wat \alpha
= \forall \phi . (P_1 \lol \ups P_2) \wat \phi \to \alpha \tri \phi\]
\[= \forall \phi . (\exists \alpha'\phi' . P_1 \wat \alpha' \x \ups P_2 \wat \phi' \x {\lol}(\alpha', \phi', \phi)) \to \alpha \tri \phi\]
\[= \forall \phi \alpha'\phi' . P_1 \wat \alpha' \to \ups P_2 \wat \phi' \to {\lol}(\alpha', \phi', \phi) \to \alpha \tri \phi\]
I want to rearrange this so that it's a function of $P_1$ and
$\dns\ups P_2$, and convince myself that since I'm living in a world
where everything's shifted so as to be positive, and maybe I have only
shifted negative atoms and no naked positive ones, I can assert that
$\dns \ups P = P$ for every P.

First of all, I'm going to make the guess that every $\phi$ is of the form $(\beta, \psi)$
assuming worlds $\alpha, \beta$ are actually like Kripke worlds on which
there is some relation $\le$, and further there's a relation $\#$ on $\psi$s. I'm going
to suppose that the relation $\lol(\alpha', (\beta', \psi'), (\beta, \psi))$
requires that $\psi = \psi'$ and otherwise imposes some unknown
relation $\lol(\alpha', \beta', \beta)$ on the remaining kripke
worlds. So what I have becomes
\[= \forall \beta\psi \alpha'\beta' . P_1 \wat \alpha' \to \ups P_2 \wat (\beta', \psi) \to {\lol}(\alpha', \beta', \beta) \to \alpha \tri (\beta, \psi)\]
I'm going to guess that $\alpha \tri (\beta, \psi)$ is $\beta \ge \alpha \to \#(\psi)$, so I now have
\[= \forall \beta\psi \alpha'\beta' . \beta \ge \alpha \to P_1 \wat \alpha' \to \ups P_2 \wat (\beta', \psi) \to {\lol}(\alpha', \beta', \beta) \to \#(\psi)\]
I want to very carefully remember what $\dns$ is.
\[ \dns N \wat \alpha' = \forall (\beta', \psi) . N \wat (\beta', \psi) \to \alpha' \tri (\beta', \psi) \]
\[  = \forall (\beta', \psi) . N \wat (\beta', \psi) \to \beta' \ge \alpha' \to \#(\psi) \]
So {\em if} I set $\lol(\alpha', \beta', \beta)$ to require that $\beta = \alpha'$ and
$\beta' \ge \beta$, I get that
\[\dns (P_1 \lol \ups P_2) \wat \alpha =\]
\[= \forall \alpha'\psi \beta' . \alpha' \ge \alpha \to P_1 \wat \alpha' \to \ups P_2 \wat (\beta', \psi) \to \beta' \ge \alpha' \to \#(\psi)\]
\[= \forall \alpha' . \alpha' \ge \alpha \to P_1 \wat \alpha' \to \dns\ups P_2 \wat \alpha'\]


\section{Focusing on What actually Matters for Presheaf Semantics}

Say $\prov \Delta : \rdctx$ is a context $i_1 : \C_1, \ldots, i_n : \C_n$ consisting
of variables typed by finite categories $\C_i$ with initial objects.

These are the things we intend to be true;
throughout them when appropriate suppose $\delta, \delta' :  \Delta_\bullet, \phi :  \Delta_{\delta\to \delta'}$.
\begin{thmbox}
If $\prov \Delta : \rdctx$ then $\prov  \Delta_\bullet : \rtype$.\\
If $\prov \Delta : \rdctx$ then $\prov  \Delta_{\delta\to\delta'} : \rtype$.\\
  If $\Delta\prov  \Gamma: \rctx$ then $ \prov \Gamma_\delta : \rtype$.\\
  If $\Delta\prov  \Gamma: \rctx$ then $\gamma : \Gamma_{\delta} \prov \Gamma_\phi(\gamma) : \Gamma_{\delta'}$.\\
  If $\Delta; \Gamma\prov A: \rtype$ then $ \gamma : \Gamma_\delta \prov A_\delta(\gamma) : \rtype$.\\
  If $\Delta; \Gamma\prov A: \rtype$ then
$ \gamma : \Gamma_\delta, x : A_\delta(\gamma) \prov A_\phi(x) : A_{\delta'}(\Gamma_\phi(\gamma)) $.
  If $\Delta; \Gamma\prov M: A$ then $ \gamma : \Gamma_\delta \prov M_\delta(\gamma) : A_\delta(\gamma)$.\\
  If $\Delta; \Gamma\prov M: A$ then
$\gamma : \Gamma_\delta \prov A_\phi(M_\delta(\gamma)) \equiv M_{\delta'}(\Gamma_\phi(\gamma))$.
\end{thmbox}
This should all be routine canonical presheaf semantics {\em except} when we don't leave
 $\Delta$ constant.
There are three nontrivial types of constructions that do this:
quantification over variables $i : \C$ in $\Delta$, witness types, and
the mysterious generalized exchange rule.

I also want to be clear about how types arise from $\Delta$s, and
what happens to contexts and types when I
weaken them across a growing $\Delta$, even though it is trivial.
\subsection{Categorical Contexts}
\begin{defnbox}
\begin{tabular}{r@{$\quad=\quad$ }l}
$(\cdot)_\bullet   $&$\top$\\
$(\Delta, i : \C)_\bullet  $&$\Delta_\bullet \x \C_\bullet$\\
$(\cdot)_{* \to *}   $&$\top$\\
$(\Delta, i : \C)_{(\delta, c) \to (\delta', c')}  $&$\Delta_{\delta\to\delta'} \x \C(c, c')$\\
\end{tabular}
\end{defnbox}
\subsection{Weakening \& Exchange}
If $\Delta \prov \Gamma\rctx$, then also $\Delta, i : \C \prov \Gamma \rctx$,
with $\Gamma_{\delta, c} = \Gamma_\delta$ and $\Gamma_{\phi, f} = \Gamma_\phi$.
We can do the same thing for permutations of $\Delta$, i.e. reflect them as permutations
of $\delta$.
Down at the level of types we'd also say $A_{\delta, c}(\gamma) = A_\delta(\gamma)$
for $\gamma$ being of type $\Gamma_{\delta, c}$ in the left side of the equation
turns out to actually be $\Gamma_\delta$ so is suitable for the rhs of the equation.
Similarly $A_{\phi, f} = A_\phi$, and $M_{\delta, c} = M_\delta$ when weakening, similarly
with everything for exchange.
\subsection{Forall}
\[
\erule
{\Delta, i : \C; \Gamma \prov A : \rtype \using \forall }
{\Delta; \Gamma \prov \forall i . A : \rtype}
\]
\[
\erule
{\Delta, i : \C; \Gamma \prov M : A \using \forall I}
{\Delta; \Gamma \prov \susp i M : \forall i . A }
\qquad
\erule
{\Delta; \Gamma \prov M : \forall i . A \using \forall E}
{\Delta, i : \C; \Gamma \prov M[i] : A }
\]
\begin{defnbox}
  $(\forall i . A)_\delta(\gamma) = A_{\delta, 0}(\gamma)$\\
  $(\forall i . A)_\phi(x) = A_{\phi, \rid_0}(\gamma)$\\
  $(\susp i M)_\delta(\gamma) = M_{\delta, 0}(\gamma)$\\
  $(M[i])_{\delta,c}(\gamma) = A_{\rid_\delta, !_c}(M_\delta(\gamma))$
\end{defnbox}
Check term/morphism equality?
Need
\[(\forall i . A)_\phi(M_\delta(\gamma)) = M_{\delta'}(\Gamma_\phi(\gamma))\]
which is
\[A_{\phi, \rid_0}(M_{\delta, 0}(\gamma)) = M_{\delta', 0}(\Gamma_{\phi, \rid_0}(\gamma))\]
because of weakening of $M$ and $\Gamma$, which follows by i.h.

Check $\beta$ and $\eta$?
First, $(\susp i (M[i]))_{\delta}(\gamma) =(M[i])_{\delta,0}(\gamma) = A_{\rid_{\delta, c}}(M_\delta(\gamma)) = M_\delta(\gamma)$. Second, $((\susp i M)[i])_{\delta, c} = A_{\rid_\delta, !_c}((\susp i M)_\delta(\gamma))$
\[ = A_{\rid_\delta, !_c}(M_{\delta, 0}(\gamma))
 = M_{\delta, c}(\Gamma_{\rid_\delta, !_c}(\gamma))
 = M_{\delta, c}(\gamma) \]

\subsection{Witness}
\[
\erule
{ \Delta; \Gamma \prov \fX_c : \rtype \qquad \Delta;\Gamma, y : \fX_c \prov  \fm_f : \fX_{c'}
\quad (\forall c,c', f:c\to c'\in \C) \using \star }
{\Delta, i : \C; \Gamma \prov (\fX,\fm) \star i : \rtype}
\]
\[
\erule
{\Delta; \Gamma \prov M : \fX_0 \using \star I}
{\Delta, i : \C; \Gamma \prov  M \wat i : (\fX, \fm) \star i }
\qquad
\erule
{\Delta, i : \C; \Gamma \prov M : (\fX, \fm) \star i \using \star E}
{\Delta; \Gamma \prov \ssusp i M : \fX_0 }
\]
(I'm not mentioning the commutativity requirement in $\star$-formation,
but surely it has to hold, too)
\begin{thmbox}
  If $\Delta; \Gamma\prov A: \rtype$ then $ \gamma : \Gamma_\delta \prov A_\delta(\gamma) : \rtype$.\\
  If $\Delta; \Gamma\prov A: \rtype$ then
  $ \gamma : \Gamma_\delta, x : A_\delta(\gamma) \prov A_\phi(x) : A_{\delta'}(\Gamma_\phi(\gamma)) $.
\end{thmbox}
 \begin{defnbox}
   $((\fX, \fm) \star i)_{\delta, c}(\gamma) = (\fX_c)_\delta(\gamma)$\\
   $((\fX, \fm) \star i)_{\phi, f}(x) = (\fX_{c'})_{\phi}((\fm_f)_\delta(x))$\\
   $(M \wat i)_{\delta, c}(\gamma) = (\fm_{!_c})_\delta(M_\delta(\gamma))$\\
   $(\ssusp i M)_{\delta}(\gamma) = M_{\delta, 0}(\gamma)$
 \end{defnbox}
I think I should anyway have
\[(\fX_{c'})_{\phi}((\fm_f)_\delta(x)) = (\fm_f)_{\delta'}((\fX_{c})_{\phi, \rid_c}(x)) : (\fX_{c'})_{\delta'}(\Gamma_\phi(\gamma))\]
from existing lemmas, so I have those two equally good options for how to define
$((\fX, \fm) \star i)_{\phi, f}(x)$.

%% For $(M \wat i)_{\delta, c}(\gamma)$, we have $M_\delta(\gamma) : (\fX_0)_\delta(\gamma)$,
%% and need
%% $(M\wat i)_{\delta, c}(\gamma) : ((\fX, \fm) \star i)_{\delta, c}(\gamma)$.
%% which is the same as
%% $(M\wat i)_{\delta, c}(\gamma) : (\fX_c)_{\delta}(\gamma)$.

%% For $(\ssusp i M)_{\delta}(\gamma)$, we have
%% $M_{\delta, c}(\gamma) : ((\fX, \fm) \star i)_{\delta, c}(\gamma)$ which is the same as
%% \[M_{\delta, c}(\gamma) : (\fX_c)_{\delta}(\gamma)\]
%% and we need
%% $(\ssusp i M)_{\delta}(\gamma) : (\fX_0)_\delta(\gamma)$, which is easy to get.
Check term/morphism equality?
We need to show
\[((\fX, \fm) \star i)_{\phi,f}(M_{\delta,c}(\gamma)) \equiv M_{\delta',c'}(\Gamma_\phi(\gamma))\]
i.e.
\[(\fX_{c'})_\phi((\fm_f)_{\delta}(M_{\delta,c}(\gamma)) \equiv M_{\delta',c'}(\Gamma_\phi(\gamma))\]
\[(\fm_f)_{\delta'}((\fX_{c})_{\phi,\rid_c}(M_{\delta,c}(\gamma))) \equiv M_{\delta',c'}(\Gamma_\phi(\gamma))\]
\[(\fm_f)_{\delta'}(M_{\delta',c}(\Gamma_\phi(\gamma))) \equiv M_{\delta',c'}(\Gamma_\phi(\gamma))\]
which should follow from commutativity properties of $\fm_f$, I think? To be
completely honest, this is a proof gap and I need to spell out more carefully
what I'm requiring, but I feel optimistic about things lining up here in the right way.
\subsection{Exchange}
\[
\erule
{\begin{tabular}{c}
$\Delta;\Gamma, x : [c/i]A \prov M_c : [c/i]B$\\
$\Delta, i : \C;\Gamma, y : \forall i.A  \prov N : [y[i]/x]B$\\
$\Delta;\Gamma, y : \forall i .A \prov [y[c]/x]M \equiv [c/i]N$\\
\end{tabular}}
{\Delta, i : \C;\Gamma, x : A \prov \bcase : B}
\]
This makes me realize that I missed some syntactic rules:
I need to say that $(\fX, \fm) \star c$ actually $\beta$-reduces to $\fX_c$.
I need to allow $M[c]$ to be a real term, with rule
\[
\erule
{\Delta; \Gamma \prov M : \forall i . A \using \forall E}
{\Delta; \Gamma \prov M[c] : [c/i]A }
\]
and say that
\begin{defnbox}
  $(M[c])_{\delta}(\gamma) = A_{\rid_\delta, !_c}(M_\delta(\gamma))$
\end{defnbox}
For this to even make sense I already have to have a theorem that
\begin{thmbox}
$  ([c/i]A)_\delta(\gamma) = A_{\delta, c}(\gamma)$
\end{thmbox}
So we know that

\[x : A_{\delta, c}(\gamma) \prov (M_c)_{\delta}(\gamma, x) : B_{\delta, c}(\gamma, x)\]
\[y : A_{\delta, 0}(\gamma) \prov (N)_{\delta, c}(\gamma, y) : B_{\delta, c}(\gamma, A_{\rid_\delta, !_c}(y))\]
And this seems like this should be enough to generate the $\bcase$!

\subsection{Universe and Small Type Constructors}
Nothing should be terrifically surprising here.
\[
\erule
{}
{\Delta;\Gamma \prov \U : \rtype}
\qquad
\erule
{\Delta;\Gamma \prov t : \U}
{\Delta;\Gamma \prov \El t : \rtype}
\]
\begin{defnbox}
  $\U_\delta(\gamma) = (\phi : \mor{\delta}{\delta'}) \to \U$\ (functorial?)\\
  $\U_{\phi: \delta \to \delta'}(x) = \lambda (\phi' : \mor{\delta'}{\delta''}).x(\phi' \o \phi)$\\
  $(\El{t})_\delta(\gamma) = (\phi : \mor{\delta}{\delta'}) \to \El{t_{\delta}(\gamma)(\phi)}$\ (natural?)\\
  $(\El{t}_{\phi : \delta \to \delta'})(\gamma) = {?}$
\end{defnbox}
\section{Compressing}
I wonder if I can categorically streamline the concrete syntax.
I know that
\begin{thmbox}
  \begin{enumerate}
  \setlength{\itemsep}{0pt}
  \setlength{\parskip}{0pt}
  \item   $\sem \Delta$ is a category
  \item   If $\Delta \prov \Gamma : \rctx$ then $\prov \sem \Gamma : \sem \Delta \imp \rtype$.
  \item ?
  \end{enumerate}
\end{thmbox}
Where 1 means
\begin{thmbox}
If $\prov \Delta : \rdctx$ then $\prov  \Delta_\bullet : \rtype$.\\
If $\prov \Delta : \rdctx$ then $\prov  \Delta_{\delta\to\delta'} : \rtype$.
\end{thmbox}
where $\imp\rtype$ means a functor into the category of rtypes and functions,
so that 2 means
\begin{thmbox}
  If $\Delta\prov  \Gamma: \rctx$ then $ \prov \Gamma_\delta : \rtype$.\\
  If $\Delta\prov  \Gamma: \rctx$ then $\gamma : \Gamma_{\delta} \prov \Gamma_\phi(\gamma) : \Gamma_{\delta'}$.
\end{thmbox}
And then we come to the $A$- and $M$-properties, and the ordinary language of
categories and functors and natural transformations seems to fall
apart, and I guess I want to talk about fibrations instead?
\begin{thmbox}
  If $\Delta; \Gamma\prov A: \rtype$ then $ \gamma : \Gamma_\delta \prov A_\delta(\gamma) : \rtype$.\\
  If $\Delta; \Gamma\prov A: \rtype$ then
$ \gamma : \Gamma_\delta, x : A_\delta(\gamma) \prov A_\phi(x) : A_{\delta'}(\Gamma_\phi(\gamma)) $.
  If $\Delta; \Gamma\prov M: A$ then $ \gamma : \Gamma_\delta \prov M_\delta(\gamma) : A_\delta(\gamma)$.\\
  If $\Delta; \Gamma\prov M: A$ then
$\gamma : \Gamma_\delta \prov A_\phi(M_\delta(\gamma)) \equiv M_{\delta'}(\Gamma_\phi(\gamma))$.
\end{thmbox}

\subsection{Second try, with fibrations}
\begin{thmbox}
  \begin{enumerate}
  \setlength{\itemsep}{0pt}
  \setlength{\parskip}{0pt}
  \item   $\sem \Delta$ is a category
  \item   If $\Delta \prov \Gamma : \rctx$ then $\Gamma$ is a category over $\Delta$,
\[\prov f_\Gamma : \sem \Gamma \imp \sem\Delta^\op\]
where $\imp$ indicates a fibration. The fiber $f_\Gamma^*(\delta)$ is the thing that
corresponds to what I would have written $\Gamma_\delta$ before, and
the fibration structure $f^*_\Gamma(\phi)$ is what would have been $\Gamma_\phi$.
  \item If $\Delta ; \Gamma \prov A : \rtype$, then $\sem A : \sem {\Gamma, A} \to \sem \Gamma$ over $\sem \Delta^\op$.
    \begin{tikzcd}
      \sem {\Gamma, A} \ar[r, "\sem A"]\ar[d, "f_{\Gamma, A}"'] & \sem \Gamma \ar[dl, "f_\Gamma"]\\
\sem \Delta^\op
    \end{tikzcd}
  \item A term is a slice of its type, as usual.
    \begin{tikzcd}
      \sem \Gamma \ar[rr, equal, bend left]\ar[ddr, bend right]\ar[dr, "\sem M"]
      & & \sem \Gamma\ar[ddl, bend left]\\
      &\sem {\Gamma, A}\ar[d]\ar[ur, "\sem A"]\\
      & \sem \Delta^\op
    \end{tikzcd}
  \end{enumerate}
\end{thmbox}

\section{Going Way Back}
Here's some axiomatic-flavored thinking, back to how I was thinking about it
last August (cf. \texttt{https://twitter.com/jcreed/status/898212084114128896})
 Suppose that for every function $f : A \to B$ that there's a type.
\def\reln#1{{\mathsf R}[#1]}
\[
\erule
{\Gamma \prov f : A \to B}
{\Gamma \prov \reln f : \rtype}
\]
With the idea being that this is standing in for the type
of functions $\sharp A \to B$ such that when you precompose them
with $\eta : A \to \sharp A$, you get precisely $f$.

I think a $\bpush$ operation always exists:
\[
\erule
{\Gamma\prov f : A \to B \qquad \Gamma \prov g : B \to C \qquad \Gamma \prov M : \reln g}
{\Gamma \prov \bpush^g_f M : \reln {gf}}
\]
and a $\bpull$ may exist only for some types, but when it does, it's supposed to be some kind
of right adjoint to $\bpush$:
\[
\erule
{\Gamma\prov f : A \to B \qquad \Gamma \prov g : B \to C \qquad \Gamma \prov M : \reln {gf}}
{\Gamma \prov \bpull_f M : \reln {g}}
\]
Plus some coproducty things
\[
\erule
{{\Gamma\prov f : A + B \to C} \qquad
{\Gamma\prov M : \reln {f \o \binl} \atop \Gamma \prov N : \reln {f \o \binr}}}
{\Gamma \prov [M, N] : \reln{f}}
\qquad
\erule
{\Gamma \prov f : 0 \to C}
{\Gamma \prov [] : \reln{f}}
\]
This might be a better way of formalizing things than talking about explicit copairing, hmm.
\vfil\eject
\subsection{Explaining $\reln{}$}

I might try to define $\reln{f}$ for $f : A \to B$ by induction on $B$,
and define $\bpush^g_f$ for $f : A \to B$ and $g : B \to C$ by induction on $C$.

\begin{defnbox}
\begin{tabular}{l@{$\qquad$ }l}
$B$&$\reln{f}$\\
\noalign{\vskip 0.3em}
\hline
\noalign{\vskip 0.3em}
$\U  $&$(C : \U) \x (a : A) \to \El C \to \El{f\ a}$\\
$B_1 \to B_2$&$ (\kappa : A \to B_1) \to \reln\kappa \to \reln{\lambda a . f\ a\ (\kappa\ a)}$
\end{tabular}
\end{defnbox}

\begin{defnbox}
\begin{tabular}{l@{$\qquad$ }l}
$C$&$\bpush_f^g(M)$\\
\noalign{\vskip 0.3em}
\hline
\noalign{\vskip 0.3em}
$\U  $&$\pair {\bfst M} {\lambda a c . (\bsnd M)\ (f\ a)\ c}$\\
$C_1 \to C_2$&$ \lambda \ell \rho .  ???$
\end{tabular}
\end{defnbox}
For the $\U$ case, we have $f : A \to B$ and $g : B \to \U$, so we're going from
$\reln{g}$ to $\reln{gf}$, i.e. from
\[M : (C : \U) \x (b : B) \to \El C \to \El{g\ b}\]
to
\[(C : \U) \x (a : A) \to \El C \to \El{g(f\ a)}\]


For the $C_1 \to C_2$ case, we have
 $f : A \to B$ and $g : B \to C_1 \to C_2$. We need to go from
$\reln{g}$ to $\reln{gf}$, i.e. from
\[ M : (\kappa : B \to C_1) \to \reln\kappa \to \reln{\lambda b . g\ b\ (\kappa\ b)}\]
to
\[ (\ell : A \to C_1) \to \reln\ell \to \reln{\lambda a . g\ (f\ a)\ (\ell\ a)}\]
And this seems to break down! Huh, interesting.
\subsection{Attempt at Kripke Gambit}
Can I say instead
\begin{defnbox}
\begin{tabular}{l@{$\qquad$ }l}
$B$&$\reln{f}$\\
\noalign{\vskip 0.3em}
\hline
\noalign{\vskip 0.3em}
$\U  $&$(C : \U) \x (a : A) \to \El C \to \El{f\ a}$\\
$B_1 \to B_2$&$ (\alpha : \U) (\phi : A \to \El\alpha) (\kappa : \El\alpha \to B_1)$\\
&$ \to \reln\kappa \to \reln{\lambda a . f\ a\ (\kappa\ (\phi\ a))}$
\end{tabular}
\end{defnbox}
so that For the $C_1 \to C_2$ case, we still have
 $f : A \to B$ and $g : B \to C_1 \to C_2$, and we now need to go from
\[ M : (\beta : \U) (\psi : B \to \El \beta)(\kappa : \El \beta \to C_1) \to \reln\kappa \to \reln{\lambda b . g\ b\ (\kappa\ (\psi\ b))}\]
to
\[ (\alpha : \U) (\phi : A \to \El \alpha)(\ell : \El \alpha \to C_1) \to \reln\ell \to \reln{\lambda a . g\ (f\ a)\ (\ell\ (\phi\ a))}\]
Nah, this doesn't seem to get me any traction.
\subsection{Separate, Much More Conjectural Thought}
What if $\kappa$  is itself relationy? Then maybe I could $\bpull$ it somehow.
I say
\begin{defnbox}
\begin{tabular}{l@{$\qquad$ }l}
$B$&$\reln{f}$\\
\noalign{\vskip 0.3em}
\hline
\noalign{\vskip 0.3em}
$\U  $&$(C : \U) \x (a : A) \to \El C \to \El{f\ a}$\\
$B_1 \to B_2$&$ (\kappa : A \sim B_1) \to \reln\kappa \to \reln{\lambda a . f\ a\ (\kappa\ a)}$
\end{tabular}
\end{defnbox}
in which case I need to get from
\[ M : (\kappa : B \sim C_1) \to \reln\kappa \to \reln{\lambda b . g\ b\ (\kappa\ b)}\]
to
\[ (\ell : A \sim C_1) \to \reln\ell \to \reln{\lambda a . g\ (f\ a)\ (\ell\ a)}\]
so I start off by saying $ \lambda \ell \rho .  ?$ and maybe try to invoke $M$
on something I'll call $\bpull_f \ell$ which has type $B \sim C_1$.
Now I have a $\reln{\ell}$ and I need a $\reln{\bpull_f \ell}$. Since $\bpull_f\ell$
is `smaller' than $\ell$, this feels like again some kind of (higher-order?) $\bpull$.
But now I want to push along $f$ to get the right type. I need the equality
\[ g\ (f\ a)\ (\bpull_f \ell\ (f\ a)) = g\ (f\ a)\ (\ell\ a)\]
\begin{defnbox}
\begin{tabular}{l@{$\qquad$ }l}
$C$&$\bpush_f^g(M)$\\
\noalign{\vskip 0.3em}
\hline
\noalign{\vskip 0.3em}
$\U  $&$\pair {\bfst M} {\lambda a c . (\bsnd M)\ (f\ a)\ c}$\\
$C_1 \to C_2$&$ \lambda \ell \rho .  \bpush_f\ (M\ (\bpull_f \ell)\ (\bpull'_f \rho))$
\end{tabular}
\end{defnbox}
But I'm playing very fast and loose with relationy things and
application. What would it really mean for $f$ itself to be a relation
in $\reln{f}$?
\end{document}
