\documentclass{article}
\input{theorem}
\input{prooftree}
\usepackage{stmaryrd}
\usepackage{latexsym}
\usepackage{yfonts}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,cd,decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}
\usepackage{tcolorbox}
\tcbuselibrary{breakable}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}

\def\bpush{\mathbf{push}}
\def\bpull{\mathbf{pull}}

\def\wo{\setminus}
\def\fA{\mathsf{A}}
\def\fC{\mathsf{C}}
\def\fX{\mathsf{X}}
\def\ff{\mathsf{f}}
\def\fm{\mathsf{m}}
\def\rspan{\mathsf{Span}}
% \def\El#1{\mathsf{El}({#1})}
\def\El#1{\ulcorner{#1}\urcorner}
\def\quote#1{{\ulcorner {#1} \urcorner}}
\def\U{\mathsf{U}}
\def\uu{\mathsf{u}}
\def\uni{\U}
\def\mor#1#2{#1 \to \underline{#2}}

\def\ridp{\mathsf{idp}}
\def\ssem#1{\langle\!\langle{#1}\rangle\!\rangle}

\definecolor{cyan}{rgb}{0.80,0.95,0.95}
\definecolor{orange}{rgb}{0.95,0.90,0.80}
\definecolor{bluegray}{rgb}{0.6,0.6,0.85}
\definecolor{lgray}{gray}{0.9}
\newtcolorbox{declbox}{colframe=lred,colback=lred,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{thmbox}{colframe=cyan,colback=cyan,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{defnbox}{colframe=orange,colback=orange,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{tangentbox}{colframe=lgray,colback=lgray,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}

\input{linear}
\def\rpath#1{[#1]}
\def\rfst{\mathsf{fst}\,}
\def\rsnd{\mathsf{snd}\,}
\def\bunfold{\mathbf{unfold}}
\def\bfold{\mathbf{fold}}
\def\susp#1{\langle {#1} \rangle}
\def\ssusp#1{\langle\!\langle {#1} \rangle\!\rangle}
\def\dto{\mathrel{\dot\to}}
\def\dns{{\downarrow}}
\def\ups{{\uparrow}}
\def\sprov{\Vdash}
\def\signat{{\color{red}\Sigma}}
\def\ep#1{\underline{#1}}
\def\wat{\mathbin{@}}
\def\wwat{\mathbin{\underline\wat}}
\def\cn{{:}}
\def\dv{{\div}}
\def\ww{{\mathsf w}}
\def\base{{\textfrak b}}

\def\munit{I}
\def\tt{{\mathsf t}}
\def\rr{{\mathsf r}}
\def\ii{{\mathbb I}}
\def\pp{\textsf{\textbf p}}
\def\nn{{\mathsf n}}
\def\PP{\textsf{\textbf P}}
\def\NN{{\mathsf N}}
\def\zz{{\mathsf z}}
\def\sem#1{[\![#1]\!]}
\def\usem#1{\lceil\!\!\lceil{#1}\rceil\!\!\rceil}
\def\zem#1{\langle\!\langle#1\rangle\!\rangle}
\def\col#1{{\mathsf{C}}_{#1}}
\def\lax{\mathop\bigcirc}
\def\rjust{\mathsf{just}}
\def\rcvt{\mathsf{cvt}}
\def\rtype{\mathsf{type}}
\def\rdtype{\mathsf{disc}}
\def\rkind{\mathsf{kind}}
\def\rmode{\mathsf{mode}}
\def\rprel{\mathbf{Prel}}
\def\rrfam{\mathbf{Rfam}}
\def\rset{\mathbf{Set}}
\def\rfinset{\mathbf{FinSet}}
\def\rrel{\mathbf{Rel}}
\def\rcat{\mathbf{Cat}}
\def\rfam{\mathbf{Fam}}
\def\binj{\mathbf{inj}}
\def\rid{\mathsf{id}}
\def\rtrue{\mathrel\mathrm{true}}
\def\pbck{\ar[dr, phantom, pos=0, "\lrcorner"]}
\def\bpbck{\ar[ddrr, phantom, pos=0, "\lrcorner"]}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\btwo{\mathbf{2}}
\def\bone{\mathbf{1}}

\newarrow {Equiv} =====
\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\def\mapt{\ar[ddd,mapsto,shorten <=2em, shorten >=2em]}
\def\frommaps{\ar[from=uu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\frommapt{\ar[from=uuu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\C{\mathbf{C}}
\def\G{\mathbf{G}}
\def\S{\mathbf{S}}
\def\D{\mathbf{D}}
\def\E{\mathbf{E}}
\def\M{\mathbf{M}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\tri{\triangleright}
\def\o{\circ}
\def\rctx{\,\mathsf{ctx}}
\def\rdctx{\,\mathsf{dctx}}
\def\del{\partial}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\null{\emptyset}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\definecolor{fib}{HTML}{ff7f00}
\definecolor{green}{HTML}{007f00}
\definecolor{red}{HTML}{df3f3f}
\definecolor{opfib}{HTML}{007fff}

% For lightening colors I used
% http://trycolors.com/ 6 parts white to 1 part color
\definecolor{opfibl}{HTML}{DBEDFF}
\definecolor{greenl}{HTML}{DBEDDB}
\definecolor{redl}{HTML}{FAE4E4}
\def\njudge#1{\fcolorbox{opfib}{white}{#1}}
\def\nrule#1{\fcolorbox{white}{opfibl}{#1}}
\def\neqn#1{\fcolorbox{white}{redl}{#1}}



\def\judge#1{\vskip 2em\noindent \njudge{$#1$}\vskip 0.5em\noindent}
\def\rule#1{\vskip 2em \noindent \nrule{$#1$}\vskip 0.5em\noindent}
\def\eqn#1{\vskip 2em \noindent \neqn{$#1$}\vskip 0.5em\noindent}
\def\prof{\nrightarrow}
\def\tensor{\otimes}
\def\htensor{\mathrel{\hat\otimes}}
\def\lol{\multimap}
\def\hlol{\mathrel{\hat\multimap}}
\def\wtf{{\color{red}???}}

\def\re{\mathbf{E}}
\def\sh{\sharp}
\def\shp{\mathrel{\sharp}}
\def\zero{\texttt{0}}
\begin{document}

\def\
\tikzset{
   commutative diagrams/.cd,
   arrow style=tikz,
   diagrams={>=stealth}}

\section{Semantics of category-typed variables}
\subsection{Zero or One}
So I can give a simple sort of {\em non-nested} parametricity semantics to the situation
\[
\begin{tikzcd}
  \rset \ar[d, "\Delta"', shift right=5]\ar[d, "\dashv", phantom]\ar[from=d, "\forall"', shift right=5] \\
\rset^{\C^\op}
\end{tikzcd}
\]
Where I have two classes of types, regular and presheaf, and the diagonal $\Delta$ that takes
a set to the constant presheaf, and the $\forall$ that computes the set of global sections.
I can talk about witness types like
\[\begin{tabular}{rccl}
  Regular Sets&$X$&$::=$&$\forall \nu . P  \celse (x : X) \to X \celse \cdots$\\
  Presheaves&$P$&$::=$&$\Delta_\nu X  \celse S \star \nu \celse (y : P) \to P \celse \cdots$\\
  Concrete Presheaves&$S$&$::=$&$ (X_c, f_m)$\\
\end{tabular}\]
where my rules are like
\[
\erule
{\nu : \C ; \Gamma^w \prov P : \rtype}
{ \Gamma \prov \forall \nu . P : \rtype}
\qquad
\erule
{\nu : \C ; \Gamma^w \prov e  : P}
{ \Gamma \prov \lambda \nu . e : \forall \nu . P }
\qquad
\erule
{ \Gamma \prov M : \forall \nu . P }
{\nu : \C ; \Gamma^w \prov M[\nu]  : P}
\]
\[
\erule
{\Gamma \prov S : \rspan}
{\nu : \C ; \Gamma^w \prov S \star \nu : \rtype}
\qquad
\erule
{\nu : \C ; \Gamma \prov e  : S \star \nu}
{ \Gamma \prov [c/\nu] e  : X_c}
\qquad
\erule
{ \Gamma \prov M_c : X_c \qquad f_m(M_d) \equiv M_c  }
{\nu : \C ; \Gamma \prov (M_c) \star \nu : S \star \nu}
\]
\[
\erule
{}
{  f_m([d/\nu]e) \equiv [c/\nu]e  }
\]
And $\Delta_\nu$ is really the special case of a witness type with the constant
concrete presheaf.
\subsection{With Residual Context}
I could also do
\[
\begin{tikzcd}
  \rset^{\D^\op} \ar[d, "\Delta"', shift right=5]\ar[d, "\dashv", phantom]\ar[from=d, "\forall"', shift right=5] \\
\rset^{(\C \x \D)^\op}
\end{tikzcd}
\]
where the rules are more like
\[
\erule
{\Delta, \nu : \C ; \Gamma^w \prov P : \rtype}
{\Delta; \Gamma \prov \forall \nu . P : \rtype}
\qquad
\erule
{\Delta, \nu : \C ; \Gamma^w \prov e  : P}
{ \Delta; \Gamma \prov \lambda \nu . e : \forall \nu . P }
\]
\[
\erule
{ \Delta; \Gamma \prov M : \forall \nu . P }
{\Delta, \nu : \C ; \Gamma^w \prov M[\nu]  : P}
\]
\[
\erule
{\Delta; \Gamma \prov S : \rspan}
{\Delta, \nu : \C ; \Gamma^w \prov S \star \nu : \rtype}
\qquad
\erule
{\Delta, \nu : \C ; \Gamma \prov e  : S \star \nu}
{\Delta; \Gamma \prov [c/\nu] e  : X_c}
\]
\[
\erule
{\Delta; \Gamma \prov M_c : X_c \qquad f_m(M_d) \equiv M_c  }
{\Delta,\nu : \C ; \Gamma \prov (M_c) \star \nu : S \star \nu}
\qquad
\erule
{}
{  f_m([d/\nu]e) \equiv [c/\nu]e  }
\]

\section{Thinking About The Cube Category}
Suppose $\square$ is, equvialently:
\begin{itemize}
\item the free cartesian category on
\[\begin{tikzcd}
  \top \ar[r, shift left]\ar[r, shift right] & \ii
\end{tikzcd}\]
\item the category of contexts and substitutions for
\[\begin{tabular}{rccl}
  Contexts&$\Gamma, \Delta$&$::=$&$\cdot \celse \Gamma, \nu : \ii$\\
  Substitutions&$\theta$&$::=$&$\cdot \celse \theta[M/\nu]$\\
  Terms&$M$&$::=$&$\nu \celse \ep 1 \celse \ep 2$\\
\end{tabular}\]
\[
\erule
{\Gamma \prov \theta: \Delta \qquad \Gamma \prov M : \ii}
{\Gamma \prov \theta[M/\nu] : (\Delta, \nu : \ii)}
\]
\item the opposite of the Kleisli category whose objects
are finite sets $n$, and whose morphisms are
partial functions $m \to n + 2$.
\end{itemize}
I want to be very clear about what a morphism $h : A \to y\ii \in \hat \square$ can look like.
Given such a thing, I can extract from it the information arising from some pullbacks:
\[
\begin{tikzcd}
  h^1 \ar[r]\ar[d]\pbck & y\top\ar[d, "{y[\ep 1 / \nu]}"]\\
  A \ar[r, "h"'] & y\ii
\end{tikzcd}
\qquad
\begin{tikzcd}
  h^2 \ar[r]\ar[d]\pbck & y\top\ar[d, "{y[\ep 2 / \nu]}"]\\
  A \ar[r, "h"'] & y\ii
\end{tikzcd}
\]
and I should be able to also think about how there's a weakening substitution
$\hat\square / y\top \to \hat\square / y\ii$  arising from pullback along
 $\cdot : \ii \to \top$ --- but pullback along a morphism into the terminal object
is just product.
\[
\begin{tikzcd}
  B \x y\ii \ar[r]\ar[d]\pbck & y\ii\ar[d, "!"]\\
  B \ar[r] & \top
\end{tikzcd}
\]
So the right adjoint to this $\hat\square / y\top \to \hat\square / y\ii$
(which is guaranteed to exist because presheaf categories are lccc)
would be $(\nu : y\ii) \to  B : \hat\square  / y \top$.

Let's bump up the generality slightly to include a context.
We suppose we have $A : (\Gamma, \nu:\ii, x : A) \to (\Gamma, \nu:\ii)$.
Then the pullback of this against a substitution for a constant
\[
\begin{tikzcd}
  \Gamma,[\ep k/\nu]A \ar[r]\ar[d]\pbck & \Gamma\ar[d, "{[\ep k / \nu]}"]\\
  \Gamma,\ii,A \ar[r, "A"'] & \Gamma,\ii
\end{tikzcd}
\]
should still work.
And then pullback against the weakening substitution
\[
\begin{tikzcd}
  \Gamma,\ii, A \ar[r, "{A^w}"]\ar[d]\pbck & \Gamma,\ii\ar[d, "{w}"]\\
  \Gamma,A \ar[r, "A"'] & \Gamma
\end{tikzcd}
\]
should have a right adjoint
\[
\begin{tikzcd}
  \Gamma,\ii, A \ar[r, "A"]\ar[d, mapsto] & \Gamma,\ii\ar[d, mapsto]\\
  \Gamma, \Pi A \ar[r, "\Pi A"'] & \Gamma
\end{tikzcd}
\]
in which we get a correspondence
\[
\begin{tikzcd}
  \Gamma,\ii,A \ar[r, "A^w"] \ar[d] & \Gamma, \ii\\
\Gamma,\ii, B \ar[ur, "B"']
\end{tikzcd}
\longleftrightarrow
\begin{tikzcd}
  \Gamma,A \ar[r, "A"] \ar[d] & \Gamma\\
\Gamma, \Pi B \ar[ur, "\Pi B"']
\end{tikzcd}
\]
So concretely, what is going on with this?

\vfil\eject

\section{Grothendieck Thoughts}
Say we have some $\C$ and $F :\C \to \rcat$. The idea is that objects of $\C$
are contexts $\Delta$ and morphisms $\Delta_1 \to \Delta_2$ are valid substitutions
among such contexts.
I'll conflate an object $\Delta$ of $\C$ with the category $F\Delta$, and
a morphism $\theta : \Delta_1 \to \Delta_2$ of $\C$ with the functor
$F\theta : F\Delta_1 \to F\Delta_2$.


The semantics of
\[ \Delta ; \Gamma \prov A : \rtype \]
Is supposed to be that for every $\delta\in\Delta$, we have
\[ \Gamma_\delta : \rtype \qquad  A_\delta : (\gamma : \Gamma_\delta) \to \rtype \]
and for every $\phi : \delta_1 \to \delta_2 \in \Delta $ we have
\[ \Gamma_\phi : \Gamma_{\delta_1} \to \Gamma_{\delta_2} \]
\[ A_\phi : (\gamma : \Gamma_{\delta_1}) \to A_{\delta_1}(\gamma) \to A_{\delta_2}(\Gamma_\phi(\gamma)) \]
But also I want to support transport across $\Delta$s, not just within $\Delta$s.
This isn't essential for just making a type theory work {\em at all}, but it is
essential for achieving internalized parametricity: for what that requires is that
a lambda sitting in an empty $\Delta$ already anticipates extensions to $\Delta$.
Something of type $(A : \U) \to \El A \to \El A$ should accept an $A : \U$
that is over $\nu : \sharp 2$, not just a $\U$ in the empty context.

So I essentially want to pick out the grothendieck construction $\G$ of $F$.

An object of $\G$ is a pair $(\Delta, \delta)$ where $\delta \in \Delta$.
A morphism $(\Delta_1, \delta_1) \to (\Delta_2, \delta_2)$ in $\G$ is
a pair $(\theta, \phi)$ such that $\theta : \Delta_1 \to \Delta_2 $ and
$\phi : \theta\delta_1 \to \delta_2$.

Then can I say that the semantics has type
\[ \Gamma_G : \rtype \qquad  A_G : (\gamma : \Gamma_G) \to \rtype \]
\[ \Gamma_g : \Gamma_{G_1} \to \Gamma_{G_2} \]
\[ A_g : (\gamma : \Gamma_{G_1}) \to A_{G_1}(\gamma) \to A_{G_2}(\Gamma_g(\gamma)) \]
? No, this seems wrong; types are defined {\em relative to a particular $\Delta$} even
if they do anticipate all extensions to $\Delta$.

So what then is a type $A$ under $\Delta$? For every morphism $\theta : \Delta' \to \Delta$ and object
 $\delta'$ of $\Delta'$, we need a type $A_{(\theta, \delta')}$. Yeah, ok, so maybe this
is the combination of `yoneda of the context' and 'grothendieck construction'?

\section{Categories of Elements}

I remembered a really important thing about presheaf categories is that
for any $\C$ and any $P : \hat\C$, we have
\[ \hat \C / P \cong \widehat{\int P} \]
That is, the slice into a particular presheaf is the same as the presheaf category
{\em over} the category of elements of $P$.

So when I'm looking for a $\sharp 2$ such that a choice of $P$ together
with a $P \to \sharp 2$ is supposed to look like a choice of span, this theorem
helps me understand what $P \to \sharp 2$ actually looks like, assuming I've decided
what category I'm living in, and what $\sharp 2$ actually is.

Let me think about the super strict
variant of $\square$ generated by {\em ordered} substitutions
where neither weakening nor contraction is allowed
\[\begin{tabular}{rccl}
  Contexts&$\Gamma, \Delta$&$::=$&$\cdot \celse \Gamma, \nu : \ii$\\
  Substitutions&$\theta$&$::=$&$\cdot \celse \theta[M/\nu]$\\
  Terms&$M$&$::=$&$\nu \celse \ep 1 \celse \ep 2$\\
\end{tabular}\]
\[
\erule
{\Omega \prov \theta: \Delta }
{\Omega, \nu' : \ii \prov \theta[\nu'/\nu] : (\Delta, \nu : \ii)}
\qquad
\erule
{\Omega \prov \theta: \Delta }
{\Omega \prov \theta[\ep k/\nu] : (\Delta, \nu : \ii)}
\]
\[
\erule
{}
{\cdot \prov \cdot: \cdot }
\]
And I want to think about a certain presheaf, but not the representable
at the singleton context $\nu : \ii$, but rather one defined by
\[
\begin{tabular}{c}
$P(\cdot) = \{a , b\}$\\
$P(\Omega, \nu : \ii) = \{a , b, f(\nu)\}$\\
$f(\ep 1) = a \qquad f(\ep 2) = b$
\end{tabular}
\]
Is it ok to pin $f$ to always use the last variable of the context like this?
Can some substitution instead
force me into using a different one? Let me try. I have a term
$\rho, \mu, \nu \prov f(\nu)$.
Any substitution that I might apply to this has to look like
either $\theta[\ep k / \nu]$ in which case I just reduce to $a$ or $b$,
or else $\theta[\nu'/\nu]$, and $\nu'$ has to be the last variable of the
new context.

So what does the category of elements of this $P$ look like? The objects
are pairs $(\Omega\prov t)$ where $t \in P(\Omega)$. There's a morphism
$(\Omega\prov t)\to (\Omega'\prov t')$ whenever
there's a substitution $\Omega \prov \theta : \Omega'$
such that $\theta t' = t$.

I can divide up the objects into $(\Omega\prov a)$, $(\Omega\prov b)$,
and $(\Omega, \nu : \ii \prov f(\nu))$. The morphisms within $(\Omega\prov a)$
are a copy of the categorical structure on just the $\Omega$s, and same with
$(\Omega\prov b)$. Also, the stuff that stays {\em within} the
$(\Omega, \nu : \ii \prov f(\nu))$ part is also, by the ordering constraint.
That accounts for the substitutions that take $\Omega, \nu : \ii$
and substitute some $\nu'$ for $\nu$ and go on to do some arbitrary thing with $\Omega$.
But --- we can also substitute an endpoint for $\nu$ (and do something arbitrary with
$\Omega$) and this accounts for the morphisms in the product category which
traverse a leg of the span.

So it almost looks like the ordering constraint, and weakening, (which corresponds to
degeneracies in cubical sets) are
independently optional, and I get that the slice category is the same as
the product of the span with the base category either way? That's very
weird. But contraction being absent seems essential, because then I
can't analyze the non-endpoint substitutions
of type $ \Omega, \nu : \ii$ as necessarily
coming in two separable parts, the $\Omega' \prov \theta :\Omega$ and the $[\nu'/\nu]$.

\section{Another Pass at Syntax For Programming over Presheaves}
Let me stare again at
\[
\begin{tikzcd}
  \rset \ar[d, "\Delta"', shift right=5]\ar[d, "\dashv", phantom]\ar[from=d, "\forall"', shift right=5] \\
{\hat \C}
\end{tikzcd}
\]
and let's have a syntax for a type theory where the default sort of thing, the
thing we call $\rtype$, is in $\hat \C$, and the things that live in merely $\rset$
are discrete types, members of $\rdtype$.
\[\begin{tabular}{rccl}
  Contexts&$\Gamma$&$::=$&$\cdot \celse \Gamma, x : A$\\
  Discrete Contexts&$\Psi$&$::=$&$\cdot \celse \Psi, y : E$\\
  Types&$A$&$::=$&$\U \celse \Delta E \celse (x : A) \to A \celse (x : A) \x A$\\
  Discrete Types&$E$&$::=$&$\uu \celse A_C \celse \forall A \celse (y : E) \to E \celse (y : E) \x E$\\
  Terms&$M$&$::=$&$\Delta e$\\
  Discrete Terms&$e$&$::=$&$e\cdot f \celse \forall M \celse M_C$\\
\end{tabular}\]
So we can instantiate a type at an object $C \in \C$ and get a discrete type.
We can also ask for the discrete type of global sections $\forall A$.
\[
\erule
{\Psi  \prov e : A_D \qquad f : C \to D \in \C }
{\Psi  \prov e \cdot f : A_C}
\]
\[e \cdot (f \o g) = (e \cdot f) \cdot g\]
\[
\erule
{\Psi \prov E : \rdtype}
{\Psi; \cdot \prov  \Delta E : \rtype}
\qquad
\erule
{\Psi; \cdot \prov A : \rtype}
{\Psi \prov  \forall A : \rdtype}
\qquad
\erule
{\Psi; \cdot \prov A : \rtype \qquad C \in \C}
{\Psi \prov  A_C : \rdtype}
\]

\[
\erule
{\Psi \prov e : E }
{\Psi; \cdot \prov  \Delta e :  \Delta E }
\qquad
\erule
{\Psi; \cdot \prov M : A}
{\Psi \prov  \forall M : \forall A}
\qquad
\erule
{\Psi; \cdot \prov M : A }
{\Psi \prov  M_C : A_C }
\]
\[M_D \cdot f = M_C \qquad (\Delta E)_C = E \qquad (\Delta e)_C = e\]

\subsection{Can't Decide if I Want Variables}
\[\begin{tabular}{rccl}
  Contexts&$\Gamma$&$::=$&$\cdot \celse \Gamma, x : A$\\
  Discrete Contexts&$\Psi$&$::=$&$\cdot \celse \Psi, y : E$\\
  LHSs&$\Omega$&$::=$&$\Psi; \nu : \C; \Gamma$\\
  Types&$A$&$::=$&$\U_\nu \celse  E \celse (x : A) \to A \celse (x : A) \x A$\\
  Discrete Types&$E$&$::=$&$\uu  \celse \forall \nu . A \celse (y : E) \to E \celse (y : E) \x E$\\
   Terms&$e$&$::=$&$e\cdot f \celse \Lambda\nu. M $\\
\end{tabular}\]

If I do have a variable to distinguish what's going on in `plain types' that I can
substitute for, then $\Delta$ can just vanish to be an inclusion of discrete
types into regular types.

We have substitution principles that say that
\begin{thmbox}
If $\Psi; \nu : \C \prov \Gamma \rctx $ then $\Psi \prov [C/\nu]\Gamma\rdctx$\\
If $\Psi; \nu : \C; \Gamma \prov A: \rtype $ then $\Psi, [C/\nu]\Gamma \prov [C/\nu]A : \rdtype$\\
If $\Psi; \nu : \C; \Gamma \prov M : A$ then $\Psi, [C/\nu]\Gamma \prov [C/\nu]M : [C/\nu]A$
\end{thmbox}
For morphisms we have a term former:
\[
\erule
{\Psi; \nu : \C; \Gamma \prov A : \rtype \qquad
\Psi, [D/\nu]\Gamma  \prov e : [D/\nu]A \qquad f : C \to D \in \C }
{\Psi, [C/\nu]\Gamma  \prov e \cdot f : [C/\nu]A}
\]
This is something like associativity of substitutions, I think:
\[([D/\nu]M) \cdot f \equiv [C/\nu]M\]
It's really just expressing consistency of $M$ as a global section.

Ach, right, the real problem with variables is that I don't get a
clean notion of substitution with, like, function types. I have to
Kripke. Boo to that.

It's as is the type $(x : A) \to B$ is actually more like
\[ (C : \C) (g : C \to \nu) \to (x : [C/\nu]A) \to [C/\nu]B\]
or if I had a yoneda-ish type or something, maybe I could say
\[ (\gamma : y\nu) (x : [\gamma/\nu]A) \to [\gamma/\nu]B\]
But I don't know how to make sense of that.

Is it the downshift that's the locus of this variable dance somehow?
This would mean that there's an aggregate type that both uses
up the ambient $\nu$ and binds another one
\[\begin{tabular}{rccl}
  Types&$A$&$::=$&$\cdots \dns_\nu\nu. (x : A) \to B \cdots$\\
\end{tabular}\]
and we have like

\[
\erule
{\Psi;\nu;\Gamma \prov A : \rtype \qquad \Psi;\nu;\Gamma, x : A \prov B : \rtype}
{\Psi;\nu;\Gamma \prov \dns_\nu \nu . (x : A) \to B : \rtype }
\]
which means that things like
\[\dns_C \nu . (x : A) \to B : \rdtype\]
for particular $C$ must be ordinary discrete types. If we feed this a morphism
of $\C$, we should get out something useful:
\[
\erule
{e : \dns_C\nu.(x : A) \to B \qquad g : D \to C \qquad N : [D/\nu]A}
{e \star_g N : [N/x][D/\nu] B}
\]
But this shouldn't be specific to function types, but should work at all negative types,
or something like that:
\[
\erule
{e : \dns_C\nu.A \qquad g : D \to C }
{e \star g  : [D/\nu] A}
\]

\subsection{Yoneda Syntactically}

A positive type is a presheaf over $\C$. And $yC$ for each $C \in \C$ is such a thing.

\[
\erule
{}
{\Psi ; \nu : \C ; \Gamma \prov y_\nu C : \rtype}
\qquad
\erule
{g : D \to C \in \C}
{\Psi  \prov g : y_D C }
\]
\[
\erule
{\Psi, [C/\nu]\Gamma  \prov e : [C/\nu]A \qquad \Psi ; \nu : \C ; \Gamma \prov f : y_\nu C }
{\Psi ;\nu : \C; \Gamma  \prov e \star_\nu f : A}
\]
\[
\erule
{\Psi, [C/\nu]\Gamma  \prov e : [C/\nu]A \qquad \Psi  \prov f : y_D C }
{\Psi, [D/\nu]\Gamma  \prov e \cdot f : [D/\nu]A}
\]
\[
\erule
{\Psi ; \nu : \C ;  \Gamma \prov M : B}
{\Psi ;\nu : \C; \Gamma \prov [] M :  \dns_\nu \nu . B ???}
\]
\[
\erule
{\Psi ; \nu : \C ;  t : y_\nu C \prov M : B}
{\Psi  \prov \susp{\nu, t}M :  \dns_C \nu . B}
\]
Nah, something's not right.

\subsection{Can \texttt{ModalT.agda} help me at all?}

I thought it could, but I think the $\C$ in question is really about
resources/positive worlds, not negatives. And not... whatever \texttt{kripke}
is, which applies to both positives and negatives.  What makes me think so is
the fact that the quantification in the yoneda-calculated definition
is coming up for {\em functions} in presheaves. So it should be something more like
the calculation in the `world where we have only positive propositions, and
functions carry along a $\dns$ disguise so they can pretend to be positive'
where we have $P_1$ and $P_2$ and we say
\[\dns (P_1 \lol \ups P_2) \wat \alpha
= \forall \phi . (P_1 \lol \ups P_2) \wat \phi \to \alpha \tri \phi\]
\[ = \forall \phi . (\exists \beta \psi . \phi = \beta \lol \psi \land P_1 \wat \beta \land \ups P_2 \wat \psi)  \to \alpha \tri \phi\]
\[ = \forall \phi  \beta \psi . \phi = \beta \lol \psi \to P_1 \wat \beta \to \ups P_2 \wat \psi  \to \alpha \tri \phi\]
\[ = \forall   \beta \psi .  P_1 \wat \beta \to \ups P_2 \wat \psi  \to \alpha \tri \beta \lol \psi\]
\[ = \forall   \beta \psi .  P_1 \wat \beta \to \ups P_2 \wat \psi  \to \alpha \tensor \beta \tri \psi\]
\[ = \forall   \beta  .  P_1 \wat \beta \to \forall \psi. \ups P_2 \wat \psi  \to  \alpha \tensor \beta \tri \psi\]
\[ = \forall   \beta  .  P_1 \wat \beta \to \dns \ups P_2 \wat \alpha \tensor \beta \]

What I want to arrive at is something where
$\dns (P_1 \lol \ups P_2) \wat C$ for $C \in \C$ looks like
$\forall( D : \C) \to  \C[D, C] \to P_1 \wat D \to \dns \ups P_2 \wat D$

So wait maybe the above calculation is encouraging me to think about what happens
with \texttt{kripke}. What is \texttt{ModalT.agda} telling me?
Positive resource specifiers are identical to kripke worlds. Negative resource
specifiers are pairs of kripke worlds and an abstract type of frames made
up just to make things intuitionistic.
{\obeylines \texttt{
Res : Signed Mode $\to$ Set -- worlds, frames
Res ($\mu$ , s+) = kripke
Res ($\mu$ , s-) = kripke $\x$ frame
}}
So I guess a \texttt{kripke} should be an object of $\C$, or maybe $\C^\op$, depending
on whether I've confused myself up to an odd number of dualizations.
The relation $\tri$ on these positive and negative thingies is
\[C \tri (D , \phi) = \C[C, D] \to \sharp(D, \phi) \]
and the $\lol$ relation is defined inductively such that only
\[ \lol (D, (D, \phi), (D, \phi)) \]
holds for any $D, \phi$.

So let's try to calculate
\[\dns (P_1 \lol \ups P_2) \wat C
= \forall (D, \phi) . (P_1 \lol \ups P_2) \wat (D, \phi) \to \C[C, D] \to \sharp(D, \phi)\]
\[ = \forall (D, \phi) . (\exists E (F, \psi) . P_1 \wat E \x (\ups P_2) \wat (F, \psi)
\x {\lol} (E, (F, \psi), (D, \phi))) \]
\[   \to \C[C, D] \to \sharp(D, \phi)\]
\[ = \forall (D, \phi) . ( P_1 \wat D \x (\ups P_2) \wat (D, \phi) )
 \to \C[C, D] \to \sharp(D, \phi)\]
\[ = \forall D .  \C[C, D] \to P_1 \wat D \to  \forall \phi . (\ups P_2) \wat (D, \phi)
 \to  \sharp(D, \phi)\]
\[ = \forall D .  \C[C, D] \to P_1 \wat D \to  {\Downarrow} \ups P_2 \wat D\]

This almost works! I just had to use a different sort of downshift to abstract away
the $\sharp$ nonsense at the end.

So if I have three classes of propositions, the $A$ which don't vary at all,
the $P$ which are $\rset^{\P}$ and the $N$ which are $\rset^{\N}$, and I say things
like
\[(\dns N) @ C = \int_{\Phi \in \N} N(\Phi) \to \tri(C, \Phi)\]
I should be able to read this as a type former
\[
\erule
{\phi : \N \prov N : \rtype}
{\alpha : \P \prov \dns_\alpha \phi . N : \rtype}
\qquad
\erule
{\phi : \N \prov N : \rtype\qquad p \in \P}
{ \prov \dns_p \phi . N : \rtype}
\]
\[
\erule
{\phi : \N, t : N \prov e : \tri(p, \phi) }
{ \prov \lambda \phi t . e : \dns_p \phi . N }
\qquad
\erule
{n \in \N \qquad  \prov t : [n/\phi]N \qquad \prov e : \dns_p \phi . N}
{ \prov e\ n\ t : \tri(p, n)}
\]

\[
\erule
{\alpha : \P \prov P : \rtype}
{\phi : \N \prov \ups_\phi \alpha . P : \rtype}
\qquad
\erule
{\alpha : \P \prov P : \rtype\qquad n \in \N}
{ \prov \ups_n \alpha . P : \rtype}
\]
\[
\erule
{\alpha : \P, t : P \prov e : \tri(\alpha, n) }
{ \prov \lambda \alpha t . e : \ups_n \alpha . P }
\]

\end{document}
