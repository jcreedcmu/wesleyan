\documentclass{article}
\input{theorem}
\input{prooftree}
\usepackage{stmaryrd}
\usepackage{latexsym}
\usepackage{yfonts}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,cd,decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}
\usepackage{tcolorbox}
\tcbuselibrary{breakable}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}

\def\bpush{\mathbf{push}}
\def\bpull{\mathbf{pull}}

\def\wo{\setminus}
\def\fA{\mathsf{A}}
\def\fC{\mathsf{C}}
\def\fX{\mathsf{X}}
\def\ff{\mathsf{f}}
\def\fm{\mathsf{m}}
\def\rspan{\mathsf{Span}}
% \def\El#1{\mathsf{El}({#1})}
\def\El#1{\ulcorner{#1}\urcorner}
\def\quote#1{{\ulcorner {#1} \urcorner}}
\def\U{\mathsf{U}}
\def\uu{\mathsf{u}}
\def\uni{\U}
\def\mor#1#2{#1 \to \underline{#2}}

\def\ridp{\mathsf{idp}}
\def\ssem#1{\langle\!\langle{#1}\rangle\!\rangle}

\definecolor{cyan}{rgb}{0.80,0.95,0.95}
\definecolor{orange}{rgb}{0.95,0.90,0.80}
\definecolor{bluegray}{rgb}{0.6,0.6,0.85}
\definecolor{lgray}{gray}{0.9}
\newtcolorbox{declbox}{colframe=lred,colback=lred,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{thmbox}{colframe=cyan,colback=cyan,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{defnbox}{colframe=orange,colback=orange,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{tangentbox}{colframe=lgray,colback=lgray,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}

\input{linear}
\def\rpath#1{[#1]}
\def\rfst{\mathsf{fst}\,}
\def\rsnd{\mathsf{snd}\,}
\def\bunfold{\mathbf{unfold}}
\def\bfold{\mathbf{fold}}
\def\susp#1{\langle {#1} \rangle}
\def\ssusp#1{\langle\!\langle {#1} \rangle\!\rangle}
\def\dto{\mathrel{\dot\to}}
\def\dns{{\downarrow}}
\def\ups{{\uparrow}}
\def\sprov{\Vdash}
\def\signat{{\color{red}\Sigma}}
\def\ep#1{\underline{#1}}
\def\wat{\mathbin{@}}
\def\wwat{\mathbin{\underline\wat}}
\def\cn{{:}}
\def\dv{{\div}}
\def\ww{{\mathsf w}}
\def\base{{\textfrak b}}

\def\munit{I}
\def\tt{{\mathsf t}}
\def\rr{{\mathsf r}}
\def\ii{{\mathbb I}}
\def\pp{\textsf{\textbf p}}
\def\nn{{\mathsf n}}
\def\PP{\textsf{\textbf P}}
\def\NN{{\mathsf N}}
\def\zz{{\mathsf z}}
\def\sem#1{[\![#1]\!]}
\def\usem#1{\lceil\!\!\lceil{#1}\rceil\!\!\rceil}
\def\zem#1{\langle\!\langle#1\rangle\!\rangle}
\def\col#1{{\mathsf{C}}_{#1}}
\def\lax{\mathop\bigcirc}
\def\rjust{\mathsf{just}}
\def\rcvt{\mathsf{cvt}}
\def\rtype{\mathsf{type}}
\def\rdtype{\mathsf{disc}}
\def\rkind{\mathsf{kind}}
\def\rmode{\mathsf{mode}}
\def\rprel{\mathbf{Prel}}
\def\rrfam{\mathbf{Rfam}}
\def\rset{\mathbf{Set}}
\def\rfinset{\mathbf{FinSet}}
\def\rrel{\mathbf{Rel}}
\def\rcat{\mathbf{Cat}}
\def\rfam{\mathbf{Fam}}
\def\binj{\mathbf{inj}}
\def\rid{\mathsf{id}}
\def\rtrue{\mathrel\mathrm{true}}
\def\pbck{\ar[dr, phantom, pos=0, "\lrcorner"]}
\def\bpbck{\ar[ddrr, phantom, pos=0, "\lrcorner"]}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\btwo{\mathbf{2}}
\def\bone{\mathbf{1}}

\newarrow {Equiv} =====
\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\def\mapt{\ar[ddd,mapsto,shorten <=2em, shorten >=2em]}
\def\frommaps{\ar[from=uu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\frommapt{\ar[from=uuu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\C{\mathbf{C}}
\def\G{\mathbf{G}}
\def\S{\mathbf{S}}
\def\D{\mathbf{D}}
\def\E{\mathbf{E}}
\def\M{\mathbf{M}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\tri{\triangleright}
\def\o{\circ}
\def\rctx{\,\mathsf{ctx}}
\def\rdctx{\,\mathsf{dctx}}
\def\del{\partial}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\null{\emptyset}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\definecolor{fib}{HTML}{ff7f00}
\definecolor{green}{HTML}{007f00}
\definecolor{red}{HTML}{df3f3f}
\definecolor{opfib}{HTML}{007fff}

% For lightening colors I used
% http://trycolors.com/ 6 parts white to 1 part color
\definecolor{opfibl}{HTML}{DBEDFF}
\definecolor{greenl}{HTML}{DBEDDB}
\definecolor{redl}{HTML}{FAE4E4}
\def\njudge#1{\fcolorbox{opfib}{white}{#1}}
\def\nrule#1{\fcolorbox{white}{opfibl}{#1}}
\def\neqn#1{\fcolorbox{white}{redl}{#1}}



\def\judge#1{\vskip 2em\noindent \njudge{$#1$}\vskip 0.5em\noindent}
\def\rule#1{\vskip 2em \noindent \nrule{$#1$}\vskip 0.5em\noindent}
\def\eqn#1{\vskip 2em \noindent \neqn{$#1$}\vskip 0.5em\noindent}
\def\prof{\nrightarrow}
\def\tensor{\otimes}
\def\htensor{\mathrel{\hat\otimes}}
\def\lol{\multimap}
\def\hlol{\mathrel{\hat\multimap}}
\def\wtf{{\color{red}???}}

\def\re{\mathbf{E}}
\def\sh{\sharp}
\def\shp{\mathrel{\sharp}}
\def\zero{\texttt{0}}
\begin{document}

\def\
\tikzset{
   commutative diagrams/.cd,
   arrow style=tikz,
   diagrams={>=stealth}}

\section{A Syntax for (Co)Ends}
Category variables are $\alpha$, with signed {\em uses} $\alpha^+$ and $\alpha^-$.
\[\begin{tabular}{rccl}
  Categories&$\C$&$::=$&$\cdots$\\
  Category Contexts&$\Delta$&$::=$&$\cdot \celse \Delta, \alpha : \C$\\
  Contexts&$\Gamma$&$::=$&$\cdot \celse \Gamma, x : A$\\
  Types&$A$&$::=$&$\forall \alpha . A \celse \exists \alpha . A \celse A \to A \celse A \x A
 \celse a(\alpha, \ldots, \alpha)$\\
\end{tabular}\]
We write $\bar A$ for $A$ with all the $+$ and $-$ in category variable appearances reversed.

\subsection{Intention of the Semantics}
The judgment
\[ \Delta; \Gamma \prov A : \rtype \]
says that $\Gamma \to A$ stands for a mixed variance
functor over all the variables in $\Delta$.

If $\Delta = \alpha_1 : \C_1^{\pm_1} , \ldots, \alpha_n : \C_n^{\pm_n}$
\subsection{Typing Rules}
\subsubsection{Variable Rules}
\[
\erule
{\forall i . \alpha_i : \C_i \in \Delta \qquad a : \C_1^{\pm_1} \x \cdots \x \C_n^{\pm_n} \to \rtype }
{\Delta \prov a(\alpha^{\pm_1}_1, \ldots, \alpha^{\pm_n}_n) : \rtype}\]
\[
\erule
{}
{\Delta; \Gamma, x : A \prov x : A}
\]
\subsubsection{Type Formation}
\[
\erule
{\Delta, \alpha : \C  \prov A : \rtype}
{\Delta \prov \forall \alpha : \C. A : \rtype}
\qquad
\erule
{\Delta, \alpha : \C  \prov A : \rtype}
{\Delta \prov \exists \alpha : \C. A : \rtype}
\]
\[
\erule
{\Delta \prov \bar A  : \rtype \qquad \Delta \prov B : \rtype}
{\Delta \prov A \to B : \rtype}
\qquad
\erule
{\Delta \prov  A  : \rtype \qquad \Delta \prov B : \rtype}
{\Delta \prov  A \x B : \rtype}
\]
\subsubsection{Contexts}
\[
\erule
{\prov \Gamma \rctx \qquad \Gamma \prov \bar A : \rtype}
{\prov \Gamma, x : A \rctx}
\]
\subsubsection{Quantifiers}
\[
\erule
{\Delta ; \Gamma \prov  e :  \forall \alpha : \C. A \qquad \Delta \prov \nu : \C}
{\Delta ; \Gamma \prov e[\nu] :  [\nu/\alpha] A }
\qquad
\erule
{\Delta, \alpha : \C ; \Gamma \prov e :  A }
{\Delta ; \Gamma \prov \Lambda \alpha . e :  \forall \alpha : \C .A }
\]
\[
\erule
{\Delta ; \Gamma \prov e :  [\nu/\alpha] A  \qquad \Delta \prov \nu : \C}
{\Delta ; \Gamma \prov  \susp{e, \nu} :  \exists \alpha : \C. A}
\] \[
\erule
{\Delta; \Gamma \prov e :  \exists \alpha : \C . A \qquad\Delta, \alpha : \C;\Gamma, x : \bar A \prov e' : B}
{\Delta ; \Gamma \prov \blet \susp{x,\alpha} = e \bin e':  B }
\]
\subsubsection{Regular Connectives}
\[
\erule
{\Delta; \Gamma \prov e : A \to B \qquad \Delta; \Gamma \prov e' : \bar A}
{\Delta;\Gamma \prov e\ e' : B}
\qquad
\erule
{\Delta; \Gamma, x : A \prov e : B}
{\Delta;\Gamma \prov \lambda x . e : A \to B}
\]
\section{Semantics}
Interpret every $\Delta$ as a category.
\begin{defnbox}
  \begin{tabular}{rcl}
$\sem{\cdot}$&$=$&$\mathbf 1$\\
$\sem{\Delta, \alpha : \C}$&$=$&$\sem \Delta \x (\C \x \C^\op)$
\end{tabular}
\end{defnbox}
Interpret every
\[ \Delta; \Gamma \prov A : \rtype\]
as a functor $\sem \Delta \to \rset$. Let $\delta$ be an arbitrary object of $\sem \Delta$.
When $\Delta = \alpha_1 : \C_1,\ldots, \alpha_n : \C_n$, we will have
$\delta = ((\delta_1, \delta_1'), \ldots, (\delta_n, \delta_n'))$.
{\renewcommand{\arraystretch}{1.5}
\begin{defnbox}
  \begin{tabular}{rcl}
$\sem{\exists \alpha : \C . A}(\delta)$&$=$&$\int^{\alpha \in \C} \sem A(\delta, (\alpha, \alpha))$\\
$\sem{\forall \alpha : \C . A}(\delta)$&$=$&$\int_{\alpha \in \C} \sem A(\delta, (\alpha, \alpha))$\\
$\sem{A \to B}(\delta)$&$=$&$\sem A(\bar \delta) \to \sem B(\delta)$\\
$\sem{A \x B}(\delta)$&$=$&$\sem A( \delta) \x \sem B(\delta)$\\
\end{tabular}
\end{defnbox}
}
Where $\bar \delta$ means the object-wise swap of every variable piece of $\delta$.

\subsection{Hom Types}

So I should be able to just say
\[
\erule
{}
{\Delta, \alpha : \C \prov \hom(\alpha^-, \alpha^+) : \rtype}
\]
or something like that, right? Or should I write simply
\[
\erule
{}
{\Delta, \alpha : \C \prov \hom(\alpha) : \rtype}
\]
? Or maybe even like
\[
\erule
{}
{\Delta, \alpha_1, \alpha_2 : \C \prov \hom(\alpha_1, \alpha_2) : \rtype}
\]
to represent the type of pairs of morphisms
\[\begin{tikzcd}
  \alpha_1^- \ar[from=d, "f"]& \alpha_1^+ \ar[d, "g"]\\
  \alpha_2^- & \alpha_2^+
\end{tikzcd}\]
For which I could expect to do transport something like
\[
\erule
{\Delta \prov \nu : \C \qquad \Delta, \alpha; \Gamma \prov f : \hom(\alpha, \nu) \qquad
\Delta, \alpha ; \Gamma \prov e : A}
{\Delta; [\nu/\alpha]\Gamma \prov e\adjust_f : [\nu/\alpha]A }
\]
Maybe need to require somehow that $\alpha \not\in f$? Or maybe more like
\[
\erule
{\Delta \prov \nu_1, \nu_2 : \C \qquad \Delta; \Gamma \prov f : \hom(\nu_1, \nu_2) \qquad
\Delta; [\nu_1/\alpha]\Gamma \prov e : [\nu_1/\alpha]A }
{\Delta; [\nu_2/\alpha]\Gamma \prov e\adjust_f : [\nu_2/\alpha]A }
\]
Because... yeah, that second to last rule is redundant, isn't it? I
don't need a $\hom(\alpha, \nu)$ to tell me that I can substitute into
$\Delta, \alpha ; \Gamma \prov e : A$ to get
$\Delta; [\nu/\alpha]\Gamma \prov e\adjust_f : [\nu/\alpha]A $, I can already do that.
I really want to ask for the {\em weaker} premise
$\Delta; [\nu_1/\alpha]\Gamma \prov e : [\nu_1/\alpha]A $
that I merely have some {\em substitution instance} of
$\Delta, \alpha ; \Gamma \prov e : A$
at some {\em particular} $\nu_1$ ---
but a $\nu_1$ for which I have a hom out of it,
critically.

Okay, I think a rule like this makes sense as an elim for $\hom$, but
I may need to be more careful about inserting some sort notion of
swaps at certain points to account for what I'm doing by essentially
requiring $\C \x \C^\op$ thingies to be flying around everywhere.

\subsection{Trying to Smell-Check the Semantics At Least}
So the meaning of
\[ \Delta; \Gamma \prov M : A \]
is
\[\sem M \in \int_{\delta \in \sem{\Delta}} \sem \Gamma(\bar \delta) \to \sem A(\delta)\]

For if $\Delta \prov \Gamma \rctx$ then we should have $\sem \Gamma
\in \rset^{\sem \Delta^\op}$. And if $\delta \in \sem\Delta$, then
$\bar \delta \in \sem \Delta^\op$.

\subsubsection{Speculating Tangentially about the Dependent Case}

Maybe I could have
\[\sem M \in \int_{\delta \in \sem{\Delta}} (\gamma : \sem \Gamma(\bar \delta)) \to \sem A(\delta, \gamma)\]

Ooh, this is hard to tell what precisely this means.
Suppose $\sem \gamma : \C \x \C^\op \to \rset$
and $\sem A : \C \x \C^\op \to \rset$ and there's a...
natural transformation $\pi : A \to \gamma$? Projecting the fibers
onto the base? Hmm, no. What about the special case where $A$ is $\rset^\C$
and $\Gamma : \rset^{\C^\op}$. In that case there definitely is a functor
$\Gamma \to A : \rset^\C$ given by
\[(\Gamma \to A)(c) = \Gamma(c) \to A(c)\]
\[(\Gamma \to A)(f) = \lambda g : (\Gamma(c) \to A(c)).  A(f) \o g \o \Gamma(f) \]
Okay, so suppose $\Gamma : \rset^{\C^\op}$ still, and maybe like...
\[A : (c : \C) (c' : \C^\op) (\gamma : \Gamma(c')) \to \rset\]
In such a way that it's functorial in $c$ and $c'$ at the same time?
For a morphism $f : c \to d$ and a fixed $c'$, we'd require that
\[A\ f\ c'\ \gamma : A\ c\ c'\ \gamma \to A\ d\ c'\ \gamma\]
and for a $g : d' \to c'$ we'd want something like (for every $\gamma : \Gamma(c')$)
\[A\ c\ g\ \gamma : A\ c\ c'\ \gamma \to A\ c\ d'\ (\Gamma\ g\ \gamma)\]

Ok, so what's $\Pi \Gamma A$ then? Something of type
\[ (c : \C) (c' : \C^\op) (\gamma : \Gamma(c')) \to A(c, c', \gamma)\]
But can we establish some reasonable notion functoriality for this, out
of the functoriality of $\gamma$ and $A$? Given $f : c \to d$, we should be
able to get from $(\gamma : \Gamma(c')) \to A(c, c', \gamma)$
to $(\gamma : \Gamma(c')) \to A(d, c', \gamma)$.
We can do this with $A(f, c', \gamma)$, no problem. Given $g : d' \to c'$, we should
be able to get from
$(\gamma : \Gamma(c')) \to A(c, c', \gamma)$
to,
$(\psi : \Gamma(d')) \to A(c, d', \psi)$.

Ok, suppose I have $z : (\gamma : \Gamma(c')) \to A(c, c', \gamma)$.
Suppose also $\psi : \Gamma(d')$. Oh, dang, this seems like I have things oriented wrong.

Surely I can't get away with just saying
\[A : (c : \C)  (\gamma : \Gamma(c)) \to \rset\]
can I? Functoriality of $A$ could be the
requirement that if $f : c \to d$ and $\gamma : \Gamma(d)$ then
\[A(f, \gamma) : A(c, \Gamma(f, \gamma)) \to A(d, \gamma)\]
Then $\Pi \Gamma A$ would be something of type
\[ (c : \C)  (\gamma : \Gamma(c)) \to A(c, \gamma)\]
And we try to say that for any $f : c \to d$ we can get from
$(\gamma : \Gamma(c)) \to A(c, \gamma)$ to $(\psi : \Gamma(d)) \to A(d, \psi)$.
Let $z : (\gamma : \Gamma(c)) \to A(c, \gamma)$ and $\psi : \Gamma(d)$ be
given. Now $\Gamma(f, \psi)$ is the right shape to put into $z$ and we get
$z (\Gamma(f, \psi)) : A(c, \Gamma(f, \psi))$. And, magically, this is
the right type to put into the `functoriality' of the type $A$,
and we have $A(f, \psi)(z(\Gamma(f, \psi))) : A(d, \psi)$ as required.

\textcolor{blue}{This actually seems like a good way of thinking about
  things}. Maybe this has a standard snappy name or compression in
terms of existing category theoretic terminology, who knows. Anyway, I
think I'm going to proceed with thinking about the simply-typed case
with some confidence that the dependently-typed case might work out
somewhat naturally, with less complication than I feared.
\subsubsection{Starting Again Then}
The meaning of a variable $\alpha : \C$ in $\Delta$ is really
a pair $\alpha : \C \x \C^\op$. The meaning of a whole context is a category
$\sem \Delta$ that's a big product of these dual-and-not-dual pairs.

So variable {\em uses} can come in the form of either regular $\alpha$ or a dualized
 $\bar \alpha$. The variable rule says things like
\[
\erule
{}
{\Delta, \alpha : \C \prov \alpha : \C}
\qquad
\erule
{}
{\Delta, \alpha : \C \prov \bar \alpha : \C^\op}
\]
Semantically what's happening is $\bar \alpha$ just swaps around the
two parts; it's not a functor $\C \to \C^\op$, which would be impossible in general,
but rather a functor $\C \x \C^\op \to \C^\op \x \C$, which is fine.

So in general we write $\bar A$ for taking every $\alpha$ in $A$ and replacing it
with $\bar\alpha$, and we'd have as an admissible rule
\[
\begin{prooftree}
\Delta \prov A : \rtype
\Justifies
\Delta^\op \prov \bar A : \rtype
\end{prooftree}
\]
For contexts we say
\[
\erule
{\Delta \prov \Gamma \rctx \qquad \Delta \prov \bar A : \rtype}
{\Delta \prov \Gamma, A \rctx}
\]
So that the meaning of a context $\sem \Gamma$ when $\Delta \prov \Gamma \rctx$
is a functor in $\rset^{\sem\Delta^\op}$.
Specifically, if $\Gamma = x_1 : A_1, \ldots, x_n : A_n$ we'd say
$\sem \Gamma(\delta) = \sem{A_1}(\delta) \x \cdots \x \sem {A_n}(\delta)$ for
$\delta \in \sem \Delta^\op$.

For terms, the meaning of
\[ \Delta; \Gamma \prov e : A \]
is
\[\sem e \in \int_{\delta \in \sem{\Delta}} \sem \Gamma(\bar \delta) \to \sem A(\delta)\]

For if $\delta \in \sem\Delta$, then
$\bar \delta \in \sem \Delta^\op$.

Ok, let's look at a nice easy asynchronous rule at first, like $\to$ introduction.
\[
\erule
{\Delta; \Gamma, x : A \prov e : B}
{\Delta;\Gamma \prov \lambda x . e : A \to B}
\]
From type formation of $A \to B$ we have $\Delta \prov \bar A : \rtype$
so it's okay to put it in the context. The top thing means
\[\sem {\Gamma, x \prov e} \in \int_{\delta \in \sem{\Delta}} \sem \Gamma(\bar \delta) \x \sem A(\bar\delta) \to
 \sem B(\delta)\]
and the bottom thing means
\[\sem {\Gamma \prov \lambda x . e} \in \int_{\delta \in \sem{\Delta}} \sem \Gamma(\bar \delta)
\to \sem A(\bar\delta) \to  \sem B(\delta)\]
and it's just a matter of currying functors. No real interaction with the end, even.
Is it more correct to write $\sem{\bar A} (\delta)$ than $\sem A(\bar \delta)$? They
should work out to just about the same thing. But no, I think what I wrote is
most correct; it's a contravariant functor $\to$ a covariant functor that is the thing
I can easily slap together.

How about the introduction rule for $\forall$?
\[
\erule
{\Delta, \alpha : \C ; \Gamma \prov e :  A }
{\Delta ; \Gamma \prov \Lambda \alpha . e :  \forall \alpha : \C .A }
\]
The thing up top says
\[\sem {\Gamma\prov e} \in \int_{(\delta, c) \in \sem{\Delta} \x \C^*}
\sem \Gamma(\bar \delta) \to \sem A(\delta, c)\]
where $\C^*$ is $\C \x \C^\op$ and $c \in \C^*$. I should note here that I'm
not quite actually using standard end syntax; the usual way of doing it would only
write each variable once. I'm explicitly conisdering the $\C$ and the $\C^\op$ bits
separately. Since $\Gamma$ below doesn't refer to $\alpha$ and is weakened
upstairs, I've used the fact that the semantics of $\Delta$-variable weakening is just
projection by writing merely $\sem\Gamma(\bar \delta)$. Anyway, the thing downstairs says
\[\sem {\Gamma\prov \Lambda \alpha. e} \in \int_{\delta \in \sem{\Delta}}
\sem \Gamma(\bar \delta) \to \int_{c\in\C^*} \sem A(\delta, c)\]
which is the same thing, I should expect.

What about $\to$ elim?
\[\erule
{\Delta; \Gamma \prov e : A \to B \qquad \Delta; \Gamma \prov e' : \bar A}
{\Delta;\Gamma \prov e\ e' : B}
\]
We need to go from both
\[\int_{\delta\in\sem{\Delta}} \sem \Gamma(\bar\delta) \to \sem A(\bar \delta) \to \sem B(\delta)
\qquad
\int_{\delta\in\sem{\Delta}} \sem \Gamma(\bar\delta) \to \sem {\bar A}( \delta)\]
to having
\[\int_{\delta\in\sem{\Delta}} \sem \Gamma(\bar\delta) \to \sem {B}( \delta)\]
and, aha, I make the distinction between $\sem A(\bar\delta)$
and $\sem {\bar A}(\delta)$ to mesh well with the definition of the end,
but at the end of the day, they're the same set, so this should all be ok.

What about $\forall$ elim?
\[
\erule
{\Delta ; \Gamma \prov  e :  \forall \alpha : \C. A \qquad \Delta \prov \nu : \C}
{\Delta ; \Gamma \prov e[\nu] :  [\nu/\alpha] A }
\]
There's some functor $\sem\nu : \sem\Delta\to\C^*$. We have to get
from
\[\int_{\delta\in\sem{\Delta}} \sem \Gamma(\bar\delta) \to \int_{c \in \C^*}\sem {A}( \delta, c)\]
to
\[\int_{\delta\in\sem{\Delta}} \sem \Gamma(\bar\delta) \to \sem {A}( \delta, \sem \nu (c))\]
Hm, actually this is a little sketchy. Am I free to choose a completely arbitrary
pair of objects in $\C$? This would be a constant functor $\sem \nu$. But the end
$\int_c\in\C^*$ only gives me a canonical way to reach the bifunctor when I use
the same object twice $(c,c)$ for arguments; or else when I supply a morphism telling
how to get from $c$ to $d$, in which case I could get to $(d, c)$ (either
covariantly from $(c,c)$ or contravariantly $(d,d)$, and the end's equalizer
condition tells me that either one gives me the same answer)

But any functor I can reasonably make syntactically out of $\Delta$ has this property
that when the variables coming in are the same, they go out the same. Or is
it even a syntactic property I need to require? Is it automatically guaranteed
semantically? Let
me specifically imagine that I have a functor $G : \D \x \D^\op \to \rset$.
and $A : \D \x \D^\op \x \C \x \C^\op$ and a functor $\nu : \D \to \C$.
I want to start with the end
\[ \int_{d \in \D, c \in \C} G(d, c) \to A(d, d, c, c) \]

which is to say the equalizer
\[
\begin{tikzcd}
  E \ar[r, >->, "e"] &
\displaystyle\prod\limits_{ d \in \D, c \in \C}G(d, d) \to A(d, d, c, c)
\ar[r, shift left]\ar[r, shift right]
&
\displaystyle\prod\limits_{\begin{tabular}{l}$\scriptstyle d,d' \in \D$\\
$\scriptstyle c,c' \in \C$ \end{tabular} } G(d', d) \to A(d, d', c, c')
\end{tikzcd}
\]
and somehow get to
\[ \int_{d \in \D} G(d, c) \to A(d, d, \nu(d), \nu(d)) \]
which is to say
\[
\begin{tikzcd}
  E' \ar[r, >->, "e'"] &
\displaystyle\prod\limits_{ d \in \D}G(d, d) \to A(d, d, \nu(d), \nu(d))
\ar[r, shift left]\ar[r, shift right]
&
\displaystyle\prod\limits_{d,d' \in \D} G(d', d) \to A(d, d', \nu(d), \nu(d'))
\end{tikzcd}
\]
Okay, so at least this type-checks, since $\nu : \D \to \C$ implies that I also have
$\nu^\op : \D^\op \to \C^\op$.

If I am to get from $E$ to $E'$, then I need to get from $E$ to
\[\prod_{ d \in \D}G(d, d) \to A(d, d, \nu(d), \nu(d))\] in such a way as to
satisfy the equalizer condition. But I do actually have the ability to choose the projection
from
\[\displaystyle\prod\limits_{ d \in \D, c \in \C}G(d, d) \to A(d, d, c, c)\]
down to the choice of $c$ being specifically $\nu(d)$. And thanks to functoriality of $\nu$,
I think I get the equalizer condition downstairs from the one upstairs.

Ah, what have I shown? I think it goes like this. Let's give a name to
the `non-doubled' semantics of $\Delta$. Say when $\Delta = x_1 :
\C_1, \ldots, x_n: \C_n$ that $\ssem \Delta$ is just plain old $\C_1
\x \cdots \x \C_n$. So I think I've shown suggestively that when there
is a functor $\nu : \ssem \Delta \to \C$ --- which is strictly
stronger than asking for $\sem \Delta \to \C^*$ --- {\bf then} I can
get from the meaning of $\Delta ; \Gamma \prov e : \forall \alpha :
\C. A$ to the meaning of $\Delta ; \Gamma \prov e[\nu] : [\nu/\alpha]
A $.

Just above I effectively went through this thinking
for the special case that $\Delta$ is a singleton, but I think
it extends. So, yeah, the moral of everything is that the meaning of
 $\Delta \prov \nu : \C$ should be
that there is a functor $\sem \nu : \ssem \Delta \to \C$.

Hm, although, wait, right at the outset I said that I could do
\[
\erule
{}
{\Delta, \alpha : \C \prov \bar \alpha: \C^\op}
\]
and this isn't at all a functor $\ssem \Delta \to \C$, it's directly contravariant to
such a thing. I don't see anything broken just yet --- the swap
also takes equal pairs of objects to equal pairs, at least ---
but I do need to tread more carefully.
Maybe I just need to convince myself that another legitimate form of
$\Delta \prov \nu : \C$ is the swap, that there is a valid interpretation of
the above rule that's compatible with $\forall$-elim.

Ok, to analyze this, let me observe that probably the $\sem \Gamma$
context isn't that crucial, and what I really need to believe in is
just that I can get out of a single end in the appropriate way. Moreover
it's not about the $\forall$ so much as the substitution principle involved.
If I have $\alpha : \C^\op, \beta : \C \prov e : A$
and I observe that $\beta : \C \prov \bar \beta : \C^\op$, I should be able
to substitute $\bar\beta$ for $\alpha$ in $e$ and get an expression
$ \beta : \C \prov [\bar\beta/\alpha]e : A$.

Semantically, I start by knowing that $A : \C^\op \x \C \x \C \x \C^\op \to \rset$
and I have something in
\[ \int_{\alpha \in \C^\op, \beta \in \C} \sem A(\alpha, \beta)\]
and I want to get to
\[ \int_{ \beta \in \C} \sem A(\bar \beta, \beta)\]
More explicitly, I start in the equalizer
\[
\begin{tikzcd}
  E \ar[r, >->, "e"] &
\displaystyle\prod\limits_{ \alpha \in \C^\op, \beta\in\C}  A(\alpha, \alpha, \beta, \beta)
\ar[r, shift left]\ar[r, shift right]
&
\displaystyle\prod\limits_{\alpha, \beta' \in \C^\op ,\beta,\alpha'\in \C}
A(\alpha, \alpha', \beta, \beta')
\end{tikzcd}
\]
and I want to get to
\[
\begin{tikzcd}
  E' \ar[r, >->, "e'"] &
\displaystyle\prod\limits_{  \beta\in\C}  A(\beta, \beta, \beta, \beta)
\ar[r, shift left]\ar[r, shift right]
&
\displaystyle\prod\limits_{ \beta' \in \C^\op ,\beta\in \C}
A(\beta', \beta, \beta, \beta')
\end{tikzcd}
\]
Okay, let's say we have $f : \alpha \to \alpha'$ and $g : \beta' \to \beta$.
We can make an $A(\alpha, \alpha', \beta, \beta')$ in two
ways. We can start with $A(\alpha, \alpha, \beta, \beta)$ and
transport via $A(\alpha, f, \beta, g)$,
covariantly along $f$ and contravariantly along $g$ (from
the perspective of $\C$ being called `covariant') or we can
start from
$A(\alpha', \alpha', \beta', \beta')$ and do the opposite,
$A(f, \alpha', g, \beta')$. If we're in $E$, these are the same. That is,
for any $\epsilon\in E$, we have
\[ A(\alpha, f, \beta, g) ( e(\epsilon)(\alpha, \beta)) = A( f, \alpha', g, \beta') (e(\epsilon)(\alpha', \beta'))\]
Ok, so there definitely {\em is} a map
\[ \lambda x . \lambda \beta . x(\beta, \beta) : \prod_{ \alpha \in \C^\op, \beta\in\C}  A(\alpha, \alpha, \beta, \beta) \to
\prod_{  \beta\in\C}  A(\beta, \beta, \beta, \beta)\]
I just want to confirm it preserves the equalizer property.
The property some $y \in \Pi_\beta A(\beta, \beta, \beta, \beta)$ is
 supposed to have to be in $E'$ is that for any $g : \beta' \to \beta$
\[ A(g, \beta, \beta, g)(y(\beta)) = A(\beta', g, g, \beta')(y(\beta'))\]
So I think this follows from a diagram chase, I'm just going to write
$0$ for $\beta$ and $1$ for $\beta'$
\[
\begin{tikzcd}
&& E \ar[d, >->]\\
  A(0000) \ar[dr] \ar[ddrr, bend right] && \Pi_{\alpha\beta} A(\alpha\alpha\beta\beta) \ar[ll]\ar[rr]\ar[d]
 && A(1111) \ar[dl] \ar[ddll, bend left]\\
& A(1000)\ar[dr] & A(1100)  \ar[l]\ar[r]\ar[d] & A(1101) \ar[dl]\\
&& A(1001)
\end{tikzcd}
\]
The fact that composition with the injection from the equalizer makes both top squares
commute is the assumption about the end we had coming in. The commutativity of the other
triangles is just functoriality of $A$.

Ok, so I suppose this all works, but I still wish I had a better handle on {\em semantically}
what sort of property of functors $\C \x \C^\op \to \D \x \D^\op$ sufficies to make this work.

\subsection{What That Property Is}

Maybe it's just being literally a functor $F : \C \x \C^\op \to \D$.
Or, in a way, it's being {\em either} a functor
$F : \C \x \C^\op \to \D$
or
$F : \C \x \C^\op \to \D^\op$, but I can convert either one of those to the other
by taking $F$ to $F^\op$ and swapping the arguments.

Then if I have a functor $A : \D \x \D^\op \to \rset$ and I have
\[e \in \int_{d \in \D} A(d, d)\]
corresponding to $y : \D \prov A : \rtype$ and I want to carry out the substitution
and find $x : \C \prov [F(x)/y]A : \rtype$ which semantically is
\[e' \in \int_{c \in \C} A(F(c, c), F(c, c))\]
In equalizer terms, I'm trying to go from
\[
\begin{tikzcd}
  E \ar[r, >->, "e"] &
\displaystyle\prod\limits_{  d\in\D}  A(d, d)
\ar[r, shift left]\ar[r, shift right]
&
\displaystyle\prod\limits_{ d' \in \D^\op ,d\in \D}
A(d, d')
\end{tikzcd}
\]
to
\[
\begin{tikzcd}
  E' \ar[r, >->, "e'"] &
\displaystyle\prod\limits_{  c\in\C}  A(F(c, c), F(c, c))
\ar[r, shift left]\ar[r, shift right]
&
\displaystyle\prod\limits_{ c' \in \C^\op ,c\in \C}
A(F(c, c'), F(c', c))
\end{tikzcd}
\]
And I do this by sending the $\prod_{d\in\D}$ to the $\prod_{c\in\C}$ in the evident way,
and I need to check the equalizer property. The thing I know, given $h : d_1 \to d_0$, is that
\[\begin{tikzcd}
  E \ar[r, "\pi e", >->]\ar[d, "\pi e"', >->] & A(d_0, d_0)\ar[d, "{A(d_0, h)}"]\\
A(d_1, d_1)\ar[r, "{A(h, d_1)}"'] & A(d_0,d_1)
\end{tikzcd}\]
and the thing I need is, for any $k : c_1 \to c_0$, that
\[\begin{tikzcd}
  E \ar[r, "\pi e", >->]\ar[d, "\pi e"', >->] & A(F(c_0, c_0), F(c_0, c_0))\ar[d]\\
A(F(c_1, c_1), F(c_1, c_1))\ar[r] & A(F(c_0, c_1), F(c_1, c_0))
\end{tikzcd}\]
and I think this follows from chasing
\[
\begin{tikzcd}
  E \ar[rrr]\ar[dr]\ar[ddd] &&& 0000\ar[ddd]\ar[dl]\\
&0101\ar[r]\ar[d]&0100\ar[d]\\
&0111\ar[r]&0110\ar[dr, equal]\\
1111 \ar[rrr]\ar[ur]&&&0110
\end{tikzcd}
\]
where $b_1b_2b_3b_4$ abbreviates $A(F(c_{b_1}, c_{b_2}), F(c_{b_3}, c_{b_4}))$. The top
two trapezoids follow by the equalizer property assumed, and the remaining cells
follow by functoriality of $A$ and $F$.

\subsubsection{$\forall$ elim}
Let's look at $\forall$-elim again.
\[
\erule
{\Delta ; \Gamma \prov  e :  \forall \alpha : \C. A \qquad \Delta \prov \nu : \C}
{\Delta ; \Gamma \prov e[\nu] :  [\nu/\alpha] A }
\]
So it sort of doesn't make any difference whether we say $\forall \alpha : \C$ or
$\forall \alpha : \C^\op$. Semantically, the $\nu$ is going to be flipped around whichever
way fits, and we use the same underlying mathematical data. This is consistent with the
end/coend computation being indifferent to whether we use $\C$ or $\C^\op$.

So if we have
\[\sem e\in \int_{\delta\in\ssem\Delta} \sem \Gamma(\delta, \delta) \to \int_{c\in \C}\sem A((\delta, c), (\delta, c)) \]
\[\nu : \ssem \Delta \x \ssem \Delta^\op \to \C\]
then yeah sure we can probably get from that to
\[\sem {e[\nu]}\in \int_{\delta\in\ssem\Delta} \sem \Gamma(\delta, \delta) \to \sem A((\delta, \nu(\delta, \delta)), (\delta, \nu(\delta, \delta))) \]

\subsubsection{$\exists$ intro}
\[
\erule
{\Delta ; \Gamma \prov e :  [\nu/\alpha] A  \qquad \Delta \prov \nu : \C}
{\Delta ; \Gamma \prov  \susp{e, \nu} :  \exists \alpha : \C. A}
\]
We need to get from
\[\sem {e}\in \int_{\delta\in\ssem\Delta} \sem \Gamma(\delta, \delta) \to \sem A((\delta, \nu(\delta, \delta)), (\delta, \nu(\delta, \delta))) \]
\[\nu : \ssem \Delta \x \ssem \Delta^\op \to \C\]
to
\[\sem {\pair e \nu}\in \int_{\delta\in\ssem\Delta} \sem \Gamma(\delta, \delta) \to \int^{c\in \C}\sem A((\delta, c), (\delta, c)) \]

This is probably just a dual situation to $\forall$ elim, but I want
to go through it a little carefully anyhow. At least in the simple case that shows
I can go from
$\int_{d\in\D} \sem A(\nu(d, d), \nu(d, d))$
to
$\int^{c\in\C} \sem A(c, c)$
given functors $\nu: \D \x \D^\op \to \C$ and $A : \C\x\C^\op \to \rset$.

The coequalizer that is
the coend is
\[
\begin{tikzcd}
  Q \ar[from=r, ->>, "q"] &
\displaystyle\coprod\limits_{  c\in\C}  A(c, c)
\ar[from=r, shift left]\ar[from=r, shift right]
&
\displaystyle\coprod\limits_{ c' \in \C^\op ,c\in \C}
A(c, c')
\end{tikzcd}
\]
the equalizer that is the end is
\[
\begin{tikzcd}
  E \ar[r, >->, "e"] &
\displaystyle\prod\limits_{  d\in\D}  A(\nu(d,d), \nu(d,d))
\ar[r, shift left]\ar[r, shift right]
&
\displaystyle\prod\limits_{ d' \in \D^\op ,d\in \D}
A(\nu(d, d'), \nu(d', d))
\end{tikzcd}
\]
Oh, wait, there actually is no problem at all getting {\em into} the coend,
of course; I just take the $\nu(d, d)$ injection for each $d$, and proceed
through $q$.
Maybe the elim will have more challenge checking that things line up?
\subsubsection{$\exists$ elim}

 \[
\erule
{\Delta; \Gamma \prov e :  \exists \alpha : \C . A \qquad\Delta, \alpha : \C;\Gamma, x : \bar A \prov e' : B}
{\Delta ; \Gamma \prov \blet \susp{x,\alpha} = e \bin e':  B }
\]
We have
\[\sem {e}\in \int_{\delta\in\ssem\Delta} \sem \Gamma(\delta, \delta) \to \int^{c\in\C}\sem A((\delta, c), (\delta, c)) \]
\[\sem {e'}\in \int_{\delta\in\ssem\Delta}  \sem \Gamma(\delta, \delta) \to \int_{c\in\C} \sem A((\delta, c), (\delta, c)) \to \sem B(\delta, \delta) \]
and we need
\[\sem {\blet \cdots}\in \int_{\delta\in\ssem\Delta}  \sem B(\delta, \delta) \]
and this is a simple matter of remembering that coends and ends realize the
logical tautology $\forall x . A(x) \imp B \equiv (\exists x . A(x)) \imp B$,
so that $\sem {e'}$ is effectively
\[\sem {e'}\in \int_{\delta\in\ssem\Delta}  \sem \Gamma(\delta, \delta) \to \left(\int^{c\in\C} \sem A((\delta, c), (\delta, c))\right) \to \sem B(\delta, \delta) \]

\subsubsection{Homset types}
I want to declare
\[
\erule
{\Delta \prov \nu : \C^\op \qquad \Delta \prov \mu : \C}
{\Delta, \Gamma \prov \C[\nu, \mu] : \rtype}
\]
and the semantics of $\C[\nu,\mu]$, given that we know $\sem \nu : \sem \Delta \to \C^\op$
and $\sem \mu : \sem \Delta \to \C$, can be given straightforwardly perhaps as
\[\sem{\C[\nu,\mu]}(\delta) = \C[\sem\nu(\delta), \sem\mu(\delta)]\]
Then I hope for some kind of transport principle like
\[
\erule
{\Delta;\Gamma \prov h : \C[\nu, \mu] \quad \Delta, \alpha : \C \prov A : \rtype
 \quad \Delta;\Gamma \prov e : [\bar \nu/\alpha] A  }
{\Delta;\Gamma \prov \mathsf{coe}_h e : [\mu/\alpha] A}
\]
Semantically we have
\[\sem h \in \int_{\delta \in \ssem \Delta} \sem \Gamma(\delta, \delta) \to \C[ \sem\nu(\delta, \delta), \sem\mu(\delta, \delta) ]\]
\[ \sem A : \sem \Delta \x (\C \x \C^\op)\to \rset\]
\[ \sem e \in \int_{\delta \in \ssem \Delta}
\sem \Gamma(\delta, \delta) \to
\sem A (\delta, \delta, \sem{\bar\nu}(\delta, \delta), \sem \nu(\delta, \delta)) \]
and we want
\[ \sem {\mathsf{coe}_h e} \in \int_{\delta \in \ssem \Delta}
\sem \Gamma(\delta, \delta) \to
 \sem A (\delta, \delta, \sem{\mu}(\delta, \delta), \sem {\bar \mu}(\delta, \delta)) \]
Ignoring $\Gamma$s for now, for each $\delta \in \ssem\Delta$ we have to make a
$\sem A (\delta, \delta, \sem{\mu}(\delta, \delta), \sem {\bar \mu}(\delta, \delta))$.

But $\sem A$'s last argument is contravariant. I can't get from $\sem{\bar\mu}(\delta, \delta)$
to $\sem{\nu}(\delta, \delta)$.

\subsubsection{Homset Types Again}
Let's try:
\[\sem{\C[\nu,\mu]}(\delta) = \C[\sem\nu(\delta), \sem\mu(\delta)] \x \C[\sem{\bar \mu}(\delta), \sem{\bar \nu}(\delta)]\]

Then we have
\[\sem h \in \int_{\delta \in \ssem \Delta} \sem \Gamma(\delta, \delta) \to  \]
\[
\C[ \sem\nu(\delta, \delta), \sem\mu(\delta, \delta) ]
\x
\C[ \sem{\bar\mu}(\delta, \delta), \sem{\bar \nu}(\delta, \delta) ]
\]
\[ \sem A : \sem \Delta \x (\C \x \C^\op)\to \rset\]
\[ \sem e \in \int_{\delta \in \ssem \Delta}
\sem \Gamma(\delta, \delta) \to
\sem A (\delta, \delta, \sem{\bar\nu}(\delta, \delta), \sem \nu(\delta, \delta)) \]
and we want
\[ \sem {\mathsf{coe}_h e} \in \int_{\delta \in \ssem \Delta}
\sem \Gamma(\delta, \delta) \to
 \sem A (\delta, \delta, \sem{\mu}(\delta, \delta), \sem {\bar \mu}(\delta, \delta)) \]

And it looks like this goes through, but it means that I can't just use a
single  $f : C \to D \in \C$
as a constructor for the hom-type, can I?
\end{document}
