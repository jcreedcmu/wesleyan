\documentclass{article}
\input{theorem}
\input{prooftree}
\usepackage{stmaryrd}
\usepackage{latexsym}
\usepackage{yfonts}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,cd,decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}
\usepackage{tcolorbox}
\tcbuselibrary{breakable}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}

\def\bpush{\mathbf{push}}
\def\bpull{\mathbf{pull}}

\def\wo{\setminus}
\def\fA{\mathsf{A}}
\def\fC{\mathsf{C}}
\def\fX{\mathsf{X}}
\def\ff{\mathsf{f}}
\def\fm{\mathsf{m}}
\def\rspan{\mathsf{Span}}
% \def\El#1{\mathsf{El}({#1})}
\def\El#1{\ulcorner{#1}\urcorner}
\def\quote#1{{\ulcorner {#1} \urcorner}}
\def\U{\mathsf{U}}
\def\uu{\mathsf{u}}
\def\uni{\U}
\def\mor#1#2{#1 \to \underline{#2}}

\def\ridp{\mathsf{idp}}
\def\ssem#1{\langle\!\langle{#1}\rangle\!\rangle}

\definecolor{cyan}{rgb}{0.80,0.95,0.95}
\definecolor{orange}{rgb}{0.95,0.90,0.80}
\definecolor{bluegray}{rgb}{0.6,0.6,0.85}
\definecolor{lgray}{gray}{0.9}
\newtcolorbox{declbox}{colframe=lred,colback=lred,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{thmbox}{colframe=cyan,colback=cyan,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{defnbox}{colframe=orange,colback=orange,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{tangentbox}{colframe=lgray,colback=lgray,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}

\input{linear}
\def\rpath#1{[#1]}
\def\rfst{\mathsf{fst}\,}
\def\rsnd{\mathsf{snd}\,}
\def\bunfold{\mathbf{unfold}}
\def\bfold{\mathbf{fold}}
\def\susp#1{\langle {#1} \rangle}
\def\ssusp#1{\langle\!\langle {#1} \rangle\!\rangle}
\def\dto{\mathrel{\dot\to}}
\def\dns{{\downarrow}}
\def\ups{{\uparrow}}
\def\sprov{\Vdash}
\def\signat{{\color{red}\Sigma}}
\def\ep#1{\underline{#1}}
\def\wat{\mathbin{@}}
\def\wwat{\mathbin{\underline\wat}}
\def\cn{{:}}
\def\dv{{\div}}
\def\ww{{\mathsf w}}
\def\base{{\textfrak b}}

\def\munit{I}
\def\tt{{\mathsf t}}
\def\rr{{\mathsf r}}
\def\ii{{\mathbb I}}
\def\pp{\textsf{\textbf p}}
\def\nn{{\mathsf n}}
\def\PP{\textsf{\textbf P}}
\def\NN{{\mathsf N}}
\def\zz{{\mathsf z}}
\def\sem#1{[\![#1]\!]}
\def\usem#1{\lceil\!\!\lceil{#1}\rceil\!\!\rceil}
\def\zem#1{\langle\!\langle#1\rangle\!\rangle}
\def\col#1{{\mathsf{C}}_{#1}}
\def\lax{\mathop\bigcirc}
\def\rjust{\mathsf{just}}
\def\rcvt{\mathsf{cvt}}
\def\rtype{\mathsf{type}}
\def\rdtype{\mathsf{disc}}
\def\rkind{\mathsf{kind}}
\def\rmode{\mathsf{mode}}
\def\rprel{\mathbf{Prel}}
\def\rrfam{\mathbf{Rfam}}
\def\rset{\mathbf{Set}}
\def\rfinset{\mathbf{FinSet}}
\def\rrel{\mathbf{Rel}}
\def\rcat{\mathbf{Cat}}
\def\rfam{\mathbf{Fam}}
\def\binj{\mathbf{inj}}
\def\rid{\mathsf{id}}
\def\rtrue{\mathrel\mathrm{true}}
\def\pbck{\ar[dr, phantom, pos=0, "\lrcorner"]}
\def\bpbck{\ar[ddrr, phantom, pos=0, "\lrcorner"]}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\btwo{\mathbf{2}}
\def\bone{\mathbf{1}}

\newarrow {Equiv} =====
\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\def\mapt{\ar[ddd,mapsto,shorten <=2em, shorten >=2em]}
\def\frommaps{\ar[from=uu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\frommapt{\ar[from=uuu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\C{\mathbf{C}}
\def\G{\mathbf{G}}
\def\S{\mathbf{S}}
\def\D{\mathbf{D}}
\def\E{\mathbf{E}}
\def\M{\mathbf{M}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\tri{\triangleright}
\def\o{\circ}
\def\rctx{\,\mathsf{ctx}}
\def\rdctx{\,\mathsf{dctx}}
\def\del{\partial}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\null{\emptyset}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\definecolor{fib}{HTML}{ff7f00}
\definecolor{green}{HTML}{007f00}
\definecolor{red}{HTML}{df3f3f}
\definecolor{opfib}{HTML}{007fff}

% For lightening colors I used
% http://trycolors.com/ 6 parts white to 1 part color
\definecolor{opfibl}{HTML}{DBEDFF}
\definecolor{greenl}{HTML}{DBEDDB}
\definecolor{redl}{HTML}{FAE4E4}
\def\njudge#1{\fcolorbox{opfib}{white}{#1}}
\def\nrule#1{\fcolorbox{white}{opfibl}{#1}}
\def\neqn#1{\fcolorbox{white}{redl}{#1}}



\def\judge#1{\vskip 2em\noindent \njudge{$#1$}\vskip 0.5em\noindent}
\def\rule#1{\vskip 2em \noindent \nrule{$#1$}\vskip 0.5em\noindent}
\def\eqn#1{\vskip 2em \noindent \neqn{$#1$}\vskip 0.5em\noindent}
\def\prof{\nrightarrow}
\def\tensor{\otimes}
\def\htensor{\mathrel{\hat\otimes}}
\def\lol{\multimap}
\def\hlol{\mathrel{\hat\multimap}}
\def\wtf{{\color{red}???}}

\def\re{\mathbf{E}}
\def\sh{\sharp}
\def\shp{\mathrel{\sharp}}
\def\zero{\texttt{0}}
\begin{document}

\def\
\tikzset{
   commutative diagrams/.cd,
   arrow style=tikz,
   diagrams={>=stealth}}

\section{A Syntax for (Co)Ends}
Category variables are $\alpha$, with signed {\em uses} $\alpha^+$ and $\alpha^-$.
\[\begin{tabular}{rccl}
  Categories&$\C$&$::=$&$\cdots$\\
  Category Contexts&$\Delta$&$::=$&$\cdot \celse \Delta, \alpha : \C$\\
  Contexts&$\Gamma$&$::=$&$\cdot \celse \Gamma, x : A$\\
  Types&$A$&$::=$&$\forall \alpha . A \celse \exists \alpha . A \celse A \to A \celse A \x A
 \celse a(\alpha, \ldots, \alpha)$\\
\end{tabular}\]
We write $\bar A$ for $A$ with all the $+$ and $-$ in category variable appearances reversed.

\subsection{Intention of the Semantics}
The judgment
\[ \Delta; \Gamma \prov A : \rtype \]
says that $\Gamma \to A$ stands for a mixed variance
functor over all the variables in $\Delta$.

If $\Delta = \alpha_1 : \C_1^{\pm_1} , \ldots, \alpha_n : \C_n^{\pm_n}$
\subsection{Typing Rules}
\subsubsection{Variable Rules}
\[
\erule
{\forall i . \alpha_i : \C_i \in \Delta \qquad a : \C_1^{\pm_1} \x \cdots \x \C_n^{\pm_n} \to \rtype }
{\Delta \prov a(\alpha^{\pm_1}_1, \ldots, \alpha^{\pm_n}_n) : \rtype}\]
\[
\erule
{}
{\Delta; \Gamma, x : A \prov x : A}
\]
\subsubsection{Type Formation}
\[
\erule
{\Delta, \alpha : \C  \prov A : \rtype}
{\Delta \prov \forall \alpha : \C. A : \rtype}
\qquad
\erule
{\Delta, \alpha : \C  \prov A : \rtype}
{\Delta \prov \exists \alpha : \C. A : \rtype}
\]
\[
\erule
{\Delta \prov \bar A  : \rtype \qquad \Delta \prov B : \rtype}
{\Delta \prov A \to B : \rtype}
\qquad
\erule
{\Delta \prov  A  : \rtype \qquad \Delta \prov B : \rtype}
{\Delta \prov  A \x B : \rtype}
\]
\subsubsection{Contexts}
\[
\erule
{\prov \Gamma \rctx \qquad \Gamma \prov \bar A : \rtype}
{\prov \Gamma, x : A \rctx}
\]
\subsubsection{Quantifiers}
\[
\erule
{\Delta ; \Gamma \prov  e :  \forall \alpha : \C. A \qquad \Delta \prov \nu : \C}
{\Delta ; \Gamma \prov e[\nu] :  [\nu/\alpha] A }
\qquad
\erule
{\Delta, \alpha : \C ; \Gamma \prov e :  A }
{\Delta ; \Gamma \prov \Lambda \alpha . e :  \forall \alpha : \C .A }
\]
\[
\erule
{\Delta ; \Gamma \prov e :  [\nu/\alpha] A  \qquad \Delta \prov \nu : \C}
{\Delta ; \Gamma \prov  \susp{e, \nu} :  \exists \alpha : \C. A}
\] \[
\erule
{\Delta; \Gamma \prov e :  \exists \alpha : \C . A \qquad\Delta, \alpha : \C;\Gamma, x : \bar A \prov e' : B}
{\Delta ; \Gamma \prov \blet \susp{x,\alpha} = e \bin e':  B }
\]
\subsubsection{Regular Connectives}
\[
\erule
{\Delta; \Gamma \prov e : A \to B \qquad \Delta; \Gamma \prov e' : \bar A}
{\Delta;\Gamma \prov e\ e' : B}
\qquad
\erule
{\Delta; \Gamma, x : A \prov e : B}
{\Delta;\Gamma \prov \lambda x . e : A \to B}
\]
\section{Semantics}
Interpret every $\Delta$ as a category.
\begin{defnbox}
  \begin{tabular}{rcl}
$\sem{\cdot}$&$=$&$\mathbf 1$\\
$\sem{\Delta, \alpha : \C}$&$=$&$\sem \Delta \x (\C \x \C^\op)$
\end{tabular}
\end{defnbox}
Interpret every
\[ \Delta; \Gamma \prov A : \rtype\]
as a functor $\sem \Delta \to \rset$. Let $\delta$ be an arbitrary object of $\sem \Delta$.
When $\Delta = \alpha_1 : \C_1,\ldots, \alpha_n : \C_n$, we will have
$\delta = ((\delta_1, \delta_1'), \ldots, (\delta_n, \delta_n'))$.
{\renewcommand{\arraystretch}{1.5}
\begin{defnbox}
  \begin{tabular}{rcl}
$\sem{\exists \alpha : \C . A}(\delta)$&$=$&$\int^{\alpha \in \C} \sem A(\delta, (\alpha, \alpha))$\\
$\sem{\forall \alpha : \C . A}(\delta)$&$=$&$\int_{\alpha \in \C} \sem A(\delta, (\alpha, \alpha))$\\
$\sem{A \to B}(\delta)$&$=$&$\sem A(\bar \delta) \to \sem B(\delta)$\\
$\sem{A \x B}(\delta)$&$=$&$\sem A( \delta) \x \sem B(\delta)$\\
\end{tabular}
\end{defnbox}
}
Where $\bar \delta$ means the object-wise swap of every variable piece of $\delta$.

\subsubsection{Hom Types}

So I should be able to just say
\[
\erule
{}
{\Delta, \alpha : \C \prov \hom(\alpha^-, \alpha^+) : \rtype}
\]
or something like that, right? Or should I write simply
\[
\erule
{}
{\Delta, \alpha : \C \prov \hom(\alpha) : \rtype}
\]
? Or maybe even like
\[
\erule
{}
{\Delta, \alpha_1, \alpha_2 : \C \prov \hom(\alpha_1, \alpha_2) : \rtype}
\]
to represent the type of pairs of morphisms
\[\begin{tikzcd}
  \alpha_1^- \ar[from=d, "f"]& \alpha_1^+ \ar[d, "g"]\\
  \alpha_2^- & \alpha_2^+
\end{tikzcd}\]
For which I could expect to do transport something like
\[
\erule
{\Delta \prov \nu : \C \qquad \Delta, \alpha; \Gamma \prov f : \hom(\alpha, \nu) \qquad
\Delta, \alpha ; \Gamma \prov e : A}
{\Delta; [\nu/\alpha]\Gamma \prov e\adjust_f : [\nu/\alpha]A }
\]
Maybe need to require somehow that $\alpha \not\in f$? Or maybe more like
\[
\erule
{\Delta \prov \nu_1, \nu_2 : \C \qquad \Delta; \Gamma \prov f : \hom(\nu_1, \nu_2) \qquad
\Delta; [\nu_1/\alpha]\Gamma \prov e : [\nu_1/\alpha]A }
{\Delta; [\nu_2/\alpha]\Gamma \prov e\adjust_f : [\nu_2/\alpha]A }
\]
Because... yeah, that second to last rule is redundant, isn't it? I
don't need a $\hom(\alpha, \nu)$ to tell me that I can substitute into
$\Delta, \alpha ; \Gamma \prov e : A$ to get
$\Delta; [\nu/\alpha]\Gamma \prov e\adjust_f : [\nu/\alpha]A $, I can already do that.
I really want to ask for the {\em weaker} premise
$\Delta; [\nu_1/\alpha]\Gamma \prov e : [\nu_1/\alpha]A $
that I merely have some {\em substitution instance} of
$\Delta, \alpha ; \Gamma \prov e : A$
at some {\em particular} $\nu_1$ ---
but a $\nu_1$ for which I have a hom out of it,
critically.

Okay, I think a rule like this makes sense as an elim for $\hom$, but
I may need to be more careful about inserting some sort notion of
swaps at certain points to account for what I'm doing by essentially
requiring $\C \x \C^\op$ thingies to be flying around everywhere.
\end{document}
