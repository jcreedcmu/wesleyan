\documentclass{article}
\input{theorem}
\input{prooftree}
\usepackage{stmaryrd}
\usepackage{latexsym}
\usepackage{yfonts}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,cd,decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}
\usepackage{tcolorbox}
\tcbuselibrary{breakable}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}

\def\coe{\mathsf{coe}}
\def\bpush{\mathbf{push}}
\def\bpull{\mathbf{pull}}

\def\wo{\setminus}
\def\fA{\mathsf{A}}
\def\fC{\mathsf{C}}
\def\fX{\mathsf{X}}
\def\ff{\mathsf{f}}
\def\fm{\mathsf{m}}
\def\rspan{\mathsf{Span}}
% \def\El#1{\mathsf{El}({#1})}
\def\El#1{\ulcorner{#1}\urcorner}
\def\quote#1{{\ulcorner {#1} \urcorner}}
\def\U{\mathsf{U}}
\def\uu{\mathsf{u}}
\def\uni{\U}
\def\mor#1#2{#1 \to \underline{#2}}

\def\ridp{\mathsf{idp}}
\def\ssem#1{\langle\!\langle{#1}\rangle\!\rangle}

\definecolor{lred}{rgb}{0.95,0.8,0.8}
\definecolor{cyan}{rgb}{0.80,0.95,0.95}
\definecolor{orange}{rgb}{0.95,0.90,0.80}
\definecolor{bluegray}{rgb}{0.6,0.6,0.85}
\definecolor{lgray}{gray}{0.9}
\newtcolorbox{declbox}{colframe=lred,colback=lred,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{thmbox}{colframe=cyan,colback=cyan,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{defnbox}{colframe=orange,colback=orange,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{tangentbox}{colframe=lgray,colback=lgray,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}

\input{linear}
\def\rpath#1{[#1]}
\def\rfst{\mathsf{fst}\,}
\def\rsnd{\mathsf{snd}\,}
\def\bunfold{\mathbf{unfold}}
\def\bfold{\mathbf{fold}}
\def\susp#1{\langle {#1} \rangle}
\def\ssusp#1{\langle\!\langle {#1} \rangle\!\rangle}
\def\dto{\mathrel{\dot\to}}
\def\dns{{\downarrow}}
\def\ups{{\uparrow}}
\def\sprov{\Vdash}
\def\signat{{\color{red}\Sigma}}
\def\ep#1{\underline{#1}}
\def\wat{\mathbin{@}}
\def\wwat{\mathbin{\underline\wat}}
\def\cn{{:}}
\def\dv{{\div}}
\def\ww{{\mathsf w}}
\def\base{{\textfrak b}}

\def\munit{I}
\def\tt{{\mathsf t}}
\def\rr{{\mathsf r}}
\def\ii{{\mathbb I}}
\def\pp{\textsf{\textbf p}}
\def\nn{{\mathsf n}}
\def\PP{\textsf{\textbf P}}
\def\NN{{\mathsf N}}
\def\zz{{\mathsf z}}
\def\sem#1{[\![#1]\!]}
\def\usem#1{\lceil\!\!\lceil{#1}\rceil\!\!\rceil}
\def\zem#1{\langle\!\langle#1\rangle\!\rangle}
\def\col#1{{\mathsf{C}}_{#1}}
\def\lax{\mathop\bigcirc}
\def\rjust{\mathsf{just}}
\def\rcvt{\mathsf{cvt}}
\def\rtype{\mathsf{type}}
\def\rdtype{\mathsf{disc}}
\def\rkind{\mathsf{kind}}
\def\rmode{\mathsf{mode}}
\def\rprel{\mathbf{Prel}}
\def\rrfam{\mathbf{Rfam}}
\def\rset{\mathbf{Set}}
\def\rfinset{\mathbf{FinSet}}
\def\rrel{\mathbf{Rel}}
\def\rcat{\mathbf{Cat}}
\def\rfam{\mathbf{Fam}}
\def\binj{\mathbf{inj}}
\def\rid{\mathsf{id}}
\def\rtrue{\mathrel\mathrm{true}}
\def\pbck{\ar[dr, phantom, pos=0, "\lrcorner"]}
\def\bpbck{\ar[ddrr, phantom, pos=0, "\lrcorner"]}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\btwo{\mathbf{2}}
\def\bone{\mathbf{1}}

\newarrow {Equiv} =====
\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\def\mapt{\ar[ddd,mapsto,shorten <=2em, shorten >=2em]}
\def\frommaps{\ar[from=uu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\frommapt{\ar[from=uuu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\C{\mathbf{C}}
\def\G{\mathbf{G}}
\def\S{\mathbf{S}}
\def\D{\mathbf{D}}
\def\E{\mathbf{E}}
\def\M{\mathbf{M}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\tri{\triangleright}
\def\o{\circ}
\def\rctx{\,\mathsf{ctx}}
\def\rdctx{\,\mathsf{cat}}
\def\del{\partial}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\definecolor{fib}{HTML}{ff7f00}
\definecolor{green}{HTML}{007f00}
\definecolor{red}{HTML}{df3f3f}
\definecolor{opfib}{HTML}{007fff}

% For lightening colors I used
% http://trycolors.com/ 6 parts white to 1 part color
\definecolor{opfibl}{HTML}{DBEDFF}
\definecolor{greenl}{HTML}{DBEDDB}
\definecolor{redl}{HTML}{FAE4E4}
\def\njudge#1{\fcolorbox{opfib}{white}{#1}}
\def\nrule#1{\fcolorbox{white}{opfibl}{#1}}
\def\neqn#1{\fcolorbox{white}{redl}{#1}}



\def\judge#1{\vskip 2em\noindent \njudge{$#1$}\vskip 0.5em\noindent}
\def\rule#1{\vskip 2em \noindent \nrule{$#1$}\vskip 0.5em\noindent}
\def\eqn#1{\vskip 2em \noindent \neqn{$#1$}\vskip 0.5em\noindent}
\def\prof{\nrightarrow}
\def\tensor{\otimes}
\def\htensor{\mathrel{\hat\otimes}}
\def\lol{\multimap}
\def\hlol{\mathrel{\hat\multimap}}
\def\wtf{{\color{red}???}}

\def\re{\mathbf{E}}
\def\sh{\sharp}
\def\shp{\mathrel{\sharp}}
\def\zero{\texttt{0}}
\begin{document}

\def\
\tikzset{
   commutative diagrams/.cd,
   arrow style=tikz,
   diagrams={>=stealth}}

\section{A Syntax for Category Variables}
Let there be some syntax class
\[\begin{tabular}{rccl}
  Categories&$\C$&$::=$&$\cdots$\\
  Category Contexts&$\Delta$&$::=$&$\cdot\celse \Delta, \alpha + \C\celse \Delta, \alpha - \C$\\
\end{tabular}\]
We suppose that some collection of categories has been prescribed. One
could think of $\C$ as `codes for categories', but we mostly just
pretend that they're literal mathematical objects sitting in the
syntax. Instead of requiring that the collection of categories
includes all duals, we just allow variance-polarized assumptions to
exist in $\Delta$. The intuitive (and soon to be described formal)
meaning of $\alpha - \C$ is the same as $\alpha + \C^\op$. We provisionally refrain
from talking about an unpolarized $\alpha : \C$, because we want to reserve that to mean
something like $\alpha + (\C \x \C^\op)$. In any event, the variable $\alpha + \C$ means
that what follows depends --- in some sense --- covariantly on an argument $\alpha$ varying
over the category $\C$.

Let the operation $\Delta^\op$ be defined by swapping + and -.
\[
\begin{tabular}{rcl}
  ${(\Delta, \alpha + \C)^\op}$&$=$&$\Delta^\op , \alpha - \C$\\
  ${(\Delta, \alpha - \C)^\op}$&$=$&$\Delta^\op , \alpha + \C$\\
\end{tabular}
\]
We will have some syntax for contexts and types. We'll describe it in somewhat piecemeal fashion, since
many parts of the full definition will have to be mutually recursive with one another, but it's easier to digest
one level at a time. For starters, we have ordinary contexts
\[\begin{tabular}{rccl}
  Contexts&$\Gamma$&$::=$&$\cdot \celse \Gamma, x - A \celse \Gamma, x + A$\\
  Types&$A$&$::=$&$\cdots$\\
\end{tabular}\]
consisting of variables typed at some notion of type that we'll
specify later. There is a polarity distinction that I don't quite know
how best to describe in words at the moment, so I'm hoping the
formalism will speak for itself; in some sense the + is `covariant'
and - is `contravariant' still, but it's not so much the variance of
the variable $x$ itself, as the variance of $A$'s dependency on
everything to its left.

Although we haven't yet said what types are, we will forward-declare
a bunch of properties we need to be true of all types in order to specify
what the semantics of contexts is. For example, there needs to be a notion of
well-formedness of a type in contexts
\[ \Delta ; \Gamma \prov A : \rtype \]
and with this we can define what it means for an (ordinary) context to
be well-formed in a categorical context
\[ \Delta \prov  \Gamma \rctx \]
It is defined by
\[
\erule
{}
{\Delta \prov \cdot \rctx}
\]
\[
\erule
{\Delta \prov \Gamma \rctx \qquad \Delta ; \Gamma \prov A : \rtype}
{\Delta \prov \Gamma, x + A \rctx}
\qquad
\erule
{\Delta \prov \Gamma \rctx \qquad \Delta^\op ; \Gamma^\op \prov A : \rtype}
{\Delta \prov \Gamma, x - A \rctx}
\]
where the operation $\Gamma^\op$ is similarly defined by swapping every $+$ and $-$:
\[
\begin{tabular}{rcl}
  ${(\Gamma, x + A)^\op}$&$=$&$\Gamma^\op , x - A$\\
  ${(\Gamma, x - A)^\op}$&$=$&$\Gamma^\op , x + A$\\
\end{tabular}
\]

An immediate consequence is the fact that the opposite of a context is
valid in the opposite category context:
\begin{lemma}
If $\Delta \prov \Gamma \rctx$ then $\Delta^\op \prov \Gamma^\op \rctx$.
\end{lemma}

\begin{proof}
By induction. Suppose
\[\erule
{\Delta \prov \Gamma \rctx \qquad \Delta ; \Gamma \prov A : \rtype}
{\Delta \prov \Gamma, x + A \rctx}\]
We need to show $\Delta^\op \prov \Gamma^\op, x - A \rctx$. By induction hypothesis,
$\Delta^\op \prov \Gamma^\op \rctx$. So we derive
\[
\erule
{\Delta^\op \prov \Gamma^\op \rctx \qquad \Delta ; \Gamma \prov A : \rtype}
{\Delta^\op \prov \Gamma^\op, x - A \rctx}
\]
In the other case, we have
\[\erule
{\Delta \prov \Gamma \rctx \qquad \Delta^\op ; \Gamma^\op \prov A : \rtype}
{\Delta \prov \Gamma, x - A \rctx}\]
and need to show
$\Delta^\op \prov \Gamma^\op, x + A \rctx$. By induction hypothesis,
$\Delta^\op \prov \Gamma^\op \rctx$. So we derive
\[
\erule
{\Delta^\op \prov \Gamma^\op \rctx \qquad \Delta^\op ; \Gamma^\op \prov A : \rtype}
{\Delta^\op \prov \Gamma^\op, x + A \rctx}
\]
\cqed
\end{proof}
\subsection{Semantics of Types}
Before we say what types we have, we'll say what it means to be a
semantically meaningful type in a given pair of contexts. First, the meaning
of a category context is just the product of all its variables.
We define the category $\sem \Delta$ by saying
\[
\begin{tabular}{rcl}
  $\sem \cdot$&$=$&$\textbf{1}$\\
  $\sem {\Delta, \alpha + \C}$&$=$&$\sem \Delta \x \C$\\
  $\sem {\Delta, \alpha - \C}$&$=$&$\sem \Delta \x \C^\op$\\
\end{tabular}
\]
Observe that
\begin{lemma}
\label{delta.op}
$ \sem {\Delta^\op} = \sem \Delta^\op$
\end{lemma}

Next, we will declare the functions involved in the semantics of contexts and types.

In general we will write $\rtype$ for the ambient metatheory's notion
of type, and use agda-style syntax for dependent products and sums in
the ambient metatheory, i.e $(x : A) \to B$ and $(x : A) \x B$. We may
be somewhat lax about currying and generally how arguments are
written.

Suppose $\Delta \prov \Gamma \rctx$, and $\delta$
is an object in $\sem \Delta$, and
$\phi : \delta \to \epsilon$ is a morphism in $\sem \Delta$. Then we declare
\begin{declbox}
  $\Gamma_\delta : \rtype$.\\
  $\Gamma_\phi : \rtype$.\\
  $\Gamma_\phi^< : \Gamma_\phi \to \Gamma_\delta $\\
  $\Gamma_\phi^> : \Gamma_\phi \to \Gamma_\epsilon $\\
  $A_\delta : \Gamma_\delta \to \rtype$\\
  $A_\phi : (\psi : \Gamma_\phi) \to A_\delta(\Gamma_\phi^< \psi) \to A_\epsilon(\Gamma_\phi^> \psi)$
\end{declbox}

The meaning of a context $\Gamma$ consists of four parts. First, $\Gamma_\delta$ is a type, `the
meaning of $\Gamma$ at object $\delta$'. The remaining three parts
constitute a notion of relational transport. $\Gamma_\phi$ is a
type; the apex of a relation. The two arms are given by the functions
$\Gamma^<_\phi$ of type $\Gamma_\phi \to \Gamma_\delta$, and
$\Gamma^>_\phi$ of type $\Gamma_\phi \to \Gamma_\epsilon$ that project
down to the meaning of the context at the two endpoints.

The meaning of a type consists of two parts. The object part, given a member
of the context's meaning at a certain object, yields a type. The morphism part,
given a member of the apex of the relation of the context's morphism part,
gives transport from the type's meaning at object to the other.

We can now recursively define the semantics of contexts, assuming the
semantics of types is given.
\begin{defnbox}
 $(\cdot)_\delta = \bone$\\
 $(\Gamma, x + A)_\delta = (\gamma : \Gamma_\delta) \x A_\delta(\gamma)$\\
 $(\Gamma, x - A)_\delta = (\gamma : \Gamma_\delta) \x A_\delta(\gamma)$\\
\\
 $(\cdot)_\phi = \bone$\\
 $(\Gamma, x + A)_\phi = (\psi : \Gamma_\phi) \x A_\delta( \Gamma_\phi^< \psi )$\\
 $(\Gamma, x - A)_\phi = (\psi : \Gamma_\phi) \x A_\epsilon( \Gamma_\phi^> \psi )$\\
\\
 $(\cdot)_\phi^< = {!}$\\
 $(\Gamma, x + A)_\phi^< (\psi , a) = (\Gamma_\phi^<\psi, a)$\\
 $(\Gamma, x - A)_\phi^< (\psi , a) = (\Gamma_\phi^<\psi, A_\phi(\psi, a))$\\
\\
 $(\cdot)_\phi^> = {!}$\\
 $(\Gamma, x + A)_\phi^> (\psi , a) = (\Gamma_\phi^>\psi, A_\phi(\psi, a))$\\
 $(\Gamma, x - A)_\phi^> (\psi , a) = (\Gamma_\phi^>\psi, a)$
\end{defnbox}
Let's carefully understand how all of these typecheck. When we say
\[(\Gamma, x + A)_\delta = (\gamma : \Gamma_\delta) \x A_\delta(\gamma)\]
it's unproblematic that $\gamma$ has the right type to be fed to $A_\delta$.
But in
\[(\Gamma, x - A)_\delta = (\gamma : \Gamma_\delta) \x A_\delta(\gamma)\]
we note that we have $\Delta \prov \Gamma \rctx$, but
$\Delta^\op ; \Gamma^\op \prov A : \rtype$. So actually $A_\delta$ first of all
expects $\delta$ to be an object of the category $\sem {\Delta^\op}$,
but thankfully by Lemma~\ref{delta.op} this is the same thing as an object of $\sem \Delta^\op$ and therefore
of $\sem \Delta$. Furthermore $A_\delta$ wants its argument to be an element of $\Gamma^\op_\delta$, but we can,
mutually recursively with the above definition, prove that
\begin{lemma}
$(\Gamma^\op)_\delta = \Gamma_\delta$
\end{lemma}
so it's fine to give it $\gamma$.

\textcolor{red}{ Actually I'm being a little sloppy here and not 100\% sure the best way to treat this.
Maybe two parallel functions, and then prove they're equivariant up to a swap after the fact?}

Moving past that for the time being, we can see that $\Gamma_\phi^<\psi$ is the right type, namely
$\Gamma_\delta$, to go into $A_\delta$, and $\Gamma_\phi^>\psi$ is of type $\Gamma_\epsilon$, appropriate
to go into $A_\epsilon$.

The projection functions are a little more intricate. The type of $(\Gamma, x + A)_\phi^<$ needs
to be is a function from $(\Gamma, x + A)_\phi$ to $(\Gamma, x + A)_\delta$, that is, of type
\[((\psi : \Gamma_\phi) \x A_\delta( \Gamma_\phi^< \psi )) \to (\gamma : \Gamma_\delta) \x A_\delta(\gamma)\]
and we can check that the definition
\[(\Gamma, x + A)_\phi^< (\psi , a) = (\Gamma_\phi^<\psi, a)\]
satisfies this type: the second component out the output pair needs to be $A_\delta(\gamma)$ for $\gamma$
specifically being the first component $\Gamma_\phi^<\psi$, and indeed $a$ has
type $A_\delta(\Gamma_\phi^<\psi)$.

The type of $(\Gamma, x - A)_\phi^<$ needs to be a function from
$(\Gamma, x - A)_\phi$ to $(\Gamma, x - A)_\delta$, that is, of type
\[((\psi : \Gamma_\phi) \x A_\epsilon( \Gamma_\phi^> \psi )) \to (\gamma : \Gamma_\delta) \x A_\delta(\gamma)\]
and so we need to do some coercion to make the second component of the output. The reason that
the definition
\[ (\Gamma, x - A)_\phi^< (\psi , a) = (\Gamma_\phi^<\psi, A_\phi(\psi, a)) \]
works is that we know $\Delta^\op ; \Gamma^\op \prov A : \rtype$, so
while $\phi$ is a morphism $\delta\to \epsilon \in \sem\Delta$, it's
also a morphism $\epsilon \to \delta \in \sem \Delta^\op$. Moreover, we can prove, mutually recursively
with this definition,

\filbreak
\begin{lemma}\ %
  \begin{enumerate}
  \item $(\Gamma^\op)_\phi = \Gamma_\phi$
  \item $(\Gamma^\op)^<_\phi\psi = \Gamma^>_\phi\psi$
  \item $(\Gamma^\op)^>_\phi\psi = \Gamma^<_\phi\psi$
  \end{enumerate}
\end{lemma}
so $A_\phi$'s type is effectively
\[(\psi : \Gamma_\phi) \to A_\epsilon(\Gamma_\phi^> \psi) \to A_\delta(\Gamma_\phi^< \psi) \]
which is just the right thing to make the definition type-check.

That was the hardest case --- the remaining two are relatively easy.
The type that $(\Gamma, x + A)_\phi^>$ needs to be is $(\Gamma, x + A)_\phi \to (\Gamma, x + A)_\epsilon$,
i.e.
\[ ((\psi : \Gamma_\phi) \x A_\delta( \Gamma_\phi^< \psi )) \to ((\gamma : \Gamma_\epsilon) \x A_\epsilon(\gamma)) \]
here we can stare at the definition
\[ (\Gamma, x + A)_\phi^> (\psi , a) = (\Gamma_\phi^>\psi, A_\phi(\psi, a)) \]
and directly see from the fact that transport along $A$ is typed
\[A_\phi : (\psi : \Gamma_\phi) \to A_\delta(\Gamma_\phi^< \psi) \to A_\epsilon(\Gamma_\phi^> \psi)\]
that it works, without any pesky contravariance going on to confuse us.

Finally, the type that $(\Gamma, x - A)_\phi^>$ needs to be is
$(\Gamma, x - A)_\phi \to (\Gamma, x - A)_\epsilon$, i.e.
\[((\psi : \Gamma_\phi) \x A_\epsilon( \Gamma_\phi^> \psi )) \to (\gamma : \Gamma_\epsilon) \x A_\epsilon(\gamma)\]
and we can stare at the definition
\[ (\Gamma, x - A)_\phi^> (\psi , a) = (\Gamma_\phi^>\psi, a) \]
and see that it works without reference to the structure of $A$, just like the first case
$(\Gamma, x + A)_\phi^<$ did. The term $a$ is already at type $A_\epsilon(\Gamma^>_\phi \psi)$ and needs
no transport.

\subsection{Defining Some Types}

Now that I've said what it means to be a type --- or at least the bare
minimum of what's required; I'm probably still missing some
preservation-of-composition lemma declarations --- let's try defining some.

\subsubsection{$\Sigma$ Types}

\[
\erule
{
\Delta; \Gamma \prov A : \rtype \qquad
\Delta; \Gamma, x + A  \prov B : \rtype
}
{\Delta ; \Gamma \prov (x : A) \x B : \rtype}
\]

Observe that the premises of this rule give us all of the following derived functions
to work with:

\[A_\delta : \Gamma_\delta \to \rtype \]
\[B_\delta : (\gamma : \Gamma_\delta) \to A_\delta(\gamma) \to \rtype \]
\[A_\phi : (\psi : \Gamma_\phi) \to A_\delta(\Gamma_\phi^< \psi) \to A_\epsilon(\Gamma_\phi^> \psi)\]
\[B_\phi : (\psi : \Gamma_\phi)(x : A_\delta(\Gamma_\phi^<\psi)) \to B_\delta(\Gamma_\phi^<\psi, x)
\to B_\epsilon(\Gamma_\phi^>\psi, A_\phi(\psi, x))\]

We define the object part of this by
\[((x : A) \x B)_\delta : \Gamma_\delta \to \rtype \]
\[((x : A) \x B)_\delta (\gamma) = (x : A_\delta(\gamma)) \x B_\delta(\gamma, x) \]

and the morphism part needs to be
\[((x:A)\x B)_\phi : (\psi : \Gamma_\phi) \to ((x : A_\delta(\Gamma_\phi^< \psi))
\x B_\delta(\Gamma_\phi^< \psi, x))\]
\[  \to ((x : A_\epsilon(\Gamma_\phi^> \psi)) \x B_\epsilon(\Gamma_\phi^> \psi, x)) \]
and we define it
\[((x:A)\x B)_\phi(\psi, (x, b)) = (A_\phi(\psi, x), B_\phi(\psi, x, b))\]

\vfil\eject
\subsubsection{$\Pi$ Types}

\[
\erule
{
\Delta^\op; \Gamma^\op \prov A : \rtype \qquad
\Delta; \Gamma, x - A  \prov B : \rtype
}
{\Delta ; \Gamma \prov (x : A) \to B : \rtype}
\]

Observe that the premises of this rule give us all of the following derived functions
to work with, for $\phi : \delta \to \epsilon \in \sem \Delta$:

\[A_\delta : \Gamma_\delta \to \rtype \]
\[B_\delta : (\gamma : \Gamma_\delta) \to A_\delta(\gamma) \to \rtype \]
\[A_\phi : (\psi : \Gamma_\phi) \to A_\epsilon(\Gamma_\phi^> \psi) \to A_\delta(\Gamma_\phi^< \psi) \]
\[B_\phi : (\psi : \Gamma_\phi)(x : A_\epsilon(\Gamma_\phi^>\psi)) \to B_\delta(\Gamma_\phi^<\psi, A_\phi(\psi, x))
\to B_\epsilon(\Gamma_\phi^>\psi, x)\]

We define the object part of this by
\[((x : A) \to B)_\delta : \Gamma_\delta \to \rtype \]
\[((x : A) \to B)_\delta (\gamma) = (x : A_\delta(\gamma)) \to B_\delta(\gamma, x) \]

and the morphism part needs to be
\[((x:A)\to B)_\phi : (\psi : \Gamma_\phi) \to ((x : A_\delta(\Gamma_\phi^< \psi))
\to B_\delta(\Gamma_\phi^< \psi, x))\]
\[  \to (x : A_\epsilon(\Gamma_\phi^> \psi)) \to B_\epsilon(\Gamma_\phi^> \psi, x) \]
and we define it
\[((x:A)\x B)_\phi(\psi, f, x) = B_\phi(\psi, x, f (A_\phi(\psi, x)))\]


\end{document}
