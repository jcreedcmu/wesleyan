\documentclass{article}
\usepackage[tmargin=0.15in, bmargin=0.15in]{geometry}
\input{theorem}
\input{prooftree}
\usepackage{relsize}
\usepackage{latexsym}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,cd,decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}
\usepackage{tcolorbox}
\tcbuselibrary{breakable}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}

\def\zed{\emptyset}
\def\lint{{\textstyle\int}}
\def\isopen{\textcolor{orange}{\mathlarger{\mathlarger{\mathlarger{\textbf ?}}}}}
\def\isok{\textcolor{green}{\mathlarger{\mathlarger{\mathlarger{\checkmark}}}}}
\def\isbad{\textcolor{red}{\mathlarger{\mathlarger{\mathlarger{\x}}}}}

\def\mhave{\textcolor{blue}{\hbox{have}}}
\def\mwant{\textcolor{orange}{\hbox{want}}}

\def\chave{\eqno\mhave}
\def\cset{\eqno \textcolor{green}{\hbox{set}}}
\def\cwant{\eqno\mwant}
\def\gol{\sqsubset}
\def\gor{\sqsupset}

\def\sp{\bullet}
\def\ot{\leftarrow}
\def\prequiv{\dashv\vdash}
\def\fdom{{\mathbf{d}f}}
\def\fcod{{\mathbf{e}f}}
\def\fidom{\mathbf{\bar d}f}
\def\ficod{\mathbf{\bar e}f}

\def\thn{\mathrel|}
\def\coe{\mathsf{coe}}
\def\bpush{\mathbf{push}}
\def\bpull{\mathbf{pull}}

\definecolor{blu}{rgb}{0.1,0.5,1}
\definecolor{orng}{rgb}{1,0.5,0.3}

\def\wo{\setminus}
\def\fA{\mathsf{A}}
\def\fC{\mathsf{C}}
\def\fX{\mathsf{X}}
\def\ff{\mathsf{f}}
\def\fm{\mathsf{m}}
\def\rspan{\mathsf{Span}}
% \def\El#1{\mathsf{El}({#1})}
\def\El#1{\ulcorner{#1}\urcorner}
\def\U{\mathsf{U}}
\def\uu{\mathsf{u}}
\def\uni{\U}
\def\mor#1#2{#1 \to \underline{#2}}

\def\ridp{\mathsf{idp}}
\def\ssem#1{\langle\!\langle{#1}\rangle\!\rangle}

\definecolor{lred}{rgb}{0.95,0.8,0.8}
\definecolor{cyan}{rgb}{0.80,0.95,0.95}
\definecolor{lorange}{rgb}{0.95,0.90,0.80}
\definecolor{bluegray}{rgb}{0.6,0.6,0.85}
\definecolor{lgray}{gray}{0.8}
\newtcolorbox{declbox}{colframe=lred,colback=lred,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{thmbox}{colframe=cyan,colback=cyan,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{defnbox}{colframe=lorange,colback=lorange,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{tangentbox}{colframe=lgray,colback=lgray,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}

\input{linear}
\def\rpath#1{[#1]}
\def\rfst{\mathsf{fst}\,}
\def\rsnd{\mathsf{snd}\,}
\def\bunfold{\mathbf{unfold}}
\def\bfold{\mathbf{fold}}
\def\susp#1{\langle {#1} \rangle}
\def\ssusp#1{\langle\!\langle {#1} \rangle\!\rangle}
\def\dto{\mathrel{\dot\to}}
\def\dns{{\downarrow}}
\def\ups{{\uparrow}}
\def\sprov{\Vdash}
\def\signat{{\color{red}\Sigma}}
\def\ep#1{\underline{#1}}
\def\wat{\mathbin{@}}
\def\wwat{\mathbin{\underline\wat}}
\def\cn{{:}}
\def\dv{{\div}}
\def\ww{{\mathsf w}}
\def\base{{\textfrak b}}

\def\N{{\mathbb N}}
\def\Z{{\mathbb Z}}
\def\munit{I}
\def\tt{{\mathsf t}}
\def\ii{{\mathbb I}}
\def\T{\mathbb{T}}
\def\tw{\mathsf{Tw}}
\def\sw#1{^{#1}_{#1}}
\def\TP{\mathbf{TPre}}
\def\pp{\textsf{\textbf p}}
\def\nn{{\mathsf n}}
\def\PP{\textsf{\textbf P}}
\def\NN{\textsf{\textbf N}}
\def\zz{{\mathsf z}}
\def\sem#1{[\![#1]\!]}
\def\usem#1{\lceil\!\!\lceil{#1}\rceil\!\!\rceil}
\def\zem#1{\langle\!\langle#1\rangle\!\rangle}
\def\col#1{{\mathsf{C}}_{#1}}
\def\lax{\mathop\bigcirc}
\def\rjust{\mathsf{just}}
\def\rcvt{\mathsf{cvt}}
\def\rtype{\mathsf{type}}
\def\rdtype{\mathsf{disc}}
\def\rkind{\mathsf{kind}}
\def\rmode{\mathsf{mode}}
\def\rprel{\mathbf{Prel}}
\def\rrfam{\mathbf{Rfam}}
\def\rset{\mathbf{Set}}
\def\rfinset{\mathbf{FinSet}}
\def\rrel{\mathbf{Rel}}
\def\rcat{\mathbf{Cat}}
\def\rfam{\mathbf{Fam}}
\def\binj{\mathbf{inj}}
\def\rid{\mathsf{id}}
\def\rtrue{\mathrel\mathrm{true}}
\def\pbck{\ar[dr, phantom, pos=0, "\lrcorner"]}
\def\bpbck{\ar[ddrr, phantom, pos=0, "\lrcorner"]}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\btwo{\mathbf{2}}
\def\bone{\mathbf{1}}

\newarrow {Equiv} =====
\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\def\mapt{\ar[ddd,mapsto,shorten <=2em, shorten >=2em]}
\def\A{\mathbf{A}}
\def\B{\mathbf{B}}
\def\C{\mathbf{C}}
\def\G{\mathbf{G}}
\def\D{\mathbf{D}}
\def\DD{\mathbb{D}}
\def\E{\mathbf{E}}
\def\M{\mathbf{M}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\ltri{{\lhd}}
\def\rtri{{\rhd}}
\def\tri{\rhd}
\def\ll{{<}}
\def\rr{{>}}
\def\cc{\mathsf{c}}
\def\dd{\mathsf{d}}
\def\o{\circ}
\def\rctx{\,\mathsf{ctx}}
\def\rdctx{\,\mathsf{dctx}}
\def\del{\partial}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\definecolor{fib}{HTML}{ff7f00}
\definecolor{green}{HTML}{007f00}
\definecolor{red}{HTML}{df3f3f}
\definecolor{opfib}{HTML}{007fff}

% For lightening colors I used
% http://trycolors.com/ 6 parts white to 1 part color
\definecolor{opfibl}{HTML}{DBEDFF}
\definecolor{greenl}{HTML}{DBEDDB}
\definecolor{redl}{HTML}{FAE4E4}
%% \def\njudge#1{\fcolorbox{opfib}{white}{#1}}
%% \def\nrule#1{\fcolorbox{white}{opfibl}{#1}}
%% \def\neqn#1{\fcolorbox{white}{redl}{#1}}



%% \def\judge#1{\vskip 2em\noindent \njudge{$#1$}\vskip 0.5em\noindent}
%% \def\rule#1{\vskip 2em \noindent \nrule{$#1$}\vskip 0.5em\noindent}
%% \def\eqn#1{\vskip 2em \noindent \neqn{$#1$}\vskip 0.5em\noindent}
%% \def\prof{\nrightarrow}
%% \def\tensor{\otimes}
%% \def\htensor{\mathrel{\hat\otimes}}
%% \def\lol{\multimap}
%% \def\hlol{\mathrel{\hat\multimap}}
%% \def\wtf{{\color{red}???}}

%% \def\re{\mathbf{E}}
%% \def\sh{\sharp}
%% \def\shp{\mathrel{\sharp}}
%% \def\zero{\texttt{0}}
\def\bd{\mathsf{Bd}}
\def\bdd{\mathsf{Bdd}}
\def\rset{\mathsf{U}}
\begin{document}

\def\
\tikzset{
   commutative diagrams/.cd,
   arrow style=tikz,
   diagrams={>=stealth}}



\section{Relational Higher OTT}
This is an exercise to see how bridges look as substitutable objects.
Let's start with binary relations as a warmup. I'll ignore universe level issues.

First of all, bridges in a type with specified endpoints form a type.

\[A : \rset \qquad a\ a' : A \over \bd_A(a, a') : \rset\]

There is some kind of equality between bridges in the universe and relations.
Assuming definitional equality seems {\em prima facie} the most convenient.

\[\bd_U(A, B) \equiv A \to B \to \rset\]

We expect bridges at function types to do exhibit the expected parametricity behavior.

\[\bd_{A \to B}(f, f') \equiv (a\ a' : A) (p : \bd_{A}(a, a')) \to \bd_{B}(f\ a , f'\ a')\]

Then we ask: how do we deal with $\Pi$? The definition for nondependent functions
cannot be immediately adapted, because we need a heterogeneous bridge.

\[\bd_{(a : A) \to B}(f, f') \equiv (a\ a' : A) (p : \bd_{A}(a, a')) \to \bd_{\color{red}{B a?\ B a'?}}(f\ a , f'\ a')\]

We have a bridge $p$ between $a$ and $a'$, and we want {\em some relation} between $B\ a$ and $B\ a'$ to assert
of $f\ a$ and $f'\ a'$. This seems like it should arise from letting $p$ interact with $B$.
So we define a substitution operation

\[ p : \bd_{A}(a, a') \qquad x : A \prov M : B \over [p/x] M : \bd_{B}([a/x]M , [a'/x]M)\]

so we have in particular
\[ p : \bd_{A}(a, a') \qquad x : A \prov B : \rset \over [p/x] B : \bd_{\rset}([a/x]B , [a'/x]B)\]

which means we can define dependent bridges
\[x : A \prov B : \rset \qquad p : \bd_{A}(a, a') \qquad b : [a/x]B \qquad b' : [a'/x]B \over \bdd^p_{x.B}(b, b') : \rset \]
\[\bdd^p_{x.B}(b, b') \equiv ([p/x]B)\ b\ b' \]

So now we can define bridges in dependent functions like
\[\bd_{(a : A) \to B}(f, f') \equiv (a\ a' : A) (p : \bd_{A}(a, a')) \to \bdd^p_{x.B}(f\ a , f'\ a')\]

Let's investigate some cases of substitution principle. Let's assume we have
\[x : A \prov f : B \to C \qquad x : A \prov M : B \qquad p : \bd_A(a, a')\]
What is $[p/x](f\ M) : \bd_C([a/x](f\ M), [a'/x](f / M))$? Well, we do have already
\[[p/x]f : \bd_{B \to C}([a/x]f, [a'/x]f) \qquad [p/x]M : \bd_{ C}([a/x]M, [a'/x]M)\]
and that first one is really
\[[p/x]f : (b\ b' : B) (q : \bd_B(b, b')) \to \bd_{C}([a/x]f\ b, [a'/x]f\ b') \]
So we need only pick $b = [a/x]M$ and $b' = [a'/x]M$ and we get
\[[p/x]f\ ([a/x]M)\ ([a'/x]M)\ ([p/x]M) : \bd_{C}([a/x]f\ [a/x]M, [a'/x]f\ [a'/x]M)\]
as required. So we define
\[p : \bd_A(a, a') \over [p/x](f\ M) \equiv [p/x]f\ ([a/x]M)\ ([a'/x]M)\ ([p/x]M)\]
Next let's think about lambdas.
\[{x : A,  y :B \prov M : C \over x : A \prov \lambda y . M : B \to C } \]
If we have $p : \bd_A(a, a')$ then we have $y : B \prov [p/x]M : \bd_C([a/x]M, [a'/x]M)$
and our goal is to find a bridge term $N$ such that
\[ x : A \prov N : \bd_{B \to C} (\lambda y . [a/x]M, \lambda y . [a'/x]M)\]
but that goal is the same as
\[ x : A \prov N : (b\ b' : B) (q : \bd_B(b, b')) \to \bd_C([b/y][a/x]M, [b'/y][a'/x]M)\]
If we directly substitute $q$ for $y$, then we're trying to make
\[N\ b\ b'\ q = [q/y][p/x]M : \bd_{\bd_C([a/x]M, [a'/x]M)}([b/y][p/x]M, [b'/y][p/x]M)\]
This seems complicated and there doesn't seem to be an obvious reduction path. The approach
that seems more promising is to allow {\em simultaneous} substitutions, which only
create one layer of $\bd$.

So how does this look for dependently typed lambdas? (Still retaining
nondependency of $x$ in any types) As before,
\[{x : A,  y :B \prov M : C \over x : A \prov \lambda y . M : B \to C } \]
only now we imagine $y$ can occur in $C$. Our goal is now to find an $N$ with
\[ x : A \prov N : (b\ b' : B) (q : \bd_B(b, b')) \to \bdd^q_{y.C}([b/y][a/x]M, [b'/y][a'/x]M)\]
So we're going to need some kind of substitution principle more like
\[
\theta\ \theta' : \Gamma \qquad \phi : \bd_{\Gamma}(\theta, \theta') \qquad \Gamma \prov M : A
\over
\phi M : \bd_{A}(\theta M, \theta' M)
\]
That's if $A$ doesn't depend on $\Gamma$. If it does, I think I need
\[
\theta\ \theta' : \Gamma \qquad \phi : \bd_{\Gamma}(\theta, \theta') \qquad \Gamma \prov M : A
\over
\phi M : \bdd^\phi_{\Gamma.A}(\theta M, \theta' M)
\]
Ok, what are contexts and substitutions?
\[ {\over \cdot \rctx} \qquad {\Gamma \rctx \qquad \Gamma \prov A : \rset \over  \Gamma, x : A \rctx}\]
\[ {\over  \cdot : \cdot} \qquad { \theta : \Gamma \qquad  M : \theta A \over   \theta[M/x] : \Gamma, x : A} \]
Standard stuff. What's a nondependent bridge between two substitutions? It's going to look syntactically like a substitution.
\[ {\over \cdot : \bd_{\cdot}(\cdot, \cdot)} \]
\[ {
 %%  \qquad \qquad  \qquad M_2 :\theta_2 A \qquad
\begin{array}{c@{\qquad}c@{\qquad}c@{\qquad}c}
&\Gamma \prov A : \rset
&M_1 : \theta_1 A
\\
\theta_1\ \theta_2 : \Gamma
&  \phi : \bd_\Gamma(\theta_1, \theta_2)
&M_2 : \theta_2 A
&p : \bdd^\phi_{\Gamma.A}(M_1, M_2)
\end{array}
\over
\phi[p/x] : \bd_{\Gamma, x:A}(\theta_1[M_1/x], \theta_2[M_2/x])
}\]
This depends mututally recursively on dependent bridges. How do we define that?
Its signature is
\[\Gamma \prov A : \rset \qquad \phi : \bd_{\Gamma}(\theta_1, \theta_2) \qquad M_i : \theta_iA  \over \bdd^\phi_{\Gamma.A}(M_1, M_2) : \rset \]

\[\bdd^\phi_{\Gamma.A}(M_1, M_2) \equiv (\phi A)\ M_1\ M_2 \]

For this to work I need to know how to apply substitution bridges. The principle
is
\[\theta_i : \Gamma \qquad  \Gamma \prov M : A \qquad \phi : \bd_\Gamma(\theta_1, \theta_2) \over \phi M : \bdd_{\Gamma.A}^\phi(\theta_1 M, \theta_2 M)\]

This seems close to nonerminatingly recursive. But the version that the definition of $\bdd$ needs is just the special-case of $\rset$. I could even write them syntactically differently as

\[\theta_i : \Gamma \qquad  \Gamma \prov A : \rset \qquad \phi : \bd_\Gamma(\theta_1, \theta_2) \over \phi \bullet A : \theta_1 A \to  \theta_2 A \to \rset\]

\[\theta_i : \Gamma \qquad  \Gamma \prov M : A \qquad \phi : \bd_\Gamma(\theta_1, \theta_2) \over \phi M : (\phi \bullet A)\ (\theta_1 M)\ ( \theta_2 M)\]

And then I can rewrite the cons case of substitution-bridges as
\[ {
 %%  \qquad \qquad  \qquad M_2 :\theta_2 A \qquad
\begin{array}{c@{\qquad}c@{\qquad}c@{\qquad}c}
&\Gamma \prov A : \rset
&M_1 : \theta_1 A
\\
\theta_1\ \theta_2 : \Gamma
&  \phi : \bd_\Gamma(\theta_1, \theta_2)
&M_2 : \theta_2 A
&p : (\phi \bullet A)\ M_1\ M_2
\end{array}
\over
\phi[p/x] : \bd_{\Gamma, x:A}(\theta_1[M_1/x], \theta_2[M_2/x])
}\]

So I must {\em define} the substitution operators $\phi \bullet A$
and $\phi M$.
\section{From Scratch}
What exists? We have the usual terms, contexts, substitutions, typing judgments.
We introduce a notion of simultaneous bridge substitutions, described by a judgment
\[\phi : \bd_\Gamma(\theta_1, \theta_2)\]
Syntactically, $\phi$ look just like substitutions.
There are two substitution principles that apply to these $\phi$:

\[\theta_i : \Gamma \qquad  \Gamma \prov A : \rset \qquad \phi : \bd_\Gamma(\theta_1, \theta_2) \over \phi \bullet A : \theta_1 A \to  \theta_2 A \to \rset\]

\[\theta_i \prov \Gamma \qquad  \Gamma \prov M : A \qquad \phi : \bd_\Gamma(\theta_1, \theta_2) \over \phi M : (\phi \bullet A)\ (\theta_1 M)\ ( \theta_2 M)\]




The judgment $\phi : \bd_\Gamma(\theta_1, \theta_2)$ is defined by
the two rules
\[{\over \cdot : \cdot}\]
\[ {
 %%  \qquad \qquad  \qquad M_2 :\theta_2 A \qquad
\begin{array}{c@{\qquad}c@{\qquad}c@{\qquad}c}
&\Gamma \prov A : \rset
&M_1 : \theta_1 A
\\
\theta_1\ \theta_2 : \Gamma
&  \phi : \bd_\Gamma(\theta_1, \theta_2)
&M_2 : \theta_2 A
&p : (\phi \bullet A)\ M_1\ M_2
\end{array}
\over
\phi[p/x] : \bd_{\Gamma, x:A}(\theta_1[M_1/x], \theta_2[M_2/x])
}\]

\subsection{Abbreviations}
Regular boundaries and refls are defined in terms of empty substitutions:
\[\bd_A(a, a') = \cdot \bullet A\ a\ a' \]
\[\mathsf{refl_M} = \cdot M  \]

\subsection{Variable}
Suppose $\Gamma = \Gamma', x : A, \Gamma''$.
Then $\phi$ will break down as $\phi'[p/x]\phi''$.
Also $\theta_i$ will as $\theta_i'[M_i/x]\theta_i''$.
We'll have $M_i : \theta_i' A$ and
$p : (\phi_1 \bullet A)\ M_1\ M_2$.
The substitution principle says that we should have
\[\phi x : (\phi_1 \bullet A)\ M_1\ M_2\]
So we simply set $\phi x = p$.
\subsection{Universe}
We define
\[(\phi \bullet \rset)\ A\ B = A \to B \to U\]
\subsection{Pi}

\[\Gamma,  b : B \prov C : \rset\over
 \Gamma \prov (b : B) \to C : \rset\]

We aim to define $\phi \bullet (b : B) \to C$,
which is supposed to have type
\[((b : \theta_1 B) \to \theta_1 C) \to ((b : \theta_2 B) \to \theta_2 C) \to \rset\]
So let's define
\[(\phi \bullet (b : B) \to C)\ f_1\ f_2 = \]
\[(b_1 : \theta_1 B) (b_2 : \theta_2 B) (q : (\phi \bullet B)\ b_1\ b_2) \to (\phi[q/b] \bullet C)\ (f_1\ b_1)\ (f_2\ b_2)\]


\subsection{Application}
\[\Gamma \prov f : (b : B) \to C \qquad \Gamma \prov M : B
\over \Gamma \prov f\ M : [M/b]C\]

By i.h. we know
\[\phi f : (\phi \bullet (b : B) \to C)\ (\theta_1 f)\ (\theta_2 f) \]
\[\phi M : (\phi \bullet B)\ (\theta_1 M)\ (\theta_2 M) \]

hence
\[\phi f :  (b_1 : \theta_1 B) (b_2 : \theta_2 B) (q : (\phi \bullet B)\ b_1\ b_2) \to (\phi[q/b] \bullet C)\ (\theta_1 f\ b_1)\ (\theta_2f\ b_2)\]
and
\[\phi f\ (\theta_1 M)\ (\theta_2 M) :(\phi[\phi M/b] \bullet C)\ (\theta_1(f\ M))\ (\theta_2(f\ M))\]
What we need is
\[\phi(f\ M)  : (\phi \bullet [M/b]C)\ (\theta_1(f\ M))\ (\theta_2(f\ M)\]
so assuming the coherence of substitution, we're done. We define
\[\phi (f\ M) = \phi f\ (\theta_1 M)\ (\theta_2 M)\]

\subsection{Lambda}
\[
\Gamma, y : B\prov  M :  C
\over
\Gamma \prov \lambda y . M : (b : B) \to C
\]
What we need is
\[\phi(\lambda y . M) : (\phi \bullet (b:B) \to C)\ (\lambda y .\theta_1 M)\ (\lambda y .\theta_2 M)\]
in other words it should have type
\[(b_1 : \theta_1 B) (b_2 : \theta_2 B) (q : (\phi \bullet B)\ b_1\ b_2) \to (\phi[q/b] \bullet C)\ ([b_1/y]\theta_1 M)\ ([b_2/y]\theta_2 M)\]
From the induction hypothesis, for any $\phi' : \bd_{\Gamma, y : B}(\theta'_1, \theta'_2)$ we have
\[\phi' M : (\phi' \bullet C)\ (\theta_1' M)\ (\theta_2' M)\]
So let's choose in particular (in the environment where $b_1, b_2, q$ have been abstracted)
\[\phi' = \phi[q/b] \qquad \theta_1' = \theta_1 [b_1/y] \qquad \theta_2' = \theta_2[b_2/y]\]
and we're done.
\[\phi(\lambda y . M) = \lambda b_1 b_2 q . (\phi [q/b]) M\]

\subsection{Parametricity}
Suppose we have $m : (X : \rset) \to X \to X$.
Let's just look at the type of
 $\mathsf{refl}_m : \bd_{(X:\rset) \to X \to X}(m, m)$.
The definition of substitution into types at $X$ gives
\[\bd_{(X:\rset) \to X \to X}(m, m) = (\cdot \bullet (X : U) \to X \to X)\ m\ m  \]
\[=(A :  U) (B :  U) (R : A \to  B \to \rset) \to ([R/X] \bullet (X \to X))\ (m\ A)\ (m\ B)\]
\[= (A :  U) (B :  U) (R : A \to  B \to \rset) (a : A) (b :  B) (q : R\ a\ b) \to R\ (m\ A\ a)\ (m\ B\ b)\]

which is the expected free theorem.

\section{Generalizing To Shapes}

Our judgment is now

\[\Delta \prov \phi \tri \theta : \Gamma \]
which presupposes $\Delta \prov \theta:\Gamma$.

$\Delta = (x:2)$ to recover the binary case.

There are again two substitution principles that apply to these $\phi$:

\[  \Gamma \prov A : \rset \qquad \Delta \prov \phi \tri \theta : \Gamma
\qquad \Delta \prov N : \theta A
\over \phi (A; \Delta.N) :  \rset\]

\[  \Gamma \prov M : A \qquad \Delta \prov \phi \tri \theta : \Gamma
\over \phi M : \phi (A;  \Delta. \theta M)\]


The judgment $\Delta \prov \phi \tri \theta : \Gamma$ is defined by
the two rules



\[{\over \Delta \prov \cdot \tri \cdot : \cdot}\]
\[ {
\Gamma \prov A : \rset
\qquad \Delta \prov \phi \tri \theta : \Gamma
\qquad \Delta \prov N : \theta A
\qquad p : \phi(A;\Delta.N)
\over
\Delta \prov (\phi[p/x]) \tri (\theta[N/x]) : \Gamma, x :A
}\]


\subsection{Abbreviations}
Regular boundaries and refls are defined in terms of empty substitutions:
\[\bd_A(\Delta.a) = \cdot (A; \Delta.a) \]
\[\mathsf{refl_M} = \cdot M  \]

\subsection{Type Variable}
We handle the case of
\[  \Gamma \prov \alpha : \rset \qquad \Delta \prov \phi \tri \theta : \Gamma
\qquad \Delta \prov N : \theta \alpha
\over \phi (\alpha; \Delta.N) :  \rset\]
when $\Gamma \prov \alpha : \rset$ is really $\alpha: \rset \in \Gamma', \alpha : \rset, \Gamma''$.
In this case, $\phi = \phi'[p/\alpha]\phi''$ and $\theta = \theta' [B/\alpha] \theta''$.
At the moment we're judging $\phi$ to be well-typed, and we add the variable $x$, things look like
\[ {
 \Delta \prov \phi' \tri \theta' : \Gamma'
\qquad \Delta \prov B :  \rset
\qquad p : \phi'(\rset;\Delta.B)
\over
\Delta \prov (\phi'[p/\alpha]) \tri (\theta'[B/\alpha]) : \Gamma, x :\rset
}\]

So we will have that $p : \phi' (\rset; \Delta. B) = (\Delta \to B) \to \rset $. And notice that we know $\theta\alpha = B$, so $\Delta \prov N : B$.
So we define \[\phi(\alpha; \Delta. N) = p\ (\Delta.N)\]

\subsection{Term Variable}
Suppose $\Gamma = \Gamma', x : A, \Gamma''$.
Then $\phi$ will break down as $\phi'[p/x]\phi''$.
We'll have $p : \phi'(A, \Delta.N)$.
The substitution principle says that we should have
\[\phi x :\phi'(A, \Delta.N)\]
So we simply set $\phi x = p$.
\subsection{Universe}
It's straightforward to give a reasonable meaning to
\[  \Delta \to A\]
For example, if $\Delta = (b : B) (c : C)$ and we have some $A(b, c)$
that is meaningful in that context, then
\[ \Delta \to  A = (b : B) (c : C) \to A(b, c)\]
We then define
\[\phi(\rset, \Delta.A) = ( \Delta\to  A) \to \rset\]
\subsection{Pi}


We aim to define $\phi((b : B) \to C; \Delta.N)$. It should satisfy

\[
\begin{prooftree}
\[\Gamma,  b : B \prov C : \rset
\justifies
 \Gamma \prov (b : B) \to C : \rset\] \qquad \Delta \prov \phi \tri \theta : \Gamma
\qquad \Delta \prov N :  (b : \theta B) \to \theta C
\justifies
\phi ((b : B) \to C; \Delta.N) :  \rset
\end{prooftree}
\]




So let's define
\[\phi((b : B) \to C; \Delta.N) =  \]
\[(\bar b : \Delta \to \theta B)  (q : \phi(B, \Delta.\bar b)) \to (\phi[q/b])(C; \Delta . (N\ \bar b))\]


\subsection{Application}

What we're working with is
\[
\begin{prooftree}
\[
\Gamma \prov f : (b : B) \to C \qquad \Gamma \prov M : B
\justifies
 \Gamma \prov f\ M : [M/b]C
\]
\Delta \prov \phi \tri \theta : \Gamma
\justifies
\phi (f\ M) : \phi ([M/b]C;  \Delta. \theta (f\ M))
\end{prooftree}
\]
and we want to define $\phi (f\ M)$.

By i.h. we know
\[\phi f : \phi((b : B) \to C; \Delta .\theta f)\]
\[\phi M : \phi(B; \Delta.\theta M)\]

hence

\[\phi f : (\bar b : \Delta \to \theta B)  (q : \phi(B, \Delta.\bar b)) \to (\phi[q/b])(C; \Delta . (\theta f\ \bar b))\]
and
\[\phi f\ (\Delta.\theta M) :   (q : \phi(B, \Delta.\theta M)) \to (\phi[q/b])(C; \Delta . (\theta f\ \theta M))\]
and
\[\phi f\ (\Delta.\theta M)\ (\phi M) : (\phi[\phi M/b])(C; \Delta . (\theta f\ \theta M))\]
What we need is
\[\phi (f\ M) : \phi ([M/b]C;  \Delta. \theta (f\ M))\]
so assuming the coherence of substitution, we're done. We define
\[\phi (f\ M) = \phi f\ (\Delta.\theta M)\ (\phi M) \]

\subsection{Lambda}
What we're working with is

\[
\begin{prooftree}
\[
\Gamma, b : B\prov  M :  C
\justifies
 \Gamma \prov \lambda b . M : (b : B) \to C
\]
\qquad
\Delta \prov \phi \tri \theta : \Gamma
\justifies
 \phi (\lambda b . M) : \phi ((b : B) \to C;  \Delta. \lambda b . \theta  M)
\end{prooftree}
\]


What we need expands to
\[(\bar b : \Delta \to \theta B)  (q : \phi(B, \Delta.\bar b)) \to (\phi[q/b])(C; \Delta . (  [\bar b / b]\theta  M))\]
From the induction hypothesis, in the environment where $\bar b$ and $q$ are bound, we can construct



\[
\begin{prooftree}
\Gamma, b : B \prov M : C
\ %
\[
\Gamma \prov B : \rset
\qquad \Delta \prov \phi \tri \theta : \Gamma
\qquad \Delta \prov \bar b : \theta B
\qquad q : \phi(B;\Delta.\bar b)
\justifies
 \Delta \prov (\phi[q/b]) \tri (\theta[\bar b/b]) : \Gamma, b :B
\]
\justifies
(\phi[q/b]) M : (\phi[q/b]) (C;  \Delta. \theta[\bar b / b] M)
\end{prooftree}
\]


So we can define
\[\phi(\lambda b . M) = \lambda \bar b q . (\phi [q/b]) M\]

\subsection{Parametricity}
Suppose we have $m : (X : \rset) \to X \to X$.
Let's look at the type of
 $\mathsf{refl}^\Delta_m : \bd_{(X:\rset) \to X \to X}(\Delta . m)$.
That's equal to
\[\cdot ((X:\rset) \to X \to X; \Delta . m)\]
The definition of substitution at $\Pi$ and $\rset$ lets us expand to
\[(\bar X : \Delta \to  \rset)  (R : (\Delta\to \bar X) \to \rset) \to ([R/X])(X \to X; \Delta . (m\ \bar X))\]
and
\[(\bar X : \Delta \to  \rset)  (R : (\Delta\to \bar X) \to \rset) \]
\[(\bar x : \Delta \to \bar X)  (q : [R/X](X, \Delta.\bar x)) \to ([R/X][q/b])(X; \Delta . (m\ \bar X\ \bar x))\]
and
\[(\bar X : \Delta \to  \rset)  (R : (\Delta\to \bar X) \to \rset) (\bar x : \Delta \to \bar X)\]
\[  \to  R\ (\Delta.\bar x) \to  R\ (\Delta . (m\ \bar X\ \bar x))\]

which is the expected free theorem.

\section{Single-Variable Shapes}

Bridge Judgment
\[\phi : \bd_\Gamma(s.\theta)\]
Bridge Substitution principle
\[
\Gamma \prov M : A \qquad \phi : \bd_\Gamma(s.\theta)
\over
\phi M : \phi A\ (\lambda s . \theta M)
\]
\subsection{Bridge Substitution}
Universe case:
\[\phi \rset \equiv \lambda A . ((s : S) \to A\ s) \to \rset \]
Variable case:
\[ [p/x] \in \phi\over \phi x \equiv p\]
Pi case:
\[\phi((b : B) \to C)  =  \]
\[\lambda f . (\bar b : S \to \theta B)  (q : \phi B\  \bar b) \to (\phi[q/b])(C)\ (\lambda s. (f\ s) (\bar b\ s))\]

\subsection{Bridge Formation}
\[{\over \cdot : \bd_\Gamma(s.\cdot)}\]
\[ {
\Gamma \prov A : \rset
\qquad \phi : \bd_\Gamma(s.\theta)
\qquad s:S \prov N : \theta A
\qquad p : \phi A\ (\lambda s.N)
\over
\phi[p/x] : \bd_{\Gamma, x : A}(s.\theta[N/x])
}\]

\end{document}
