\documentclass{article}
\usepackage[tmargin=0.15in, bmargin=0.15in]{geometry}
\input{theorem}
\input{prooftree}
\usepackage{relsize}
\usepackage{latexsym}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,cd,decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}
\usepackage{tcolorbox}
\tcbuselibrary{breakable}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}


\def\dec{\mathsf{\downarrow}}
\def\enc{\mathsf{\uparrow}}
\def\I{\mathbb{I}}
\def\bget{\mathop\mathbf{get}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\zed{\emptyset}
\def\lint{{\textstyle\int}}
\def\isopen{\textcolor{orange}{\mathlarger{\mathlarger{\mathlarger{\textbf ?}}}}}
\def\isok{\textcolor{green}{\mathlarger{\mathlarger{\mathlarger{\checkmark}}}}}
\def\isbad{\textcolor{red}{\mathlarger{\mathlarger{\mathlarger{\x}}}}}

\def\mhave{\textcolor{blue}{\hbox{have}}}
\def\mwant{\textcolor{orange}{\hbox{want}}}

\def\chave{\eqno\mhave}
\def\cset{\eqno \textcolor{green}{\hbox{set}}}
\def\cwant{\eqno\mwant}
\def\gol{\sqsubset}
\def\gor{\sqsupset}

\def\sp{\bullet}
\def\ot{\leftarrow}
\def\prequiv{\dashv\vdash}
\def\fdom{{\mathbf{d}f}}
\def\fcod{{\mathbf{e}f}}
\def\fidom{\mathbf{\bar d}f}
\def\ficod{\mathbf{\bar e}f}

\def\thn{\mathrel|}
\def\coe{\mathsf{coe}}
\def\bpush{\mathbf{push}}
\def\bpull{\mathbf{pull}}

\definecolor{blu}{rgb}{0.1,0.5,1}
\definecolor{orng}{rgb}{1,0.5,0.3}

\def\wo{\setminus}
\def\fA{\mathsf{A}}
\def\fC{\mathsf{C}}
\def\fX{\mathsf{X}}
\def\ff{\mathsf{f}}
\def\fm{\mathsf{m}}
\def\rspan{\mathsf{Span}}
% \def\El#1{\mathsf{El}({#1})}
\def\El#1{\ulcorner{#1}\urcorner}
\def\U{\mathsf{U}}
\def\uu{\mathsf{u}}
\def\uni{\U}
\def\mor#1#2{#1 \to \underline{#2}}

\def\ridp{\mathsf{idp}}
\def\ssem#1{\langle\!\langle{#1}\rangle\!\rangle}

\definecolor{lred}{rgb}{0.95,0.8,0.8}
\definecolor{cyan}{rgb}{0.80,0.95,0.95}
\definecolor{lorange}{rgb}{0.95,0.90,0.80}
\definecolor{bluegray}{rgb}{0.6,0.6,0.85}
\definecolor{lgray}{gray}{0.8}
\newtcolorbox{declbox}{colframe=lred,colback=lred,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{thmbox}{colframe=cyan,colback=cyan,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{defnbox}{colframe=lorange,colback=lorange,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{tangentbox}{colframe=lgray,colback=lgray,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}

\input{linear}
\def\rpath#1{[#1]}
\def\rfst{\mathsf{fst}\,}
\def\rsnd{\mathsf{snd}\,}
\def\bunfold{\mathbf{unfold}}
\def\bfold{\mathbf{fold}}
\def\susp#1{\langle {#1} \rangle}
\def\ssusp#1{\langle\!\langle {#1} \rangle\!\rangle}
\def\dto{\mathrel{\dot\to}}
\def\dns{{\downarrow}}
\def\ups{{\uparrow}}
\def\sprov{\Vdash}
\def\signat{{\color{red}\Sigma}}
\def\ep#1{\underline{#1}}
\def\wat{\mathbin{@}}
\def\wwat{\mathbin{\underline\wat}}
\def\cn{{:}}
\def\dv{{\div}}
\def\ww{{\mathsf w}}
\def\base{{\textfrak b}}

\def\N{{\mathbb N}}
\def\Z{{\mathbb Z}}
\def\munit{I}
\def\tt{{\mathsf t}}
\def\ii{{\mathbb I}}
\def\T{\mathbb{T}}
\def\tw{\mathsf{Tw}}
\def\sw#1{^{#1}_{#1}}
\def\TP{\mathbf{TPre}}
\def\pp{\textsf{\textbf p}}
\def\nn{{\mathsf n}}
\def\PP{\textsf{\textbf P}}
\def\NN{\textsf{\textbf N}}
\def\zz{{\mathsf z}}
\def\sem#1{[\![#1]\!]}
\def\usem#1{\lceil\!\!\lceil{#1}\rceil\!\!\rceil}
\def\zem#1{\langle\!\langle#1\rangle\!\rangle}
\def\col#1{{\mathsf{C}}_{#1}}
\def\lax{\mathop\bigcirc}
\def\rjust{\mathsf{just}}
\def\rcvt{\mathsf{cvt}}
\def\rtype{\mathsf{type}}
\def\rdtype{\mathsf{disc}}
\def\rkind{\mathsf{kind}}
\def\rmode{\mathsf{mode}}
\def\rprel{\mathbf{Prel}}
\def\rrfam{\mathbf{Rfam}}
\def\rset{\mathbf{Set}}
\def\rfinset{\mathbf{FinSet}}
\def\rrel{\mathbf{Rel}}
\def\rcat{\mathbf{Cat}}
\def\rfam{\mathbf{Fam}}
\def\binj{\mathbf{inj}}
\def\rid{\mathsf{id}}
\def\rtrue{\mathrel\mathrm{true}}
\def\pbck{\ar[dr, phantom, pos=0, "\lrcorner"]}
\def\bpbck{\ar[ddrr, phantom, pos=0, "\lrcorner"]}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\btwo{\mathbf{2}}
\def\bone{\mathbf{1}}

\newarrow {Equiv} =====
\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\def\mapt{\ar[ddd,mapsto,shorten <=2em, shorten >=2em]}
\def\A{\mathbf{A}}
\def\B{\mathbf{B}}
\def\C{\mathbf{C}}
\def\G{\mathbf{G}}
\def\D{\mathbf{D}}
\def\DD{\mathbb{D}}
\def\E{\mathbf{E}}
\def\M{\mathbf{M}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\ltri{{\lhd}}
\def\rtri{{\rhd}}
\def\tri{\rhd}
\def\ll{{<}}
\def\rr{{>}}
\def\cc{\mathsf{c}}
\def\dd{\mathsf{d}}
\def\o{\circ}
\def\rctx{\,\mathsf{ctx}}
\def\rdctx{\,\mathsf{dctx}}
\def\del{\partial}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\definecolor{fib}{HTML}{ff7f00}
\definecolor{green}{HTML}{007f00}
\definecolor{red}{HTML}{df3f3f}
\definecolor{opfib}{HTML}{007fff}

% For lightening colors I used
% http://trycolors.com/ 6 parts white to 1 part color
\definecolor{opfibl}{HTML}{DBEDFF}
\definecolor{greenl}{HTML}{DBEDDB}
\definecolor{redl}{HTML}{FAE4E4}
%% \def\njudge#1{\fcolorbox{opfib}{white}{#1}}
%% \def\nrule#1{\fcolorbox{white}{opfibl}{#1}}
%% \def\neqn#1{\fcolorbox{white}{redl}{#1}}



%% \def\judge#1{\vskip 2em\noindent \njudge{$#1$}\vskip 0.5em\noindent}
%% \def\rule#1{\vskip 2em \noindent \nrule{$#1$}\vskip 0.5em\noindent}
%% \def\eqn#1{\vskip 2em \noindent \neqn{$#1$}\vskip 0.5em\noindent}
%% \def\prof{\nrightarrow}
%% \def\tensor{\otimes}
%% \def\htensor{\mathrel{\hat\otimes}}
%% \def\lol{\multimap}
%% \def\hlol{\mathrel{\hat\multimap}}
%% \def\wtf{{\color{red}???}}

%% \def\re{\mathbf{E}}
%% \def\sh{\sharp}
%% \def\shp{\mathrel{\sharp}}
%% \def\zero{\texttt{0}}
\def\bd{\mathsf{Bd}}
\def\bdd{\mathsf{Bdd}}
\def\rset{\mathsf{U}}
\begin{document}

\def\
\tikzset{
   commutative diagrams/.cd,
   arrow style=tikz,
   diagrams={>=stealth}}



\section{Relational Higher OTT}
This is an exercise to see how bridges look as substitutable objects.
Let's start with binary relations as a warmup. I'll ignore universe level issues.

First of all, bridges in a type with specified endpoints form a type.

\[A : \rset \qquad a\ a' : A \over \bd_A(a, a') : \rset\]

There is some kind of equality between bridges in the universe and relations.
Assuming definitional equality seems {\em prima facie} the most convenient.

\[\bd_\rset(A, B) \equiv A \to B \to \rset\]

We expect bridges at function types to do exhibit the expected parametricity behavior.

\[\bd_{A \to B}(f, f') \equiv (a\ a' : A) (p : \bd_{A}(a, a')) \to \bd_{B}(f\ a , f'\ a')\]

Then we ask: how do we deal with $\Pi$? The definition for nondependent functions
cannot be immediately adapted, because we need a heterogeneous bridge.

\[\bd_{(a : A) \to B}(f, f') \equiv (a\ a' : A) (p : \bd_{A}(a, a')) \to \bd_{\color{red}{B a?\ B a'?}}(f\ a , f'\ a')\]

We have a bridge $p$ between $a$ and $a'$, and we want {\em some relation} between $B\ a$ and $B\ a'$ to assert
of $f\ a$ and $f'\ a'$. This seems like it should arise from letting $p$ interact with $B$.
So we define a substitution operation

\[ p : \bd_{A}(a, a') \qquad x : A \prov M : B \over [p/x] M : \bd_{B}([a/x]M , [a'/x]M)\]

so we have in particular
\[ p : \bd_{A}(a, a') \qquad x : A \prov B : \rset \over [p/x] B : \bd_{\rset}([a/x]B , [a'/x]B)\]

which means we can define dependent bridges
\[x : A \prov B : \rset \qquad p : \bd_{A}(a, a') \qquad b : [a/x]B \qquad b' : [a'/x]B \over \bdd^p_{x.B}(b, b') : \rset \]
\[\bdd^p_{x.B}(b, b') \equiv ([p/x]B)\ b\ b' \]

So now we can define bridges in dependent functions like
\[\bd_{(a : A) \to B}(f, f') \equiv (a\ a' : A) (p : \bd_{A}(a, a')) \to \bdd^p_{x.B}(f\ a , f'\ a')\]

Let's investigate some cases of substitution principle. Let's assume we have
\[x : A \prov f : B \to C \qquad x : A \prov M : B \qquad p : \bd_A(a, a')\]
What is $[p/x](f\ M) : \bd_C([a/x](f\ M), [a'/x](f / M))$? Well, we do have already
\[[p/x]f : \bd_{B \to C}([a/x]f, [a'/x]f) \qquad [p/x]M : \bd_{ C}([a/x]M, [a'/x]M)\]
and that first one is really
\[[p/x]f : (b\ b' : B) (q : \bd_B(b, b')) \to \bd_{C}([a/x]f\ b, [a'/x]f\ b') \]
So we need only pick $b = [a/x]M$ and $b' = [a'/x]M$ and we get
\[[p/x]f\ ([a/x]M)\ ([a'/x]M)\ ([p/x]M) : \bd_{C}([a/x]f\ [a/x]M, [a'/x]f\ [a'/x]M)\]
as required. So we define
\[p : \bd_A(a, a') \over [p/x](f\ M) \equiv [p/x]f\ ([a/x]M)\ ([a'/x]M)\ ([p/x]M)\]
Next let's think about lambdas.
\[{x : A,  y :B \prov M : C \over x : A \prov \lambda y . M : B \to C } \]
If we have $p : \bd_A(a, a')$ then we have $y : B \prov [p/x]M : \bd_C([a/x]M, [a'/x]M)$
and our goal is to find a bridge term $N$ such that
\[ x : A \prov N : \bd_{B \to C} (\lambda y . [a/x]M, \lambda y . [a'/x]M)\]
but that goal is the same as
\[ x : A \prov N : (b\ b' : B) (q : \bd_B(b, b')) \to \bd_C([b/y][a/x]M, [b'/y][a'/x]M)\]
If we directly substitute $q$ for $y$, then we're trying to make
\[N\ b\ b'\ q = [q/y][p/x]M : \bd_{\bd_C([a/x]M, [a'/x]M)}([b/y][p/x]M, [b'/y][p/x]M)\]
This seems complicated and there doesn't seem to be an obvious reduction path. The approach
that seems more promising is to allow {\em simultaneous} substitutions, which only
create one layer of $\bd$.

So how does this look for dependently typed lambdas? (Still retaining
nondependency of $x$ in any types) As before,
\[{x : A,  y :B \prov M : C \over x : A \prov \lambda y . M : B \to C } \]
only now we imagine $y$ can occur in $C$. Our goal is now to find an $N$ with
\[ x : A \prov N : (b\ b' : B) (q : \bd_B(b, b')) \to \bdd^q_{y.C}([b/y][a/x]M, [b'/y][a'/x]M)\]
So we're going to need some kind of substitution principle more like
\[
\theta\ \theta' : \Gamma \qquad \phi : \bd_{\Gamma}(\theta, \theta') \qquad \Gamma \prov M : A
\over
\phi M : \bd_{A}(\theta M, \theta' M)
\]
That's if $A$ doesn't depend on $\Gamma$. If it does, I think I need
\[
\theta\ \theta' : \Gamma \qquad \phi : \bd_{\Gamma}(\theta, \theta') \qquad \Gamma \prov M : A
\over
\phi M : \bdd^\phi_{\Gamma.A}(\theta M, \theta' M)
\]
Ok, what are contexts and substitutions?
\[ {\over \cdot \rctx} \qquad {\Gamma \rctx \qquad \Gamma \prov A : \rset \over  \Gamma, x : A \rctx}\]
\[ {\over  \cdot : \cdot} \qquad { \theta : \Gamma \qquad  M : \theta A \over   \theta[M/x] : \Gamma, x : A} \]
Standard stuff. What's a nondependent bridge between two substitutions? It's going to look syntactically like a substitution.
\[ {\over \cdot : \bd_{\cdot}(\cdot, \cdot)} \]
\[ {
 %%  \qquad \qquad  \qquad M_2 :\theta_2 A \qquad
\begin{array}{c@{\qquad}c@{\qquad}c@{\qquad}c}
&\Gamma \prov A : \rset
&M_1 : \theta_1 A
\\
\theta_1\ \theta_2 : \Gamma
&  \phi : \bd_\Gamma(\theta_1, \theta_2)
&M_2 : \theta_2 A
&p : \bdd^\phi_{\Gamma.A}(M_1, M_2)
\end{array}
\over
\phi[p/x] : \bd_{\Gamma, x:A}(\theta_1[M_1/x], \theta_2[M_2/x])
}\]
This depends mututally recursively on dependent bridges. How do we define that?
Its signature is
\[\Gamma \prov A : \rset \qquad \phi : \bd_{\Gamma}(\theta_1, \theta_2) \qquad M_i : \theta_iA  \over \bdd^\phi_{\Gamma.A}(M_1, M_2) : \rset \]

\[\bdd^\phi_{\Gamma.A}(M_1, M_2) \equiv (\phi A)\ M_1\ M_2 \]

For this to work I need to know how to apply substitution bridges. The principle
is
\[\theta_i : \Gamma \qquad  \Gamma \prov M : A \qquad \phi : \bd_\Gamma(\theta_1, \theta_2) \over \phi M : \bdd_{\Gamma.A}^\phi(\theta_1 M, \theta_2 M)\]

This seems close to nonerminatingly recursive. But the version that the definition of $\bdd$ needs is just the special-case of $\rset$. I could even write them syntactically differently as

\[\theta_i : \Gamma \qquad  \Gamma \prov A : \rset \qquad \phi : \bd_\Gamma(\theta_1, \theta_2) \over \phi \bullet A : \theta_1 A \to  \theta_2 A \to \rset\]

\[\theta_i : \Gamma \qquad  \Gamma \prov M : A \qquad \phi : \bd_\Gamma(\theta_1, \theta_2) \over \phi M : (\phi \bullet A)\ (\theta_1 M)\ ( \theta_2 M)\]

And then I can rewrite the cons case of substitution-bridges as
\[ {
 %%  \qquad \qquad  \qquad M_2 :\theta_2 A \qquad
\begin{array}{c@{\qquad}c@{\qquad}c@{\qquad}c}
&\Gamma \prov A : \rset
&M_1 : \theta_1 A
\\
\theta_1\ \theta_2 : \Gamma
&  \phi : \bd_\Gamma(\theta_1, \theta_2)
&M_2 : \theta_2 A
&p : (\phi \bullet A)\ M_1\ M_2
\end{array}
\over
\phi[p/x] : \bd_{\Gamma, x:A}(\theta_1[M_1/x], \theta_2[M_2/x])
}\]

So I must {\em define} the substitution operators $\phi \bullet A$
and $\phi M$.
\section{From Scratch}
What exists? We have the usual terms, contexts, substitutions, typing judgments.
We introduce a notion of simultaneous bridge substitutions, described by a judgment
\[\phi : \bd_\Gamma(\theta_1, \theta_2)\]
Syntactically, $\phi$ look just like substitutions.
There are two substitution principles that apply to these $\phi$:

\[\theta_i : \Gamma \qquad  \Gamma \prov A : \rset \qquad \phi : \bd_\Gamma(\theta_1, \theta_2) \over \phi \bullet A : \theta_1 A \to  \theta_2 A \to \rset\]

\[\theta_i \prov \Gamma \qquad  \Gamma \prov M : A \qquad \phi : \bd_\Gamma(\theta_1, \theta_2) \over \phi M : (\phi \bullet A)\ (\theta_1 M)\ ( \theta_2 M)\]




The judgment $\phi : \bd_\Gamma(\theta_1, \theta_2)$ is defined by
the two rules
\[{\over \cdot : \cdot}\]
\[ {
 %%  \qquad \qquad  \qquad M_2 :\theta_2 A \qquad
\begin{array}{c@{\qquad}c@{\qquad}c@{\qquad}c}
&\Gamma \prov A : \rset
&M_1 : \theta_1 A
\\
\theta_1\ \theta_2 : \Gamma
&  \phi : \bd_\Gamma(\theta_1, \theta_2)
&M_2 : \theta_2 A
&p : (\phi \bullet A)\ M_1\ M_2
\end{array}
\over
\phi[p/x] : \bd_{\Gamma, x:A}(\theta_1[M_1/x], \theta_2[M_2/x])
}\]

\subsection{Abbreviations}
Regular boundaries and refls are defined in terms of empty substitutions:
\[\bd_A(a, a') = \cdot \bullet A\ a\ a' \]
\[\mathsf{refl_M} = \cdot M  \]

\subsection{Variable}
Suppose $\Gamma = \Gamma', x : A, \Gamma''$.
Then $\phi$ will break down as $\phi'[p/x]\phi''$.
Also $\theta_i$ will as $\theta_i'[M_i/x]\theta_i''$.
We'll have $M_i : \theta_i' A$ and
$p : (\phi_1 \bullet A)\ M_1\ M_2$.
The substitution principle says that we should have
\[\phi x : (\phi_1 \bullet A)\ M_1\ M_2\]
So we simply set $\phi x = p$.
\subsection{Universe}
We define
\[(\phi \bullet \rset)\ A\ B = A \to B \to \rset\]
\subsection{Pi}

\[\Gamma,  b : B \prov C : \rset\over
 \Gamma \prov (b : B) \to C : \rset\]

We aim to define $\phi \bullet (b : B) \to C$,
which is supposed to have type
\[((b : \theta_1 B) \to \theta_1 C) \to ((b : \theta_2 B) \to \theta_2 C) \to \rset\]
So let's define
\[(\phi \bullet (b : B) \to C)\ f_1\ f_2 = \]
\[(b_1 : \theta_1 B) (b_2 : \theta_2 B) (q : (\phi \bullet B)\ b_1\ b_2) \to (\phi[q/b] \bullet C)\ (f_1\ b_1)\ (f_2\ b_2)\]


\subsection{Application}
\[\Gamma \prov f : (b : B) \to C \qquad \Gamma \prov M : B
\over \Gamma \prov f\ M : [M/b]C\]

By i.h. we know
\[\phi f : (\phi \bullet (b : B) \to C)\ (\theta_1 f)\ (\theta_2 f) \]
\[\phi M : (\phi \bullet B)\ (\theta_1 M)\ (\theta_2 M) \]

hence
\[\phi f :  (b_1 : \theta_1 B) (b_2 : \theta_2 B) (q : (\phi \bullet B)\ b_1\ b_2) \to (\phi[q/b] \bullet C)\ (\theta_1 f\ b_1)\ (\theta_2f\ b_2)\]
and
\[\phi f\ (\theta_1 M)\ (\theta_2 M) :(\phi[\phi M/b] \bullet C)\ (\theta_1(f\ M))\ (\theta_2(f\ M))\]
What we need is
\[\phi(f\ M)  : (\phi \bullet [M/b]C)\ (\theta_1(f\ M))\ (\theta_2(f\ M)\]
so assuming the coherence of substitution, we're done. We define
\[\phi (f\ M) = \phi f\ (\theta_1 M)\ (\theta_2 M)\]

\subsection{Lambda}
\[
\Gamma, y : B\prov  M :  C
\over
\Gamma \prov \lambda y . M : (b : B) \to C
\]
What we need is
\[\phi(\lambda y . M) : (\phi \bullet (b:B) \to C)\ (\lambda y .\theta_1 M)\ (\lambda y .\theta_2 M)\]
in other words it should have type
\[(b_1 : \theta_1 B) (b_2 : \theta_2 B) (q : (\phi \bullet B)\ b_1\ b_2) \to (\phi[q/b] \bullet C)\ ([b_1/y]\theta_1 M)\ ([b_2/y]\theta_2 M)\]
From the induction hypothesis, for any $\phi' : \bd_{\Gamma, y : B}(\theta'_1, \theta'_2)$ we have
\[\phi' M : (\phi' \bullet C)\ (\theta_1' M)\ (\theta_2' M)\]
So let's choose in particular (in the environment where $b_1, b_2, q$ have been abstracted)
\[\phi' = \phi[q/b] \qquad \theta_1' = \theta_1 [b_1/y] \qquad \theta_2' = \theta_2[b_2/y]\]
and we're done.
\[\phi(\lambda y . M) = \lambda b_1 b_2 q . (\phi [q/b]) M\]

\subsection{Parametricity}
Suppose we have $m : (X : \rset) \to X \to X$.
Let's just look at the type of
 $\mathsf{refl}_m : \bd_{(X:\rset) \to X \to X}(m, m)$.
The definition of substitution into types at $X$ gives
\[\bd_{(X:\rset) \to X \to X}(m, m) = (\cdot \bullet (X : \rset) \to X \to X)\ m\ m  \]
\[=(A :  \rset) (B :  \rset) (R : A \to  B \to \rset) \to ([R/X] \bullet (X \to X))\ (m\ A)\ (m\ B)\]
\[= (A :  \rset) (B :  \rset) (R : A \to  B \to \rset) (a : A) (b :  B) (q : R\ a\ b) \to R\ (m\ A\ a)\ (m\ B\ b)\]

which is the expected free theorem.

\section{Generalizing To Shapes}

Our judgment is now

\[\Delta \prov \phi \tri \theta : \Gamma \]
which presupposes $\Delta \prov \theta:\Gamma$.

$\Delta = (x:2)$ to recover the binary case.

There are again two substitution principles that apply to these $\phi$:

\[  \Gamma \prov A : \rset \qquad \Delta \prov \phi \tri \theta : \Gamma
\qquad \Delta \prov N : \theta A
\over \phi (A; \Delta.N) :  \rset\]

\[  \Gamma \prov M : A \qquad \Delta \prov \phi \tri \theta : \Gamma
\over \phi M : \phi (A;  \Delta. \theta M)\]


The judgment $\Delta \prov \phi \tri \theta : \Gamma$ is defined by
the two rules



\[{\over \Delta \prov \cdot \tri \cdot : \cdot}\]
\[ {
\Gamma \prov A : \rset
\qquad \Delta \prov \phi \tri \theta : \Gamma
\qquad \Delta \prov N : \theta A
\qquad p : \phi(A;\Delta.N)
\over
\Delta \prov (\phi[p/x]) \tri (\theta[N/x]) : \Gamma, x :A
}\]


\subsection{Abbreviations}
Regular boundaries and refls are defined in terms of empty substitutions:
\[\bd_A(\Delta.a) = \cdot (A; \Delta.a) \]
\[\mathsf{refl_M} = \cdot M  \]

\subsection{Type Variable}
We handle the case of
\[  \Gamma \prov \alpha : \rset \qquad \Delta \prov \phi \tri \theta : \Gamma
\qquad \Delta \prov N : \theta \alpha
\over \phi (\alpha; \Delta.N) :  \rset\]
when $\Gamma \prov \alpha : \rset$ is really $\alpha: \rset \in \Gamma', \alpha : \rset, \Gamma''$.
In this case, $\phi = \phi'[p/\alpha]\phi''$ and $\theta = \theta' [B/\alpha] \theta''$.
At the moment we're judging $\phi$ to be well-typed, and we add the variable $x$, things look like
\[ {
 \Delta \prov \phi' \tri \theta' : \Gamma'
\qquad \Delta \prov B :  \rset
\qquad p : \phi'(\rset;\Delta.B)
\over
\Delta \prov (\phi'[p/\alpha]) \tri (\theta'[B/\alpha]) : \Gamma, x :\rset
}\]

So we will have that $p : \phi' (\rset; \Delta. B) = (\Delta \to B) \to \rset $. And notice that we know $\theta\alpha = B$, so $\Delta \prov N : B$.
So we define \[\phi(\alpha; \Delta. N) = p\ (\Delta.N)\]

\subsection{Term Variable}
Suppose $\Gamma = \Gamma', x : A, \Gamma''$.
Then $\phi$ will break down as $\phi'[p/x]\phi''$.
We'll have $p : \phi'(A, \Delta.N)$.
The substitution principle says that we should have
\[\phi x :\phi'(A, \Delta.N)\]
So we simply set $\phi x = p$.
\subsection{Universe}
It's straightforward to give a reasonable meaning to
\[  \Delta \to A\]
For example, if $\Delta = (b : B) (c : C)$ and we have some $A(b, c)$
that is meaningful in that context, then
\[ \Delta \to  A = (b : B) (c : C) \to A(b, c)\]
We then define
\[\phi(\rset, \Delta.A) = ( \Delta\to  A) \to \rset\]
\subsection{Pi}


We aim to define $\phi((b : B) \to C; \Delta.N)$. It should satisfy

\[
\begin{prooftree}
\[\Gamma,  b : B \prov C : \rset
\justifies
 \Gamma \prov (b : B) \to C : \rset\] \qquad \Delta \prov \phi \tri \theta : \Gamma
\qquad \Delta \prov N :  (b : \theta B) \to \theta C
\justifies
\phi ((b : B) \to C; \Delta.N) :  \rset
\end{prooftree}
\]




So let's define
\[\phi((b : B) \to C; \Delta.N) =  \]
\[(\bar b : \Delta \to \theta B)  (q : \phi(B, \Delta.\bar b)) \to (\phi[q/b])(C; \Delta . (N\ \bar b))\]


\subsection{Application}

What we're working with is
\[
\begin{prooftree}
\[
\Gamma \prov f : (b : B) \to C \qquad \Gamma \prov M : B
\justifies
 \Gamma \prov f\ M : [M/b]C
\]
\Delta \prov \phi \tri \theta : \Gamma
\justifies
\phi (f\ M) : \phi ([M/b]C;  \Delta. \theta (f\ M))
\end{prooftree}
\]
and we want to define $\phi (f\ M)$.

By i.h. we know
\[\phi f : \phi((b : B) \to C; \Delta .\theta f)\]
\[\phi M : \phi(B; \Delta.\theta M)\]

hence

\[\phi f : (\bar b : \Delta \to \theta B)  (q : \phi(B, \Delta.\bar b)) \to (\phi[q/b])(C; \Delta . (\theta f\ \bar b))\]
and
\[\phi f\ (\Delta.\theta M) :   (q : \phi(B, \Delta.\theta M)) \to (\phi[q/b])(C; \Delta . (\theta f\ \theta M))\]
and
\[\phi f\ (\Delta.\theta M)\ (\phi M) : (\phi[\phi M/b])(C; \Delta . (\theta f\ \theta M))\]
What we need is
\[\phi (f\ M) : \phi ([M/b]C;  \Delta. \theta (f\ M))\]
so assuming the coherence of substitution, we're done. We define
\[\phi (f\ M) = \phi f\ (\Delta.\theta M)\ (\phi M) \]

\subsection{Lambda}
What we're working with is

\[
\begin{prooftree}
\[
\Gamma, b : B\prov  M :  C
\justifies
 \Gamma \prov \lambda b . M : (b : B) \to C
\]
\qquad
\Delta \prov \phi \tri \theta : \Gamma
\justifies
 \phi (\lambda b . M) : \phi ((b : B) \to C;  \Delta. \lambda b . \theta  M)
\end{prooftree}
\]


What we need expands to
\[(\bar b : \Delta \to \theta B)  (q : \phi(B, \Delta.\bar b)) \to (\phi[q/b])(C; \Delta . (  [\bar b / b]\theta  M))\]
From the induction hypothesis, in the environment where $\bar b$ and $q$ are bound, we can construct



\[
\begin{prooftree}
\Gamma, b : B \prov M : C
\ %
\[
\Gamma \prov B : \rset
\qquad \Delta \prov \phi \tri \theta : \Gamma
\qquad \Delta \prov \bar b : \theta B
\qquad q : \phi(B;\Delta.\bar b)
\justifies
 \Delta \prov (\phi[q/b]) \tri (\theta[\bar b/b]) : \Gamma, b :B
\]
\justifies
(\phi[q/b]) M : (\phi[q/b]) (C;  \Delta. \theta[\bar b / b] M)
\end{prooftree}
\]


So we can define
\[\phi(\lambda b . M) = \lambda \bar b q . (\phi [q/b]) M\]

\subsection{Parametricity}
Suppose we have $m : (X : \rset) \to X \to X$.
Let's look at the type of
 $\mathsf{refl}^\Delta_m : \bd_{(X:\rset) \to X \to X}(\Delta . m)$.
That's equal to
\[\cdot ((X:\rset) \to X \to X; \Delta . m)\]
The definition of substitution at $\Pi$ and $\rset$ lets us expand to
\[(\bar X : \Delta \to  \rset)  (R : (\Delta\to \bar X) \to \rset) \to ([R/X])(X \to X; \Delta . (m\ \bar X))\]
and
\[(\bar X : \Delta \to  \rset)  (R : (\Delta\to \bar X) \to \rset) \]
\[(\bar x : \Delta \to \bar X)  (q : [R/X](X, \Delta.\bar x)) \to ([R/X][q/b])(X; \Delta . (m\ \bar X\ \bar x))\]
and
\[(\bar X : \Delta \to  \rset)  (R : (\Delta\to \bar X) \to \rset) (\bar x : \Delta \to \bar X)\]
\[  \to  R\ (\Delta.\bar x) \to  R\ (\Delta . (m\ \bar X\ \bar x))\]

which is the expected free theorem.

\section{Single-Variable Shapes}

Bridge Judgment
\[\phi : \bd_\Gamma(s.\theta)\]
Bridge Substitution principle
\[
\Gamma \prov M : A \qquad \phi : \bd_\Gamma(s.\theta)
\over
\phi M : \phi A\ (\lambda s . \theta M)
\]
\subsection{Bridge Substitution}
Universe case:
\[\phi \rset \equiv \lambda A . ((s : S) \to A\ s) \to \rset \]
Variable case:
\[ [p/x] \in \phi\over \phi x \equiv p\]
Pi case:
\[\phi((b : B) \to C)  =  \]
\[\lambda f . (\bar b : S \to \theta B)  (q : \phi B\  \bar b) \to (\phi[q/b])(C)\ (\lambda s. (f\ s) (\bar b\ s))\]

\subsection{Bridge Formation}
\[{\over \cdot : \bd_\Gamma(s.\cdot)}\]
\[ {
\Gamma \prov A : \rset
\qquad \phi : \bd_\Gamma(s.\theta)
\qquad s:S \prov N : \theta A
\qquad p : \phi A\ (\lambda s.N)
\over
\phi[p/x] : \bd_{\Gamma, x : A}(s.\theta[N/x])
}\]

\section{Completely Different Thought}
Is there any sense in the idea
\[\bd_A(a, a') \equiv (C : A \to \rset) \to C\ a \to C\ a' \to \rset\]
? Probably not, there's way too many such pseudobridges. Could one imagine
separating out the true ones?
\[\mathsf{refl}_A : \bd_A(a, a) = (C : A \to \rset) \to C\ a \to C\ a \to \rset\]
\[\mathsf{refl}_A(a)\ C\ c_1\ c_2 = \bd_{Ca}(c_1, c_2)?\]
Can I do $\mathsf{ap}$? Suppose I have a function $f : A \to B$.
Can I get sensibly from
\[\beta : (D : A \to \rset) \to D\ a \to D\ a' \to \rset\]
to
\[(C : B \to \rset) \to C\ (f\ a) \to C\ (f\ a') \to \rset\]
?
I have $(C : B \to \rset) (c : f\ a) (c' : f\ a')$.
Indeed, $\beta\  (\lambda a . C\ (f\ a))\ c\ c' : \rset$.

Is there any relationship for function types?

\[\bd_{A \to B}(f, f') \equiv (C : (A \to B) \to \rset) \to C\ f \to C\ f' \to \rset\]
\[\bd_{A}(a, a') \equiv (C_1 : A \to \rset) \to C_1\ a \to C\ a' \to \rset\]
\[\bd_{B}(b, b') \equiv (C_2 : B \to \rset) \to C_2\ b \to C_2\ b' \to \rset\]
Ideally we'd have
\[\bd_{A \to B}(f, f') \equiv (a\ a' : A) \to \bd_{A}(a, a') \to \bd_{B}(f\ a, f\ a')\]
That would mean \[\tau_1 \equiv \tau_2\] for
\[\tau_1 = ((C : (A \to B) \to \rset) \to C\ f \to C\ f' \to \rset) \]
\[ \tau_2 = (a\ a' : A) (r : (C_1 : A \to \rset) \to C_1\ a \to C\ a' \to \rset) \]
\[ (C_2 : B \to \rset) (c : C_2\ (f\ a)) (c' :  C_2\ (f'\ a')) \to \rset\]
Suppose I have $f : \tau_1$. Then
\[\lambda a a' r C_2 c c' . ?\]
No, I don't know what to do.
\subsection{Preservation}
Does this definition of $\bd$ preserve anything interesting?
\[p : \bd_A(a, a') \qquad x:A \prov C : \rset \over \mathsf{ap}_{x.C}(p) : [a/x]C \to [a'/x]C \to \rset\]

\[q : \bd_B(b, b') \qquad y:B \prov M : A \over \mathsf{ap}_{y.M}(q) : \bd_A([b/y]A, [b'/y]A)\]

\section{More General Shapes}

I think it was a mistake to think of contexts $\Delta$ as representing single bridge-formation substitutions.
I should be thinking in terms of multiple consecutive substitutions. Or: I can easily picture shapes that are not cubes.
For example, tetrahedra. What hapenns with these?

I'll write substitution as $[\phi]^S$ for a shape $S$. I have some operation of $\partial S$ that gives
the boundary of a shape. I think the empty substitution at $\rset$ looks like
\[[]^S\rset_i = \lambda \beta :(\partial S \to \rset_i).((x : \partial S) \to \beta\ x) \to \rset_i\]
\[[]^S\rset_i : []^S \rset_{i+1}(\lambda \_ . \rset_i)\]

The empty substitution gives me bridges indexed over their boundary, but I think the `function space'
$\partial S \to \dash$ is actually talking about bridges with arbitrary boundary. So could I say something like

\[S \to  \rset_i =  (\beta :(\partial S \to \rset_i)) \x ((x : \partial S) \to \beta\ x) \to \rset_i\]
\[S \to \rset_i :  \rset_{i+1}\]

For example

\[\I_2 \to \rset_0 = (\beta: 2 \to \rset_0) \x ((x : 2) \to \beta\ x) \to \rset_0\]

And composition with the inclusion $\partial S \to S$ should be the same as projecting out the first component $\beta$.

Hm, I really should be writing $\to$ as $\lol$.
\[S \lol  \rset_i =  (\beta :(\partial S \lol \rset_i)) \x ((x : \partial S) \lol \beta\ x) \to \rset_i\]
\[S \lol \rset_i :  \rset_{i+1}\]

That dependent $\lol$ scares me a bit.
The boundary of the tensor product of shapes should be a pushout, I think:
\[
\begin{tikzcd}
\partial (S_1 \otimes S_2)\ar[from=r]\pbck\ar[from=d]&\partial S_1 \times S_2\ar[from=d,"{\partial S_1 \x \iota}",swap]\\
 S_1 \times \partial S_2 \ar[from=r,"{\iota \x \partial S_2}"]& \partial S_1 \times \partial S_2
%%  \ar[d,      "F"{name=F1,swap}, shift right, bend right=10]
%%  \ar[from=d, "U"{name=U1,swap}, shift right, bend right=10]
%%  \ar[r, "\Delta"]&[2em]
%% \D'
%%  \ar[d,      "F'"{name=F2,swap}, shift right, bend right=10]
%%  \ar[from=d, "U'"{name=U2,swap}, shift right, bend right=10]
%% \\[2em]
%% \C  \ar[r, "\Gamma" swap] &\C'
%% \ar[from=F1,to=U1,phantom,"\dashv"]
%% \ar[from=F2,to=U2,phantom,"\dashv"]
\end{tikzcd}
\]

For example,
\[\partial(\I \otimes \I) = (\I \x 2) +_{2\x2} (2 \x \I)\]
\subsection{Reinventing Substitutions}
Ok, so I still expect substitutions to arise again when I treat $\lambda$. Let's try to guess the syntax.
The well-formed substitution judgment probably looks something like like
\[\phi : (S \prov  \theta : \Gamma) \]
The substitution principle might look like
\[
\Gamma \prov M : A \qquad \phi : (S \prov  \theta : \Gamma)
\over
\phi M : \phi A\ [ s . \theta M]
\]

Hm, this is making me want to first carefully invent the notion of substitution for the 2-case just to make sure I can
coherently talk about bridges without boundary.
\subsection{2-bridges without boundary}
The well-formed bridge substitution  judgment looks like
\[\phi : [\cdot]\Gamma \]
We claim substitution and endpoint principles
\[
\Gamma \prov M : A \qquad \phi : [\cdot]\Gamma
\over
[\phi] M : [\phi] A
\]
\[ \phi : [\cdot]\Gamma \qquad t \in \{0, 1\}  \over \phi^t : \Gamma \]
\[ \phi : [\cdot]\Gamma \qquad \Gamma \prov A : \rset \qquad p : [\phi] A \qquad t \in \{0, 1\}  \over p^t : \phi^t A \]
and substitution formation works like
\[ {
\phi : [\cdot]\Gamma
\qquad \Gamma \prov A : \rset
\qquad p : [\phi] A
\over
 (\phi[p/x]) : [\cdot](\Gamma, x : A)
}\]
We have some coherences
\[ ([\phi] M)^t \equiv \phi^t M \]
\[(\phi[p/x])^t \equiv (\phi^t)[p^t/x] \]
The universe: (I don't care about $\phi$ anywhere here)
I can't seem to {\em set}
\[[\_]\rset_i \equiv (A_0\ A_1: \rset_i) \x A_0 \to A_1 \to \rset_i\]
because then I won't have
\[[\_]\rset_i  : [\_]\rset_{i+1}\]
I think this is the phenomenon Mike Shulman mentioned in one of his talks.
But I can require
\[\dec : [\_]\rset_i \to (A_0\ A_1: \rset_i) \x A_0 \to A_1 \to \rset_i\]
\[\enc : ((A_0\ A_1: \rset_i) \x A_0 \to A_1 \to \rset_i) \to [\_]\rset_i  \]
\[\dec \o \enc \equiv \mathsf{id}\]
Then since I've made a new intro form for $[\_]\rset_i$ I need to say
\[(\enc\langle A_0, A_1, R\rangle)^t \equiv A_t \]
which entails as a corollary that
\[(\dec R) . A_t \equiv R^t \]
\subsection{Can I Define $\lambda$}
The real question I'm worried about is: can I define substitution across a lambda
without needing to introduce a notion of substitution that pins down boundaries
up to definitional equality. I guess I have to define substitution across $\Pi$ first.
\subsubsection{Pi}
I'm working with
\[
\begin{prooftree}
\[
\Gamma, b : B \prov C : \rset
\justifies
\Gamma \prov ((b : B) \to C) : \rset
\]
\justifies
\Gamma \prov [\phi]((b : B) \to C) : [\_]\rset
\end{prooftree}
\]
Induction hypothesis tells me
\[
\phi : [\cdot]\Gamma
\qquad b' : [\phi] B
\over [\phi][b'/b] C : [\_]\rset \]
So I want to set like
\[[\phi]((b : B) \to C) \equiv (b' : [\phi]B) \to [\phi][b'/b] C\]
But this seems potentially to contain too many functions! I want
to have the property that
\[(f : [\phi]((b : B) \to C)) (b' : [\phi]B) \to f^t \ b^t \equiv (f\ b)^t\]
Maybe this is somehow ok? And we can never construct badly shaped functions?
\subsubsection{Lambda}
We're working with
\[
\begin{prooftree}
\[
\Gamma, b : B \prov M : C
\justifies
\Gamma, (\lambda b . M) :  (b : B) \to C
\]
\justifies
\Gamma \prov [\phi](\lambda b . M) :  [\phi]((b : B) \to C)
\end{prooftree}
\]
Induction hypothesis gives us
\[
\phi : [\cdot]\Gamma
\qquad b' : [\phi] B
\over [\phi][b'/b] M :  [\phi][b'/b]C\]
So I can type
\[
\begin{prooftree}
\[
\justifies
\]
  b' :[\phi]B \prov  [\phi][b'/b] M :  [\phi][b'/b] C
\justifies
\lambda  b' . [\phi][b'/b] M : (b' : [\phi]B) \to [\phi][b'/b] C
\end{prooftree}
\]

So maybe we can just set
\[[\phi](\lambda b .M) \equiv \lambda  b' . [\phi][b'/b] M \]
\[(\lambda b' . M)^t \equiv \lambda b' . (M^t)\]

\subsection{Back to General Shapes}
The well-formed bridge substitution  judgment looks like
\[\Delta \prov \phi : \Gamma \]
but $\Delta$ is not an ordinary context. Rather, it is a `shape'. For example
$\Delta$ can be two points, or a line, or a cube, or a tetrahedron.
We have well-formed `substitutions' between $\Delta$ `contexts'
$\Delta' \prov \zeta : \Delta$. There is an operation
of taking boundaries $\partial \Delta$ of shapes $\Delta$.
There is an inclusion substitution $\partial\Delta \prov \iota : \Delta$.
I could write the single vertex as the empty context $\cdot$
and the line is maybe $\bf 2$, so that
For shapes that have vertices I expect degeneracy substitutions like
\[ \cdot \prov [i_0/\ell] : (\ell : {\bf 2})\]
but really this is a special case of the inclusion
\[ t : 2 \prov \iota : (\ell : {\bf 2})\]
because $2 \equiv \partial {\bf 2}$.

We claim substitution principles
\[
 \Delta \prov \phi : \Gamma \qquad \Gamma \prov M : A
\over
\Delta \prov [\phi] M : [\phi] A
\]
\[ \Delta' \prov \zeta : \Delta \qquad \Delta \prov \phi : \Gamma  \over \Delta' \prov [\zeta]\phi : \Gamma \]
\[\Delta' \prov \zeta : \Delta \qquad  \Delta \prov B : [\_]\rset \qquad \Delta \prov p : B
 \over\Delta' \prov  [\zeta]p : [\zeta]B \]
Then substitution formation works like
\[ {
\Delta \prov \phi : \Gamma
\qquad \Gamma \prov A : \rset
\qquad \Delta \prov p : [\phi] A
\over
 \Delta \prov (\phi[p/x]) : (\Gamma, x : A)
}\]
We expect some coherences
\[[\zeta](\phi[p/x]) \equiv ([\zeta]\phi)[[\zeta]p/x] \]
\[[\zeta]([\phi]A) \equiv [\zeta[\phi]]A\]
the latter which means we get a derived principle

\[\Delta' \prov \zeta : \Delta \qquad   \Delta \prov \phi : \Gamma \qquad \Gamma \prov A : \rset \qquad \Delta \prov p : [\phi]A
 \over\Delta' \prov  [\zeta]p : [[\zeta]\phi ]A \]

\subsection{The Universe}
\[\Delta \prov [\_]\rset_i : [\_]\rset_{i+1}\]
I'm going to write $[\phi]$ as $[\_]^\Delta$ here to emphasize I know what $\Delta$ is.
I'll write $\approx$ for the relevant $\enc/\dec$ retract.
\[[\_]^\Delta\rset_i \approx (\beta: \dec ([\_]^{\partial \Delta} \rset_i)) \x (x : \beta) \to \rset_i\]

I need to set up a function type abstracting over $\Delta$s.
\[
{
\Delta \prov A : [\_]\rset_i
\over
\cdot \prov \Delta \to A : \rset_i
}
\qquad
{
\Delta \prov M :  A
\over
\cdot \prov \lambda \Delta. M : \Delta \to A
}
\qquad
{
\cdot \prov M : \Delta \to A \qquad \Delta' \prov \zeta : \Delta
\over
\Delta' \prov M\ \zeta : [\zeta]A
}
\]
\[(\lambda \Delta.M)\ \zeta \equiv [\zeta]M\]

An explicit elim form for $[\_]^\Delta\rset_i$ is

\[\Delta \prov A : [\_]\rset_i
\qquad
\cdot \prov M : \partial \Delta \to [\iota]A
\over \cdot \prov A\star M : \rset_i\]

$M$ is the argument to the second component of the dependent pair. The first component is
given by applying the inclusion substitution $\partial \Delta \prov \iota : \Delta$.
For the intro form,

\[\partial \Delta \prov B : [\_]\rset_i
\qquad
\cdot \prov C : (\partial \Delta \to B) \to \rset_i
\over
\Delta \prov \langle B,  C \rangle :  [\_]\rset_i\]
The $\beta$ laws are
\[[\iota]\langle B, C \rangle \equiv B\]
\[\langle B, C \rangle \star M \equiv C\ M\]

Actually, I think I need an intro form for the intro form!
\[\begin{array}{c@{\quad}c}
\partial \Delta \prov B : [\_]\rset_i&\cdot \prov C : (\partial \Delta \to B) \to \rset_i
\\
\partial \Delta \prov b : B & \cdot \prov c :  C\ \lambda \Delta . b
\end{array}
\over
\Delta \prov  \langle b, c \rangle :  \langle B,  C \rangle\]
\[[\iota]\langle b, c\rangle \equiv b\]

\[\Delta \prov e : A
\over
\cdot \prov \bget \Delta. e : A \star ([\iota] e)
\]

\[\bget \langle b, c\rangle \equiv c\]
\subsection{Substitutions}
Perhaps all other substitutions are boring. This is a strong claim
and needs to be checked.
\subsection{Free Theorem}
We assume we have $\prov M : (X : \rset) \to X \to X$. We suppose we have
the shape $\bf 2$ with $\partial {\bf 2} = 2$, and
 \[(\cdot \prov i_0 : 2),  (\cdot \prov i_1 : 2)\]
hence
 \[(\cdot \prov i_0 \o \iota : {\bf 2}),  (\cdot \prov i_1 \o \iota : {\bf 2})\]
Then
\[t : {\bf 2} \prov [\cdot] M : (X : [\_]\rset) \to X \to X \]
Now we can use the introduction form for $[\_]\rset$.
Suppose we have a relation $R : A \to B \to \rset$ in mind.
\[i:2 \prov \langle A | B\rangle(i) : [\_]\rset
\qquad
\cdot \prov \lambda f . R\ (f\ i_0)\ (f\ i_1) : ( (i:2) \to  \langle A | B\rangle(i)) \to \rset
\over
t : {\bf 2} \prov \langle \langle A | B\rangle,  \lambda f . R\ (f\ i_0)\ (f\ i_1) \rangle :  [\_]\rset\]
and thus if we let $X_0 = \langle \langle A | B\rangle,  \lambda f . R\ (f\ i_0)\ (f\ i_1) \rangle$
we find
\[
t : {\bf 2} \prov [\cdot]^{\bf 2}M\ X_0 : X_0 \to X_0
\]
Now I want to get into $X_0$ somehow. Suppose I have an element $a :A$ and $b : B$ and $r : R\ a\ b$.
Then I think
\[ t:{\bf 2} \prov \langle \langle a | b\rangle,  r \rangle : X_0 \]
Hence if we define
\[q = M\ X_0\  \langle \langle a | b\rangle,  r \rangle\]
then
\[ t:{\bf 2} \prov q : X_0 \]
and now we can extract
\[\cdot \prov \bget t.q : X_0 \star ([\iota] q)\]
And let's start computing $X_0 \star ([\iota] q)$. It's
\[( \lambda f . R\ (f\ i_0)\ (f\ i_1) )([\iota]q)\]
\[= R\ ([\iota]q\ i_0)\ ([\iota]q\ i_1) \]
\[= R\ (M\ A\ a)\ (M\ B\ b) \]
as required.

Maybe I need to have as a general principle that all substitutions into $\Delta$ must
factor through $\partial \Delta \prov \iota : \Delta$. That will make
substitutions on $\langle B, C\rangle$ unconditionally well-defined.

\subsection{Displayed Types}

Suppose I have the record type $B = \{A : \rset, a : A\}$ and I want to compute from
it the binary displayed type
\[B^d : B \to B  \to \rset\]
\[B^d\ \langle A_1, a_1\rangle\ \langle A_2, a_2\rangle = \{A^d : A_1 \to A_2 \to \rset, a^d : A^d\ a_1\ a_2\}\]


I'm pretty sure the thing I want is $\bget((t : {\bf 1}).B)$
but that doesn't reduce!

I guess I need to be able to reduce $\star$ and $\bget$ for types that aren't intro forms at $\rset$.

\[\Delta \prov e : A
\over
\cdot \prov \bget \Delta.e : A \star ([\iota] e)
\]

\[\Delta \prov A : [\_]\rset_i
\qquad
\cdot \prov M : \partial \Delta \to [\iota]A
\over \cdot \prov A\star M : \rset_i\]


\[\Delta \prov ((a : A) \x B) : \rset
\over
\cdot \prov \bget \Delta.((a : A) \x B) : \rset \star ([\iota] ((a : A) \x B))
\]

\[\Delta \prov A : [\_]\rset_i
\qquad
\cdot \prov M : \partial \Delta \to [\iota]A
\over \cdot \prov A\star M : \rset_i\]

Let's think of the 2-case.

\[t:{\bf 2} \prov \Sigma (a : A) . B : \rset\]
\[ \prov \bget ((t:{\bf 2}).\Sigma (a : A) . B) : \rset  \star ([\iota] ((a : A) \x B))\]

Somehow I think
\[\rset  \star ([\iota] ((a : A) \x B)) \approx (A : \rset) (B : \rset) \x A \to B \to \rset\]

\section{Stepping Back}
The central mysteries for me right now have to do with the nature of $\rset$.
Let's drop the weakening substitution notation from the syntax.
The main thing I think I believe is that if $A$ names a type in the context
of some shape, i.e. $\Delta \prov A : \rset_i$, then
$A$ can be described in terms of
\begin{itemize}
\item its boundary $\partial \Delta \prov [\iota]A : \rset_i$.
\item its content, which is something notionally of the type $(\partial \Delta \to [\iota]A) \to  \rset_i$.
\end{itemize}
To avoid questions of double-boundaries being zero, I'm thinking that perhaps it's the responsibility
of a shape $\Delta$ to explain, up to definitional equality, what the above types look like.
Informally, I'm going to rewrite
\def\dapt#1#2{#1[\![#2]\!]}
\def\dap#1#2{#1\{#2\}}
\begin{itemize}
\item  $\partial\Delta \to \rset_i$ as $\dapt \Delta {\rset_i}$.
\item  $\partial\Delta \to [\iota]A$ as $\dap \Delta A$.
\end{itemize}




\[
{\Delta \,\mathsf{shape} \qquad  \Delta \prov A : \rset_i
\over
\cdot \prov \dap \Delta A : \rset_i}
\qquad
{\Delta \,\mathsf{shape} \qquad  \Delta \prov M : A
\over
\cdot \prov \lambda \Delta . M :  \dap \Delta A }
\]



For example, if $\Delta = {(t : 2)}$ and $t :  2 \prov A : \rset_i $, we say
\begin{itemize}
\item $\dap {\Delta}{A} \equiv [t_0]A \x [t_1]A$
\end{itemize}

Hence to give $\Delta \prov A : \rset_i$ should be approximately the same as giving
\begin{itemize}
\item its boundary $\partial \Delta \prov [\iota] A : \rset_i$.
\item its content, $\cdot \prov  \lambda M . A \star M  : \dap{\partial\Delta}{[\iota] A} \to \rset_i$.
\end{itemize}

Intro:
\[\color{gray}\partial \Delta \prov B : \rset_i
\qquad
\cdot \prov C : \dap{\partial \Delta}{ B} \to \rset_i
\over
\Delta \prov \langle B,  C \rangle :  \rset_i\]
Elim:
\[\Delta \prov A : \rset_i
\qquad
\cdot \prov M : \dap {\partial\Delta}{[\iota] A}
\over \cdot \prov A\star M : \rset_i\]
$\beta$:
\[\color{gray}[\iota]\langle B, C \rangle \equiv B\]
\[\color{gray}\langle B, C \rangle \star M \equiv C\ M\]

Intro:
\[\color{gray}\begin{array}{c@{\quad}c}
\partial \Delta \prov B : \rset_i&\cdot \prov C : \dap{\partial \Delta} B \to \rset_i
\\
\partial \Delta \prov b : B & \cdot \prov c :  C\ \lambda \Delta . b
\end{array}
\over
\Delta \prov  \langle b, c \rangle :  \langle B,  C \rangle\]


\[
\partial \Delta \prov b : [\iota]A \qquad \cdot \prov c :  A\star \lambda \Delta . b
\over
\Delta \prov  \langle b, c \rangle :  A\]


\[[\iota]\langle b, c\rangle \equiv b\]

\[\Delta \prov e : A
\over
\cdot \prov \bget \Delta. e : A \star ([\iota] e)
\]

\[\bget \langle b, c\rangle \equiv c\]
\subsection{Maybe A Different Idea}
I'm starting to think I might not need extra descriptions of types $\langle B, C\rangle  $ at all?
\[\Delta \prov A : \rset_i
\qquad
\partial\Delta \prov M : {[\iota] A}
\over \cdot \prov A\star \partial\Delta . M : \rset_i\]

\[
\partial \Delta \prov M : [\iota]A \qquad \cdot \prov N :  A\star \partial \Delta . M
\over
\Delta \prov  \langle \partial \Delta . M, N \rangle :  A\]

\[\Delta \prov e : A
\over
\cdot \prov \bget  \Delta. e : A \star (\partial \Delta . [\iota] e)
\]
$\beta$:
\[\langle \partial\Delta.[\iota]e , \bget \Delta .e\rangle \equiv e\]
$\eta$:
\[\bget \Delta. \langle \partial\Delta . M, N \rangle \equiv N \]
\subsection{Identity Free Theorem}
We're given $A\ B : \rset$ and $R : A \to B \to \rset$ and $f : (X : \rset) \to X \to X$
and $a : A$ and $b : B$.
Assume
\[t : 2 \prov A : \rset_i \qquad \cdot \prov x_0 : [t_0/t]A \qquad \prov x_1 : [t_1/t]A
\over
t : 2 \prov \langle x_0 | x_1 \rangle : A\]
\[t : {\bf 2} \prov f : (X : \rset_0) \to X \to X\]

We first need to get into $\rset_0$.
\[
\partial \Delta \prov \langle A | B\rangle : \rset_0 \qquad \cdot \prov N :  \rset_0\star \partial \Delta .  \langle A | B\rangle
\over
\Delta \prov  \langle \partial \Delta . \langle A | B\rangle, N \rangle :  \rset_0\]
Ok, now we need to make $\rset_0\star \partial \Delta .  \langle A | B\rangle$.
Oh no, the only way I know how to get into that is $\Delta \prov e : \rset_0$!
That's going around in circles.

I'm afraid of going down the road of letting $\star$ be a defined operation because
that smells like where I started, recursively defining bridge types at a boundary.
But let's take a guess that
\[\rset_i \star (\partial\Delta.A) \equiv \dap{\partial\Delta}{A} \to \rset_i\]
And then we can have
\[ \lambda f . R\ (f\ t_0)\ (f\ t_1) : \rset_0\star \partial \Delta .  \langle A | B\rangle\]
and let's define
\[X' = \Delta \prov \langle\partial\Delta.\langle A|B\rangle, \lambda f . R\ (f\ t_0)\ (f\ t_1)\rangle : \rset_0\]
Now how do I get a term of type $X'$ at $\Delta$?
\[
\partial \Delta \prov M : [\iota]X' \qquad \cdot \prov N :  X'\star \partial \Delta . M
\over
\Delta \prov  \langle \partial \Delta . M, N \rangle :  X'\]
Here I may need to bring back my other $\beta$ and $\eta$ principles that
\[\langle \partial \Delta . B, C \rangle[\iota] \equiv B\]
\[\langle B, C \rangle \star M \equiv C\ M\]
to reduce my goal to
\[
\partial \Delta \prov M : \partial\Delta.\langle A|B\rangle \qquad \cdot \prov N : R\ ([t_0/t]M)\ ([t_1/t]M)
\over
\Delta \prov  \langle \partial \Delta . M, N \rangle :  X'\]
but now I can definitely say
\[
\partial \Delta \prov \langle a|b\rangle : \partial\Delta.\langle A|B\rangle \qquad \cdot \prov r : R\ a\ b
\over
\Delta \prov x' =  \langle \partial \Delta . \langle a|b \rangle, r \rangle :  X'\]
and so
\[\Delta \prov M\ X'\ x' : X'\]
\[ \prov \bget (\partial\Delta . M\ X'\ x') : X' \star (\partial \Delta.[\iota](M\ X'\ x'))\]
\[ \prov \bget (\partial\Delta . M\ X'\ x') : R\ (M\ A\ a)\ (M\ B\ b)\]
\subsection{Displayed Sets}
Suppose I consider
\[P :\rset_1\]
\[P = \Sigma (A : \rset_0) . A\]
I want to derive the binary displayed version of this,
\[P^d : P \to P \to \rset_1\]
\[P^d\  \langle A_1, a_1 \rangle\  \langle A_2, a_2 \rangle  = \Sigma(A^d : A_1 \to A_2 \to  \rset_0). A^d\ a_1\ a_2 \]
I claim
\[ P^d \cong \bget((t : {\bf 2}). P)\]
Let's consider the typing first
\[\Delta \prov P : \rset_1
\over
\cdot \prov \bget \Delta. P : \rset_1 \star (\partial\Delta . [\iota] P) \equiv \dap{\partial \Delta}{[\iota]P} \to \rset_1
\]
If I have $A\ B : \rset_0$ and $R : A \to B \to \rset_0$ and $a : A$ and $b : B$ and $r : R\ a\ b$, then
I should be able to get into this type by pairing.
\[X' = \Delta \prov \langle\partial\Delta.\langle A|B\rangle, \lambda f . R\ (f\ t_0)\ (f\ t_1)\rangle : \rset_0\]
\[
\partial \Delta \prov \langle a|b\rangle : \partial\Delta.\langle A|B\rangle \qquad \cdot \prov r : R\ a\ b
\over
\Delta \prov x' =  \langle \partial \Delta . \langle a|b \rangle, r \rangle :  X'\]
Then
\[\Delta \prov \langle X', x' \rangle : \Sigma(A : \rset_0).A\]
i.e.
\[\Delta \prov \langle X', x' \rangle : P\]
\[ \prov \bget \Delta . (\langle X', x' \rangle) : (\Sigma(A : \rset_0).A) \star [\iota]\langle X', x' \rangle\]
That isn't quite what I wanted.
\subsection{Back a Step}

No, I am very confused and want to go back to explicit notation for constructing types.
\def\ll{\langle\!\langle}
\def\rr{\rangle\!\rangle}
Let it be distinct notation even. Here's how I make $\Delta$-types out of relations:

\[\partial \Delta \prov B : \rset_i
\qquad
\cdot \prov C : \dap{\partial \Delta}{ B} \to \rset_i
\over
\Delta \prov \ll \partial\Delta . B,  C \rr :  \rset_i\]

Here's how I make types with specified boundaries:
\[\Delta \prov A : \rset_i
\qquad
\partial\Delta \prov M : [\iota] A
\over \cdot \prov A\star \partial \Delta . M : \rset_i\]


Here's how I inhabit a $\Delta$-type:
\[\begin{array}{c@{\quad}c}
\Delta \prov D : \rset_i\\
\partial \Delta \prov d_1 : [\iota]D & \cdot \prov d_2 :  D \star (\partial \Delta . d_1)
\end{array}
\over
\Delta \prov  \langle \partial \Delta .d_1, d_2 \rangle :  D\]

Here's how I get out of a $\Delta$-type:
\[\Delta \prov e : A
\over
\cdot \prov \bget  \Delta. e : A \star (\partial \Delta . [\iota] e)
\]

$\beta/\eta$ for $\langle\_,\_\rangle/\bget$:
\[
\langle \partial\Delta.[\iota]e , \bget \Delta .e\rangle \equiv e
\qquad
\bget \Delta. \langle \partial\Delta . M, N \rangle \equiv N
\]
\[\langle M, N\rangle[\iota] \equiv M\]
$\beta$ for $\ll\_,\_\rr$:
\[
[\iota]\ll \partial\Delta . B, C \rr \equiv B
\qquad
\ll \partial\Delta . B, C \rr \star \partial \Delta . M \equiv C\ (\lambda \partial\Delta . M)\]


of which there is a special case
\[\begin{array}{c@{\quad}c}
\partial \Delta \prov B : \rset_i&\cdot \prov C : \dap{\partial \Delta} B \to \rset_i
\\
\partial \Delta \prov b : B & \cdot \prov c :  C\ (\lambda\partial \Delta . b)
\end{array}
\over
\Delta \prov  \langle \partial \Delta .b, c \rangle :  \ll \partial\Delta . B,  C \rr\]
\subsection{Displayed Types Again}
Suppose I consider
\[P :\rset_1\]
\[P = \Sigma (A : \rset_0) . A\]
I want to derive the binary displayed version of this,
\[P^d : P \to P \to \rset_1\]
\[P^d\  \langle A_1, a_1 \rangle\  \langle A_2, a_2 \rangle  = \Sigma(A^d : A_1 \to A_2 \to  \rset_0). A^d\ a_1\ a_2 \]
I claim that if I set $\Delta = (t : {\bf 2})$ I can say
\[ P^d \cong \bget(\Delta. P)\]
Let's consider the typing first
\[\Delta \prov P : \rset_1
\over
\cdot \prov \bget \Delta. P : \rset_1 \star (\partial\Delta . [\iota] P)
\]
If I have $A\ B : \rset_0$ and $R : A \to B \to \rset_0$ and $a : A$ and $b : B$ and $r : R\ a\ b$, then
I should be able to get into something. Remember my notion that
\[\rset_i \star (\partial\Delta.A) \approx \dap{\partial\Delta}{A} \to \rset_i\]
and given the non-$\eta$ principle that
\[A \approx \ll \partial \Delta. [\iota]A, \lambda M . A \star M \rr\]
I can imagine that
\[\rset_i \approx \ll \partial \Delta. \rset_i, \lambda f . \rset_i \star f \rr\]
\[\rset_i \approx \ll \partial \Delta. \rset_i, \lambda f .  \dap \Delta f \to \rset_i \rr\]




\[\Delta \prov P : \rset_1
\over
\cdot \prov \bget  \Delta. P : \rset_1 \star (\partial \Delta . [\iota] P)
\]

%% \[X' = \Delta \prov \langle\partial\Delta.\langle A|B\rangle, \lambda f . R\ (f\ t_0)\ (f\ t_1)\rangle : \rset_0\]
%% \[
%% \partial \Delta \prov \langle a|b\rangle : \partial\Delta.\langle A|B\rangle \qquad \cdot \prov r : R\ a\ b
%% \over
%% \Delta \prov x' =  \langle \partial \Delta . \langle a|b \rangle, r \rangle :  X'\]
%% Then
%% \[\Delta \prov \langle X', x' \rangle : \Sigma(A : \rset_0).A\]
%% i.e.
%% \[\Delta \prov \langle X', x' \rangle : P\]
%% \[ \prov \bget \Delta . (\langle X', x' \rangle) : (\Sigma(A : \rset_0).A) \star [\iota]\langle X', x' \rangle\]
%% That isn't quite what I wanted.




\end{document}
