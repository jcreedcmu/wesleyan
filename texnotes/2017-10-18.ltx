\documentclass{article}
\input{theorem}
\input{prooftree}
\usepackage{stmaryrd}
\input{linear}
\def\merge{\star}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\bpush{\mathbf{push}}
\def\push{\circ}
\def\func#1{\overline{#1}}
\def\bpull{\mathbf{pull}}
\def\btriv{\mathbf{triv}}
\def\bas{\mathrel\mathbf{as}}
\newarrow {Equiv} =====
\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\o{\comp}
\def\ups#1{#1^G}
\def\dns#1{#1^B}
\def\rsn{\ \mathsf{sn}}
\def\rx{\mapsto}
\def\ep{\varepsilon}
\def\wat{{@}}
\def\sem#1{[\![#1]\!]}
\def\cn{{:}}
\def\rok{\mathrel\mathsf{ok}}
\def\rtype{\mathrm{type}}

\def\rset{\mathbf{Set}}
\def\rcat{\mathbf{Cat}}
\def\rid{\mathrm{id}}
\def\C{\mathbf{C}}
\def\E{\mathbf{E}}
\def\T{\mathbf{T}}
\def\B{\mathbf{B}}
\def\F{\mathbb{F}}
\def\H{\mathbf{H}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\tri{\triangleright}
\def\o{\circ}
\def\rctx{\,\mathrm{ctx}}
\def\cc{\mathrel{\mathring :}}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\usepackage{tikz}
\usepackage{tikz-cd}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}

\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\begin{document}

\tikzset{
   commutative diagrams/.cd,
   arrow style=tikz,
   diagrams={>=stealth}}
% got this from
% https://tex.stackexchange.com/questions/169512/tikz-style-arrow-tips-missing-when-using-tikz-cd-crossing-over
% ???

\subsection*{Judgments}
$$\Gamma \prov M : A$$
$$\Gamma; \sharp n \prov M : A$$
\subsection*{$\sharp$-Substitution}
There is a syntactic substitution-esque operation $M[i]$ with admissible rule
\[
\erule
{\Gamma; {\sharp n} \prov  M : A \qquad i < n}
{\Gamma \prov  M[i] : A[i]}
\]
\subsection*{Typing}
\subsubsection*{Mix}
There's some `mix' rules like
\[
\erule
{\Gamma; {\sharp n_1} \prov  M_1 : A \qquad
\Gamma; {\sharp n_2} \prov M_2 : A}
{\Gamma; {\sharp (n_1 + n_2)} \prov M_1 \merge M_2 : A}
\qquad
\erule
{}
{\Gamma; {\sharp 0} \prov I : A}
\]
with substitution
\[
(M_1 \merge M_2)[i]  \equiv  \cases{ M_1[i] & $i < n_1$ \cr M_2[i-n_1] & otherwise.}
\]
\subsubsection*{Push}
Push (opreindexing, composition with map) works like
\[
\erule
{\Gamma; {\sharp m} \prov  M : A \qquad f : n \to m}
{\Gamma; {\sharp n} \prov M \push f : A}
\]
with substitution
\[
(M \push f)[i] \equiv M[f(i)]
\]
\subsubsection*{Pull}
Pull (reindexing, 2-pushout) works like
\[
\erule
{\Gamma; {\sharp n} \prov  N : A\qquad \Gamma \prov \bar M^m : \bar A^m \qquad f : n \to m
\qquad {A_{f(i)} \equiv A[i] \atop M_{f(i)} \equiv N[i]}}
{\Gamma; {\sharp m} \prov \bpull_f(\bar M, N) : A}
\]
with substitution
$$ {(\bpull_f(\bar M, N))[i] \equiv M_i} $$

\section{Examples}
Given $\Gamma; \sharp 2 \prov R : A$
and $\Gamma; \sharp 2 \prov S : A$, with $R[1] \equiv S[0]$, I can form
$$\Gamma; \sharp 4 \prov R \merge S : A$$
$$\Gamma; \sharp 3 \prov \bpull_{\func{0112}}(R[0], S[0], S[1], R \merge S) : A$$
$$\Gamma; \sharp 2 \prov (\bpull_{\func{0112}}(R[0], S[0], S[1], R \merge S)) \push \func{02} : A$$

\subsection*{Trivial Objects}
A special case of the $\bpull$ rule is
\[
\erule
{\Gamma; {\sharp 0} \prov  I : A\qquad \Gamma \prov \bar M^m : A }
{\Gamma; {\sharp m} \prov \bpull_{\func\cdot}(\bar M, I) : A}
\]
and so we define the abbreviation
$\btriv(\bar M) = \bpull_f(\bar M, I) : A$.

{\color{red} Oh no, what's the dependent version of this?}

{\color{gray} Oh, wait, maybe it's fine; I think it's
\[
\erule
{\Gamma; {\sharp 0} \prov  I : B\qquad \Gamma \prov \bar M^m : \bar A^m }
{\Gamma; {\sharp m} \prov \bpull_{\func\cdot}(\bar M, I) : \bpull_{\func\cdot}(\bar A, B)}
\]
The general version is actually maybe
\[
\erule
{\Gamma; {\sharp n} \prov  N : B\qquad \Gamma \prov \bar M^m : \bar A^m \qquad f : n \to m
\qquad {A_{f(i)} \equiv B[i] \atop M_{f(i)} \equiv N[i]}}
{\Gamma; {\sharp m} \prov \bpull_f(\bar M, N) : \bpull_f(\bar A , B)}
\]
\[
\erule
{\Gamma; {\sharp n} \prov  B : \rtype\qquad \Gamma \prov \bar A^m : \rtype \qquad f : n \to m
\qquad A_{f(i)} \equiv B[i]}
{\Gamma; {\sharp m} \prov  \bpull_f(\bar A , B) : \rtype}
\]
\[ \erule{}{\bpull_f(\langle B, \ldots, B\rangle, B) \equiv B }\]
}
\subsubsection*{Excercise 1}

Given $\Gamma; \sharp 1 \prov R : A$
and $\Gamma; \sharp 1 \prov S : A$, with $R[0] \equiv S[0] \equiv a : A$, I can form
$$\Gamma; \sharp 2 \prov R \merge S : A$$
$$\Gamma; \sharp 1 \prov \bpull_{\func{00}}(a, R \merge S) : A$$
Suppose $S = \btriv(a)$. How do we know that
$\bpull_{\func{00}}(a, R \merge \btriv(a)) \equiv R$?

\subsubsection*{Beck-Chevalley Condition}
Suppose we have a commutative square of functions on finite sets:
\[
\begin{tikzcd}
n \ar[r, "f"] \ar[d, "h" swap]& m \ar[d, "g"]\\
p \ar[r, "k" swap] & q
\end{tikzcd}
\]
And some $\Gamma \prov \bar Q : \bar A$ and $\bar M : \bar B$
 such that $B_{f(i)} \equiv A_{k(h(i))}$ and
$M_{f(i)} \equiv Q_{k(h(i))}$ for all $i < n$.

Start with $\Gamma; \sharp p \prov P : C$. Form
\[
\erule
{\Gamma; {\sharp p} \prov  P : C\qquad \Gamma \prov \bar Q^q : \bar A^q \qquad k : p \to q
\qquad {A_{k(i)} \equiv C[i] \atop Q_{k(i)} \equiv P[i]}}
{\Gamma; {\sharp q} \prov \bpull_k(\bar Q, P) : C}
\]
then form $\Gamma; \sharp m \prov (\bpull_k(\bar Q, P)) \push g : C \push g$.
In the other direction, form $\Gamma; \sharp n \prov P \push h : A$ then form
\[
\erule
{\Gamma; {\sharp n} \prov  P \push h : C \push h\qquad \Gamma \prov \bar M^m : \bar B^m \qquad f : n \to m
\qquad {B_{f(i)} \equiv C[h(i)] \atop M_{f(i)} \equiv P[h(i)]}}
{\Gamma; {\sharp m} \prov \bpull_f(\bar M, P \push h) : B}
\]

Well clearly I'm fucking up all the dependent types involved, but something like
$$\bpull_k(\bar Q, P) \push g \equiv \bpull_f(\bar M, P \push h)$$
 should hold under suitable
conditions on the $\bar M$ and $\bar Q$ matching up.
\end{document}
