\documentclass{article}
\input{theorem}
\input{prooftree}
\usepackage{stmaryrd}
\usepackage{latexsym}
\usepackage{yfonts}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,cd,decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}
\usepackage{tcolorbox}
\tcbuselibrary{breakable}


\def\el#1{\textcolor{bluegray}{\texttt{[}}{#1}\textcolor{bluegray}{\texttt{]}}}
\def\quote#1{{\ulcorner {#1} \urcorner}}
\def\U{\mathsf{U}}
\def\A{\mathsf{A}}
\def\uni{\U}
\def\mor#1#2{#1 \to \underline{#2}}

\def\ridp{\mathsf{idp}}
\def\fc{\mathfrak{C}}
\def\ff{\mathfrak{F}}
\def\ssem#1{\langle\!\langle{#1}\rangle\!\rangle}

\definecolor{cyan}{rgb}{0.80,0.95,0.95}
\definecolor{orange}{rgb}{0.95,0.90,0.80}
\definecolor{lred}{rgb}{0.95,0.8,0.8}
\definecolor{bluegray}{rgb}{0.4,0.4,0.8}
\definecolor{lgray}{gray}{0.9}
\newtcolorbox{declbox}{colframe=lred,colback=lred,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{thmbox}{colframe=cyan,colback=cyan,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{defnbox}{colframe=orange,colback=orange,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt}
\newtcolorbox{tangentbox}{colframe=lgray,colback=lgray,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}

\input{linear}
\def\rpath#1{[#1]}
\def\rfst{\mathsf{fst}\,}
\def\rsnd{\mathsf{snd}\,}
\def\bunfold{\mathbf{unfold}}
\def\bfold{\mathbf{fold}}
\def\susp#1{\langle {#1} \rangle}
\def\ssusp#1{\langle\!\langle {#1} \rangle\!\rangle}
\def\dto{\mathrel{\dot\to}}
\def\dns{{\downarrow}}
\def\ups{{\uparrow}}
\def\sprov{\Vdash}
\def\signat{{\color{red}\Sigma}}

\def\wat{\mathbin{@}}
\def\wwat{\mathbin{\underline\wat}}
\def\cn{{:}}
\def\dv{{\div}}
\def\ww{{\mathsf w}}
\def\base{{\textfrak b}}

\def\N{{\mathbb N}}
\def\munit{I}
\def\tt{{\mathsf t}}
\def\rr{{\mathsf r}}
\def\ii{{\mathbb I}}
\def\pp{\textsf{\textbf p}}
\def\nn{{\mathsf n}}
\def\PP{\textsf{\textbf P}}
\def\NN{{\mathsf N}}
\def\zz{{\mathsf z}}
\def\sem#1{[\![#1]\!]}
\def\usem#1{\lceil\!\!\lceil{#1}\rceil\!\!\rceil}
\def\zem#1{\langle\!\langle#1\rangle\!\rangle}
\def\col#1{{\mathsf{C}}_{#1}}
\def\lax{\mathop\bigcirc}
\def\rjust{\mathsf{just}}
\def\rcvt{\mathsf{cvt}}
\def\rtype{\mathsf{type}}
\def\rkind{\mathsf{kind}}
\def\rmode{\mathsf{mode}}
\def\rprel{\mathbf{Prel}}
\def\rrfam{\mathbf{Rfam}}
\def\rset{\mathbf{Set}}
\def\rfinset{\mathbf{FinSet}}
\def\rrel{\mathbf{Rel}}
\def\rcat{\mathbf{Cat}}
\def\rfam{\mathbf{Fam}}
\def\binj{\mathbf{inj}}
\def\rid{\mathsf{id}}
\def\rtrue{\mathrel\mathrm{true}}
\def\pbck{\ar[dr, phantom, pos=0, "\lrcorner"]}
\def\bpbck{\ar[ddrr, phantom, pos=0, "\lrcorner"]}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\btwo{\mathbf{2}}
\def\bone{\mathbf{1}}

\newarrow {Equiv} =====
\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\def\mapt{\ar[ddd,mapsto,shorten <=2em, shorten >=2em]}
\def\frommaps{\ar[from=uu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\frommapt{\ar[from=uuu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\C{\mathbf{C}}
\def\S{\mathbf{S}}
\def\D{\mathbf{D}}
\def\E{\mathbf{E}}
\def\M{\mathbf{M}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\tri{\triangleright}
\def\o{\circ}
\def\rctx{\,\mathsf{ctx}}
\def\del{\partial}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\null{\emptyset}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\definecolor{fib}{HTML}{ff7f00}
\definecolor{green}{HTML}{007f00}
\definecolor{red}{HTML}{df3f3f}
\definecolor{opfib}{HTML}{007fff}

% For lightening colors I used
% http://trycolors.com/ 6 parts white to 1 part color
\definecolor{opfibl}{HTML}{DBEDFF}
\definecolor{greenl}{HTML}{DBEDDB}
\definecolor{redl}{HTML}{FAE4E4}
\def\njudge#1{\fcolorbox{opfib}{white}{#1}}
\def\nrule#1{\fcolorbox{white}{opfibl}{#1}}
\def\neqn#1{\fcolorbox{white}{redl}{#1}}

\def\judge#1{\vskip 2em\noindent \njudge{$#1$}\vskip 0.5em\noindent}
\def\rule#1{\vskip 2em \noindent \nrule{$#1$}\vskip 0.5em\noindent}
\def\eqn#1{\vskip 2em \noindent \neqn{$#1$}\vskip 0.5em\noindent}

\def\tensor{\otimes}
\def\lol{\multimap}

\def\wtf{{\color{red}???}}

\def\zero{\texttt{0}}

\begin{document}

\def\
\tikzset{
   commutative diagrams/.cd,
   arrow style=tikz,
   diagrams={>=stealth}}
% got this from
% https://tex.stackexchange.com/questions/169512/tikz-style-arrow-tips-missing-when-using-tikz-cd-crossing-over
% ???

\section{Dictionary of Covariant Presheaf Semantics}

Fix a category $\C$. Conventionally $f : b \to c$ and $g : c \to d$ are morphisms.
All the $\sem A$ and $\sem M$ carry $\Gamma$ superscripts, technically, but we omit them
when the $\Gamma$ involved is clear.
\begin{declbox}
  $\sem \Gamma_c : \rset$\\
  $\sem \Gamma_g : \sem \Gamma_c \to \sem \Gamma_d$\\
  $\sem A_c : \sem \Gamma_c \to \rset$\\
  $\sem A_g : \{\rho : \sem \Gamma_c\} \to \sem A_c(\rho) \to \sem A_d(\sem \Gamma_g(\rho))$\\
  $\sem M_c : (\rho : \sem \Gamma_c) \to \sem A_c(\rho)$
\end{declbox}

\begin{thmbox}
  $ \sem \Gamma_{\rid} \equiv \rid$\qquad
  $ \sem \Gamma_{g \o f} \equiv \sem \Gamma_g \o \sem \Gamma_f$\\
  $ \sem A_{\rid} \equiv \rid$\qquad
  $ \sem A_{g \o f} \equiv \sem A_g \o \sem A_f$\\
  $(\rho : \sem \Gamma_c) \to \sem A_f (\sem M_c(\rho)) \equiv \sem M_d(\sem \Gamma_f(\rho)) $
\end{thmbox}

\subsection{Definitions}
\subsubsection{Contexts}
\begin{defnbox}
\begin{tabular}{lll}
$\sem {\cdot}_c$&$=$&$\top$\\
$\sem {\Gamma, x : A}_c$&$=$&$(\rho : \sem \Gamma_c) \x \sem A_c(\rho)$\\
$\sem {\cdot}_f$&$=$&$\lambda {*} . {*}$\\
$\sem {\Gamma, x : A}_f$&$=$&$\lambda \pair \rho a . \pair {\sem \Gamma_f(\rho)} {\sem A_f(a)}$
\end{tabular}
\end{defnbox}


\subsubsection{Function Types}
\begin{defnbox}
\begin{tabbing}
\hspace*{2em}\=\hspace*{2em}\= \kill
$\sem {(y : A) \to B}^\Gamma_c(\rho) = {}$\\
\> $(\omega : (g : \mor c d) (y : \sem A_d \sem \Gamma_g (\rho)) \to \sem B_d
\pair{\sem \Gamma_g(\rho)}{y}) \x $\\
\> $(\kappa : (g : \mor c d)(h : \mor d e)  (y : \sem A_d \sem \Gamma_g (\rho)) \to$\\
\> \> $  \sem B_h (\omega\ g\ y) \equiv \omega\ hg\ ( \sem A_h(y))) $\\
\\
$\sem {(y : A) \to B}_f  (x) = {}$\\
\> $\langle \omega = \lambda g  . (x.\omega)\ gf,$\\
\> $\ \kappa = \lambda g  . (x.\kappa)\ gf\rangle$
\end{tabbing}
\end{defnbox}

\subsubsection{The Universe}
Suppose $f' : b' \to b$.
\begin{defnbox}
\begin{tabbing}
\hspace*{2em}\=\hspace*{2em}\= \kill
$\sem \U_b (\rho)  = $\\
\> $(\omega : (f : \mor b  c) \to \U)  $\\
\> $(\kappa : (f : \mor b  c)(g : \mor c d) \to \el{\omega\ f} \to \el{\omega\ gf}) \x$\\
\> $(\iota : (f : \mor b  c) \to \kappa\ f\ \rid_c \equiv \rid_{\el{\omega\ f}}) \x$\\
\> $(\alpha : (f : \mor b  c)(g : \mor c d)(h : \mor d e) \to$\\
\> \> $\kappa\ f\ hg \equiv (\kappa\ gf\ h) \o (\kappa\ f\ g)  $
\\
$\sem \U_{f'} (x)  = $\\
\> $\langle\lambda f . (x.\omega)\ ff',$\\
\> $\ \lambda f . (x.\kappa)\ ff',$\\
\> $\ \lambda f . (x.\iota)\ ff',$\\
\> $\ \lambda f . (x.\alpha)\ ff'\rangle$
\end{tabbing}
\end{defnbox}
The critical thing for showing functoriality is
that the only occurrences of the first argument of each function in the tuple
are {\em occurrences as the first argument} to some prior function in the tuple, maybe precomposed
with some other morphism.

\subsubsection{Elements of the Universe}
\begin{defnbox}
\begin{tabbing}
\hspace*{2em}\=\hspace*{2em}\= \kill
$\sem {\el{\A}}_b (\rho)  = \el{\sem \A_b(\rho).\omega(\rid_b)}$\\
$\sem {\el{\A}}_f \{\rho\}(x)  = \sem \A_b(\rho).\kappa\ \rid_b\ f\ x$
\end{tabbing}
\end{defnbox}
Suppose $\Gamma\prov \A: \U$ is the code of some type.
We know that $\sem \A_c : (\rho : \sem \Gamma_c) \to \sem \U_c(\rho)$,
and we must make it so that
\[\sem {\el{\A}}_f  : \sem {\el{\A}}_b(\rho) \to \sem {\el{\A}}_c(\sem \Gamma_f(\rho))\]
in other words
\[\sem {\el{\A}}_f  : \el{\sem \A_b(\rho).\omega(\rid_b)} \to \el{\sem \A_c(\sem \Gamma_f(\rho)).\omega(\rid_c)}\]
and by naturality of term interpretation
\[\sem {\el{\A}}_f  : \el{\sem \A_b(\rho).\omega(\rid_b)} \to \el{\sem \U_f(\sem \A_b(\rho)).\omega(\rid_c)}\]
which expanding definitions is
\[\sem {\el{\A}}_f  : \el{\sem \A_b(\rho).\omega(\rid_b)} \to \el{\sem \A_b(\rho).\omega\ f}\]
We observe that
\[\sem \A_b(\rho).\kappa : (f' : \mor b c) (g' : \mor c d) \to \el{\sem \A_b(\rho).\omega\ f'} \to \el{\sem \A_b(\rho).\omega\ g'f'}\]
so instantiating $f' := \rid_b$ and $g' := f$ we get
\[\sem \A_b(\rho).\kappa\ \rid_b\ f : \el{\sem \A_b(\rho).\omega\ \rid_b} \to \el{\sem \A_b(\rho).\omega\ f}\]

\section{The Bernardy-Moulin Category Specifically}
$\C$ for has objects finite sets, and for morphisms partial injections.
We write $H, I, J, K$ for objects instead of $b, c, d, e$.

We can extend syntax
\[
\begin{tabular}{r@{$\quad$}c@{$\quad::=\quad$ }l}
  Contexts&$\Gamma$&$\cdots \celse \Gamma, i : \ii$\\
  Terms&$M$&$\cdots \celse \lambda i . M \celse M \wat i \celse \Psi M \celse \Phi M$\\
  Types&$A$&$\cdots \celse \forall i . A \celse a \in i . A$\\
\end{tabular}
\]


\subsection{Definitions}

\subsubsection{Contexts}
\begin{defnbox}
\begin{tabular}{lll}
$\sem {\Gamma, i : \ii}_I$&$=$&$\sem \Gamma_I + \sum_{k \in I} \sem \Gamma_{I\setminus k}$\\
$\sem {\Gamma, i : \ii}_f$&$=$&$\lambda (\rho, i := z) \mapsto( \sem \Gamma_f(\rho), i := f(z))$
\end{tabular}
\end{defnbox}
Where we write the inhabitants of two branches of the sum type $\sem{\Gamma, i: \ii}_I$
as $(\rho, i := \zero)$ or $(\rho, i := k)$ for, respectively,
some $\rho : \sem \Gamma_I$ or $\rho : \sem \Gamma_{I\setminus k}$. The variable $z$ stands
for either an actual variable $k$ or a $\zero$.
Why is the definition of the function clause well-typed?

Assume $f : I \to J$. We have that
$(\rho, i : z) : \sem \Gamma_I + \sum_{k \in I} \sem \Gamma_{I\setminus k}$
and we need to make $\sem \Gamma_J + \sum_{k \in J} \sem \Gamma_{J\setminus k}$.
If $z = \zero$, then $\rho : \sem \Gamma_I$ and $(\sem \Gamma_f(\rho), i := 0)$ is as required.
If $z = k$, then $\rho : \sem \Gamma_{I\setminus k}$, and since $f$ is a partial injection,
we can think of $f$ also as a function $I\setminus k \to J \setminus f(k)$, hence
$\sem \Gamma_f (\rho) : \sem \Gamma_{J\setminus f(k)} (\rho)$.
up to weakening.

A way to say this in one fell swoop instead of inductively is that
$\sem \Gamma_I$ requires a partial injection {\em from} all of the
$\ii$ variables in $\Gamma$ and {\em into} $I$. The functoriality part
$\sem\Gamma_f$ is just composition of partial injections.
\subsubsection{Interval Function Types}
\begin{defnbox}
\begin{tabbing}
\hspace*{2em}\=\hspace*{2em}\= \kill
$\sem {\forall i . A}_I(\rho) = \sem A_{I, j} (\rho, i := j)$\\
$\sem {\forall i . A}_f\ \{\rho\}\ (x) = \sem A_{(f,\,j\mapsto j)}\ \{\rho, i := j \}\ (x)$
\end{tabbing}
\end{defnbox}
A note about the variables involved: since $\Gamma, i : \ii \prov A : \rtype$,
we have \[\sem A_{I, j} :  \sem {\Gamma,  i : \ii} \to \rset\]
in other words
\[\sem A_{I, j} :  ( \sem {\Gamma} + \sum_{k\in (I,j)} \sem \Gamma_{(I,j)\setminus k}) \to \rset\]
and so what we're doing is assigning to the context variable $i$ the
finite-set element $j$ from the category object we're interpreting at.
That is, we chose $k$ to be $j$, so the remainder of the
interpretation obligation, $\sem \Gamma_{(I, j) \setminus k}$, turns
out to be satisfied by $\rho : \sem \Gamma_I$.

For the functoriality part, assume $f : I \to J$. We have the typing
\[\sem A_{(f,\,j\mapsto j)} : \{\rho' : \sem\Gamma_{I, j}\} \to \sem{A}_{I, j}(\rho') \to \sem{A}_{J, j}(\sem\Gamma_{(f,\,j\mapsto j)}(\rho'))\]
so when $\rho : \sem\Gamma_I$, we can substitute $(\rho, i:=j)$ for $\rho'$, and find that
\[\sem A_{(f,\,j\mapsto j)}\ \{\rho, i:=j\} :  \sem{A}_{I, j}(\rho, i:=j) \to \sem{A}_{J, j}(\sem\Gamma_{(f,\,j\mapsto j)}(\rho, i:=j))\]
in other words
\[\sem A_{(f,\,j\mapsto j)}\ \{\rho, i:=j\} :  \sem{A}_{I, j}(\rho, i:=j) \to \sem{A}_{J, j} (\sem\Gamma_{f}(\rho), i:=j)\]
and equivalently
\[\sem A_{(f,\,j\mapsto j)}\ \{\rho, i:=j\} : \sem {\forall i . A}_I(\rho) \to \sem {\forall i . A}_J(\sem \Gamma_f(\rho))\]
as required for $\sem{\forall i . A}_f\ \{\rho\}$.

\subsubsection{Interval Function Abstraction}
\begin{defnbox}
\begin{tabbing}
\hspace*{2em}\=\hspace*{2em}\= \kill
$\sem {\langle i \rangle M}_I(\rho) = \sem M_{I, j}(\rho, i:= j) $
\end{tabbing}
\end{defnbox}
\[
\erule
{\Gamma, i : \ii \prov M : A}
{\Gamma  \langle i \rangle M : \forall i . A}
\]
We need $(\rho : \sem \Gamma_I) \to \sem A_{I, j}(\rho, i := j)$
and we know for any $I$ that
\[\sem M_I : (\rho :  \sem {\Gamma, i : \ii}_I) \to \sem A_{I}(\rho)\]
It's a simple matter of picking the right arguments to $\sem M$.

\subsubsection{Interval Function Application}
\begin{defnbox}
\begin{tabbing}
\hspace*{2em}\=\hspace*{2em}\= \kill
$\sem {M \wat i}_I(\rho) = \bcase \rho \bof$\\
\> $(\rho_0, i:=\zero) \mapsto \sem A_{j := \zero}(\sem M_I(\rho_0))$\\
\> $(\rho_0, i:=k) \mapsto \sem A_{j := k} (\sem M_{I\setminus k}(\rho_0))$\\
$\sem {M \wat \zero}_I(\rho) = \sem A_{j:=\zero}(\sem M_I(\rho))$
\end{tabbing}
\end{defnbox}

When we apply to a variable, we have
\[
\erule
{\Gamma \prov M : \forall i . A}
{\Gamma, i : \ii \prov M \wat i : A}
\]
We have to make something of type
\[(\rho : \sem {\Gamma, i : \ii}_{I})\to \sem {A}_{I}(\rho)\]
but we get to assume for any $I$ that
$\sem M_I : (\rho : \sem \Gamma_I)\to \sem {\forall i . A}_I(\rho)$,
in other words
\[\sem M_I : (\rho : \sem \Gamma_I)\to \sem {A}_{I,j}(\rho, i := j)\]
 The thing we build is a case analysis;
it splits cases depending on whether $\rho$ is $(\rho_0, i:=\zero)$ or
$(\rho_0, i:=k)$ for some $k \in I$.

If we have $(\rho_0, i:=\zero)$, then $\rho_0 \in \sem\Gamma_I$ and we feed
it to $\sem M_I$ and we have something of type $\sem A_{I, j}(\rho_0, i := j)$.
Consider the projection $(j := \zero) : I,j \to I$. We can consider functoriality along it
\[ \sem A_{j := \zero} : \{\rho' : \sem{\Gamma,i:\ii}_{I,j}\} \to
\sem A_{I,j}(\rho') \to \sem A_{I}(\sem{\Gamma,i:\ii}_{j := \zero}(\rho'))\]
and applying it we find
\[ \sem A_{j := \zero}\ \{\rho_0, i:= j\}\ (\sem M_I(\rho_0)) :
\sem A_{I}(\sem{\Gamma,i:\ii}_{j := \zero}(\rho_0, i:= j))
 \]
or equivalently (by functoriality, since `most of' the morphism $j := \zero$ is the identity)
\[ \sem A_{j := \zero}\ \{\rho_0, i:= j\}\ (\sem M_I(\rho_0)) :
\sem A_{I}(\rho_0, i:= \zero))
 \]
 Otherwise, $\rho = (\rho_0, i:=k)$ and $\rho_0 \in \sem\Gamma_{I\setminus k}$.
 So we want to put $\rho_0$ into $\sem M_{I\setminus k}$,
and we get out $\sem A_{I\setminus k, j}(\rho_0, i := j)$. There clearly is a map $(j := k) : I\setminus k, j \to I$ which assigns $j$ to $k$. So similarly to before we consider
\[ \sem A_{j := k} : \{\rho' : \sem{\Gamma,i:\ii}_{I\setminus k,j}\} \to
\sem A_{I\setminus k,j}(\rho') \to \sem A_{I}(\sem{\Gamma,i:\ii}_{j := k}(\rho'))\]
and observe
\[ \sem A_{j := k}\  \{\rho_0, i := j\} :
\sem A_{I\setminus k,j}(\rho_0, i := j) \to \sem A_{I}(\sem{\Gamma,i:\ii}_{j := k}(\rho_0, i := j))\]
\[ \sem A_{j := k}\  \{\rho_0, i := j\}\ (\sem M_{I\setminus k}(\rho_0)) :
 \sem A_{I}(\sem{\Gamma,i:\ii}_{j := k}(\rho_0, i := j))\]
\[ \sem A_{j := k}\  \{\rho_0, i := j\}\ (\sem M_{I\setminus k}(\rho_0)) :
 \sem A_{I}(\rho_0, i := k)\]

When we apply to zero, we have
\[
\erule
{\Gamma \prov M : \forall i . A}
{\Gamma \prov M \wat \zero : [\zero/i]A}
\]
We have to make something of type
\[(\rho : \sem {\Gamma}_{I})\to \sem {[\zero/i]A}_{I}(\rho)\]
but we get to assume for any $I$ that
\[\sem M_I : (\rho : \sem \Gamma_I)\to \sem {A}_{I,j}(\rho, i := j)\]
I expect for any $\rho : \sem \Gamma_I$ that
$\sem{[\zero/i]A}_I(\rho) \equiv \sem A_{I}(\rho, i := \zero)$, so we
really just have to get from $\sem {A}_{I,j}(\rho, i := j)$
to $\sem {A}_{I}(\rho, i := \zero)$. But we do that the same way as above, with a
projection $j := \zero$. Indeed, to {\em make} this $\zero$-substitution lemma true,
we basically need to imitate the variable case when the context-element happens to
have a $i := \zero$ in it.

\subsection{Interval Conversions}

It appears that we have $\eta$-equality
\[\sem {\langle i \rangle M \wat i}_I(\rho) = \sem {M}_{I}(\rho) \]
and $\beta$-equality
\[\sem {(\langle h \rangle M) \wat i}_I(\rho, i:=\zero) = \sem A_{j:=\zero}(\sem {\langle h\rangle M}_I(\rho)) \]
\[ = \sem A_{j:=\zero}(\sem { M}_{I,j}(\rho, h := j)) \]
\[ = \sem { M}_{I}(\rho, h := \zero) \]
\[\sem {(\langle h \rangle M) \wat i}_I(\rho, i:=k) = \sem A_{j:=k}(\sem {\langle h\rangle M}_{I\setminus k}(\rho)) \]
\[ = \sem A_{j:=k}(\sem { M}_{I\setminus k,j}(\rho, h := j)) \]
\[ = \sem { M}_{I}(\rho, h := k) \]
And I figure surely by $\alpha$-equivalence
 $\sem {[i/h]M}_I(\rho, i := v) \equiv \sem M_I(\rho, h := v)$, so this checks out.

Similarly we get a $\beta$-equation for application to zero,
\[\sem {(\langle h \rangle M) \wat \zero}_I(\rho) = \sem A_{j:=\zero}(\sem{\langle h\rangle M}_I(\rho)) \]
\[= \sem A_{j:=\zero}(\sem{ M}_{I,j}(\rho, h := j)) \]
\[= \sem{ M}_{I}(\rho, h := \zero) \]
\[= \sem{ [\zero/h]M}_{I}(\rho) \]


\end{document}
