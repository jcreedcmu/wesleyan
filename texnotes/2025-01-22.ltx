\documentclass{article}
\usepackage[tmargin=0.15in, bmargin=0.15in]{geometry}
\input{theorem}
\input{prooftree}
\usepackage{relsize}
\usepackage{latexsym}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,cd,decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}
\usepackage{tcolorbox}
\tcbuselibrary{breakable}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}

\def\tel{\mathsf{T}}
\def\bdot{\mathrel{\bar\cdot}}
\def\bodot{\mathrel{\bar\odot}}
\def\dec{\mathsf{\downarrow}}
\def\enc{\mathsf{\uparrow}}
\def\I{\mathbb{I}}
\def\bget{\mathop\mathbf{get}}
\def\bGet{\mathop\mathbf{Get}}
\def\dapt#1#2{#1[\![#2]\!]}
\def\dap#1#2{#1\{#2\}}
\def\ll{\langle\!\langle}
\def\rr{\rangle\!\rangle}
\def\rshape{\ {\mathsf{shape}}}
\def\rrefl{{\mathsf{refl}}}
\def\bd{\mathsf{Bd}}
\def\bdd{\mathsf{Bdd}}
\def\rset{\mathsf{U}}
\def\rid{\mathsf{Id}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\prequiv{\dashv\vdash}

\definecolor{blu}{rgb}{0.1,0.5,1}
\definecolor{orng}{rgb}{1,0.5,0.3}

\def\El#1{\ulcorner{#1}\urcorner}
\def\U{\mathsf{U}}
\def\uu{\mathsf{u}}
\def\uni{\U}



\definecolor{lred}{rgb}{0.95,0.8,0.8}
\definecolor{cyan}{rgb}{0.80,0.95,0.95}
\definecolor{lorange}{rgb}{0.95,0.90,0.80}
\definecolor{bluegray}{rgb}{0.6,0.6,0.85}
\definecolor{lgray}{gray}{0.8}
\newtcolorbox{declbox}{colframe=lred,colback=lred,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{thmbox}{colframe=cyan,colback=cyan,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{defnbox}{colframe=lorange,colback=lorange,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{tangentbox}{colframe=lgray,colback=lgray,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}

\input{linear}
\def\rpath#1{[#1]}
\def\rfst{\mathsf{fst}\,}
\def\rsnd{\mathsf{snd}\,}
\def\bunfold{\mathbf{unfold}}
\def\bfold{\mathbf{fold}}
\def\susp#1{\langle {#1} \rangle}
\def\ssusp#1{\langle\!\langle {#1} \rangle\!\rangle}
\def\dto{\mathrel{\dot\to}}
\def\dns{{\downarrow}}
\def\ups{{\uparrow}}
\def\sprov{\Vdash}
\def\signat{{\color{red}\Sigma}}
\def\ep#1{\underline{#1}}
\def\wat{{@}}
\def\wwat{\mathbin{\underline\wat}}
\def\cn{{:}}
\def\dv{{\div}}
\def\ww{{\mathsf w}}
\def\base{{\textfrak b}}

\def\N{{\mathbb N}}
\def\Z{{\mathbb Z}}
\def\munit{I}
\def\tt{{\mathsf t}}
\def\ii{{\mathbb I}}
\def\T{\mathbb{T}}
\def\tw{\mathsf{Tw}}
\def\sw#1{^{#1}_{#1}}
\def\TP{\mathbf{TPre}}
\def\pp{\textsf{\textbf p}}
\def\nn{{\mathsf n}}
\def\PP{\textsf{\textbf P}}
\def\NN{\textsf{\textbf N}}
\def\zz{{\mathsf z}}
\def\sem#1{[\![#1]\!]}
\def\usem#1{\lceil\!\!\lceil{#1}\rceil\!\!\rceil}
\def\zem#1{\langle\!\langle#1\rangle\!\rangle}
\def\col#1{{\mathsf{C}}_{#1}}
\def\lax{\mathop\bigcirc}
\def\rjust{\mathsf{just}}
\def\rcvt{\mathsf{cvt}}
\def\rtype{\mathsf{type}}
\def\rdtype{\mathsf{disc}}
\def\rkind{\mathsf{kind}}
\def\rmode{\mathsf{mode}}
\def\rprel{\mathbf{Prel}}
\def\rrfam{\mathbf{Rfam}}
%\def\rset{\mathbf{Set}}
\def\rfinset{\mathbf{FinSet}}
\def\rrel{\mathbf{Rel}}
\def\rcat{\mathbf{Cat}}
\def\rfam{\mathbf{Fam}}
\def\binj{\mathbf{inj}}
\def\rtrue{\mathrel\mathrm{true}}
\def\pbck{\ar[dr, phantom, pos=0, "\lrcorner"]}
\def\bpbck{\ar[ddrr, phantom, pos=0, "\lrcorner"]}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\btwo{\mathbf{2}}
\def\bone{\mathbf{1}}

\newarrow {Equiv} =====
\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\def\mapt{\ar[ddd,mapsto,shorten <=2em, shorten >=2em]}
\def\A{\mathbf{A}}
\def\B{\mathbf{B}}
\def\C{\mathbf{C}}
\def\G{\mathbf{G}}
\def\D{\mathbf{D}}
\def\DD{\mathbb{D}}
\def\E{\mathbf{E}}
\def\M{\mathbf{M}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\ltri{{\lhd}}
\def\rtri{{\rhd}}
\def\tri{\rhd}
\def\cc{\mathsf{c}}
\def\dd{\mathsf{d}}
\def\o{\circ}
\def\rctx{\,\mathsf{ctx}}
\def\rdctx{\,\mathsf{dctx}}
\def\del{\partial}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\definecolor{fib}{HTML}{ff7f00}
\definecolor{green}{HTML}{007f00}
\definecolor{red}{HTML}{df3f3f}
\definecolor{opfib}{HTML}{007fff}

% For lightening colors I used
% http://trycolors.com/ 6 parts white to 1 part color
\definecolor{opfibl}{HTML}{DBEDFF}
\definecolor{greenl}{HTML}{DBEDDB}
\definecolor{redl}{HTML}{FAE4E4}
\begin{document}

\def\
\tikzset{
   commutative diagrams/.cd,
   arrow style=tikz,
   diagrams={>=stealth}}

\section{Applicative Parametricity}
I notice that the requirements of $\partial\Delta \lol \dash$
and $\Delta \lol \dash$ look a lot like being a `dependent applicative functor'.
Suppose I have
\[F : \rset_i \to \rset_i\]
\[\Gamma : F\rset_i \to \rset_i\]
\[\eta : A \to FA\]
\[{\_\cdot\_} : F(A \to B) \to FA \to FB\]
\[{\_\odot\_} : \{A : \rset_i\} \{B : A \to \rset_i\} \to F((x : A) \to B(x)) \to (a : FA) \to \Gamma (\eta B \cdot a)\]

Probably expect the standard applicative axioms, plus that dependent things degenerate into simply typed
things correctly, i.e.
\[A : \rset_i
\over
\Gamma (\eta A) \equiv FA
\]
\[
B = (\lambda \_ . B_0)\qquad f : A \to B
\over
f \odot x \equiv f \cdot x
\]
An example is the reader applicative for input type $S$,
\[FA = S \to A\]
\[\Gamma\ (A : S \to \rset_i) = (s : S) \to A\ s\]
\[\eta\ a = \lambda\_ . a\]
\[f \cdot x = \lambda s . (f\ s)\ (x\ s)\]
\[f \odot x = \lambda s . (f\ s)\ (x\ s)\]
Then from this data we aim to construct another such object,
\[\bar F : \rset_i \to \rset_i\]
\[\bar \Gamma : \bar F\rset_i \to \rset_i\]
\[\bar \eta : A \to \bar FA\]
\[{\_\bdot\_} : \bar F(A \to B) \to \bar FA \to \bar FB\]
\[{\_\bodot\_} : \{A : \rset_i\} \{B : A \to \rset_i\} \to \bar F((x : A) \to  B(x)) \to (a : \bar FA) \to \bar\Gamma (\bar \eta B \bdot a)\]
%% which lies over $F$ in the sense that there's a map
%% \[\partial : \{A : \rset_i\} \to \bar F A \to F A\]
%% which commutes appropriately with all the operations above.
%% In particular, $\partial (\bar\eta\ a) \equiv \eta $.
Where it will turn out that we choose to define $\bar F$ and $\bar \Gamma$ as record types:
\[\bar F A \equiv \{\partial : F A, \beta : \bd_A(\partial) \}\]
\[\bar \Gamma (C : \bar F \rset_i) \equiv \{\partial : \Gamma(\partial C), \beta : \bdd_{ C}(\partial) \}\]
It is our job to define
\[
{A: \rset_i  \over \bd_A : FA \to \rset_i}
\qquad
{C: \bar F \rset_i  \over  \bdd_C : \Gamma(\partial C) \to  \rset_i}
\]
This will satisfy various nice properties. A central one is
 {\em relativity}, that bridges in the universe are relations:
\[\bd_{\rset_i}(A ) \equiv \Gamma A \to \rset_i\]
Some compatibilities that will be need to be satisfied are
%\[\partial(\bar \Gamma C) \equiv \Gamma (\partial C)\]
\[\partial (\bar \eta a) \equiv \eta a\]
\[\partial(f \mathrel{\bdot} x) \equiv \partial f \cdot \partial x\]
\[\partial(f \bodot x) \equiv \partial f \cdot \partial x\]
Let's suppose $A : \rset_i$. Then
\[\bar\eta A : \bar F \rset_i\]
\[\beta(\bar\eta A) : \bd_{\rset_i}(\partial(\bar\eta A))\]
\[\beta(\bar\eta A) : \bd_{\rset_i}(\eta A)\]
\[\beta(\bar\eta A) : \Gamma(\eta A) \to \rset_i\]
\[\beta(\bar\eta A) : FA \to \rset_i\]
So we can equate
\[\bd_A \equiv \beta(\bar\eta A)\]
For $\bdd$, do I need a higher form of reflexivity? Maybe not.
Can I just say
\[\bdd_C = \beta C\]
For
\[\bar F \rset_i = \{ \partial : F \rset_i , \beta : \bd_{\rset_i}(\partial)\}\]
\[ C : \bar F \rset_i\]
which together mean
\[\beta C : \bd_{\rset_i}(\partial C)\]
\[\beta C : \Gamma(\partial C) \to \rset_i\]

\subsection{Dependent Pairing}
For substitutions below, I think I want some compatibility between $F/\Gamma$ and dependent pairing.
To the signature of a ``dependent applicative functor'' I add the requirements:
whenever $A : \rset_i$ and $B : A \to \rset_i$, we have dependent pairing under $F$:
\[
N : FA \qquad M : \Gamma(\eta B \cdot N)
\over
\ll N, M \rr : F(\Sigma A B)
\]
and also first and second projection:
\[
{M : F(\Sigma A B)
\over
\pi_1 M : F A}
\qquad
{M : F(\Sigma A B)
\over
\pi_2 M : \Gamma (\eta B \cdot \pi_1 M)}
\]


For the example of $\Delta = {\bf S}$, nothing surprising happens with pairing:
\[
A : \rset_i \qquad B : A \to \rset_i \qquad N : S \to A \qquad M : (s :S) \to B (N\ s)
\over
\lambda s . \langle N s, M\ s\rangle  : S \to (\Sigma A B)
\]
Or projections:
\[
{M : S \to (\Sigma A B)
\over
\lambda s . \pi_1 (M\ s) : S \to A}
\qquad
{M : S \to (\Sigma A B)
\over
\lambda s .\pi_2 (M\ s) : (s : S) \to  B  (\pi_1 (M\ s))}
\]
The projections I can probably just obtain from functoriality. Pairing might be a genuinely new requirement.

\subsection{Trying To Imagine Substitutions}
In binary parametricity:

\begin{itemize}
\item  $F$ takes a type $A$ to the type $A \x A$.
\item  $\Gamma$ takes something that lives in $F\rset_i$, e.g.
a pair of types  $\langle A_0,A_1\rangle$ to the type of global sections $A_0 \x A_1$.
\item In general, if we have two telescopes $\Gamma_0, \Gamma_1$, we should
have a way of computing the type of pairs of substitutions $\theta_0 : \Gamma_0, \theta_1 : \Gamma_1$.
\end{itemize}

Let $\tel_i$ be the type of telescopes of maximum universe level $i$.
\[\begin{array}{l}\mathbf{data}\ \tel_i : \N \to  \rset_{i+1}\ \mathbf{where}\\
\qquad \mathsf{nil} : \tel_i\ 0\\
\qquad \mathsf{\_,\_} : (t : \tel_i\ n) \to (\sem{t} \to \rset_j) \to \tel_{i\sqcup j} (n+1)\\
\\
\sem{\_} : \{ n : \N\} \to \tel_i\ n \to \rset_i\\
 \sem{\mathsf{nil}} = \top\\
 \sem{\mathsf{t\ ,\ A}} = \Sigma \sem t A\\
\end{array}\]
\[F : \rset_i \to  \rset_i\]
\[G : F \rset_i \to  \rset_i\]
\[\zeta : \{n : \N\} \to F (\tel_i\ n) \to  \tel_i\ n\]
\[\mathsf{map}F : (A \to B) \to FA \to FB\]
\[Z : \{n : \N\} (x : F (\tel_i\ n)) \to  \sem{\zeta\ x} \cong G(\mathsf{map}F\ \sem\_\ x)\]

Example:
\[\begin{array}{l}
FA = A \x A\\
G\langle A_0, A_1 \rangle = A_0 \x A_1\\
\zeta : \{n : \N\} \to (\tel_i\ n \x \tel_i\ n) \to  \tel_i\ n\\
Z : \{n : \N\} (x : \tel_i\ n \x \tel_i\ n) \to  \sem{\zeta\ x} \cong \sem{x.0} \x \sem{x.1}\\
\zeta {\langle \mathsf{nil}, \mathsf{nil}\rangle} \equiv \mathsf{nil}\\
\zeta \langle (T, A),  (T', A')\rangle \equiv \langle \zeta \langle T, T'\rangle ,  \lambda z : \sem{\zeta \langle T, T'\rangle}.\\
\qquad A ((Z\  \langle T,T'\rangle\ z) .0) \x A' ((Z\  \langle T,T'\rangle\ z) .1)
\rangle
\end{array}\]
In general if $\eta : A \to FA$, then we should expect
\[\zeta (\eta  (\mathsf{nil})) = \mathsf{nil}\]
Then we have something for conses. Let's try to explain the pair case generally.
Imagine we have first of all a pair of teles.
\[T : F(\tel_i n)\]
Then we have a pair of suitable types defined over those teles.
\[(t : F(\tel_i n)) \to \mathsf{map}F\ \sem\_\ t : F\rset_i\]

\subsection{Defining Telescopes Better}
I may not need to apply $F$ to the type of teles. I notice I only ever deal in one $\Gamma$
at a time, but multiple $\theta$. So I may not need to nat-index teles.
\[\begin{array}{l}\mathbf{data}\ \tel_i :   \rset_{i+1}\ \mathbf{where}\\
\qquad \mathsf{nil} : \tel_i\\
\qquad \mathsf{\_::\_} : (t : \tel_i) \to (\sem{t} \to \rset_j) \to \tel_{i\sqcup j}\\
\\
\sem{\_} :  \tel_i \to \rset_i\\
 \sem{\mathsf{nil}} = \top\\
 \sem{\mathsf{t} :: A} = \Sigma \sem t A\\
\end{array}\]

Using tools I already have, I can build up ``tuples of substitutions'' that live in $F \sem t$:
\[
t : \tel_i \qquad  \theta : F\sem{t} \qquad M : \Gamma(\eta A \cdot \theta)
\over
\ll \theta, M\rr : F\sem {t :: A}
\]

To capture bridge-substitutions, I'm going to simultaneously define
a type
\[
t : \tel_i
\over
\bd_t : F\sem t \to \rset_i
\]
and two operations
\[
t : \tel_i \qquad \theta : F\sem{t} \qquad   A : \sem t \to  \rset_i\qquad \phi : \bd_t(\theta)
\over
\phi \bullet A : \Gamma(\eta A \cdot \theta ) \to \rset_i
\]

\[
\begin{array}{c@{\qquad}c@{\qquad}c@{\qquad}c}
&&  A : \sem t \to  \rset_i \\
t : \tel_i & \theta : F\sem{t} &   M : (x : \sem t) \to A\ x  & \phi : \bd_{t}(\theta)
\end{array}
\over
\phi M : ( \phi \bullet A)\ (\eta M \odot \theta)
\]

I could think of bridge substitutions as having the intro rule:
\[
\begin{array}{c@{\qquad}c@{\qquad}c}
t : \tel_i &  \theta : F\sem{t} & M : \Gamma(\eta A \cdot \theta) \\
A: \sem t \to \rset_i &    \phi : \bd_{t}(\theta) & p : (\phi \bullet A)\ (\eta M \odot \theta)
\end{array}
\over
 \langle\phi , p\rangle  : \bd_{t :: A} \ll \theta, M\rr
\]
But this is the same as saying
\[ \bd_\cdot (*) = \top\]
\[ \bd_{t::A}\ N = \Sigma (\phi : \bd_{t}(\pi_1 N) ).(\phi \bullet A)\ (\eta ( \pi_2 N) \odot \pi_1 N)\]


What happens when $t = \mathsf{nil}$? I'm going to assert $F \top \equiv \top$ is part
of $F$ preserving products.
\[
  A :   \rset_i
\over
* \bullet A : F A \to \rset_i
\]

\[
  A :  \rset_i \qquad  M :  A
\over
*  M : (* \bullet A)(\eta M)
\]
As expected, these reduce to having the type of $\bd$ and $\rrefl$.
\subsection{Substitution}
\subsubsection{The Universe}
\[
t : \tel_{i+1} \qquad    \rset_i :   \rset_{i+1}\qquad \phi : \bd_t(\theta)
\over
\phi \bullet \rset_i : F\rset_i  \to \rset_{i+1}
\]
\[(\phi \bullet \rset_i ) A\equiv \Gamma A \to \rset_i\]
\subsubsection{Pi}
\[
\begin{prooftree}
t : \tel_i \qquad \theta : F\sem{t}
\qquad
\[
\tau : \sem t \prov A : \rset_i  \qquad \tau : \sem t, x : A \prov B:  \rset_i
\justifies
(\lambda \tau . (x : A) \to B) : \sem t \to  \rset_i
\]
\qquad \phi : \bd_t(\theta)
\justifies
\phi \bullet (\lambda \tau . (x : A) \to B) : \Gamma(\eta (\lambda \tau . (x : A) \to B) \cdot \theta ) \to \rset_i
\end{prooftree}
\]

Here I'm stuck. I don't know how to apply anything from $\Gamma$. Or wait, maybe I do? Might need dependent pairing.

We start by $\Pi$'ing up $(x : S)$...
\section{What are Dependent Applicative Functors?}
I believe I should have
\[F : \rset_i \to \rset_i\]
\[\Gamma : F\rset_i \to \rset_i\]
\[\eta : A \to FA\]
\[{\_\cdot\_} : F(A \to B) \to FA \to FB\]
\[{\_\odot\_} : \{A : \rset_i\} \{B : A \to \rset_i\} \to F((x : A) \to B(x)) \to (a : FA) \to \Gamma (\eta B \cdot a)\]
\[
\ll\_,\_\rr : (N : FA) \to \Gamma(\eta B \cdot N)\to  F(\Sigma A B)
\]

\section{Different Substitutions}
We can wrap up a $\theta: F\sem t$ and a $\phi:\bd_t(\theta)$ as a tuple
$\psi: \bar F \sem t$. The substitution principles then look like
\def\ss{/\!/}
\[
t : \tel_i \qquad \psi : \bar F\sem{t} \qquad   A : \sem t \to  \rset_i
\over
\psi \ss A : F \rset_i
\]
\[\langle \theta,\phi\rangle \ss A = \eta A \cdot \theta \]
\[
t : \tel_i \qquad \psi : \bar F\sem{t} \qquad   A : \sem t \to  \rset_i
\over
\psi \bullet A : \Gamma(\psi \ss A ) \to \rset_i
\]

\[
\begin{array}{c@{\qquad}c@{\qquad}c@{\qquad}c}
&&  A : \sem t \to  \rset_i \\
t : \tel_i & \psi : \bar F\sem{t} &   M : (x : \sem t) \to A\ x
\end{array}
\over
\psi / M : \psi \ss A
\]

\[\langle \theta,\phi\rangle / M = \eta M \odot \theta\]
\[
\begin{array}{c@{\qquad}c@{\qquad}c@{\qquad}c}
&&  A : \sem t \to  \rset_i \\
t : \tel_i & \psi : \bar F\sem{t} &   M : (x : \sem t) \to A\ x
\end{array}
\over
\psi M : ( \psi \bullet A)\ (\psi / M)
\]
\section{Just Postulate It}
Can we get any mileage out of asserting that for any dependent
applicative functor $F$, there exists a $\bar F$ and an appropriately
nice natural transformation $\partial : \bar F \to F$ whose fibers on $\rset$ are
the appropriate relational thing?

I expect `appropriately nice' includes preserving the function application structure
of the applicative functors. So
\[\_\bdot\_ : \bar F(A \to B) \to \bar FA \to \bar FB \]
\[\_\cdot\_ : F(A \to B) \to FA \to FB \]

\[
\begin{tikzcd}
 \bar F(A \to B) \x \bar FA\ar[r]\ar[d,"{\partial\x\partial}",swap]& \bar FB\ar[d]\\
 F(A \to B)\x FA\ar[r]&   FB
\end{tikzcd}
\]
Hm, the diagram commuting is enough to push forward, but I expect more of a UMP. Are
products any easier to think about?

What do I know about $FA \x FB$ versus $F(A \x B)$? They're not necessarily iso.
Consider the list monad to see why not.

If I have an element $\bar F A$ and an element $\bar F B$, then I should have an
element $\bar F(A \x B)$.

\section{What If I Zip Functor Along Substitutions}

I'd like to retain more of the `syntactic' character of contexts and substitutions if possible.
Instead of converting them to types and terms eagerly, maybe I can say, given a dependent applicative
functor $F$, that $F$ applied to a context yields another context:

We have:
\[ \Gamma \prov A : \rset_i \over \Gamma \prov FA : \rset_i\]
\[ \Gamma \prov A : F \rset_i \over \Gamma \prov G A : \rset_i\]
\[ \eta : \{A : \rset_i\} \to A \to FA\]
\[{\_\cdot\_} : \{A : \rset_i\} \{B : A \to \rset_i\} \to F(A \to B) \to FA \to F B \]
\[{\_\odot\_} : \{A : \rset_i\} \{B : A \to \rset_i\} \to F((x : A) \to B(x)) \to (a : FA) \to G (\eta B \cdot a)\]
\[G\eta A \equiv A\]

We simultaneously define
\[{\prov \Gamma : \rctx
\over
\prov F \Gamma : \rctx}
\qquad
{\Gamma \prov M : A
\over
F \Gamma \prov \eta_\Gamma M :   F_\Gamma A}
\qquad
{\Gamma \prov  A : \rset_i
\over
F \Gamma \prov F_\Gamma A :   \rset_i}
\qquad
{F\Gamma \prov  A : F\rset_i
\over
F \Gamma \prov G_\Gamma A :  \rset_i}
\]
%% \[\color{gray}F\Gamma \prov M : F_\Gamma(A \to B) \qquad F\Gamma \prov N : F_\Gamma A
%% \over
%% F\Gamma \prov M \cdot N : F_\Gamma B\]
\[F\Gamma \prov M : F_\Gamma((x : A) \to B) \qquad F\Gamma \prov N : F_\Gamma A
\over
F\Gamma \prov M \odot_\Gamma N : G_\Gamma([N/x]\eta_{\Gamma,x:A} B)\]
\[
F\Gamma \prov M : F_\Gamma A
\over
F\Gamma, x : F_\Gamma B \prov \enc M : F_{\Gamma,x :B} A
\]
by
\[F\cdot = \cdot\]
\[F(\Gamma, x : A) = F\Gamma, x : F_\Gamma A\]
\[\eta_{\cdot}(M) = \eta M \]
\[\eta_{\Gamma, x : A}(M) = \eta_\Gamma(\lambda x.M) \odot_{\Gamma,x:A} x\]
%\[\theta_{\Gamma, x : A} = \theta_\Gamma[\eta_\Gamma(x)/x]\]
\[F_{\cdot} B = F B\]
\[F_{\Gamma, x : A} B = ?\]
\[G_{\cdot} B = G B\]
\[G_{\Gamma, x : A} B = ?\]
\vskip1em
\[F_{\Gamma} A \equiv G_\Gamma \eta_\Gamma A\]
{\bf Proof}: We must show
\begin{enumerate}
\item
  \[{\prov (\Gamma, x : A) : \rctx
    \over
    \prov  F\Gamma, x : F_\Gamma A : \rctx}
  \]
Follows by i.h. and appeal to (3)

\item
It suffices to show
  \[
    {\Gamma, y : A \prov M : B
      \over
      F\Gamma, x : F_\Gamma A \prov \eta_\Gamma(\lambda y.M) \odot x :   F_{\Gamma,x:A} [x/y] B}
    \]
We can apply weakening and function introduction to get
\[\Gamma, x : A \prov \lambda y . M : (y : A) \to B\]
Applying i.h. gives us
\[F\Gamma, x : F_\Gamma A \prov \eta_{\Gamma, x: A}(\lambda y .M) : F_{\Gamma,x:A}((y : A) \to B)\]
By variable use and weakening we have
\[F\Gamma, x : F_\Gamma A \prov \enc x : F_{\Gamma, x:A} A\]

Write $\bar \Gamma$ for $F(\Gamma, x : A) \equiv F\Gamma, x : F_\Gamma A$.
Now we can derive
\[\bar \Gamma \prov \eta_{\Gamma, x: A}(\lambda y . M) : F_{\Gamma, x : A}((y : A) \to B) \qquad \bar \Gamma \prov  \enc x : F_{\Gamma, x:A} A
\over
\bar \Gamma \prov \eta_{\Gamma, x: A}(\lambda y . M) \odot \enc x : G_{\Gamma, x : A}([\enc x/y] \eta_{\Gamma,x:A,y:A} B)\]
Now as long as
\[\eta_{\Gamma, x: A}(\lambda y . M) \odot \enc x \equiv \eta_\Gamma(\lambda y.M) \odot x\]
\[G_{\Gamma, x : A}([\enc x/y] \eta_{\Gamma,x:A,y:A} B) \equiv   F_{\Gamma,x:A} [x/y] B\]
which I expect, we're done.

\item
We must show
\[\Gamma, x : A \prov  B : \rset_i
\over
F \Gamma, x : F_\Gamma A \prov F_{\Gamma, x:A} B :   \rset_i\]

We have
\[F\Gamma, x : \Gamma_F A \prov  \eta_{\Gamma, x:A} B : F_\Gamma \rset_i\]
which should be the same by unproven lemma as
\[F\Gamma, x : \Gamma_F A \prov  \eta_{\Gamma, x:A} B : F\rset_i\]
\item
We must show
\[F\Gamma, x : F_A \prov  B :F_{\Gamma, x: A}\rset_i
\over
F \Gamma \prov G_{\Gamma, x: A} B :  \rset_i\]
\end{enumerate}

In the $\bf 2$ case:
\[\Gamma, x : A \prov  B : \rset_i
\over
F \Gamma, x : (A\ \Gamma.0) \x (A\ \Gamma_1) \prov  (B\ \Gamma.0\ x.0) \x (B\ \Gamma.1\ x.1) :   \rset_i\]

\subsection{Example for $\btwo$}
\[a : A \prov M\ a : B\ a\]
\[a_0\ a_1 : A \prov \langle M\ a_0, M\ a_1\rangle : B\ a_0 \x B\ a_1\]

\[a : A, b : B\ a, c : C\ a\ b \prov  M\ a\ b\ c : D\ a\ b\ c\]
\[a : G(\lambda s.A), b : G(\lambda s . B\ (a\ s)), c : G(\lambda s. C\ (a\ s)\ (b\ s)) \prov \lambda s . M : G(\lambda s.D\ (a\ s)\ (b\ s)\ (c\ s))\]

\[a' : F_\cdot A, b' : F_{a:A}(B\ a), c' : F_{a:A,b:B}(C\ a\ b) \prov  \eta_{a:A,b:B,c:C}(M\ a\ b\ c) : F_{a:A,b:B,c:C}(D\ a\ b\ c)\]
Here $F_\cdot A = FA$ is truly a type operator. It takes $\cdot \prov A : \rset_i$ and returns $G(\lambda s . A) : \rset_i$.
If we have
\[ a : A\prov M : B\ a\]
then what can we yield? We can yield
\[ a' : A \x A \prov \langle [a'.0/a]M, [a'.1/a]M\rangle : (B\ a'.0) \x (B\ a'.1)\]
which can be explained as
\[ a' : FA \prov \lambda s . [a'\ s/a]M : G(\lambda s . [a'\ s/a]B)\]
which, if we have substitution principles like
\[ \Gamma \prov a' : FA \qquad a : A \prov B : \rset \over \Gamma \prov [a'/a]B : F\rset_i\]
\[ \Gamma \prov a' : FA \qquad a : A \prov M : B\ a\over \Gamma \prov [a'/a]M : G([a'/a]B)\]
can be expressed as
\[ a' : FA \prov  [a'/a]M : G([a'/a]B)\]
Ok so if we start with
\[a : A, b : B\ a\prov  M\ a\ b : C\ a\ b\]
we should get
\[a' : G(\lambda s.A), b' : G(\lambda s . B\ (a'\ s)) \prov \lambda s . M\ (a' s)\ (b' s) : G(\lambda s.C\ (a\ s)\ (b\ s))\]
i.e.
\[a' : G([]A), b' : G([a'/a]B) \prov [a'/a][b'/b]M : G([a'/a][b'/b]C)\]
\section{Simpler}
\subsection{Substitutions}
Given a dependent applicative functor $F, G, \ldots$, we define a notion of substitution
and what it means to apply it. These definitions are mutually recursive.

The substitution well-formedness judgment is
\[ \Gamma' \prov_F \theta : \Gamma \]
The substitution principles are
\[ \Gamma' \prov_F \theta : \Gamma \qquad \Gamma \prov B : \rset \over \Gamma' \prov \theta B : F\rset_i\]
\[ \Gamma' \prov_F \theta : \Gamma \qquad \Gamma \prov M : B \over \Gamma' \prov \theta M : G(\theta B)\]
Substitution well-formedness is defined by
\[\cdot \prov_F \cdot : \cdot\]
\[\Gamma' \prov_F \theta : \Gamma \qquad \Gamma' \prov M :  G\theta A
\over
\Gamma' \prov_F \theta[M/x] : (\Gamma, x :A )\]

\subsection{Applying $F$ to contexts}
We simultaneously define what it means to apply $F$ to a context, and what the `identity' substitution is.
Note that applying the identity substitution is not a no-op! It uses the $\eta$ of the applicative functor.
\[F\Gamma \prov \rid_\Gamma : \Gamma \qquad {\Gamma:\rctx \over F\Gamma :\rctx}\]
\[F(\Gamma, x : A) = F\Gamma, x : G(\rid_\Gamma A)\]
\[\rid_{\Gamma, x:A} = \rid_\Gamma[x/x]\]

\subsection{Cases of Substitution}
\subsubsection{Variable Case}
\[(\theta_1[M/x]\theta_2)x\]
\[ \Gamma' \prov_F (\theta_1[M/x]\theta_2) : \Gamma \qquad \Gamma \prov x : A \over \Gamma' \prov (\theta_1[M/x]\theta_2) x : G(\theta_1 A)\]
By inversion, we know $\Gamma = \Gamma_1,x:A,\Gamma_2$ and
 $\Gamma' \prov_F \theta_1 : \Gamma_1$ and $\Gamma' \prov M : G (\theta_1 A)$.
So we define
\[(\theta_1[M/x]\theta_2)x = M\]
 and we're done.
\subsubsection{Pi Case}
\[
\begin{prooftree}
 \Gamma' \prov_F \theta : \Gamma \qquad
\[
 \Gamma, x : A \prov B : \rset_i
\justifies
 \Gamma \prov (x : A) \to B : \rset_i
\]
\justifies
 \Gamma' \prov \theta (x : A) \to B : F\rset_i
\end{prooftree}\]
We can extend $\theta$ with an identity:
\[\Gamma' \prov_F \theta : \Gamma \qquad \Gamma', x : G\theta A \prov x :  G\theta A
\over
\Gamma', x : G\theta A \prov_F \theta[x/x] : (\Gamma, x :A )\]
So by induction hypothesis
\[\Gamma', x : G\theta A \prov \theta[x/x] B : F \rset_i\]
and we want to get from here to
\[\Gamma' \prov ? : F \rset_i\]


I {\em can't} go in general from
\[\qquad \Gamma, x : GA \prov B : F\rset_i\]
to some $\Pi$-type comprehension, because there's nothing to say that $B$ can't
illegally use the wrong parts of the global object $x$. The fact that I'm coordinating
and using $\theta[x/x]$ is important.

The $\btwo$ case would look like
\[z' : G([]Z), a' : G([z'/z]A) \prov [z'/z][a'/a]B : F\rset_i\]
What we have is
\[z': Z \x Z, x' : (A\ z'.0 \x A\ z'.1)\prov  \langle B\ z'.0\ x'.0, B\ z'.1\ x'.1 \rangle : \rset_i \x \rset_i\]
and what we want is
\[z': Z \x Z \prov  \langle (x'.0 : A\ z'.0) \to B\ z'.0\ x'.0, (x'.1 : A\ z'.1) \to B\ z'.1\ x'.1 \rangle : \rset_i \x \rset_i\]

\section{Thinking about Adjoints}

Notice that I have exact agreement that
\[S \to (A_1 \x A_2) \cong (S \to A_1) \x (S \to A_2)\]
but merely
\[S \to (A_1 \to A_2) \to (S \to A_1) \to (S \to A_2)\]
and not the converse. The real meaning of
\[\Gamma \prov M : A\]
under $F = 2 \to \dash$ is not
\[\Gamma_1, \Gamma_2 \prov \langle M_1, M_2\rangle : A_1 \x A_2\]
but more like
\[\langle \Gamma_1 \prov M_1 : A_1, \Gamma_2 \prov M_2 : A_2\rangle\]
I.e. the subject of the judgment is not a map $(\Gamma_1 \x \Gamma_2)  \to (A_1 \x A_2)$
but a map $(\Gamma_1 \to A_1) \x (\Gamma_2 \to A_2)$.
\vfil\eject
\section{Contexts}
\subsection{Contextual Dependent Applicative Functors}
Suppose I have a regular dependent applicative functor $F, G, \ldots$.
We can define simultaneously
\[{\Gamma : \rctx_i \over \prov \Sigma \Gamma : \rset_i}
\qquad
{\Gamma : \rctx_i \qquad \Gamma' \prov M : \Sigma\Gamma \over \Gamma'\prov [M/\Gamma]: \Gamma}\]

\[\Sigma(\cdot) = \top\qquad
\Sigma(\Gamma, x : A)  = (g : \Sigma\Gamma) \x [g/\Gamma] A\]
\[[M/\cdot] = \cdot \qquad
[M/(\Gamma,x:A)] = [M.1/\Gamma][M.2/x]\]
We can then define some convenience syntax
\[
{\Gamma \prov A : \rset_i \over \prov \Gamma.A : \Sigma\Gamma \to \rset_i}
\qquad
{\Pi : (\Sigma\Gamma \to \rset_i) \to \rset_i}
\qquad
{\Gamma \prov M : A \over \prov \Gamma.M : \Pi \Gamma.A}
\]
By saying
\[
(\Gamma.A)\ g = [g/\Gamma]A
\qquad
\Pi\ k = (g : \Sigma\Gamma) \to k\ g
\qquad
(\Gamma.M)\ g :  [g/\Gamma] M
\]
Note that $\Pi\Gamma . A =  (g : \Sigma \Gamma) \to [g/\Gamma]A $, so we could retroactively say that
\[
{\Gamma \prov A : \rset_i \over \prov \Gamma.A : \Pi \Gamma. \rset_i}
\]
A contextual dependent applicative functor consists of
\begin{enumerate}
\item  For every  judgment $\Gamma \prov A : \rset_i$, a type $F_\Gamma A : \rset_i$
\item  For every  judgment $\Gamma \prov M : A$, a term $ \eta_\Gamma M : F_\Gamma A$
\end{enumerate}
We can lift any dependent applicative functor to a contextual one.
We define
\[F_\Gamma A = F(\Pi\Gamma.A)\]
\[\eta_\Gamma M = \eta(\Gamma.M)\]

%% If  $\Gamma \prov A : \rset_i$, then $\Gamma . A : \Pi\Gamma.\rset_i$
%% and $\eta(\Gamma.A) : F(\Pi\Gamma.\rset_i)$.


%% If  $\Gamma \prov M : A$, then $\Gamma . M : \Pi \Gamma . A$
%% and $\eta(\Gamma.M) : F(\Pi\Gamma.A)$.
\subsection{Lifting}
We want to claim that for every (contextual?) dependent applicative functor $F$ there exists
an extension $\bar F$ that lies over it, such that the fiber of $\bar F$ does the appropriate
thing at universes to give relations. We define it as a record type:
\[\bar F A = \{ \partial : F A, \beta : \bd_{A}(\partial)\}\]
with
\[A : \rset_i \over \bd_A : FA \to \rset_i\]
 to be defined later. Our target is that
\[\bd_{\rset_i}(\phi) = G\phi \to \rset_i\]
This is the closed version. For open terms, we hope
\[\bar F_\Gamma A = \{ \partial : F_\Gamma A, \beta : \bd_{\Gamma.A}(\partial)\}\]
and we know that
\[\bd_{\Gamma.A} : F_\Gamma A \to \rset_i\]
So what should we expect when $A = \rset_i$?
\[\bd_{\Gamma.\rset_i} : F_\Gamma \rset_i \to \rset_{i+1}\]
This is a predicate on tuples of types in context. $F_\Gamma\rset_i = F(\Pi \Gamma.\rset_i)$.
So we have to think about how parametricity works for functions. We should require that
for any related tuples at type $\Sigma\Gamma$, we get a relation among the types
that arise from applying the functions in the tuple. So a collection of related tuples
is something of type $\bar F(\Sigma\Gamma)$. If we have an $f : F(\Pi\Gamma.\rset_i)$, we can apply this
to a $\partial x : F(\Sigma\Gamma)$ to get $f \cdot x : F\rset_i$. Then $G(f \cdot x) : \rset_i$. So I think
we want to assert
\[\bd_{\Gamma.\rset_i}\ f = (x : \bar F(\Sigma \Gamma)) \to G(f \cdot x) \to \rset_i\]

But should I have to define this this way? Shouldn't I get all the higher functions for free, out of the
closed definitions of $\bar F, \bar \eta$? Not sure yet. Maybe I need them as induction hypotheses or something.
I should dig into the $\Pi$ and $\lambda$ cases of reflexivity or $\bd$ or whatever.

\subsubsection{Pi}
In the closed case, we have
\[\bd_A : FA \to \rset_i\]
So we should have
\[\bd_{(x:A)\to B} : F((x:A) \to B) \to \rset_i\]
And I want to say that a tuple of functions are related if, for all related input tuples, their outputs are related.

Recall that we have
\[f : F((x : A) \to B(x)) \qquad x : FA \over f \odot x : G (\eta B \cdot x)\]
and we get stuck at
\[\bd_{(x:A)\to B\ x}\ f = (x : \bar FA) \to \bd_{?} (f \cdot \partial x) \]
because there's no single type $\bd_B$ that accepts $FB$ as an argument. What we have is $G(\eta B \cdot x)$.
So would $\bd_{x.B}$ do the trick? Well, $\bd_{x.B} : F_{x:A}B \to \rset_i$. Can we get
from $G(\eta B \cdot x)$ to $F_{x:A} B$? We know $F_{x:A} B = F(\Pi(x:A).B)$. This is back where we started and doesn't let us make any progress.
\end{document}
