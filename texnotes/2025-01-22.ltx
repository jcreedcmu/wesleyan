\documentclass{article}
\usepackage[tmargin=0.15in, bmargin=0.15in]{geometry}
\input{theorem}
\input{prooftree}
\usepackage{relsize}
\usepackage{latexsym}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,cd,decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}
\usepackage{tcolorbox}
\tcbuselibrary{breakable}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}

\def\tel{\mathsf{T}}
\def\bdot{\mathrel{\bar\cdot}}
\def\bodot{\mathrel{\bar\odot}}
\def\dec{\mathsf{\downarrow}}
\def\enc{\mathsf{\uparrow}}
\def\I{\mathbb{I}}
\def\bget{\mathop\mathbf{get}}
\def\bGet{\mathop\mathbf{Get}}
\def\dapt#1#2{#1[\![#2]\!]}
\def\dap#1#2{#1\{#2\}}
\def\ll{\langle\!\langle}
\def\rr{\rangle\!\rangle}
\def\rshape{\ {\mathsf{shape}}}
\def\rrefl{{\mathsf{refl}}}
\def\bd{\mathsf{Bd}}
\def\bdd{\mathsf{Bdd}}
\def\rset{\mathsf{U}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\prequiv{\dashv\vdash}

\definecolor{blu}{rgb}{0.1,0.5,1}
\definecolor{orng}{rgb}{1,0.5,0.3}

\def\El#1{\ulcorner{#1}\urcorner}
\def\U{\mathsf{U}}
\def\uu{\mathsf{u}}
\def\uni{\U}

\def\ridp{\mathsf{idp}}

\definecolor{lred}{rgb}{0.95,0.8,0.8}
\definecolor{cyan}{rgb}{0.80,0.95,0.95}
\definecolor{lorange}{rgb}{0.95,0.90,0.80}
\definecolor{bluegray}{rgb}{0.6,0.6,0.85}
\definecolor{lgray}{gray}{0.8}
\newtcolorbox{declbox}{colframe=lred,colback=lred,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{thmbox}{colframe=cyan,colback=cyan,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{defnbox}{colframe=lorange,colback=lorange,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{tangentbox}{colframe=lgray,colback=lgray,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}

\input{linear}
\def\rpath#1{[#1]}
\def\rfst{\mathsf{fst}\,}
\def\rsnd{\mathsf{snd}\,}
\def\bunfold{\mathbf{unfold}}
\def\bfold{\mathbf{fold}}
\def\susp#1{\langle {#1} \rangle}
\def\ssusp#1{\langle\!\langle {#1} \rangle\!\rangle}
\def\dto{\mathrel{\dot\to}}
\def\dns{{\downarrow}}
\def\ups{{\uparrow}}
\def\sprov{\Vdash}
\def\signat{{\color{red}\Sigma}}
\def\ep#1{\underline{#1}}
\def\wat{{@}}
\def\wwat{\mathbin{\underline\wat}}
\def\cn{{:}}
\def\dv{{\div}}
\def\ww{{\mathsf w}}
\def\base{{\textfrak b}}

\def\N{{\mathbb N}}
\def\Z{{\mathbb Z}}
\def\munit{I}
\def\tt{{\mathsf t}}
\def\ii{{\mathbb I}}
\def\T{\mathbb{T}}
\def\tw{\mathsf{Tw}}
\def\sw#1{^{#1}_{#1}}
\def\TP{\mathbf{TPre}}
\def\pp{\textsf{\textbf p}}
\def\nn{{\mathsf n}}
\def\PP{\textsf{\textbf P}}
\def\NN{\textsf{\textbf N}}
\def\zz{{\mathsf z}}
\def\sem#1{[\![#1]\!]}
\def\usem#1{\lceil\!\!\lceil{#1}\rceil\!\!\rceil}
\def\zem#1{\langle\!\langle#1\rangle\!\rangle}
\def\col#1{{\mathsf{C}}_{#1}}
\def\lax{\mathop\bigcirc}
\def\rjust{\mathsf{just}}
\def\rcvt{\mathsf{cvt}}
\def\rtype{\mathsf{type}}
\def\rdtype{\mathsf{disc}}
\def\rkind{\mathsf{kind}}
\def\rmode{\mathsf{mode}}
\def\rprel{\mathbf{Prel}}
\def\rrfam{\mathbf{Rfam}}
%\def\rset{\mathbf{Set}}
\def\rfinset{\mathbf{FinSet}}
\def\rrel{\mathbf{Rel}}
\def\rcat{\mathbf{Cat}}
\def\rfam{\mathbf{Fam}}
\def\binj{\mathbf{inj}}
\def\rid{\mathsf{id}}
\def\rtrue{\mathrel\mathrm{true}}
\def\pbck{\ar[dr, phantom, pos=0, "\lrcorner"]}
\def\bpbck{\ar[ddrr, phantom, pos=0, "\lrcorner"]}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\btwo{\mathbf{2}}
\def\bone{\mathbf{1}}

\newarrow {Equiv} =====
\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\def\mapt{\ar[ddd,mapsto,shorten <=2em, shorten >=2em]}
\def\A{\mathbf{A}}
\def\B{\mathbf{B}}
\def\C{\mathbf{C}}
\def\G{\mathbf{G}}
\def\D{\mathbf{D}}
\def\DD{\mathbb{D}}
\def\E{\mathbf{E}}
\def\M{\mathbf{M}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\ltri{{\lhd}}
\def\rtri{{\rhd}}
\def\tri{\rhd}
\def\cc{\mathsf{c}}
\def\dd{\mathsf{d}}
\def\o{\circ}
\def\rctx{\,\mathsf{ctx}}
\def\rdctx{\,\mathsf{dctx}}
\def\del{\partial}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\definecolor{fib}{HTML}{ff7f00}
\definecolor{green}{HTML}{007f00}
\definecolor{red}{HTML}{df3f3f}
\definecolor{opfib}{HTML}{007fff}

% For lightening colors I used
% http://trycolors.com/ 6 parts white to 1 part color
\definecolor{opfibl}{HTML}{DBEDFF}
\definecolor{greenl}{HTML}{DBEDDB}
\definecolor{redl}{HTML}{FAE4E4}
\begin{document}

\def\
\tikzset{
   commutative diagrams/.cd,
   arrow style=tikz,
   diagrams={>=stealth}}

\section{Applicative Parametricity}
I notice that the requirements of $\partial\Delta \lol \dash$
and $\Delta \lol \dash$ look a lot like being a `dependent applicative functor'.
Suppose I have
\[F : \rset_i \to \rset_i\]
\[\Gamma : F\rset_i \to \rset_i\]
\[\eta : A \to FA\]
\[{\_\cdot\_} : F(A \to B) \to FA \to FB\]
\[{\_\odot\_} : \{A : \rset_i\} \{B : A \to \rset_i\} \to F((x : A) \to B(x)) \to (a : FA) \to \Gamma (\eta B \cdot a)\]

Probably expect the standard applicative axioms, plus that dependent things degenerate into simply typed
things correctly, i.e.
\[A : \rset_i
\over
\Gamma (\eta A) \equiv FA
\]
\[
B = (\lambda \_ . B_0)\qquad f : A \to B
\over
f \odot x \equiv f \cdot x
\]
An example is the reader applicative for input type $S$,
\[FA = S \to A\]
\[\Gamma\ (A : S \to \rset_i) = (s : S) \to A\ s\]
\[\eta\ a = \lambda\_ . a\]
\[f \cdot x = \lambda s . (f\ s)\ (x\ s)\]
\[f \odot x = \lambda s . (f\ s)\ (x\ s)\]
Then from this data we aim to construct another such object,
\[\bar F : \rset_i \to \rset_i\]
\[\bar \Gamma : \bar F\rset_i \to \rset_i\]
\[\bar \eta : A \to \bar FA\]
\[{\_\bdot\_} : \bar F(A \to B) \to \bar FA \to \bar FB\]
\[{\_\bodot\_} : \{A : \rset_i\} \{B : A \to \rset_i\} \to \bar F((x : A) \to  B(x)) \to (a : \bar FA) \to \bar\Gamma (\bar \eta B \bdot a)\]
%% which lies over $F$ in the sense that there's a map
%% \[\partial : \{A : \rset_i\} \to \bar F A \to F A\]
%% which commutes appropriately with all the operations above.
%% In particular, $\partial (\bar\eta\ a) \equiv \eta $.
Where it will turn out that we choose to define $\bar F$ and $\bar \Gamma$ as record types:
\[\bar F A \equiv \{\partial : F A, \beta : \bd_A(\partial) \}\]
\[\bar \Gamma (C : \bar F \rset_i) \equiv \{\partial : \Gamma(\partial C), \beta : \bdd_{\partial C}(\partial) \}\]
It is our job to define
\[
{A: \rset_i  \over \bd_A : FA \to \rset_i}
\qquad
{C: F \rset_i  \over  \bdd_C : \Gamma C \to  \rset_i}
\]
This will satisfy various nice properties. A central one is
 {\em relativity}, that bridges in the universe are relations:
\[\bd_{\rset_i}(A ) \equiv \Gamma A \to \rset_i\]
Some compatibilities that will be need to be satisfied are
%\[\partial(\bar \Gamma C) \equiv \Gamma (\partial C)\]
\[\partial (\bar \eta a) \equiv \eta a\]
\[\partial(f \mathrel{\bdot} x) \equiv \partial f \cdot \partial x\]
\[\partial(f \bodot x) \equiv \partial f \cdot \partial x\]
Let's suppose $A : \rset_i$. Then
\[\bar\eta A : \bar F \rset_i\]
\[\beta(\bar\eta A) : \bd_{\rset_i}(\partial(\bar\eta A))\]
\[\beta(\bar\eta A) : \bd_{\rset_i}(\eta A)\]
\[\beta(\bar\eta A) : \Gamma(\eta A) \to \rset_i\]
\[\beta(\bar\eta A) : FA \to \rset_i\]
So we can equate
\[\bd_A \equiv \beta(\bar\eta A)\]
For $\bdd$, do I need a higher form of reflexivity?
If
\[\eta : \{A : \rset_i\} \to A \to F A\]
Then maybe
\[\theta : \{C : F\rset_i\} (c : \Gamma C) \to ?\]
Maybe this is where the substitution generalization also needs to happen.
\subsection{Dependent Pairing}
For substitutions below, I think I want some compatibility between $F/\Gamma$ and dependent pairing.
To the signature of a ``dependent applicative functor'' I add the requirements:
whenever $A : \rset_i$ and $B : A \to \rset_i$, we have dependent pairing under $F$:
\[
N : FA \qquad M : \Gamma(\eta B \cdot N)
\over
\ll N, M \rr : F(\Sigma A B)
\]
and also first and second projection:
\[
{M : F(\Sigma A B)
\over
\pi_1 M : F A}
\qquad
{M : F(\Sigma A B)
\over
\pi_2 M : \Gamma (\eta B \cdot \pi_1 M)}
\]


For the example of $\Delta = {\bf S}$, nothing surprising happens with pairing:
\[
A : \rset_i \qquad B : A \to \rset_i \qquad N : S \to A \qquad M : (s :S) \to B (N\ s)
\over
\lambda s . \langle N s, M\ s\rangle  : S \to (\Sigma A B)
\]
Or projections:
\[
{M : S \to (\Sigma A B)
\over
\lambda s . \pi_1 (M\ s) : S \to A}
\qquad
{M : S \to (\Sigma A B)
\over
\lambda s .\pi_2 (M\ s) : (s : S) \to  B  (\pi_1 (M\ s))}
\]
The projections I can probably just obtain from functoriality. Pairing might be a genuinely new requirement.

\subsection{Trying To Imagine Substitutions}
In binary parametricity:

\begin{itemize}
\item  $F$ takes a type $A$ to the type $A \x A$.
\item  $\Gamma$ takes something that lives in $F\rset_i$, e.g.
a pair of types  $\langle A_0,A_1\rangle$ to the type of global sections $A_0 \x A_1$.
\item In general, if we have two telescopes $\Gamma_0, \Gamma_1$, we should
have a way of computing the type of pairs of substitutions $\theta_0 : \Gamma_0, \theta_1 : \Gamma_1$.
\end{itemize}

Let $\tel_i$ be the type of telescopes of maximum universe level $i$.
\[\begin{array}{l}\mathbf{data}\ \tel_i : \N \to  \rset_{i+1}\ \mathbf{where}\\
\qquad \mathsf{nil} : \tel_i\ 0\\
\qquad \mathsf{\_,\_} : (t : \tel_i\ n) \to (\sem{t} \to \rset_j) \to \tel_{i\sqcup j} (n+1)\\
\\
\sem{\_} : \{ n : \N\} \to \tel_i\ n \to \rset_i\\
 \sem{\mathsf{nil}} = \top\\
 \sem{\mathsf{t\ ,\ A}} = \Sigma \sem t A\\
\end{array}\]
\[F : \rset_i \to  \rset_i\]
\[G : F \rset_i \to  \rset_i\]
\[\zeta : \{n : \N\} \to F (\tel_i\ n) \to  \tel_i\ n\]
\[\mathsf{map}F : (A \to B) \to FA \to FB\]
\[Z : \{n : \N\} (x : F (\tel_i\ n)) \to  \sem{\zeta\ x} \cong G(\mathsf{map}F\ \sem\_\ x)\]

Example:
\[\begin{array}{l}
FA = A \x A\\
G\langle A_0, A_1 \rangle = A_0 \x A_1\\
\zeta : \{n : \N\} \to (\tel_i\ n \x \tel_i\ n) \to  \tel_i\ n\\
Z : \{n : \N\} (x : \tel_i\ n \x \tel_i\ n) \to  \sem{\zeta\ x} \cong \sem{x.0} \x \sem{x.1}\\
\zeta {\langle \mathsf{nil}, \mathsf{nil}\rangle} \equiv \mathsf{nil}\\
\zeta \langle (T, A),  (T', A')\rangle \equiv \langle \zeta \langle T, T'\rangle ,  \lambda z : \sem{\zeta \langle T, T'\rangle}.\\
\qquad A ((Z\  \langle T,T'\rangle\ z) .0) \x A' ((Z\  \langle T,T'\rangle\ z) .1)
\rangle
\end{array}\]
In general if $\eta : A \to FA$, then we should expect
\[\zeta (\eta  (\mathsf{nil})) = \mathsf{nil}\]
Then we have something for conses. Let's try to explain the pair case generally.
Imagine we have first of all a pair of teles.
\[T : F(\tel_i n)\]
Then we have a pair of suitable types defined over those teles.
\[(t : F(\tel_i n)) \to \mathsf{map}F\ \sem\_\ t : F\rset_i\]

\subsection{Defining Telescopes Better}
I may not need to apply $F$ to the type of teles. I notice I only ever deal in one $\Gamma$
at a time, but multiple $\theta$. So I may not need to nat-index teles.
\[\begin{array}{l}\mathbf{data}\ \tel_i :   \rset_{i+1}\ \mathbf{where}\\
\qquad \mathsf{nil} : \tel_i\\
\qquad \mathsf{\_::\_} : (t : \tel_i) \to (\sem{t} \to \rset_j) \to \tel_{i\sqcup j}\\
\\
\sem{\_} :  \tel_i \to \rset_i\\
 \sem{\mathsf{nil}} = \top\\
 \sem{\mathsf{t} :: A} = \Sigma \sem t A\\
\end{array}\]

Using tools I already have, I can build up ``tuples of substitutions'' that live in $F \sem t$:
\[
t : \tel_i \qquad  \theta : F\sem{t} \qquad M : \Gamma(\eta A \cdot \theta)
\over
\ll \theta, M\rr : F\sem {t :: A}
\]

To capture bridge-substitutions, I'm going to simultaneously define
a type
\[
t : \tel_i
\over
\bd_t : F\sem t \to \rset_i
\]
and two operations
\[
t : \tel_i \qquad \theta : F\sem{t} \qquad   A : \sem t \to  \rset_i\qquad \phi : \bd_t(\theta)
\over
\phi \bullet A : \Gamma(\eta A \cdot \theta ) \to \rset_i
\]

\[
\begin{array}{c@{\qquad}c@{\qquad}c@{\qquad}c}
&&  A : \sem t \to  \rset_i \\
t : \tel_i & \theta : F\sem{t} &   M : (x : \sem t) \to A\ x  & \phi : \bd_{t}(\theta)
\end{array}
\over
\phi M : ( \phi \bullet A)\ (\eta M \odot \theta)
\]

I could think of bridge substitutions as having the intro rule:
\[
\begin{array}{c@{\qquad}c@{\qquad}c}
t : \tel_i &  \theta : F\sem{t} & M : \Gamma(\eta A \cdot \theta) \\
A: \sem t \to \rset_i &    \phi : \bd_{t}(\theta) & p : (\phi \bullet A)\ (\eta M \odot \theta)
\end{array}
\over
 \langle\phi , p\rangle  : \bd_{t :: A} \ll \theta, M\rr
\]
But this is the same as saying
\[ \bd_\cdot (*) = \top\]
\[ \bd_{t::A}\ N = \Sigma (\phi : \bd_{t}(\pi_1 N) ).(\phi \bullet A)\ (\eta ( \pi_2 N) \odot \pi_1 N)\]


What happens when $t = \mathsf{nil}$? I'm going to assert $F \top \equiv \top$ is part
of $F$ preserving products.
\[
  A :   \rset_i
\over
* \bullet A : F A \to \rset_i
\]

\[
  A :  \rset_i \qquad  M :  A
\over
*  M : (* \bullet A)(\eta M)
\]
As expected, these reduce to having the type of $\bd$ and $\rrefl$.
\subsection{Substitution}
\subsubsection{The Universe}
\[
t : \tel_{i+1} \qquad    \rset_i :   \rset_{i+1}\qquad \phi : \bd_t(\theta)
\over
\phi \bullet \rset_i : F\rset_i  \to \rset_{i+1}
\]
\[(\phi \bullet \rset_i ) A\equiv \Gamma A \to \rset_i\]
\subsubsection{Pi}
\[
\begin{prooftree}
t : \tel_i \qquad \theta : F\sem{t}
\qquad
\[
\tau : \sem t \prov A : \rset_i  \qquad \tau : \sem t, x : A \prov B:  \rset_i
\justifies
(\lambda \tau . (x : A) \to B) : \sem t \to  \rset_i
\]
\qquad \phi : \bd_t(\theta)
\justifies
\phi \bullet (\lambda \tau . (x : A) \to B) : \Gamma(\eta (\lambda \tau . (x : A) \to B) \cdot \theta ) \to \rset_i
\end{prooftree}
\]

Here I'm stuck. I don't know how to apply anything from $\Gamma$. Or wait, maybe I do? Might need dependent pairing.

We start by $\Pi$'ing up $(x : S)$...
\section{What are Dependent Applicative Functors?}
I believe I should have
\[F : \rset_i \to \rset_i\]
\[\Gamma : F\rset_i \to \rset_i\]
\[\eta : A \to FA\]
\[{\_\cdot\_} : F(A \to B) \to FA \to FB\]
\[{\_\odot\_} : \{A : \rset_i\} \{B : A \to \rset_i\} \to F((x : A) \to B(x)) \to (a : FA) \to \Gamma (\eta B \cdot a)\]
\[
\ll\_,\_\rr : (N : FA) \to \Gamma(\eta B \cdot N)\to  F(\Sigma A B)
\]

\section{Different Substitutions}
We can wrap up a $\theta: F\sem t$ and a $\phi:\bd_t(\theta)$ as a tuple
$\psi: \bar F \sem t$. The substitution principles then look like
\def\ss{/\!/}
\[
t : \tel_i \qquad \psi : \bar F\sem{t} \qquad   A : \sem t \to  \rset_i
\over
\psi \ss A : F \rset_i
\]
\[\langle \theta,\phi\rangle \ss A = \eta A \cdot \theta \]
\[
t : \tel_i \qquad \psi : \bar F\sem{t} \qquad   A : \sem t \to  \rset_i
\over
\psi \bullet A : \Gamma(\psi \ss A ) \to \rset_i
\]

\[
\begin{array}{c@{\qquad}c@{\qquad}c@{\qquad}c}
&&  A : \sem t \to  \rset_i \\
t : \tel_i & \psi : \bar F\sem{t} &   M : (x : \sem t) \to A\ x
\end{array}
\over
\psi / M : \psi \ss A
\]

\[\langle \theta,\phi\rangle / M = \eta M \odot \theta\]
\[
\begin{array}{c@{\qquad}c@{\qquad}c@{\qquad}c}
&&  A : \sem t \to  \rset_i \\
t : \tel_i & \psi : \bar F\sem{t} &   M : (x : \sem t) \to A\ x
\end{array}
\over
\psi M : ( \psi \bullet A)\ (\psi / M)
\]
\section{Just Postulate It}
Can we get any mileage out of asserting that for any dependent
applicative functor $F$, there exists a $\bar F$ and an appropriately
nice natural transformation $\partial : \bar F \to F$ whose fibers on $\rset$ are
the appropriate relational thing?

I expect `appropriately nice' includes preserving the function application structure
of the applicative functors. So
\[\_\bdot\_ : \bar F(A \to B) \to \bar FA \to \bar FB \]
\[\_\cdot\_ : F(A \to B) \to FA \to FB \]

\[
\begin{tikzcd}
 \bar F(A \to B) \x \bar FA\ar[r]\ar[d,"{\partial\x\partial}",swap]& \bar FB\ar[d]\\
 F(A \to B)\x FA\ar[r]&   FB
\end{tikzcd}
\]
Hm, the diagram commuting is enough to push forward, but I expect more of a UMP. Are
products any easier to think about?

What do I know about $FA \x FB$ versus $F(A \x B)$? They're not necessarily iso.
Consider the list monad to see why not.

If I have an element $\bar F A$ and an element $\bar F B$, then I should have an
element $\bar F(A \x B)$.

\end{document}
