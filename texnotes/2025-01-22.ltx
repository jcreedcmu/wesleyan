\documentclass{article}
\usepackage[tmargin=0.15in, bmargin=0.15in]{geometry}
\input{theorem}
\input{prooftree}
\usepackage{relsize}
\usepackage{latexsym}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,cd,decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}
\usepackage{tcolorbox}
\tcbuselibrary{breakable}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}

\def\tel{\mathsf{T}}
\def\bdot{\mathrel{\bar\cdot}}
\def\bodot{\mathrel{\bar\odot}}
\def\dec{\mathsf{\downarrow}}
\def\enc{\mathsf{\uparrow}}
\def\I{\mathbb{I}}
\def\bget{\mathop\mathbf{get}}
\def\bGet{\mathop\mathbf{Get}}
\def\dapt#1#2{#1[\![#2]\!]}
\def\dap#1#2{#1\{#2\}}
\def\ll{\langle\!\langle}
\def\rr{\rangle\!\rangle}
\def\rshape{\ {\mathsf{shape}}}
\def\rrefl{{\mathsf{refl}}}
\def\bd{\mathsf{Bd}}
\def\bdd{\mathsf{Bdd}}
\def\rset{\mathsf{U}}
\def\rid{\mathsf{Id}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\prequiv{\dashv\vdash}

\definecolor{blu}{rgb}{0.1,0.5,1}
\definecolor{orng}{rgb}{1,0.5,0.3}

\def\El#1{\ulcorner{#1}\urcorner}
\def\U{\mathsf{U}}
\def\uu{\mathsf{u}}
\def\uni{\U}



\definecolor{lred}{rgb}{0.95,0.8,0.8}
\definecolor{cyan}{rgb}{0.80,0.95,0.95}
\definecolor{lorange}{rgb}{0.95,0.90,0.80}
\definecolor{bluegray}{rgb}{0.6,0.6,0.85}
\definecolor{lgray}{gray}{0.8}
\newtcolorbox{declbox}{colframe=lred,colback=lred,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{thmbox}{colframe=cyan,colback=cyan,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{defnbox}{colframe=lorange,colback=lorange,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{tangentbox}{colframe=lgray,colback=lgray,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}

\input{linear}
\def\rpath#1{[#1]}
\def\rfst{\mathsf{fst}\,}
\def\rsnd{\mathsf{snd}\,}
\def\bunfold{\mathbf{unfold}}
\def\bfold{\mathbf{fold}}
\def\susp#1{\langle {#1} \rangle}
\def\ssusp#1{\langle\!\langle {#1} \rangle\!\rangle}
\def\dto{\mathrel{\dot\to}}
\def\dns{{\downarrow}}
\def\ups{{\uparrow}}
\def\sprov{\Vdash}
\def\signat{{\color{red}\Sigma}}
\def\ep#1{\underline{#1}}
\def\wat{{@}}
\def\wwat{\mathbin{\underline\wat}}
\def\cn{{:}}
\def\dv{{\div}}
\def\ww{{\mathsf w}}
\def\base{{\textfrak b}}

\def\N{{\mathbb N}}
\def\Z{{\mathbb Z}}
\def\munit{I}
\def\tt{{\mathsf t}}
\def\ii{{\mathbb I}}
\def\T{\mathbb{T}}
\def\tw{\mathsf{Tw}}
\def\sw#1{^{#1}_{#1}}
\def\TP{\mathbf{TPre}}
\def\pp{\textsf{\textbf p}}
\def\nn{{\mathsf n}}
\def\PP{\textsf{\textbf P}}
\def\NN{\textsf{\textbf N}}
\def\zz{{\mathsf z}}
\def\sem#1{[\![#1]\!]}
\def\usem#1{\lceil\!\!\lceil{#1}\rceil\!\!\rceil}
\def\zem#1{\langle\!\langle#1\rangle\!\rangle}
\def\col#1{{\mathsf{C}}_{#1}}
\def\lax{\mathop\bigcirc}
\def\rjust{\mathsf{just}}
\def\rcvt{\mathsf{cvt}}
\def\rtype{\mathsf{type}}
\def\rdtype{\mathsf{disc}}
\def\rkind{\mathsf{kind}}
\def\rmode{\mathsf{mode}}
\def\rprel{\mathbf{Prel}}
\def\rrfam{\mathbf{Rfam}}
%\def\rset{\mathbf{Set}}
\def\rfinset{\mathbf{FinSet}}
\def\rrel{\mathbf{Rel}}
\def\rcat{\mathbf{Cat}}
\def\rfam{\mathbf{Fam}}
\def\binj{\mathbf{inj}}
\def\rtrue{\mathrel\mathrm{true}}
\def\pbck{\ar[dr, phantom, pos=0, "\lrcorner"]}
\def\bpbck{\ar[ddrr, phantom, pos=0, "\lrcorner"]}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\btwo{\mathbf{2}}
\def\bone{\mathbf{1}}

\newarrow {Equiv} =====
\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\def\mapt{\ar[ddd,mapsto,shorten <=2em, shorten >=2em]}
\def\A{\mathbf{A}}
\def\B{\mathbf{B}}
\def\C{\mathbf{C}}
\def\G{\mathbf{G}}
\def\D{\mathbf{D}}
\def\DD{\mathbb{D}}
\def\E{\mathbf{E}}
\def\M{\mathbf{M}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\ltri{{\lhd}}
\def\rtri{{\rhd}}
\def\tri{\rhd}
\def\cc{\mathsf{c}}
\def\dd{\mathsf{d}}
\def\o{\circ}
\def\rctx{\,\mathsf{ctx}}
\def\rdctx{\,\mathsf{dctx}}
\def\del{\partial}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\definecolor{fib}{HTML}{ff7f00}
\definecolor{green}{HTML}{007f00}
\definecolor{red}{HTML}{df3f3f}
\definecolor{opfib}{HTML}{007fff}

% For lightening colors I used
% http://trycolors.com/ 6 parts white to 1 part color
\definecolor{opfibl}{HTML}{DBEDFF}
\definecolor{greenl}{HTML}{DBEDDB}
\definecolor{redl}{HTML}{FAE4E4}
\begin{document}

\def\
\tikzset{
   commutative diagrams/.cd,
   arrow style=tikz,
   diagrams={>=stealth}}

\section{Applicative Parametricity}
I notice that the requirements of $\partial\Delta \lol \dash$
and $\Delta \lol \dash$ look a lot like being a `dependent applicative functor'.
Suppose I have
\[F : \rset_i \to \rset_i\]
\[\Gamma : F\rset_i \to \rset_i\]
\[\eta : A \to FA\]
\[{\_\cdot\_} : F(A \to B) \to FA \to FB\]
\[{\_\odot\_} : \{A : \rset_i\} \{B : A \to \rset_i\} \to F((x : A) \to B(x)) \to (a : FA) \to \Gamma (\eta B \cdot a)\]

Probably expect the standard applicative axioms, plus that dependent things degenerate into simply typed
things correctly, i.e.
\[A : \rset_i
\over
\Gamma (\eta A) \equiv FA
\]
\[
B = (\lambda \_ . B_0)\qquad f : A \to B
\over
f \odot x \equiv f \cdot x
\]
An example is the reader applicative for input type $S$,
\[FA = S \to A\]
\[\Gamma\ (A : S \to \rset_i) = (s : S) \to A\ s\]
\[\eta\ a = \lambda\_ . a\]
\[f \cdot x = \lambda s . (f\ s)\ (x\ s)\]
\[f \odot x = \lambda s . (f\ s)\ (x\ s)\]
Then from this data we aim to construct another such object,
\[\bar F : \rset_i \to \rset_i\]
\[\bar \Gamma : \bar F\rset_i \to \rset_i\]
\[\bar \eta : A \to \bar FA\]
\[{\_\bdot\_} : \bar F(A \to B) \to \bar FA \to \bar FB\]
\[{\_\bodot\_} : \{A : \rset_i\} \{B : A \to \rset_i\} \to \bar F((x : A) \to  B(x)) \to (a : \bar FA) \to \bar\Gamma (\bar \eta B \bdot a)\]
%% which lies over $F$ in the sense that there's a map
%% \[\partial : \{A : \rset_i\} \to \bar F A \to F A\]
%% which commutes appropriately with all the operations above.
%% In particular, $\partial (\bar\eta\ a) \equiv \eta $.
Where it will turn out that we choose to define $\bar F$ and $\bar \Gamma$ as record types:
\[\bar F A \equiv \{\partial : F A, \beta : \bd_A(\partial) \}\]
\[\bar \Gamma (C : \bar F \rset_i) \equiv \{\partial : \Gamma(\partial C), \beta : \bdd_{ C}(\partial) \}\]
It is our job to define
\[
{A: \rset_i  \over \bd_A : FA \to \rset_i}
\qquad
{C: \bar F \rset_i  \over  \bdd_C : \Gamma(\partial C) \to  \rset_i}
\]
This will satisfy various nice properties. A central one is
 {\em relativity}, that bridges in the universe are relations:
\[\bd_{\rset_i}(A ) \equiv \Gamma A \to \rset_i\]
Some compatibilities that will be need to be satisfied are
%\[\partial(\bar \Gamma C) \equiv \Gamma (\partial C)\]
\[\partial (\bar \eta a) \equiv \eta a\]
\[\partial(f \mathrel{\bdot} x) \equiv \partial f \cdot \partial x\]
\[\partial(f \bodot x) \equiv \partial f \cdot \partial x\]
Let's suppose $A : \rset_i$. Then
\[\bar\eta A : \bar F \rset_i\]
\[\beta(\bar\eta A) : \bd_{\rset_i}(\partial(\bar\eta A))\]
\[\beta(\bar\eta A) : \bd_{\rset_i}(\eta A)\]
\[\beta(\bar\eta A) : \Gamma(\eta A) \to \rset_i\]
\[\beta(\bar\eta A) : FA \to \rset_i\]
So we can equate
\[\bd_A \equiv \beta(\bar\eta A)\]
For $\bdd$, do I need a higher form of reflexivity? Maybe not.
Can I just say
\[\bdd_C = \beta C\]
For
\[\bar F \rset_i = \{ \partial : F \rset_i , \beta : \bd_{\rset_i}(\partial)\}\]
\[ C : \bar F \rset_i\]
which together mean
\[\beta C : \bd_{\rset_i}(\partial C)\]
\[\beta C : \Gamma(\partial C) \to \rset_i\]

\subsection{Dependent Pairing}
For substitutions below, I think I want some compatibility between $F/\Gamma$ and dependent pairing.
To the signature of a ``dependent applicative functor'' I add the requirements:
whenever $A : \rset_i$ and $B : A \to \rset_i$, we have dependent pairing under $F$:
\[
N : FA \qquad M : \Gamma(\eta B \cdot N)
\over
\ll N, M \rr : F(\Sigma A B)
\]
and also first and second projection:
\[
{M : F(\Sigma A B)
\over
\pi_1 M : F A}
\qquad
{M : F(\Sigma A B)
\over
\pi_2 M : \Gamma (\eta B \cdot \pi_1 M)}
\]


For the example of $\Delta = {\bf S}$, nothing surprising happens with pairing:
\[
A : \rset_i \qquad B : A \to \rset_i \qquad N : S \to A \qquad M : (s :S) \to B (N\ s)
\over
\lambda s . \langle N s, M\ s\rangle  : S \to (\Sigma A B)
\]
Or projections:
\[
{M : S \to (\Sigma A B)
\over
\lambda s . \pi_1 (M\ s) : S \to A}
\qquad
{M : S \to (\Sigma A B)
\over
\lambda s .\pi_2 (M\ s) : (s : S) \to  B  (\pi_1 (M\ s))}
\]
The projections I can probably just obtain from functoriality. Pairing might be a genuinely new requirement.

\subsection{Trying To Imagine Substitutions}
In binary parametricity:

\begin{itemize}
\item  $F$ takes a type $A$ to the type $A \x A$.
\item  $\Gamma$ takes something that lives in $F\rset_i$, e.g.
a pair of types  $\langle A_0,A_1\rangle$ to the type of global sections $A_0 \x A_1$.
\item In general, if we have two telescopes $\Gamma_0, \Gamma_1$, we should
have a way of computing the type of pairs of substitutions $\theta_0 : \Gamma_0, \theta_1 : \Gamma_1$.
\end{itemize}

Let $\tel_i$ be the type of telescopes of maximum universe level $i$.
\[\begin{array}{l}\mathbf{data}\ \tel_i : \N \to  \rset_{i+1}\ \mathbf{where}\\
\qquad \mathsf{nil} : \tel_i\ 0\\
\qquad \mathsf{\_,\_} : (t : \tel_i\ n) \to (\sem{t} \to \rset_j) \to \tel_{i\sqcup j} (n+1)\\
\\
\sem{\_} : \{ n : \N\} \to \tel_i\ n \to \rset_i\\
 \sem{\mathsf{nil}} = \top\\
 \sem{\mathsf{t\ ,\ A}} = \Sigma \sem t A\\
\end{array}\]
\[F : \rset_i \to  \rset_i\]
\[G : F \rset_i \to  \rset_i\]
\[\zeta : \{n : \N\} \to F (\tel_i\ n) \to  \tel_i\ n\]
\[\mathsf{map}F : (A \to B) \to FA \to FB\]
\[Z : \{n : \N\} (x : F (\tel_i\ n)) \to  \sem{\zeta\ x} \cong G(\mathsf{map}F\ \sem\_\ x)\]

Example:
\[\begin{array}{l}
FA = A \x A\\
G\langle A_0, A_1 \rangle = A_0 \x A_1\\
\zeta : \{n : \N\} \to (\tel_i\ n \x \tel_i\ n) \to  \tel_i\ n\\
Z : \{n : \N\} (x : \tel_i\ n \x \tel_i\ n) \to  \sem{\zeta\ x} \cong \sem{x.0} \x \sem{x.1}\\
\zeta {\langle \mathsf{nil}, \mathsf{nil}\rangle} \equiv \mathsf{nil}\\
\zeta \langle (T, A),  (T', A')\rangle \equiv \langle \zeta \langle T, T'\rangle ,  \lambda z : \sem{\zeta \langle T, T'\rangle}.\\
\qquad A ((Z\  \langle T,T'\rangle\ z) .0) \x A' ((Z\  \langle T,T'\rangle\ z) .1)
\rangle
\end{array}\]
In general if $\eta : A \to FA$, then we should expect
\[\zeta (\eta  (\mathsf{nil})) = \mathsf{nil}\]
Then we have something for conses. Let's try to explain the pair case generally.
Imagine we have first of all a pair of teles.
\[T : F(\tel_i n)\]
Then we have a pair of suitable types defined over those teles.
\[(t : F(\tel_i n)) \to \mathsf{map}F\ \sem\_\ t : F\rset_i\]

\subsection{Defining Telescopes Better}
I may not need to apply $F$ to the type of teles. I notice I only ever deal in one $\Gamma$
at a time, but multiple $\theta$. So I may not need to nat-index teles.
\[\begin{array}{l}\mathbf{data}\ \tel_i :   \rset_{i+1}\ \mathbf{where}\\
\qquad \mathsf{nil} : \tel_i\\
\qquad \mathsf{\_::\_} : (t : \tel_i) \to (\sem{t} \to \rset_j) \to \tel_{i\sqcup j}\\
\\
\sem{\_} :  \tel_i \to \rset_i\\
 \sem{\mathsf{nil}} = \top\\
 \sem{\mathsf{t} :: A} = \Sigma \sem t A\\
\end{array}\]

Using tools I already have, I can build up ``tuples of substitutions'' that live in $F \sem t$:
\[
t : \tel_i \qquad  \theta : F\sem{t} \qquad M : \Gamma(\eta A \cdot \theta)
\over
\ll \theta, M\rr : F\sem {t :: A}
\]

To capture bridge-substitutions, I'm going to simultaneously define
a type
\[
t : \tel_i
\over
\bd_t : F\sem t \to \rset_i
\]
and two operations
\[
t : \tel_i \qquad \theta : F\sem{t} \qquad   A : \sem t \to  \rset_i\qquad \phi : \bd_t(\theta)
\over
\phi \bullet A : \Gamma(\eta A \cdot \theta ) \to \rset_i
\]

\[
\begin{array}{c@{\qquad}c@{\qquad}c@{\qquad}c}
&&  A : \sem t \to  \rset_i \\
t : \tel_i & \theta : F\sem{t} &   M : (x : \sem t) \to A\ x  & \phi : \bd_{t}(\theta)
\end{array}
\over
\phi M : ( \phi \bullet A)\ (\eta M \odot \theta)
\]

I could think of bridge substitutions as having the intro rule:
\[
\begin{array}{c@{\qquad}c@{\qquad}c}
t : \tel_i &  \theta : F\sem{t} & M : \Gamma(\eta A \cdot \theta) \\
A: \sem t \to \rset_i &    \phi : \bd_{t}(\theta) & p : (\phi \bullet A)\ (\eta M \odot \theta)
\end{array}
\over
 \langle\phi , p\rangle  : \bd_{t :: A} \ll \theta, M\rr
\]
But this is the same as saying
\[ \bd_\cdot (*) = \top\]
\[ \bd_{t::A}\ N = \Sigma (\phi : \bd_{t}(\pi_1 N) ).(\phi \bullet A)\ (\eta ( \pi_2 N) \odot \pi_1 N)\]


What happens when $t = \mathsf{nil}$? I'm going to assert $F \top \equiv \top$ is part
of $F$ preserving products.
\[
  A :   \rset_i
\over
* \bullet A : F A \to \rset_i
\]

\[
  A :  \rset_i \qquad  M :  A
\over
*  M : (* \bullet A)(\eta M)
\]
As expected, these reduce to having the type of $\bd$ and $\rrefl$.
\subsection{Substitution}
\subsubsection{The Universe}
\[
t : \tel_{i+1} \qquad    \rset_i :   \rset_{i+1}\qquad \phi : \bd_t(\theta)
\over
\phi \bullet \rset_i : F\rset_i  \to \rset_{i+1}
\]
\[(\phi \bullet \rset_i ) A\equiv \Gamma A \to \rset_i\]
\subsubsection{Pi}
\[
\begin{prooftree}
t : \tel_i \qquad \theta : F\sem{t}
\qquad
\[
\tau : \sem t \prov A : \rset_i  \qquad \tau : \sem t, x : A \prov B:  \rset_i
\justifies
(\lambda \tau . (x : A) \to B) : \sem t \to  \rset_i
\]
\qquad \phi : \bd_t(\theta)
\justifies
\phi \bullet (\lambda \tau . (x : A) \to B) : \Gamma(\eta (\lambda \tau . (x : A) \to B) \cdot \theta ) \to \rset_i
\end{prooftree}
\]

Here I'm stuck. I don't know how to apply anything from $\Gamma$. Or wait, maybe I do? Might need dependent pairing.

We start by $\Pi$'ing up $(x : S)$...
\section{What are Dependent Applicative Functors?}
I believe I should have
\[F : \rset_i \to \rset_i\]
\[\Gamma : F\rset_i \to \rset_i\]
\[\eta : A \to FA\]
\[{\_\cdot\_} : F(A \to B) \to FA \to FB\]
\[{\_\odot\_} : \{A : \rset_i\} \{B : A \to \rset_i\} \to F((x : A) \to B(x)) \to (a : FA) \to \Gamma (\eta B \cdot a)\]
\[
\ll\_,\_\rr : (N : FA) \to \Gamma(\eta B \cdot N)\to  F(\Sigma A B)
\]

\section{Different Substitutions}
We can wrap up a $\theta: F\sem t$ and a $\phi:\bd_t(\theta)$ as a tuple
$\psi: \bar F \sem t$. The substitution principles then look like
\def\ss{/\!/}
\[
t : \tel_i \qquad \psi : \bar F\sem{t} \qquad   A : \sem t \to  \rset_i
\over
\psi \ss A : F \rset_i
\]
\[\langle \theta,\phi\rangle \ss A = \eta A \cdot \theta \]
\[
t : \tel_i \qquad \psi : \bar F\sem{t} \qquad   A : \sem t \to  \rset_i
\over
\psi \bullet A : \Gamma(\psi \ss A ) \to \rset_i
\]

\[
\begin{array}{c@{\qquad}c@{\qquad}c@{\qquad}c}
&&  A : \sem t \to  \rset_i \\
t : \tel_i & \psi : \bar F\sem{t} &   M : (x : \sem t) \to A\ x
\end{array}
\over
\psi / M : \psi \ss A
\]

\[\langle \theta,\phi\rangle / M = \eta M \odot \theta\]
\[
\begin{array}{c@{\qquad}c@{\qquad}c@{\qquad}c}
&&  A : \sem t \to  \rset_i \\
t : \tel_i & \psi : \bar F\sem{t} &   M : (x : \sem t) \to A\ x
\end{array}
\over
\psi M : ( \psi \bullet A)\ (\psi / M)
\]
\section{Just Postulate It}
Can we get any mileage out of asserting that for any dependent
applicative functor $F$, there exists a $\bar F$ and an appropriately
nice natural transformation $\partial : \bar F \to F$ whose fibers on $\rset$ are
the appropriate relational thing?

I expect `appropriately nice' includes preserving the function application structure
of the applicative functors. So
\[\_\bdot\_ : \bar F(A \to B) \to \bar FA \to \bar FB \]
\[\_\cdot\_ : F(A \to B) \to FA \to FB \]

\[
\begin{tikzcd}
 \bar F(A \to B) \x \bar FA\ar[r]\ar[d,"{\partial\x\partial}",swap]& \bar FB\ar[d]\\
 F(A \to B)\x FA\ar[r]&   FB
\end{tikzcd}
\]
Hm, the diagram commuting is enough to push forward, but I expect more of a UMP. Are
products any easier to think about?

What do I know about $FA \x FB$ versus $F(A \x B)$? They're not necessarily iso.
Consider the list monad to see why not.

If I have an element $\bar F A$ and an element $\bar F B$, then I should have an
element $\bar F(A \x B)$.

\section{What If I Zip Functor Along Substitutions}

I'd like to retain more of the `syntactic' character of contexts and substitutions if possible.
Instead of converting them to types and terms eagerly, maybe I can say, given a dependent applicative
functor $F$, that $F$ applied to a context yields another context:

We have:
\[ \Gamma \prov A : \rset_i \over \Gamma \prov FA : \rset_i\]
\[ \Gamma \prov A : F \rset_i \over \Gamma \prov G A : \rset_i\]
\[ \eta : \{A : \rset_i\} \to A \to FA\]
\[{\_\cdot\_} : \{A : \rset_i\} \{B : A \to \rset_i\} \to F(A \to B) \to FA \to F B \]
\[{\_\odot\_} : \{A : \rset_i\} \{B : A \to \rset_i\} \to F((x : A) \to B(x)) \to (a : FA) \to G (\eta B \cdot a)\]
\[G\eta A \equiv A\]

We simultaneously define
\[{\prov \Gamma : \rctx
\over
\prov F \Gamma : \rctx}
\qquad
{\Gamma \prov M : A
\over
F \Gamma \prov \eta_\Gamma M :   F_\Gamma A}
\qquad
{\Gamma \prov  A : \rset_i
\over
F \Gamma \prov F_\Gamma A :   \rset_i}
\qquad
{F\Gamma \prov  A : F\rset_i
\over
F \Gamma \prov G_\Gamma A :  \rset_i}
\]
%% \[\color{gray}F\Gamma \prov M : F_\Gamma(A \to B) \qquad F\Gamma \prov N : F_\Gamma A
%% \over
%% F\Gamma \prov M \cdot N : F_\Gamma B\]
\[F\Gamma \prov M : F_\Gamma((x : A) \to B) \qquad F\Gamma \prov N : F_\Gamma A
\over
F\Gamma \prov M \odot_\Gamma N : G_\Gamma([N/x]\eta_{\Gamma,x:A} B)\]
\[
F\Gamma \prov M : F_\Gamma A
\over
F\Gamma, x : F_\Gamma B \prov \enc M : F_{\Gamma,x :B} A
\]
by
\[F\cdot = \cdot\]
\[F(\Gamma, x : A) = F\Gamma, x : F_\Gamma A\]
\[\eta_{\cdot}(M) = \eta M \]
\[\eta_{\Gamma, x : A}(M) = \eta_\Gamma(\lambda x.M) \odot_{\Gamma,x:A} x\]
%\[\theta_{\Gamma, x : A} = \theta_\Gamma[\eta_\Gamma(x)/x]\]
\[F_{\cdot} B = F B\]
\[F_{\Gamma, x : A} B = ?\]
\[G_{\cdot} B = G B\]
\[G_{\Gamma, x : A} B = ?\]
\vskip1em
\[F_{\Gamma} A \equiv G_\Gamma \eta_\Gamma A\]
{\bf Proof}: We must show
\begin{enumerate}
\item
  \[{\prov (\Gamma, x : A) : \rctx
    \over
    \prov  F\Gamma, x : F_\Gamma A : \rctx}
  \]
Follows by i.h. and appeal to (3)

\item
It suffices to show
  \[
    {\Gamma, y : A \prov M : B
      \over
      F\Gamma, x : F_\Gamma A \prov \eta_\Gamma(\lambda y.M) \odot x :   F_{\Gamma,x:A} [x/y] B}
    \]
We can apply weakening and function introduction to get
\[\Gamma, x : A \prov \lambda y . M : (y : A) \to B\]
Applying i.h. gives us
\[F\Gamma, x : F_\Gamma A \prov \eta_{\Gamma, x: A}(\lambda y .M) : F_{\Gamma,x:A}((y : A) \to B)\]
By variable use and weakening we have
\[F\Gamma, x : F_\Gamma A \prov \enc x : F_{\Gamma, x:A} A\]

Write $\bar \Gamma$ for $F(\Gamma, x : A) \equiv F\Gamma, x : F_\Gamma A$.
Now we can derive
\[\bar \Gamma \prov \eta_{\Gamma, x: A}(\lambda y . M) : F_{\Gamma, x : A}((y : A) \to B) \qquad \bar \Gamma \prov  \enc x : F_{\Gamma, x:A} A
\over
\bar \Gamma \prov \eta_{\Gamma, x: A}(\lambda y . M) \odot \enc x : G_{\Gamma, x : A}([\enc x/y] \eta_{\Gamma,x:A,y:A} B)\]
Now as long as
\[\eta_{\Gamma, x: A}(\lambda y . M) \odot \enc x \equiv \eta_\Gamma(\lambda y.M) \odot x\]
\[G_{\Gamma, x : A}([\enc x/y] \eta_{\Gamma,x:A,y:A} B) \equiv   F_{\Gamma,x:A} [x/y] B\]
which I expect, we're done.

\item
We must show
\[\Gamma, x : A \prov  B : \rset_i
\over
F \Gamma, x : F_\Gamma A \prov F_{\Gamma, x:A} B :   \rset_i\]

We have
\[F\Gamma, x : \Gamma_F A \prov  \eta_{\Gamma, x:A} B : F_\Gamma \rset_i\]
which should be the same by unproven lemma as
\[F\Gamma, x : \Gamma_F A \prov  \eta_{\Gamma, x:A} B : F\rset_i\]
\item
We must show
\[F\Gamma, x : F_A \prov  B :F_{\Gamma, x: A}\rset_i
\over
F \Gamma \prov G_{\Gamma, x: A} B :  \rset_i\]
\end{enumerate}

In the $\bf 2$ case:
\[\Gamma, x : A \prov  B : \rset_i
\over
F \Gamma, x : (A\ \Gamma.0) \x (A\ \Gamma_1) \prov  (B\ \Gamma.0\ x.0) \x (B\ \Gamma.1\ x.1) :   \rset_i\]

\subsection{Example for $\btwo$}
\[a : A \prov M\ a : B\ a\]
\[a_0\ a_1 : A \prov \langle M\ a_0, M\ a_1\rangle : B\ a_0 \x B\ a_1\]

\[a : A, b : B\ a, c : C\ a\ b \prov  M\ a\ b\ c : D\ a\ b\ c\]
\[a : G(\lambda s.A), b : G(\lambda s . B\ (a\ s)), c : G(\lambda s. C\ (a\ s)\ (b\ s)) \prov \lambda s . M : G(\lambda s.D\ (a\ s)\ (b\ s)\ (c\ s))\]

\[a' : F_\cdot A, b' : F_{a:A}(B\ a), c' : F_{a:A,b:B}(C\ a\ b) \prov  \eta_{a:A,b:B,c:C}(M\ a\ b\ c) : F_{a:A,b:B,c:C}(D\ a\ b\ c)\]
Here $F_\cdot A = FA$ is truly a type operator. It takes $\cdot \prov A : \rset_i$ and returns $G(\lambda s . A) : \rset_i$.
If we have
\[ a : A\prov M : B\ a\]
then what can we yield? We can yield
\[ a' : A \x A \prov \langle [a'.0/a]M, [a'.1/a]M\rangle : (B\ a'.0) \x (B\ a'.1)\]
which can be explained as
\[ a' : FA \prov \lambda s . [a'\ s/a]M : G(\lambda s . [a'\ s/a]B)\]
which, if we have substitution principles like
\[ \Gamma \prov a' : FA \qquad a : A \prov B : \rset \over \Gamma \prov [a'/a]B : F\rset_i\]
\[ \Gamma \prov a' : FA \qquad a : A \prov M : B\ a\over \Gamma \prov [a'/a]M : G([a'/a]B)\]
can be expressed as
\[ a' : FA \prov  [a'/a]M : G([a'/a]B)\]
Ok so if we start with
\[a : A, b : B\ a\prov  M\ a\ b : C\ a\ b\]
we should get
\[a' : G(\lambda s.A), b' : G(\lambda s . B\ (a'\ s)) \prov \lambda s . M\ (a' s)\ (b' s) : G(\lambda s.C\ (a\ s)\ (b\ s))\]
i.e.
\[a' : G([]A), b' : G([a'/a]B) \prov [a'/a][b'/b]M : G([a'/a][b'/b]C)\]
\section{Simpler}
\subsection{Substitutions}
Given a dependent applicative functor $F, G, \ldots$, we define a notion of substitution
and what it means to apply it. These definitions are mutually recursive.

The substitution well-formedness judgment is
\[ \Gamma' \prov_F \theta : \Gamma \]
The substitution principles are
\[ \Gamma' \prov_F \theta : \Gamma \qquad \Gamma \prov B : \rset \over \Gamma' \prov \theta B : F\rset_i\]
\[ \Gamma' \prov_F \theta : \Gamma \qquad \Gamma \prov M : B \over \Gamma' \prov \theta M : G(\theta B)\]
Substitution well-formedness is defined by
\[\cdot \prov_F \cdot : \cdot\]
\[\Gamma' \prov_F \theta : \Gamma \qquad \Gamma' \prov M :  G\theta A
\over
\Gamma' \prov_F \theta[M/x] : (\Gamma, x :A )\]

\subsection{Applying $F$ to contexts}
We simultaneously define what it means to apply $F$ to a context, and what the `identity' substitution is.
Note that applying the identity substitution is not a no-op! It uses the $\eta$ of the applicative functor.
\[F\Gamma \prov \rid_\Gamma : \Gamma \qquad {\Gamma:\rctx \over F\Gamma :\rctx}\]
\[F(\Gamma, x : A) = F\Gamma, x : G(\rid_\Gamma A)\]
\[\rid_{\Gamma, x:A} = \rid_\Gamma[x/x]\]

\subsection{Cases of Substitution}
\subsubsection{Variable Case}
\[(\theta_1[M/x]\theta_2)x\]
\[ \Gamma' \prov_F (\theta_1[M/x]\theta_2) : \Gamma \qquad \Gamma \prov x : A \over \Gamma' \prov (\theta_1[M/x]\theta_2) x : G(\theta_1 A)\]
By inversion, we know $\Gamma = \Gamma_1,x:A,\Gamma_2$ and
 $\Gamma' \prov_F \theta_1 : \Gamma_1$ and $\Gamma' \prov M : G (\theta_1 A)$.
So we define
\[(\theta_1[M/x]\theta_2)x = M\]
 and we're done.
\subsubsection{Pi Case}
\[
\begin{prooftree}
 \Gamma' \prov_F \theta : \Gamma \qquad
\[
 \Gamma, x : A \prov B : \rset_i
\justifies
 \Gamma \prov (x : A) \to B : \rset_i
\]
\justifies
 \Gamma' \prov \theta (x : A) \to B : F\rset_i
\end{prooftree}\]
We can extend $\theta$ with an identity:
\[\Gamma' \prov_F \theta : \Gamma \qquad \Gamma', x : G\theta A \prov x :  G\theta A
\over
\Gamma', x : G\theta A \prov_F \theta[x/x] : (\Gamma, x :A )\]
So by induction hypothesis
\[\Gamma', x : G\theta A \prov \theta[x/x] B : F \rset_i\]
and we want to get from here to
\[\Gamma' \prov ? : F \rset_i\]


I {\em can't} go in general from
\[\qquad \Gamma, x : GA \prov B : F\rset_i\]
to some $\Pi$-type comprehension, because there's nothing to say that $B$ can't
illegally use the wrong parts of the global object $x$. The fact that I'm coordinating
and using $\theta[x/x]$ is important.

The $\btwo$ case would look like
\[z' : G([]Z), a' : G([z'/z]A) \prov [z'/z][a'/a]B : F\rset_i\]
What we have is
\[z': Z \x Z, x' : (A\ z'.0 \x A\ z'.1)\prov  \langle B\ z'.0\ x'.0, B\ z'.1\ x'.1 \rangle : \rset_i \x \rset_i\]
and what we want is
\[z': Z \x Z \prov  \langle (x'.0 : A\ z'.0) \to B\ z'.0\ x'.0, (x'.1 : A\ z'.1) \to B\ z'.1\ x'.1 \rangle : \rset_i \x \rset_i\]

\section{Thinking about Adjoints}

Notice that I have exact agreement that
\[S \to (A_1 \x A_2) \cong (S \to A_1) \x (S \to A_2)\]
but merely
\[S \to (A_1 \to A_2) \to (S \to A_1) \to (S \to A_2)\]
and not the converse. The real meaning of
\[\Gamma \prov M : A\]
under $F = 2 \to \dash$ is not
\[\Gamma_1, \Gamma_2 \prov \langle M_1, M_2\rangle : A_1 \x A_2\]
but more like
\[\langle \Gamma_1 \prov M_1 : A_1, \Gamma_2 \prov M_2 : A_2\rangle\]
I.e. the subject of the judgment is not a map $(\Gamma_1 \x \Gamma_2)  \to (A_1 \x A_2)$
but a map $(\Gamma_1 \to A_1) \x (\Gamma_2 \to A_2)$.
\section{Contexts}
\subsection{Contextual Dependent Applicative Functors}
Suppose I have a regular dependent applicative functor $F, G, \ldots$.
We can define simultaneously
\[{\Gamma : \rctx_i \over \prov \Sigma \Gamma : \rset_i}
\qquad
{\Gamma : \rctx_i \qquad \Gamma' \prov M : \Sigma\Gamma \over \Gamma'\prov [M/\Gamma]: \Gamma}\]

\[\Sigma(\cdot) = \top\qquad
\Sigma(\Gamma, x : A)  = (g : \Sigma\Gamma) \x [g/\Gamma] A\]
\[[M/\cdot] = \cdot \qquad
[M/(\Gamma,x:A)] = [M.1/\Gamma][M.2/x]\]
We can then define some convenience syntax
\[
{\Gamma \prov A : \rset_i \over \prov \Gamma.A : \Sigma\Gamma \to \rset_i}
\qquad
{\Pi : (\Sigma\Gamma \to \rset_i) \to \rset_i}
\qquad
{\Gamma \prov M : A \over \prov \Gamma.M : \Pi \Gamma.A}
\]
By saying
\[
(\Gamma.A)\ g = [g/\Gamma]A
\qquad
\Pi\ k = (g : \Sigma\Gamma) \to k\ g
\qquad
(\Gamma.M)\ g :  [g/\Gamma] M
\]
Note that $\Pi\Gamma . A =  (g : \Sigma \Gamma) \to [g/\Gamma]A $, so we could retroactively say that
\[
{\Gamma \prov A : \rset_i \over \prov \Gamma.A : \Pi \Gamma. \rset_i}
\]
A contextual dependent applicative functor consists of
\begin{enumerate}
\item  For every  judgment $\Gamma \prov A : \rset_i$, a type $F_\Gamma A : \rset_i$
\item  For every  judgment $\Gamma \prov M : A$, a term $ \eta_\Gamma M : F_\Gamma A$
\end{enumerate}
We can lift any dependent applicative functor to a contextual one.
We define
\[F_\Gamma A = F(\Pi\Gamma.A)\]
\[\eta_\Gamma M = \eta(\Gamma.M)\]

%% If  $\Gamma \prov A : \rset_i$, then $\Gamma . A : \Pi\Gamma.\rset_i$
%% and $\eta(\Gamma.A) : F(\Pi\Gamma.\rset_i)$.


%% If  $\Gamma \prov M : A$, then $\Gamma . M : \Pi \Gamma . A$
%% and $\eta(\Gamma.M) : F(\Pi\Gamma.A)$.
\subsection{Lifting}
We want to claim that for every (contextual?) dependent applicative functor $F$ there exists
an extension $\bar F$ that lies over it, such that the fiber of $\bar F$ does the appropriate
thing at universes to give relations. We define it as a record type:
\[\bar F A = \{ \partial : F A, \beta : \bd_{A}(\partial)\}\]
with
\[A : \rset_i \over \bd_A : FA \to \rset_i\]
 to be defined later. Our target is that
\[\bd_{\rset_i}(\phi) = G\phi \to \rset_i\]
This is the closed version. For open terms, we hope
\[\bar F_\Gamma A = \{ \partial : F_\Gamma A, \beta : \bd_{\Gamma.A}(\partial)\}\]
and we know that
\[\bd_{\Gamma.A} : F_\Gamma A \to \rset_i\]
So what should we expect when $A = \rset_i$?
\[\bd_{\Gamma.\rset_i} : F_\Gamma \rset_i \to \rset_{i+1}\]
This is a predicate on tuples of types in context. $F_\Gamma\rset_i = F(\Pi \Gamma.\rset_i)$.
So we have to think about how parametricity works for functions. We should require that
for any related tuples at type $\Sigma\Gamma$, we get a relation among the types
that arise from applying the functions in the tuple. So a collection of related tuples
is something of type $\bar F(\Sigma\Gamma)$. If we have an $f : F(\Pi\Gamma.\rset_i)$, we can apply this
to a $\partial x : F(\Sigma\Gamma)$ to get $f \cdot x : F\rset_i$. Then $G(f \cdot x) : \rset_i$. So I think
we want to assert
\[\bd_{\Gamma.\rset_i}\ f = (x : \bar F(\Sigma \Gamma)) \to G(f \cdot x) \to \rset_i\]

But should I have to define this this way? Shouldn't I get all the higher functions for free, out of the
closed definitions of $\bar F, \bar \eta$? Not sure yet. Maybe I need them as induction hypotheses or something.
I should dig into the $\Pi$ and $\lambda$ cases of reflexivity or $\bd$ or whatever.

\subsubsection{Pi}
In the closed case, we have
\[\bd_A : FA \to \rset_i\]
So we should have
\[\bd_{(x:A)\to B} : F((x:A) \to B) \to \rset_i\]
And I want to say that a tuple of functions are related if, for all related input tuples, their outputs are related.

Recall that we have
\[f : F((x : A) \to B(x)) \qquad x : FA \over f \odot x : G (\eta B \cdot x)\]
and we get stuck at
\[\bd_{(x:A)\to B\ x}\ f = (x : \bar FA) \to \bd_{?} (f \cdot \partial x) \]
because there's no single type $\bd_B$ that accepts $FB$ as an argument. What we have is $G(\eta B \cdot x)$.
So would $\bd_{x.B}$ do the trick? Well, $\bd_{x.B} : F_{x:A}B \to \rset_i$. Can we get
from $G(\eta B \cdot x)$ to $F_{x:A} B$? We know $F_{x:A} B = F(\Pi(x:A).B)$. This is back where we started and doesn't let us make any progress.
\section{Understanding What I Did Wrong}

I think I still need a separate notion of substitutions-over. Going
all the way back and trying to imitate section 2 from
\verb+2022-01-15.ltx+.

We need dependent function application and pairing under $F$:
\[f : F((x : A) \to B(x)) \qquad x : FA \over f \odot x : G (\eta B \cdot x)\]

\[A: \rset_i \qquad B : A \to \rset_i \qquad M : FA \qquad N : G(\eta B \cdot M)
\over
\ll M, N\rr : F((x : A) \x B\ x)
\]

\subsection{Tuples of Substitutions}
First some convenience syntax for tuples of substitutions. First application:
\[
{\theta : F(\Sigma\Gamma) \qquad \Gamma \prov A : \rset_i
\over
[\theta]^\bullet A : F\rset_i}
\qquad
{\theta : F(\Sigma\Gamma) \qquad \Gamma \prov M : A
\over
[\theta]M : G[\theta]^\bullet A}
\]
\[[\theta]^\bullet A = \eta(\Gamma.A) \cdot \theta
\qquad
[\theta] M = \eta(\Gamma.M) \odot \theta\]

Then construction:
\[\theta : F(\Sigma\Gamma) \qquad  M : G[\theta]^\bullet A
\over
\theta[M/x] : F(\Sigma(\Gamma,x:A))
\]
\[\theta[M/x] = \ll \theta, M\rr\]

%%  We're using dependent pairing under $F$,

%% The typing works out because $F(\Sigma(\Gamma,x:A)) = F((g : \Sigma \Gamma) \x [g/\Gamma]A)$ and
%% the relevant instantiation of the rule is
%% \[\Sigma\Gamma: \rset_i \qquad \Gamma.A : \Sigma\Gamma \to \rset_i \qquad \theta : F(\Sigma\Gamma) \qquad M : G(\eta (\Gamma.A) \cdot \theta)
%% \over
%% \ll \theta, M\rr : F((g : \Sigma\Gamma) \x [g/\Gamma]A)
%% \]
\subsection{Substitutions Over}

when $\Gamma : \rctx$ and $\theta : F(\Sigma\Gamma)$, we invent a syntactic
class of {\em substitutions over} $\theta$. Their well-formedness judgment is
\[ \phi : \bd_\Gamma (\theta) \]
 We simultaneously define this judgment and two substitution operations
\[
\theta : F(\Sigma\Gamma)
\qquad \phi:\bd_\Gamma(\theta)
\qquad \Gamma \prov A : \rset_i
\over
[\phi]^\bullet A: G[\theta]^\bullet A \to \rset_i
\]
\[
\theta : F(\Sigma\Gamma)
\qquad \phi:\bd_\Gamma(\theta)
\qquad \Gamma \prov  M : A
\over
[\phi]M : [\phi]^\bullet A\ ([\theta]M)
\]

Formation of substitutions-over works like:
\[\over \cdot : \bd_{\cdot}{\cdot}\]
\[
\theta : F(\Sigma\Gamma)
\qquad \phi:\bd_\Gamma(\theta)
\qquad M : G[\theta]^\bullet A
\qquad p : [\phi]^\bullet A\ M
\over
\phi[p/x] : \bd_{\Gamma,x:A}(\theta[M/x])
\]
%% \subsection{Spot Check}
%% I expect $[\phi]^\bullet$ to reduce to something like $\bd$, and $[\phi]$ to reduce to something like $\eta$
%% when the substitution and contexts are empty.

%% For the first one,
%% \[
%% \qquad \cdot:\bd_\Gamma(\cdot)
%% \qquad  \prov A : \rset_i
%% \over
%% [\cdot]^\bullet A: G[\cdot]^\bullet A \to \rset_i
%% \]
%% checks out, because $[\theta]^\bullet A = \eta A$ when $\theta = \cdot$, so this is concluding
%% \[[\cdot]^\bullet A: G\eta A \to \rset_i = FA \to \rset_i\]
%% which is the right type for $\bd_A$.
%% For the second, we get
%% \[
%% \theta : F(\top)
%% \qquad \cdot:\bd_{\cdot}(\theta)
%% \qquad \Gamma \prov  M : A
%% \over
%% [\cdot]M : \bd_A (\eta M)
%% \]
%% which is appropriate for being able to construct the $\eta$ of the lifted dependent applicative functor.
\subsection{Application of Substitutions Over}
Actually defining substitution application is where all the excitement is. Let's warm up on
non-dependent functions.
\subsubsection{Arrow}
\[
\theta : F(\Sigma\Gamma)
\qquad \phi:\bd_\Gamma(\theta)
\qquad \Gamma \prov (A \to B) : \rset_i
\over
[\phi]^\bullet (A \to B): G[\theta]^\bullet (A \to B) \to \rset_i
\]
We'd like to say the result is
\[ [\phi]^\bullet (A \to B)(f) = (x : A^\phi) \to [\phi]^\bullet B\ (f \star \partial x)\]
for the record type
\[A^\phi = \{ \partial : G[\theta]^\bullet A, \beta : [\phi]^\bullet A\ \partial\}\]
and require the existence of some
\[f : G[\theta]^\bullet (A \to B) \qquad x : G[\theta]^\bullet A \over f \star x : G[\theta]^\bullet B \]

I think I could do this if I defined
\[{A_0\ A_1 : F\rset_i
\over
 A_0 \x_F A_1 : F\rset_i}
\qquad
{A_0 \x_F A_1 = \langle A_0, A_1\rangle \cdot (\lambda x. x.0 \x x.1)}\]
and required
\[A_0\ A_1 : F\rset_i \qquad M_0 : GA_0\qquad M_1 : GA_1
\over
\langle M_0, M_1 \rangle_G : G(A_0 \x_F A_1)\]
which of course should degenerate to regular pairing if $A_0$ and $A_1$ are both $\eta$ of something.
Then suppose that we could prove somehow that
\[[\theta]^\bullet (A \to B) \equiv \pair {[\theta]^\bullet A}{[\theta]^\bullet  B} \cdot (\lambda x. x.0 \to x.1)\]
In this case, we'd have
\[\langle f, x\rangle_G : G([\theta]^\bullet(A \to B) \x_F [\theta]^\bullet A)\]
\[= G(\langle [\theta]^\bullet(A \to B), [\theta]^\bullet A\rangle \cdot (\lambda x . x.0 \x x.1))\]
\[= G(\langle \pair {[\theta]^\bullet A}{[\theta]^\bullet  B} \cdot (\lambda x. x.0 \to x.1), [\theta]^\bullet A\rangle \cdot (\lambda x . x.0 \x x.1))\]
and by some principle I haven't thought of yet probably
\[= G( \pair {[\theta]^\bullet A}{[\theta]^\bullet  B}  \cdot (\lambda x . (x.0 \to x.1) \x  x.0))\]
and probably by some mapping principle under $G$ I can obtain
\[\to G( \pair {[\theta]^\bullet A}{[\theta]^\bullet  B}  \cdot (\lambda x .  x.1))\]
\[= G( {[\theta]^\bullet  B} )\]

%% Now from the $f, x$ above I should be able to obtain
%% \[\langle f, x\rangle_G  : G((\eta(\lambda g . [g/\Gamma](A\to B)) \cdot \theta)  \x_F (\eta(\lambda g . [g/\Gamma]A) \cdot \theta))\]
%% and some combination of theorems should probably let me get this down to
%% \[?  : G(\eta(\lambda g . [g/\Gamma]((A\to B) \x A)) \cdot \theta) \]
%% and from there I should be able to map application to obtain
%% \[?  : G(\eta(\lambda g . [g/\Gamma](B) \cdot \theta) \]
%% What principles should I assume or lemmas should I prove to get this?
%% I think first of all that maybe application distributes across products somehow.
%% I can see that

%% \[f\ g : F(A \to \rset_i) \qquad M : FA
%% \over
%% (f \cdot M) \x_F (g \cdot M) \equiv \langle f, g\rangle \cdot \lambda x. (f\cdot M) \x (g \cdot M) \]
%% Ok, how does $\eta$ distribute across products? I want to assert
%% \[ M : A \qquad N : B
%% \over
%% \eta_{A \x B}\langle M, N\rangle \equiv \langle \eta_A M, \eta_B N \rangle_F  \]
%% where I'm punning across regular and under-$F$ pairing. Gosh, this is messy. Let me postpone this optimistically
%% hoping it will work out with sufficient lemmas and axioms, and pop back up a level.

\subsubsection{Lambda}
\[
\begin{prooftree}
  \theta : F(\Sigma\Gamma)
  \qquad \phi:\bd_\Gamma(\theta)
  \qquad \[\Gamma, x:A \prov  M :  B \justifies \Gamma \prov  \lambda x. M : (A \to B)\]
\justifies
      [\phi](\lambda x . M) : (x : A^\phi) \to [\phi]^\bullet B\ (([\theta](\lambda x. M)) \star \partial x)
\end{prooftree}
\]
The induction hypothesis on $x:A\prov M : B$ gives us
\[
\theta : F(\Sigma(\Gamma, x :A))
\qquad \phi:\bd_{\Gamma,x:A}(\theta)
\over
[\phi]M : [\phi]^\bullet B\ ([\theta]M)
\]
but we have convenience syntax for building substitutions:
\[\theta : F(\Sigma\Gamma) \qquad  M : G[\theta]^\bullet A
\over
\theta[M/x] : F(\Sigma(\Gamma,x:A))
\]
So what we really have is
\[
\theta : F(\Sigma\Gamma)
\qquad N : G[\theta]^\bullet A
\qquad \phi:\bd_{\Gamma,x:A}(\theta[N/x])
\over
[\phi]M : [\phi]^\bullet B\ ([\theta[N/x]]M)
\]
and using the $\theta$ that we have coming in, and a variable $x : A^\phi$ in context means
\[
\phi:\bd_{\Gamma,x:A}(\theta[\partial x/x])
\over
x : A^\phi \prov [\phi]M : [\phi]^\bullet B\ ([\theta[\partial x/x]]M)
\]
Now staring at substitution formation we can get
\[
\qquad \beta x : [\phi]^\bullet A\ \partial x
\over
\phi[\beta x/x] : \bd_{\Gamma,x:A}(\theta[\partial x/x])
\]
so we have
\[
x : A^\phi \prov [\phi[\beta x/x]]M : [\phi[\beta x/x]]^\bullet B\ ([\theta[\partial x/x]]M)
\]
and
\[
\prov \lambda x . [\phi[\beta x/x]]M : (A^\phi) \to [\phi[\beta x/x]]^\bullet B\ ([\theta[\partial x/x]]M)
\]
So as long as we can prove some kind of coherence lemma that
\[ [\phi]^\bullet B\ (([\theta](\lambda x. M)) \star \partial x) \equiv [\phi[\beta x/x]]^\bullet B\ ([\theta[\partial x/x]]M)  \]
we can set
\[[\phi](\lambda x . M) =  \lambda x . [\phi[\beta x/x]]M\]

\subsection{More Inclusive Substitutions-Over}
what if I want to bundle up the $\theta$s as data with the $\phi$s. I have a judgment
that is simply
\[\psi : \bar F \Gamma\]
and a projection operation
\[\psi : \bar F \Gamma \over \partial \psi : F(\Sigma \Gamma)\]
and substitution operations
\[{\psi : \bar F \Gamma \qquad \Gamma \prov A : \rset_i
\over
[\psi]^\bullet A : G[\partial \psi]^\bullet A \to \rset_i}
\qquad
{\psi : \bar F \Gamma \qquad \Gamma \prov M : A
\over
[\psi] M : [\psi]^\bullet A\ ([\partial\psi] M)
} \]
We define
\[{\psi:\bar F \Gamma \qquad \Gamma \prov A : \rset_i
\over
\sem\psi^\bullet A : \rset_i}
\qquad
{\psi : \bar F \Gamma \qquad \Gamma \prov M : A
\over
\sem\psi M : \sem\psi^\bullet A
} \]

\[
\sem\psi^\bullet A = \{ \partial : G[\partial\psi]^\bullet A, \beta : [\psi]^\bullet A\ \partial\}
\qquad
\sem\psi M = \langle \partial = [\partial\psi]M, \beta = [\psi]M \rangle
\]
and now substitution-formation looks like
\[
\psi : \bar F \Gamma \qquad \Gamma \prov A : \rset_i \qquad M : \sem\psi^\bullet A
\over
\psi[M/x] : \bar F(\Gamma, x :A)
\]
%% If I wanted to take $\sem\psi^\bullet A$ and $\sem\psi M$ as the primitives, then I'd
%% want to also establish that there is a map
%% \[\partial_\psi : \sem\psi^\bullet A \to G[\partial \psi]^\bullet A\]
%% (which generalizes $\partial : \bar FA \to FA$) which has the compatibility property that
%% \[\partial_\psi (\sem\psi M) = [\partial \psi]M\]

\subsubsection{The Universe}
\[{\psi : \bar F \Gamma \qquad \Gamma \prov \rset_i : \rset_{i+1}
\over
[\psi]^\bullet \rset_i : G[\partial \psi]^\bullet \rset_i \to \rset_{i+1}}\]
We must assume that we can show that $[\partial \psi]^\bullet \rset_i = \eta \rset_i$, hence
we need
\[[\psi]^\bullet \rset_i : F \rset_i \to \rset_{i+1}\]
and so we define
\[[\psi]^\bullet \rset_i\ x : G x \to \rset_i\]
\subsubsection{Term-Type Transition}
We consider the case of term substitution where the term happens to be a type.\[
{\psi : \bar F \Gamma \qquad \Gamma \prov A : \rset_i
\over
[\psi] A : [\psi]^\bullet \rset_i\ ([\partial\psi] A)
} \]
This is the same as requiring
\[[\psi] A : G ([\partial\psi] A) \to \rset_i\]
and I think I can say $[\partial\psi] A = [\partial\psi]^\bullet A$ when $A$ has a classifier
like $\rset_i$ that is nondependent, so this is the same as
\[[\psi] A : G ([\partial\psi]^\bullet A) \to \rset_i\]
which is exactly the right type for us to be able to set
\[[\psi] A = [\psi]^\bullet A\]


\subsubsection{Pi Types}
\[{\psi : \bar F \Gamma \qquad \Gamma \prov ((x:A)\to B) : \rset_i
\over
[\psi]^\bullet ((x:A)\to B) : G[\partial \psi]^\bullet ((x:A)\to B) \to \rset_i}
\]
We define
\[[\psi]^\bullet ((x:A)\to B)\ f = (x : \sem\psi^\bullet A) \to [\psi[x/x]]^\bullet B\ (f \star \partial x)\]
using the induction hypothesis on $B$ like
\[
x : \sem\psi^\bullet A \prov \psi[x/x] : \bar F (\Gamma,x:A) \qquad \Gamma,x:A \prov B : \rset_i
\over
x : \sem\psi^\bullet A \prov [\psi[x/x]]^\bullet B : G[\partial \psi[\partial x/x]]^\bullet B \to \rset_i
\]
assuming we can define some operation
\[ f : G[\theta]^\bullet ((x:A)\to B) \qquad M : G[\theta]^\bullet A
\over
f \star x : G[\theta[M/x]]^\bullet B\]
But fortunately that looks very plausible.

\subsubsection{Lambdas}
\[\psi : \bar F \Gamma \qquad \Gamma \prov \lambda x.M : (x:A) \to B
\over
[\psi] (\lambda x.M) : [\psi]^\bullet ((x:A) \to B)\ ([\partial\psi] (\lambda x.M))
 \]
This is equivalent by the previous definition to
\[
\begin{prooftree}
  \psi : \bar F \Gamma \qquad
\[
 \Gamma,x:A \prov M : B
  \justifies
 \Gamma \prov \lambda x.M : (x:A) \to B
\]
  \justifies
      [\psi] (\lambda x.M) : (x : \sem\psi^\bullet A) \to [\psi[x/x]]^\bullet B\ (([\partial\psi] (\lambda x.M)) \star \partial x)
\end{prooftree}
\]
We want to apply the induction hypothesis to get
\[
x : \sem\psi^\bullet A\prov \psi[\partial x/x] : \bar F (\Gamma, x:A) \qquad \Gamma,x:A \prov  M :  B
\over
x : \sem\psi^\bullet A\prov [\psi[x/x]] M : [\psi[ x/x]]^\bullet  B\ ([\partial\psi[\partial x / x]] (M))
 \]
So we can set
\[   [\psi] (\lambda x.M) = \lambda x . [\psi[x/x]]M \]
as long as we have a compatibility lemma that yields
\[([\partial\psi] (\lambda x.M)) \star \partial x \equiv [\partial\psi[\partial x / x]] M\]
In general I bet I could establish
\[
\theta : F(\Sigma \Gamma) \qquad \Gamma, x:A \prov M : B \qquad  N : G[\theta]^\bullet A
\over
([\theta] (\lambda x.M)) \star N \equiv [\theta [N / x]] M
\]
%% which is a well-typed equation at type $G[\theta[N/x]]^\bullet B$ because
%% \[[\theta] (\lambda x.M) : G[\theta]^\bullet ((x:A) \to B)\]

\section{Looking at What I've Done}
Given a particular dependent applicative functor $F$, there is a notion of `$F$-enhanced substitution for $\Gamma$',
namely something of type $F(\Sigma \Gamma)$, and `applying a substitution to a term or type'
that comes just from that structure. It is the thing defined by
\[
{\theta : F(\Sigma\Gamma) \qquad \Gamma \prov A : \rset_i
\over
[\theta]^\bullet A : F\rset_i}
\qquad
{\theta : F(\Sigma\Gamma) \qquad \Gamma \prov M : A
\over
[\theta]M : G[\theta]^\bullet A}
\]
\[[\theta]^\bullet A = \eta(\Gamma.A) \cdot \theta
\qquad
[\theta] M = \eta(\Gamma.M) \odot \theta\]

Given $F, G, \eta, \cdot, \odot$ we can compute these. Now let's consider what we have defined for the lifted functor.
Let's change notation so it actually reflects $F, \eta$ etc.

\subsection{Redefining Dependent Applicative Functors}
Say an dependent applicative functor has to define $F, G, \eta, \cdot, \odot$ as before, but also
\[\begin{array}{c@{\qquad}c@{\qquad}c}
\displaystyle{\theta : F(\Sigma\Gamma) \qquad \Gamma \prov A : \rset_i
\over
\rho_\theta A : F \rset_i}
&
\displaystyle{\theta : F(\Sigma\Gamma) \qquad \Gamma \prov M : A
\over
\eta_\theta M : F_\theta A}
&
\displaystyle{\theta : F(\Sigma\Gamma) \qquad \Gamma \prov A : \rset_i
\over
F_\theta A :  \rset_i}
\\ \\
\rho_\theta A = \eta(\Gamma.A) \cdot \theta
&
\eta_\theta M = \eta(\Gamma.M) \odot \theta
&
F_\theta A = G \rho_\theta A
\end{array}
\]
\subsection{Checking Similarities}
Now what is $\phi : \bd_\Gamma(\theta)$? It is an element of $\bar F(\Sigma \Gamma)$ that, for the map $\partial$,
 lies over $\theta: F(\Sigma\Gamma)$.
What is $[\phi]^\bullet A$? It's a function, that given an element of $F_{\partial \phi} A$, gives us the set of elements of $\bar F_\phi A$ that lie
over it. This is something I expect to define recursively by decomposition of $A$.

What is $[\phi]M$? It's an element of $\bar F_{\phi} A$ lies over $\eta_{\partial\phi} M$.
This is something I expect to define recursively by decomposition of $M$.

Or I can try to just go about defining $\bar F_{\phi}$ directly.

\subsubsection{The Universe}
We define
\[\bar \rho_\phi \rset_i = \bar \eta_\phi \rset_i = \bar \eta \rset_i\]
\[\bar F_\phi \rset_i = \{ \partial : F \rset_i , \beta: G\partial \to \rset_i \}\]
Here we're tacitly assuming we can show that $F_{\partial\phi} \rset_i \equiv G\rho_{\partial\phi}\rset_i \equiv G\eta \rset_i \equiv F\rset_i$ because $\rset_i$ is closed.
\subsubsection{Pi Types}
\def\fiber{\mathbf{fiber}}
We invent some type
\[{\phi : \bar F(\Sigma\Gamma) \qquad \Gamma \prov A : \rset_i \qquad N : F_{\partial \phi} A
 \over
\fiber(\bar F_\phi A, N) : \rset_i}
\qquad
{
M : \bar F_\phi A
\over
[M] : \fiber(\bar F_\phi A, \partial M) : \rset_i
}
\]
and some operation
\[f : F_{\theta} ((x : A) \to B) \qquad M :  F_\theta A
\over
f \star x : F_{\theta[M/x]} B\]

then we can set

\[\bar F_\phi ((x : A) \to B) = \{ f : F_{\partial\phi} ((x : A) \to B) ,\]
\[ \beta: (x : \bar F_\phi A) \to \fiber (\bar F_{\phi[x/x]}B, f \star \partial x) \}\]

\vfil\eject
\section{Dependent Applicative Functors}
Some meditation on what operations ought to exist led me to the following slightly expanded notion.
We should have, at a minimum,
\[{A : \rset_i \over FA : \rset_i}
\qquad {A : \rset_i \over \eta : A \to FA}
\qquad {A : F \rset_i \over GA : \rset_i}\]
I really ought to write $\cdot$ and $\cdot_F$ and $\odot$ as $\odot_F$ below, but I
drop the $F$ for brevity.
We expect $G\eta A \equiv A$. Probably a bunch of other compatibility axioms.
Defined operations are in {\color{gray} gray}.

\vskip0.5em\noindent$\bullet$ {\bf Ordinary $F$-Pairing}\\
\[{M: FA \qquad N : FB
\over
\langle M, N \rangle_F : F(A \x B)}
\]

\vskip0.5em\noindent$\bullet$ {\bf Ordinary $F$-Application}\\
\[{M: F(A \to B) \qquad N : FA
\over
 M\cdot N  : FB}
\]

\vskip0.5em\noindent$\bullet$ {\bf Dependent $F$-Pairing}\\
\[
{ B: A \to \rset_i \qquad M: FA \qquad N : G(\eta B \cdot M)
\over
\ll M, N \rr_F : F((x :A) \x B\ x)
}\]

\vskip0.5em\noindent$\bullet$ {\bf Dependent $F$-Application}\\
\[{B : A \to \rset_i \qquad M: F((x : A) \to B\ x) \qquad N : FA
\over
 M\odot N  : G(\eta B \cdot N)
}\]

\vskip0.5em\noindent{\color{gray} $\bullet$ {\bf $F$-Substitution}}\\
\[{M : FA \qquad x : A \prov B : \rset_i
\over
[M/x]_FB : F \rset_i
}
\qquad
[M/x]B = \eta(\lambda x . B) \cdot M\]

\vskip0.5em\noindent{\color{gray} $\bullet$ {\bf Product under $F$}}\\
\[{A: F\rset_i \qquad B : F\rset_i
\over
A \x_F  B : F\rset_i}
\qquad
A \x_F B = [\langle A, B\rangle_F/x]_F(x.0 \x x.1)
\]

\vskip0.5em\noindent{\color{gray} $\bullet$ {\bf Arrow under $F$}}\\
\[{A: F\rset_i \qquad B : F\rset_i
\over
A \to_F  B : F\rset_i}
\qquad
A \to_F B = [\langle A, B\rangle_F/x]_F(x.0 \to x.1)
\]

\vskip0.5em\noindent{\color{gray} $\bullet$ {\bf $\Sigma$ under $F$}}\\
\[{A:F\rset_i\qquad B : G(A \to_F \eta\rset_i)
\over
 \Sigma_F\ A\ B  : F\rset_i}
\qquad
\Sigma_F\ A\ B =  [ \ll A, B \rr_F/x]_F(  \Sigma\ (x.0)\ (x.1))
\]

\vskip0.5em\noindent{\color{gray} $\bullet$ {\bf $\Pi$ under $F$}}\\
\[{A:F\rset_i\qquad B : G(A \to_F \eta\rset_i)
\over
 \Pi_F\ A\ B  : F\rset_i}
\qquad
\Pi_F\ A\ B =  [ \ll A, B \rr_F/x]_F(  \Pi\ (x.0)\ (x.1))
\]


\vskip0.5em\noindent$\bullet$ {\bf Ordinary $G$-Pairing}\\
\[{A\ B : F\rset_i \qquad M: GA \qquad N : GB
\over
\langle M, N \rangle_G : G(A \x_F B)}
\]

\vskip0.5em\noindent$\bullet$ {\bf  Ordinary $G$-Application}\\
\[
{ A\ B : F\rset_i
\qquad M : G(A \to_F B) \qquad N: GA
\over
M \cdot_G N  : GB}\]


\vskip0.5em\noindent$\bullet$ {\bf Dependent $G$-Pairing}\\
\[{A:F\rset_i\qquad B : G(A \to_F \eta\rset_i) \qquad M: GA \qquad N : G(B \cdot_G M)
\over
\ll M, N \rr_G : G(\Sigma_F\ A\ B)
}\]

\vskip0.5em\noindent$\bullet$ {\bf Dependent $G$-Application}\\
\[{A:F\rset_i\qquad B : G(A \to_F \eta\rset_i)
\qquad M: G(\Pi_F\ A\ B) \qquad N : GA
\over
 M\odot_G N  : G(B \cdot_G N)
}\]

\section{Syntax}
An idea that can help constrain the definition of dependent applicative functor is: it should be enough data
that we can interpret syntax ``under a variable''.

It's easy to get myself confused about how dependencies on contexts
work, so let's start with some closed examples.

When we have a bundle of types, we can write equivalently either of
\[\Delta ; \cdot \prov A : \rset_i\qquad \sim\qquad \sem A: F\rset_i  \]
When we have a bundle of terms, it's
\[\Delta ; \cdot \prov M : A \qquad \sim\qquad \sem M: G\sem A  \]
The interpretation of an expression probably should be written to `bind the variable $\Delta$'
but I'm going to leave it implicit for brevity for now.
\subsection{Individual Constructs}
\subsubsection{Arrow}
\[\Delta ; \cdot \prov A \to B : \rset_i\qquad \sim\qquad \sem {A \to B}: F\rset_i  \]
We need to construct a bundle of types out of two bundles. This seems easy enough; abstract
over the bundle and join them by $\to$.
\[\sem{A \to B} = \sem A \to_F \sem B = \langle \sem A, \sem B\rangle_F \cdot (\lambda x . (x.0) \to (x.1))\]

\subsubsection{Lambda}
Given \[\Delta ;x : A \prov M : B\] we need to somehow construct a term of type
\[ G\sem{A \to B} = G(\langle A, B\rangle_F \cdot (\lambda x . (x.0) \to (x.1)))\]
If $B$ is $\Delta$-closed, then $\sem B = \eta B_0$ and I think this should reduce to
\[ G\sem{A \to B} = G(\langle \sem A, \eta B_0\rangle_F \cdot (\lambda x . (x.0) \to (x.1)))\]
\[ = G( [\sem A /x] ( x \to B_0) )\]
I don't think there's any operation I'm going to explicitly do to construct the lambda; it has to
come from the more general statement of what it means to take the interpretation of
\[\Delta;\Gamma \prov M : A\]
\subsubsection{Contextual Types}
Suppose $\Delta;\Gamma \prov A : \rset_i$. Then $\Delta; \prov \Gamma.A : \Sigma\Gamma \to \rset_i$ leads to
\[\qquad\sem{\Gamma.A} : G\sem{\Sigma\Gamma \to \rset_i}\]
\[= G(\sem{\Sigma\Gamma} \to_F \sem{\rset_i})\]
\[= G(\sem{\Sigma\Gamma} \to_F \eta{\rset_i})\]
\[\sem{\Gamma.A}: G([\sem{\Sigma\Gamma}/x]  (x \to \rset_i))\]
Suppose $\Delta;\Gamma \prov M : A$. Then we start with $\Delta; \prov \Gamma.M : (g : \Sigma\Gamma) \to (\Gamma.A)\ g$.
Observe that $\sem{\Sigma\Gamma} : F\rset_i$. So $G\sem{\Sigma\Gamma}:\rset_i$.



\subsubsection{Pi}
\[\Delta ; \cdot \prov (x : A) \to B : \rset_i\qquad \sim\qquad \sem {(x : A) \to B}: F\rset_i  \]
We'll need dependent pairing to bundle up the two types. For sure $\sem A : F\rset_i$, and
Let's assume  $\Delta ;\cdot \prov \lambda x . B : A \to \rset_i$
gives us
\[ \sem{ x . B} : G(\sem A \to_F \eta\rset_i)\]
Then the above $\Pi$ under $F$ construction gives us what we want!
\subsection{The Induction Hypothesis I Want}
This is starting to be clearer with the primitives I now have.
The theorem is that we can define
\[\sem\Gamma_\Delta \qquad \sem {\Gamma.A}_\Delta \qquad \sem {\Gamma.M}_\Delta\]
such that, for all the familiar syntactic constructors with a $\Delta$ out front,
\def\sto{\rightsquigarrow}
\[{ B : F\rset_i
\over
\sem\Gamma_\Delta \sto  B : F\rset_i}
\qquad
{ B : G(\sem\Gamma_\Delta \sto \eta\rset_i)
\over
  \sem\Gamma_\Delta\sto' B  : F\rset_i}
\]
\[{\color{gray}\Delta \prov\Gamma : \rctx_i
\over
\sem\Gamma_\Delta : F \rset_i
}\qquad{\Delta ; \Gamma \prov A : \rset_i
\over
\sem {\Gamma.A}_\Delta : G(\sem \Gamma_\Delta \sto \eta\rset_i)}
\qquad
{\Delta ; \Gamma \prov M : A
\over
\sem {\Gamma.M}_\Delta : G( \sem\Gamma_\Delta\sto' \sem{\Gamma.A}_\Delta)}\]





\subsubsection{Ordinary Context Abstration}
\[\sem\cdot_\Delta B = B\]

\[{ B : F\rset_i
\over
\sem{\Gamma,x:A}_\Delta \sto  B : F\rset_i}\]
We set
\[\sem{\Gamma, x : A}_\Delta \sto B =  \sem{\Gamma} \sto (\sem {\Gamma.A}_\Delta \to_F B)\]


\[\Delta \prov \Gamma : \rctx_i \qquad \Delta ;\Gamma \prov A : \rset_i
\over
\Delta \prov (\Gamma, x : A) : \rctx
\]
%% The induction hypothesis gives us $\sem\Gamma_\Delta : F\rset_i$
%% and $\sem {\Gamma.A}_\Delta : G(\sem \Gamma_\Delta \to_F \eta\rset_i)$.



\subsubsection{Pi Case}
\[\Delta ; \Gamma, x : A \prov B : \rset_i
\over
\Delta ; \Gamma \prov (x : A) \to B : \rset_i
\]
The induction hypothesis gives us
\[\sem{(\Gamma,x:A).B}_\Delta : G(\sem {\Gamma, x: A}_\Delta \to_F \eta \rset_i)\]
\section{A Recursion Excursion}
What would I need to say to be able to inline the `definition' $F = G\o\eta$?

I think something like
\[{ A : \rset_i\qquad M : A
\over \eta_iM : G_{i+\ell}(\eta_{i+1} A) }
\qquad
{ B : G_{i+k}(\eta_{i+2}\rset_i)
\over G_i B : \rset_i }\]
but I don't know $k$ and $\ell$.

I expect: if the premises of a rule are well-typed, then its conclusion is.
Let's apply that idea to the $\eta$ rule. From $A : \rset_i : \rset_{i+1}$ and $M : A : \rset_i$
we should expect that $G_{i+\ell}(\eta_{i+1}A) : \rset_i$  holds, because we
expect $\eta M$ to be at the same level as $M$. So this immediately tells us that $\ell = 0$, assuming $G_i$ is indexed by the level of the type it outputs. So we have
\[{ A : \rset_i\qquad M : A
\over \eta_iM : G_{i}(\eta_{i+1} A) }
\qquad
{ B : G_{i+k}(\eta_{i+2}\rset_i)
\over G_i B : \rset_i }\]
and we don't know $k$. We want to investigate why
\[G_{i}(\eta_{i+1}A) : \rset_i\] holds. By $G$-rule, we need to show
\[{ \eta_{i+1}A : G_{i+k}(\eta_{i+2}\rset_i)
\over G_i (\eta_{i+1}A) : \rset_i }\]
So by $\eta$-rule, we'd need to show
\[{ \rset_{i} : \rset_{i+1}\qquad A : \rset_{i}
\over \eta_{i+1}A : G_{i+1}(\eta_{i+2} \rset_{i}) }\]
So we've discovered $k=1$. I think my rules are:
\[{ A : \rset_i\qquad M : A
\over \eta_iM : G_{i}(\eta_{i+1} A) }
 \qquad
{ B : G_{i+1}(\eta_{i+2}\rset_i)
\over G_i B : \rset_i }\]
Now to check that the premise of the $G$-rule makes sense?
By the $\eta$-rule,
\[{ \rset_{i+1} : \rset_{i+2}\qquad \rset_i : \rset_{i+1}
\over \eta_{i+2}\rset_i : G_{i+2}(\eta_{i+3} \rset_{i+1}) }\]
Hence by the $G$ rule, with $B = \eta_{i+2}\rset_i$, we see
\[{ \eta_{i+2}\rset_i : G_{i+2}(\eta_{i+3}\rset_{i+1})
\over G_i (\eta_{i+2}\rset_i) : \rset_{i+1} }\]
So we have a kind of consistency that
\[{ A : \rset_i : \rset_{i+1} \qquad M : A : \rset_i
\over \eta_iM : G_{i}(\eta_{i+1} A) : \rset_i }
 \qquad
{ B : G_{i+1}(\eta_{i+2}\rset_i) : \rset_{i+1}
\over G_i B : \rset_i : \rset_{i+1}}\]
%% Do we want to reindex, then? I think I want
%% \[ H_i : \cdots : \rset_i \]
%% where
%% \[G_i : \cdots : \rset_{i+1}\]
%% So $H_{i+1} =G_i$. So the rules (rewriting $H$ immediately back to $G$) are
%% \[{ A : \rset_i\qquad M : A
%% \over \eta_iM : G_{i+1}(\eta_{i+1} A) }
%%  \qquad
%% { B : G_{i+2}(\eta_{i+2}\rset_i)
%% \over G_{i+1} B : \rset_i }\]
%% and if we set $F_i = G_{i+1}\eta_{i+1}$ then
%% \[{ A : \rset_i\qquad M : A
%% \over \eta_iM : F_i A }
%%  \qquad
%% { B : F_{i+1}\rset_i
%% \over G_{i+1} B : \rset_i }\]
%% huh but what if I reindex back and say
I can make this more compact again by saying
\[F_i = G_{i}\eta_{i+1}
\qquad
{ A : \rset_i
\over F_iA : \rset_i }
\qquad
{ A : \rset_i\qquad M : A
\over \eta_iM : F_i A }
 \qquad
{ B : F_{i+1}\rset_i
\over G_{i} B : \rset_i }\]
\subsection{Inner Universe}
This is going to be very confusing if we're talking about actual levels,
so let's have a little inner universe to make it more concrete.

Let's suppose we have some type $L$ that's going to abstractly behave like levels,
and a successor function $s : L \to L$, and $V  :  L \to \rset$ and $E : \{\ell : L\} \to V\ \ell \to \rset$ that gives us sets of elements provided a code from $V$.
Suppose also we have codes for universes : $v : (\ell : L) \to V\ (s\ \ell)$
with $E\ (v\ \ell) \equiv V\ \ell$.
Now suppose we're given out of nowhere a $F : \{\ell : L\} \to V\ \ell \to V\ \ell$.
If we had this, we could talk about what it meant to be a well-typed $\eta/G$ pair.

\[ \eta : (\ell : L) (A : V\ \ell) \to  E\ A \to E\ (F\ A)\]
\[ G : (\ell : L) : E\ (F\ (v\ \ell)) \to V\ \ell\]

Given all that data, I can extract another $F$ via composition. I'd like this to be a fixedpoint. Don't see any clever way of doing that, hm.

What if I thought more `typelessly' and said that there are types $E, V, L$
with $\tau : E \to V$ and $\lambda : V \to L$.
There is an encoding map $\epsilon : V \to E$ which takes a type name to its
representative in $E$. There is a map $v : L \to V$ which takes a level to the universe
at that level.
Then $\eta$ is a map $E \to E$. And maybe $G$ is a partial map $E \to E$.
They happen to have the properties that
\[ \forall x \in E . \tau (\eta x) = G\eta\epsilon (\tau x) \]
Ugh no this is still a mess.

\section{Another Crack at Syntax Interpretation}

%% Let's do the curried abstraction in the base language. We define
%% \[\Gamma : \rctx \qquad \Gamma \prov A : \rset_i \over \Gamma \sto A : \rset_i\]
%% by
%% \[\cdot \sto A = A \qquad (\Gamma, x:A) \sto B = \Gamma \sto ((x:A) \to B)\]
The theorem to be proved is

\[{\Delta \prov \Gamma : \rctx
\over
\Gamma \sto \rset_i : F\rset_{i+1}}
\qquad
{\Delta \prov \Gamma : \rctx \qquad  B : G(\Gamma \sto  \rset_i)
\over
\Gamma \sto B : F\rset_i}\]


%% {\Delta \prov\Gamma : \rctx_i
%% \over
%% \sem\Gamma_\Delta : F \rset_i
%% }\qquad

\[{\Delta ; \Gamma \prov A : \rset_i
\over
\sem {\Gamma.A}_\Delta : G( \Gamma \sto \rset_i)}
\qquad
{\Delta ; \Gamma \prov M : A
\over
\sem {\Gamma.M}_\Delta : G( \Gamma\sto \sem{\Gamma.A}_\Delta)}\]

\subsection{Proof}
\subsubsection{Empty Context}
\[\cdot \sto \rset_i = \eta\rset_i\]
\[\cdot \sto B = B\]
\subsubsection{Context Extension}
\[(\Gamma,x:A) \sto B = ?\]

\[{\Delta \prov \Gamma : \rctx \qquad  \Gamma \prov A : \rset_i \qquad
 B : G((\Gamma,x:A) \sto  \rset_i)
\over
(\Gamma,x:A) \sto B : F\rset_i}\]

\[{A:F\rset_i\qquad B : G(A \to_F \eta\rset_i)
\over
 \Pi_F\ A\ B  : F\rset_i}
\]

\end{document}
