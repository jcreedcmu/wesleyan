\documentclass{article}
\input{theorem}
\input{prooftree}
\usepackage{stmaryrd}
\usepackage{latexsym}
\usepackage{yfonts}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,cd,decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}
\usepackage{tcolorbox}
\tcbuselibrary{breakable}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}

\def\fA{\mathsf{A}}
\def\fC{\mathsf{C}}
\def\ff{\mathsf{f}}
\def\rspan{\mathsf{Span}}
\def\El#1{\mathsf{El}({#1})}
\def\quote#1{{\ulcorner {#1} \urcorner}}
\def\U{\mathsf{U}}
\def\uni{\U}
\def\mor#1#2{#1 \to \underline{#2}}

\def\ridp{\mathsf{idp}}
\def\ssem#1{\langle\!\langle{#1}\rangle\!\rangle}

\definecolor{cyan}{rgb}{0.80,0.95,0.95}
\definecolor{orange}{rgb}{0.95,0.90,0.80}
\definecolor{lred}{rgb}{0.95,0.8,0.8}
\definecolor{lgray}{gray}{0.9}
\newtcolorbox{declbox}{colframe=lred,colback=lred,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{thmbox}{colframe=cyan,colback=cyan,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{defnbox}{colframe=orange,colback=orange,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{tangentbox}{colframe=lgray,colback=lgray,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}

\input{linear}
\def\rpath#1{[#1]}
\def\rfst{\mathsf{fst}\,}
\def\rsnd{\mathsf{snd}\,}
\def\bunfold{\mathbf{unfold}}
\def\bfold{\mathbf{fold}}
\def\susp#1{\langle {#1} \rangle}
\def\ssusp#1{\langle\!\langle {#1} \rangle\!\rangle}
\def\dto{\mathrel{\dot\to}}
\def\dns{{\downarrow}}
\def\ups{{\uparrow}}
\def\sprov{\Vdash}
\def\signat{{\color{red}\Sigma}}
\def\ep#1{\underline{#1}}
\def\wat{\mathbin{@}}
\def\wwat{\mathbin{\underline\wat}}
\def\cn{{:}}
\def\dv{{\div}}
\def\ww{{\mathsf w}}
\def\base{{\textfrak b}}

\def\N{{\mathbb N}}
\def\munit{I}
\def\tt{{\mathsf t}}
\def\rr{{\mathsf r}}
\def\ii{{\mathbb I}}
\def\pp{\textsf{\textbf p}}
\def\nn{{\mathsf n}}
\def\PP{\textsf{\textbf P}}
\def\NN{{\mathsf N}}
\def\zz{{\mathsf z}}
\def\sem#1{[\![#1]\!]}
\def\usem#1{\lceil\!\!\lceil{#1}\rceil\!\!\rceil}
\def\zem#1{\langle\!\langle#1\rangle\!\rangle}
\def\col#1{{\mathsf{C}}_{#1}}
\def\lax{\mathop\bigcirc}
\def\rjust{\mathsf{just}}
\def\rcvt{\mathsf{cvt}}
\def\rtype{\mathsf{type}}
\def\rkind{\mathsf{kind}}
\def\rmode{\mathsf{mode}}
\def\rprel{\mathbf{Prel}}
\def\rrfam{\mathbf{Rfam}}
\def\rset{\mathbf{Set}}
\def\rfinset{\mathbf{FinSet}}
\def\rrel{\mathbf{Rel}}
\def\rcat{\mathbf{Cat}}
\def\rfam{\mathbf{Fam}}
\def\binj{\mathbf{inj}}
\def\rid{\mathsf{id}}
\def\rtrue{\mathrel\mathrm{true}}
\def\pbck{\ar[dr, phantom, pos=0, "\lrcorner"]}
\def\bpbck{\ar[ddrr, phantom, pos=0, "\lrcorner"]}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\btwo{\mathbf{2}}
\def\bone{\mathbf{1}}

\newarrow {Equiv} =====
\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\def\mapt{\ar[ddd,mapsto,shorten <=2em, shorten >=2em]}
\def\frommaps{\ar[from=uu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\frommapt{\ar[from=uuu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\C{\mathbf{C}}
\def\W{\mathbf{W}}
\def\S{\mathbf{S}}
\def\D{\mathbf{D}}
\def\E{\mathbf{E}}
\def\M{\mathbf{M}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\tri{\triangleright}
\def\o{\circ}
\def\rctx{\,\mathsf{ctx}}
\def\del{\partial}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\null{\emptyset}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\definecolor{fib}{HTML}{ff7f00}
\definecolor{green}{HTML}{007f00}
\definecolor{red}{HTML}{df3f3f}
\definecolor{opfib}{HTML}{007fff}

% For lightening colors I used
% http://trycolors.com/ 6 parts white to 1 part color
\definecolor{opfibl}{HTML}{DBEDFF}
\definecolor{greenl}{HTML}{DBEDDB}
\definecolor{redl}{HTML}{FAE4E4}
\def\njudge#1{\fcolorbox{opfib}{white}{#1}}
\def\nrule#1{\fcolorbox{white}{opfibl}{#1}}
\def\neqn#1{\fcolorbox{white}{redl}{#1}}



\def\judge#1{\vskip 2em\noindent \njudge{$#1$}\vskip 0.5em\noindent}
\def\rule#1{\vskip 2em \noindent \nrule{$#1$}\vskip 0.5em\noindent}
\def\eqn#1{\vskip 2em \noindent \neqn{$#1$}\vskip 0.5em\noindent}
\def\prof{\nrightarrow}
\def\tensor{\otimes}
\def\htensor{\mathrel{\hat\otimes}}
\def\lol{\multimap}
\def\hlol{\mathrel{\hat\multimap}}
\def\wtf{{\color{red}???}}

\def\re{\mathbf{E}}
\def\shp{\mathrel{\sharp}}
\def\zero{\texttt{0}}
\begin{document}

\def\
\tikzset{
   commutative diagrams/.cd,
   arrow style=tikz,
   diagrams={>=stealth}}

\section{Thinking about Dependency and Substructurality in Bernardy-Moulin}

If interval variables are supposed to be substructural, then I figure I should be
able to fruitfully think about $\ii/\sharp n$ not being a {\em type}, but rather a
function from worlds/resource-things to types.

Indeed, the failure of exchange makes me think that it might be appropriate to
think that there is sort of an intrinsic
difference between types that sit before and after an interval variable: that the things
after are higher-dimensional than the things before. Although maybe this is a regression
to the big complicated cube notation that Moulin had earlier in his thesis?

How would I be inclined to notate this, though? I could say that there
is such thing as a $\rtype_\Delta$ for a context $\Delta$ that's specifically
made of only $\sharp$ed variables, such that a $\rtype_\cdot$ is
just a type, and a $\rtype_{\Delta, \nu:\sharp n}$ is an $n$-span made of things in $\rtype_n$.

\[
\erule
{\Gamma \prov C, A_i : \rtype_\Delta \qquad \Gamma \prov f_i :  C \to_{\Delta} A_i}
{\Gamma \prov [C, A, f] : \rtype_{\Delta, \nu : \sharp n}}
\]

But I would need to explain what $\to_\Delta$ means; and actually, there's something missing
from that judgment, because I would expect $\to_\Delta$ to take two things in $\rtype_\Delta$
and yield another such thing, and things in $\rtype_\Delta$ aren't themselves able to have
inhabitants unless $\Delta$ is empty.

Ok, so if $\rtype_{\Delta, \nu : \sharp n}$ is like a substructural
kind, let me turn to how that would work in the resource semantics
mindset I've employed before. If I had `linear types', I'd have kinds
$r^+ \to \rtype$ and $r^- \to \rtype$ for positive and negative
`linear types' where $r^+$ is the type of resources and $r^-$ is the
type of frames. So here I have a different type of resource for every possible $\Delta$, it's
like I have a family of types $r_\Delta$, and a $\rtype_\Delta$ is a $r_\Delta \to \rtype$.
I know right off the bat that $r_\cdot$ should be the unit type $1$, so that
$\rtype_\cdot = r_\cdot \to \rtype = 1 \to \rtype = \rtype$.

But what about $r_{\Delta, \nu : \sharp n}$? I know I should be able to go from $\rtype_{\Delta, \nu : \sharp n}$ to $\rtype_{\Delta}$ in at least $n$ specific ways by projection, so I should be able to go
from $r_{\Delta}$ to $r_{\Delta, \nu : \sharp n}$ in at least $n$ specific ways.

So maps from $r_\Delta$ to $r_{\Gamma}$ are probably at least like (affine)
substitutions $\Delta \prov \theta : \Gamma$.
How might I think about witness types? Maybe $\rspan$ is a thing that takes
a number $n$ (for how many branches {\em this} particular span has) and
a resource expression $\rho : r_{\Delta}$ for how much higher-dimensional stuff the type is supposed to have.
\[
\erule
{\Gamma \prov S : \rspan^\Delta_n(\rho) \qquad \Gamma \prov \rho : r_{\Delta}}
{\Gamma, \alpha : r_{\sharp n}, \nu : \sharp_n(\alpha) \prov S \star \nu : \rtype_{\Delta, \nu : \sharp n}}
\]
What {\em is} a $\rspan^\Delta_n(\rho)$, then?
Perhaps a member of $\rspan^\Delta_n(\rho)$ is a record with fields
\def\rspan{\mathsf{Span}}
\begin{tabbing}
\hspace*{2em}\=\hspace*{2em}\= \kill
\> $\fC : \rtype_\Delta$\\
\> $\fA : n \to \rtype_\Delta$\\
\> $\ff : (k : n) \to \fC(\rho) \to \fA_k(\rho)$
\end{tabbing}

How does quantification over interval variables work?
I'd expect
\[
\erule
{\Gamma, \nu : \sharp n \prov A : \rtype}
{\Gamma \prov \forall \nu . A : \rtype}
\qquad
\erule
{\Gamma \prov M : \forall \nu . A}
{\Gamma, \nu : \sharp n \prov M\ \nu : A}
\]
to translate into something like

\[
\erule
{\Gamma, \alpha : r_{\sharp n}, \nu : \sharp_n(\alpha) \prov A : \rtype_{\Delta, \nu : \sharp n}}
{\Gamma \prov \forall \nu . A : \rtype_{\Delta}}
\]

\[
\erule
{\Gamma \prov M : (\rho : r_\Delta) \to (\forall \nu . A)(\rho)}
{\Gamma, \alpha : r_{\sharp n}, \nu : \sharp_n(\alpha) \prov \lambda \rho . M(\rho\adjust_\Delta )(\alpha)(\nu) : (\rho : r_{\Delta, \nu : \sharp n}) \to  A(\rho)}
\]

where
\[(\forall \nu . A) := \lambda (\rho : r_\Delta) . (\alpha : r_{\sharp n})(\nu : \sharp_n(\alpha)) \to A(\rho \tensor \alpha)\]

So yeah maybe I do have an operation $\tensor$ that takes $r_{\Delta}$ and $r_{\sharp n}$ and yields $r_{\Delta, \nu : \sharp n}$? The restriction operation $\rho\adjust_\Delta$ is sketching me out a lot more.

\subsection{Could it be the case that I just have $r$, not $r_\Delta$?}
It seem like maybe $\sharp_n(\alpha)$ could do all the work of keeping
track of the $n$-span-ness of things without additionally tracking it
in the kinds of worlds.

Could I say something as simple as
\[
\erule
{\Gamma \prov \rho : r \qquad \Gamma \prov S : \rspan_n(\rho) \qquad  \Gamma \prov \nu : \sharp_n(\rho)}
{\Gamma \prov S \star \nu :\rtype}
\]
or is it more like
\[(\Gamma \prov S \star \nu) : r \to \rtype\]
such that
\[(\Gamma \prov S \star \nu)(\rho) := \exists \rho_1 \rho_2 . (\nu : \sharp_n(\rho_1)) \x (S : \rspan_n(\rho_2)) \x (\rho = \rho_1 \tensor \rho_2)\]
That actually looks pretty good as expressing the multiplicativity involved!
and perhaps $\rspan_n(\rho)$ is still something like
\begin{tabbing}
\hspace*{2em}\=\hspace*{2em}\= \kill
\> $\fC : r \to \rtype$\\
\> $\fA : n \to r \to \rtype$\\
\> $\ff : (k : n) \to \fC(\rho) \to \fA_k(\rho)$
\end{tabbing}
No, wait, something's wrong; $\nu$ is given to the type constructor, but it's not really checked on the right side of the $:=$.

%% \[
%% \begin{tabular}{r@{$\quad$}c@{$\quad::=\quad$ }l}
%%   Mode Contexts&$\Delta$&$\cdot \celse \Delta, x: \alpha$\\
%% \end{tabular}
%% \]
%% \begin{tabbing}
%% \hspace*{2em}\=\hspace*{2em}\= \kill
%% $\cdot \prov \ell^+, \ell^-, t^+, t^- : \rtype$\\
%% \end{tabbing}
\section{Backing up}

Irrespective of how different-dimensioned types are translationally realized, let
me remind myself of what I do know about their behavior.

Let me write $\rtype_\Delta$ as a type depending on the interval variables in $\Delta$.
An expression of kind $\rtype_\Delta$ always binds those variables; so something in bernardy-moulin
written
\[\Gamma, i : \ii, z : C, j : \ii, x : A \prov M : B\]
I would think of as perhaps something like
\[\Gamma, z : i.\sem C^i, x : ij.\sem A^{ij} \prov M : ij.\sem B^{ij}\]
where for example $ij.\sem A^{ij}  : \rtype_{i, j}$, and the $i,j$ in the superscript of $\sem{\dash}$ are {\em occurrences} of the bound variables that are fed to the translation of $A$.
The subscripts in $\rtype_{i,j}$ are neither binding or occurrences of variables; in fact they're
kind of a convenient lie.
The more correct thing to say would be like $\rtype_{\sharp n, \sharp n'}$ or something, I suppose.
This all for the moment leaves unanswered the question:
what kind of things are allowed to be {\em inhabitants} of a member of $\rtype_\Delta$?

Putting that aside, we can at least observe that we probably have a
more normal form of exchange between non-dependent hypotheses, for the
local binders account for the dimension variables.

Let's look however at the phenomenon that was otherwise the `mysterious exchange variant':
\[
\erule
{\Gamma, k : n,  [\ep k/i]A \prov [\ep k /i]C
\qquad
\Gamma, \forall i . A, i : \ii  \prov C
\qquad
\hbox{(some equality)}}
{\Gamma, i : \ii, A \prov C}
\]
What I'd rather say, when $A : \rtype_{\Delta, i : \ii}$
and $C : \rtype_{\Delta, i : \ii}$, is something like
\[
\erule
{\Gamma, k : n,  [\ep k/i]A \prov [\ep k /i]C
\qquad
\Gamma, \forall i . A \prov C
\qquad
\hbox{(some equality)}}
{\Gamma, A \prov C}
\]
Where I still need operations `$[\ep k/i]$' and `$\forall i.$' that
both take a $\rtype_{\Delta,i:\ii}$ to a $\rtype_\Delta$.
Though I kind of think that I need to express more about the term parts of what's going on.
If indeed $\rtype_\Delta$ is like $r_\Delta \to \rtype$, then maybe the term-building proof
\[\Gamma, \forall i . A \prov C\]
is really
\[\Gamma, \rho : r_{\Delta,i:\ii}, (\forall i . A)(r\adjust_\Delta) \prov C(r)\]
Ok, fine, maybe I am thinking about $\rtype_\Delta = r_\Delta \to \rtype$ again.

\[\nu_1 : \sharp n_1, x : A, \nu_2 : \sharp n_2, y : B, \nu_3 : \sharp n_3 \prov M : C\]
becomes
\[\rho : r_{n_1,n_2,n_3}, x : \sem A(\rho\adjust_{n_1}), y : \sem B(\rho\adjust_{n_1,n_2}) \prov \sem M(\rho\adjust_{n_1,n_2,n_3}) : \sem C(\rho\adjust_{n_1,n_2,n_3})\]
with the understanding that {\em since} for example $B$ is a well-defined type in
the context where $\nu_1,\nu_2$ exist, then $\sem B$ is a $r_{n_1,n_2} \to \rtype$.
At this point it seems hard not to justify postulating that $r_{n_1,n_2}$ literally
is $r_{n_1} \x r_{n_2}$, hm.

\subsection{Trying a Clean Description}

In the target language there is a type $r_n$ for each $n$. Define a translation
of contexts like so:
\[
\begin{tabular}{r@{$\quad=\quad$ }l}
$\ssem{\cdot}  $&$\cdot$\\
$\ssem{\Gamma, \nu : \sharp n}  $&$\ssem \Gamma, (\alpha_\nu, \nu)$\\
$\ssem{\Gamma, x : A}  $&$\ssem \Gamma$\\
$\sem{\cdot}  $&$\cdot$\\
$\sem{\Gamma, \nu : \sharp n}  $&$\sem \Gamma, \alpha_\nu : r_n, \nu : \sharp_n(\alpha_\nu)$\\
$\sem{\Gamma, x : A}  $&$\sem \Gamma, \sem A(\ssem \Gamma)$\\
$\usem{\cdot}  $&$\cdot$\\
$\usem{\Gamma, \nu : \sharp n}  $&$\usem \Gamma, \alpha_\nu : r_n, \nu : \sharp_n(\alpha_\nu)$\\
$\usem{\Gamma, x : A}  $&$\usem \Gamma$\\
\end{tabular}
\]
With the idea that if $\Gamma \prov A : \rtype$ then $\sem \Gamma \prov \sem A : \usem \Gamma \to \rtype$, and that $\sem \Gamma \prov \ssem \Gamma : \usem \Gamma$.

Hm but I fear that making $\sharp n = \Sigma (\alpha \cn r_n) . \sharp_n(\alpha)$ doesn't seem
any more special than just making $\sharp n$ persistent.

\section{The Meaning of Types under interval variables}

Let me instead try to think of all the interval variables as occurring
all the way to the left. The interpretation of a type expression $A$
in light of an interval context $\Delta = x_1 : \sharp n_1, \ldots, x_n : \sharp n_m$
is nothing more than a choice of sets
\[ \sem A : (z_1 : n_1^+) \cdots (z_m : n_m^+) \to \rset \]
where $X^+ = X \cup \{\bullet\}$ and commuting maps
\[ \sem A (\cdots z_i = \bullet \cdots) \to \sem A(\cdots z_i = z_i \cdots) \]
that go from apexes of spans to feet.

If I think of $\sharp n$ as literally the $n$-legged free walking span category in the sense of dHoTT,
$\sem A$ in context $\Delta$ is literally then of type $\sharp n_1 \to \cdots \to \sharp n_m \to \rset$,
assuming $\rset$ is a covariant universe.

What $S \star (\nu : \sharp n)$ is interpreted as, then, is quite straightforward; it just is the appropriate span.

So the feeling I'm getting is that what I want to describe is not a single presheaf semantics
for Bernardy-Moulin, but a adjoint-logicky semantics, where each choice of how many interval
variables are around is its own possibility of which presheaf category we're presently
interpreting into. This may end up being equivalent, but I think it may fit in my brain better.

The quantifiers over interval variables --- and the applications that
linearly consume them --- are then perhaps like $F/U$ operators that
move from one category to another. There could be some kind of
weakening principle that allows you to take $A$ sitting at $\Delta$
and migrate it up to $A'$ sitting at $\Delta, \nu : \sharp n$, which
is what corresponds to identity extension, I think, that
thing whose importance Bob Atkey is always going on about.

\subsection{Staring at $\forall$ rules}

\[
\erule
{\Delta, i : \ii; \Gamma \prov  A : \rtype}
{\Delta; \Gamma \prov \forall i . A : \rtype}
\qquad
\erule
{\Delta, i : \ii; \Gamma \prov  M : A }
{\Delta; \Gamma \prov \susp i M : \forall i . A }
\]

\begin{thmbox}
  If $\Delta \prov \Gamma \rctx$, then $\prov \sem \Gamma^\Delta : \sem \Delta \to \rtype$\\
  If $\Delta ; \Gamma \prov A : \rtype$, then $\prov \sem A^\Delta : (\delta : \sem \Delta) \to \sem \Gamma^{\Delta}(\delta)  \to \rtype$.\\
  If $\Delta ; \Gamma \prov M : A$, then $\prov \sem M^\Delta : (\delta : \sem \Delta) (\gamma : \sem \Gamma^{\Delta}(\delta))  \to \sem A^\Delta(\delta, \gamma)$.
\end{thmbox}

But $\sem\Delta$ is kind of a category, so $\sem\Delta \to \rtype$ is really a functor,
 talking about a bunch of choices of types and (commuting) functions. As a category, $\sem\Delta$
is straightforwardly a product of the things in $\Delta$; the category $\sharp 1$ is the arrow
category, $\sharp 2$ is the span category, etc.

To see that the $\forall$ formation rule is sensible, we assume
we have by induction hypothesis
\[\sem A^{\Delta, i : \ii} : (\delta : \sem \Delta \x \sem \ii) \to \sem \Gamma^{\Delta, i : \ii}(\delta) \to \rtype\]
At this point we assume that the way $\Gamma$ gets weakened from $\Delta$ to $\Delta, i : \ii$
is determinate, so we might as well say
\[\sem A^{\Delta, i : \ii} : (\delta : \sem \Delta \x \sem \ii) \to \sem \Gamma^{\Delta}(\pi_1 \delta) \to \rtype\]
And we set
\[\sem {\forall i.A}^{\Delta}(\delta : \sem \Delta, \gamma : \sem \Gamma^\Delta(\delta)) = (i : \sem{\ii}) \to \sem A^{\Delta, i : \ii}\langle\delta, i\rangle(\gamma)\]

\subsubsection{Abstraction}
For the abstraction rule, we suppose that we have
\[\sem M^{\Delta, i : \ii} : (\delta : \sem \Delta \x \sem{\ii})(\gamma : \sem \Gamma^{\Delta, i : \ii}(\delta)) \to \sem A^{\Delta, i: \ii}(\delta, \gamma)\]
which is more or less the same as
\[\sem M^{\Delta, i : \ii} : (\delta : \sem \Delta \x \sem{\ii})(\gamma : \sem \Gamma^{\Delta}(\pi_1 \delta)) \to \sem A^{\Delta, i: \ii}(\delta, \gamma)\]
so we want to come up with
\[ \sem{\susp i M}^\Delta : (\delta : \sem \Delta)(\gamma : \sem \Gamma^{\Delta}(\delta)) \to \sem {\forall i . A}^{\Delta}(\delta, \gamma) \]
i.e.
\[ \sem{\susp i M}^\Delta : (\delta : \sem \Delta)(\gamma : \sem \Gamma^{\Delta}(\delta))  (i : \sem{\ii}) \to \sem A^{\Delta, i : \ii}\langle\delta, i\rangle(\gamma) \]
so we can simply set
\[ \sem{\susp i M}^\Delta(\delta, \gamma, i) = \sem M^{\Delta, i:\ii}(\langle \delta, i\rangle, \gamma)\]

\subsubsection{Application}
\[
\erule
{\Delta; \Gamma \prov M : \forall i . A }
{\Delta, i : \ii; \Gamma \prov  M \bullet i : A }
\]
We start with an assumption that
\[ \sem{ M}^\Delta : (\delta : \sem \Delta)(\gamma : \sem \Gamma^{\Delta}(\delta)) \to \sem {\forall i . A}^{\Delta}(\delta, \gamma) \]
i.e.
\[ \sem{ M}^\Delta : (\delta : \sem \Delta)(\gamma : \sem \Gamma^{\Delta}(\delta))  (i : \sem{\ii}) \to \sem A^{\Delta, i : \ii}\langle\delta, i\rangle(\gamma) \]
and we need to come up with
\[\sem {M \bullet i}^{\Delta, i : \ii} : (\delta : \sem \Delta \x \sem{\ii})(\gamma : \sem \Gamma^{\Delta}(\pi_1 \delta)) \to \sem A^{\Delta, i: \ii}(\delta, \gamma)\]
so we set
\[\sem {M \bullet i}^{\Delta, i : \ii}\langle \delta , i\rangle (\gamma) = \sem M^{\Delta}(\delta, \gamma, i)\]
And pretty clearly $\beta$ and $\eta$ hold here!
\subsection{An important question}
Why is this `substructural', if we're taking $\sem \Delta$ to be the
categorical {\em product} as opposed to some mere monoidal product of
its constituents' interpretations? I think I have a chance of this
being ok, because the application rule intrinsically, explicitly
widens the context. Although... no, I'm still kind of worried, I'm not
sure that a non-context-widening application rule is {\em ruled out}.
Will have to see how spans play out.

\subsection{Ordinary Function Types}
\[
\erule
{\Delta;\Gamma, x : A \prov B : \rtype}
{\Delta;\Gamma \prov  (x : A) \to B : \rtype}
\]
We know
\[ \sem B^\Delta : (\delta : \sem \Delta) \to \sem {\Gamma, x : A}^{\Delta}(\delta)  \to \rtype\]
and want to construct
\[ \sem {(x:A) \to B}^\Delta : (\delta : \sem \Delta) \to \sem \Gamma^{\Delta}(\delta)  \to \rtype\]
Assume
$\sem {\Gamma, x : A}^{\Delta}(\delta) = (\gamma : \sem \Gamma^\Delta(\delta)) \x (x : \sem A(\delta, \gamma))$
we can set
\[ \sem {(x:A) \to B}^\Delta(\delta, \gamma) = (x : \sem A^\Delta(\delta, \gamma))\to \sem B^\Delta(\delta, \langle \gamma, x\rangle)\]
\[
\erule
{\Delta;\Gamma, x : A \prov M : B}
{\Delta;\Gamma \prov \lambda x . M : (x : A) \to B}
\]
We get to assume
\[\sem M^\Delta : (\delta : \sem \Delta) (\gamma : \sem {\Gamma, x : A}^{\Delta}(\delta))  \to \sem B^\Delta(\delta, \gamma)\]
and
want to construct
\[\sem {\lambda x . M}^\Delta : (\delta : \sem \Delta) (\gamma : \sem \Gamma^{\Delta}(\delta))  \to \sem {(x:A)\to B}^\Delta(\delta, \gamma)\]
so we set
\[\sem {\lambda x . M}^\Delta(\delta, \gamma) = \lambda x . \sem M^\Delta(\delta, \langle \gamma, x\rangle) \]
\subsection{Witness types}
\[
\erule
{\Delta; \Gamma \prov S : \rspan_n}
{\Delta, i : \ii; \Gamma \prov S \star i : \rtype}
\]

We get to assume
\[\sem S^\Delta : (\delta : \sem \Delta) (\gamma : \sem {\Gamma}^{\Delta}(\delta))  \to \sem {\rspan_n}^\Delta(\delta, \gamma)\]
and we need to construct
\[\sem {S\star i}^{\Delta, i : \ii} : (\delta : \sem {\Delta} \x \sem{\ii}) (\gamma : \sem {\Gamma}^{\Delta}(\pi_1 \delta))  \to \rtype\]
so we set
\[\sem {S\star i}^{\Delta, i : \ii}(\delta, \gamma) = \blet (\fC, \fA, \ff) = \sem S^\Delta(\pi_1 \delta, \gamma) \]
\[\bin \bcase i \bof \bullet \mapsto \fC \celse \ep k \mapsto \fA \celse f\mapsto \ff\]
Knowing that $\fC : \sem\rset^\Delta(\pi_1 \delta, \gamma) = \rset$ etc.

\subsubsection{intro}
\[
\erule
{\Delta; \Gamma \prov M : \fC }
{\Delta, i : \ii; \Gamma \prov M \star i : S \star i}
\]
Assume
\[\sem M^{\Delta} : (\delta : \sem \Delta) (\gamma : \sem {\Gamma}^{\Delta}(\delta))  \to \fC(\delta, \gamma)\]
Need to construct
\[\sem {M\star i}^{\Delta, i : \ii} : (\delta : \sem \Delta \x \sem \ii) (\gamma : \sem {\Gamma}^{\Delta}(\pi_1 \delta))  \to \sem {S \star i}^{\Delta, i :\ii}(\delta, \gamma)\]
i.e.
\[\sem {M\star i}^{\Delta, i : \ii} : (\delta : \sem \Delta \x \sem \ii ) (\gamma : \sem {\Gamma}^{\Delta}(\pi_1 \delta))  \to \blet (\fC, \fA, \ff) = \sem S^\Delta(\pi_1 \delta, \gamma) \]
\[\bin \bcase i \bof \bullet \mapsto \fC \celse \ep k \mapsto \fA \celse f\mapsto \ff\]
so we set
\[\sem {M\star i}^{\Delta, i : \ii}\langle \delta, i\rangle (\gamma) = \blet c = \sem M^\Delta(\delta, \gamma) \]
\[\bin \bcase i \bof \bullet \to c \celse \ep k \to \ff(c)\]
\subsubsection{elim}
\[
\erule
{\Delta, i : \ii; \Gamma \prov M : S \star i}
{\Delta; \Gamma \prov \ssusp i M : \fC }
\]
Assume
\[\sem M^{\Delta, i : \ii} : (\delta : \sem \Delta \x \sem \ii) (\gamma : \sem {\Gamma}^{\Delta}(\pi_1 \delta))  \to \sem {S \star i}^{\Delta, i :\ii}(\delta, \gamma)\]
i.e.
\[\sem M^{\Delta, i : \ii} : (\delta : \sem \Delta \x \sem \ii ) (\gamma : \sem {\Gamma}^{\Delta}(\pi_1 \delta))  \to \blet (\fC, \fA, \ff) = \sem S^\Delta(\pi_1 \delta, \gamma) \]
\[\bin \bcase i \bof \bullet \mapsto \fC \celse \ep k \mapsto \fA \celse f\mapsto \ff\]
and we need
\[\sem {\ssusp i M}^\Delta : (\delta : \sem \Delta ) (\gamma : \sem {\Gamma}^{\Delta}( \delta))  \to \fC(\delta, \gamma)\]

So just set
$\sem {\ssusp i M}^\Delta(\delta, \gamma) = \sem M^{\Delta, i:\ii}\langle \delta, \bullet \rangle (\gamma)$
\subsection{$\sharp$-elimination}
\[
\erule
{\[
\Delta, i : \ii ; \Gamma, y : \forall i . A  \prov N : [y\ i/x]C
\djust
\Delta; [\ep k/i]\Gamma,   x : [\ep k/i]A \prov M_k : [\ep k /i]C
\]}
{\Delta, i : \ii; \Gamma, x : A \prov \bcase : C}
\]
We get to assume (letting $\Gamma_k = [\ep k / i]\Gamma$ and
$C_k = [\ep k / i]C$ and
$A_k = [\ep k / i]A$ and
$\Delta' = \Delta, i : \ii$)
\[\sem N^{\Delta'} : (\delta : \sem \Delta \x \sem \ii) (\gamma : \sem \Gamma^{\Delta'}(\delta)) (y : \sem {\forall i . A}^{\Delta'}(\delta, \gamma)) \to \sem {[y\ i/x]C}^{\Delta'}(\delta, \gamma)\]
\[\sem {M_k}^{\Delta} : (\delta : \sem \Delta) (\gamma : \sem {\Gamma_k}^{\Delta}(\delta)) (x : \sem{A_k}^\Delta(\delta, \gamma)) \to \sem {C_k}^{\Delta}(\delta, \gamma)\]
we need to construct
\[\sem {\bcase}^{\Delta'} : (\delta : \sem \Delta \x \sem \ii) (\gamma : \sem {\Gamma}^{\Delta'}(\delta)) (x : \sem{A}^{\Delta'}(\delta, \gamma)) \to \sem {C}^{\Delta'}(\delta, \gamma)\]
so we set
\[\sem {\bcase}^{\Delta'}  (\langle \delta, i\rangle , \gamma) (x) = \bcase i \bof\]
\[\celse \bullet \mapsto \sem N^{\Delta'}(\langle \delta, \bullet\rangle, \gamma ) \]
\[\celse \ep k \mapsto \sem{M_k}^\Delta( )\]
$\cdots$ actually no, this is kind of broken, because $\forall i$ formation requires the $\Gamma$ be free of $i$.

\subsection{$\sharp$-elimination for the special case where $i \not\in \Gamma$}
\[
\erule
{\[
\Delta, i : \ii ; \Gamma, y : \forall i . A  \prov N : [y\ i/x]C
\djust
\Delta; \Gamma,   x : [\ep k/i]A \prov M_k : [\ep k /i]C
\]}
{\Delta, i : \ii; \Gamma, x : A \prov \bcase : C}
\]
We get to assume (letting
$C_k = [\ep k / i]C$ and
$A_k = [\ep k / i]A$ and
$\Delta' = \Delta, i : \ii$)
\[\sem N^{\Delta'} : (\delta : \sem \Delta \x \sem \ii) (\gamma : \sem \Gamma^{\Delta}(\pi_1\delta)) (y : \sem {\forall i . A}^{\Delta}(\pi_1\delta, \gamma)) \to \sem {[y\ i/x]C}^{\Delta'}(\delta, \gamma)\]
\[\sem {M_k}^{\Delta} : (\delta : \sem \Delta) (\gamma : \sem {\Gamma}^{\Delta}(\delta)) (x : \sem{A_k}^\Delta(\delta, \gamma)) \to \sem {C_k}^{\Delta}(\delta, \gamma)\]
we need to construct
\[\sem {\bcase}^{\Delta'} : (\delta : \sem \Delta \x \sem \ii) (\gamma : \sem {\Gamma}^{\Delta}(\pi_1 \delta)) (x : \sem{A}^{\Delta'}(\delta, \gamma)) \to \sem {C}^{\Delta'}(\delta, \gamma)\]
so we set
\[\sem {\bcase}^{\Delta'}  (\langle \delta, i\rangle , \gamma) (x) = \bcase i \bof\]
\[\celse \bullet \mapsto \sem N^{\Delta'}(\langle \delta, \bullet\rangle, \gamma )(x) \]
\[\celse \ep k \mapsto \sem{M_k}^\Delta(\delta, \gamma)(x)\]
Or something like this perhaps?

\section{Trying to Figure Out What's Absolutely Necessary}

Let's say $\Delta$ is a list of variables associated with categories (or maybe just reflexive graphs? Maybe while demanding an initial object?)
\[\Delta ::= \cdot \celse \Delta, i : \C\]
The interpretation of
\[\Delta ; \Gamma \rctx\]
is a functor (or reflexive graph homomorphism? maybe preserving
initial objects?) $\sem \Gamma$ of type $\prod \Delta \to \rset$.
The thing to say of greater generality might be that $\C$ has
to be merely an object in {\em some} finite-product-having category
--- or merely that $\Delta$ itself is an object in that category ---
and talking about fibered objects $\sem \Gamma \to \Delta$ over
$\Delta$.

Let me put that off for now --- $\C$ is definitely
specifically a {\em category}, there are no dependencies within $\Delta$ so
the object $\sem \Delta \in \rcat$ that $\Delta$ represents is simply the product of categories,
(although ---
in the reflexive graph case, maybe the tensor product of graphs?)
and the interpretation of a well-formed context of ordinary variables
is a functor $\sem \Gamma : \sem \Delta \to \rset$.

I want to say that the interpretation of
\[\Delta ; \Gamma \prov A : \rtype\]
is $\sem A : (\delta : \sem \Delta) \to \sem \Gamma(\delta) \to \rset$,
but since $\sem \Delta$ isn't literally a {\em type}, I need to explain what this means,
and what coherences it has. For every object $\delta \in \sem \Delta$, there should indeed
be a fiber
\[\sem A(\delta) : \sem \Gamma(\delta) \to \rset\]
For every morphism $\phi : \delta_1 \to \delta_2 \in \sem \Delta$, there should be a
function
\[\sem A(\phi) : (\gamma : \sem\Gamma(\delta_1)) \to \sem A(\delta_1)(\gamma) \to
 \sem A(\delta_2)(\sem \Gamma(\phi)(\gamma))\]
probably satisfying unsurprising coherence laws.
This smells like a morphism in a category of elements.

The interpretation of $\Gamma \prov M : A$ is, for every object $\delta \in \sem \Delta$,
a function
\[ \sem M(\delta) : (\gamma : \sem \Gamma(\delta)) \to \sem A(\delta)(\gamma)\]
and for every $\phi : \delta_1 \to \delta_2$, an equality
\[ \sem M(\phi) : (\gamma : \sem\Gamma(\delta_1))  \to
\sem A(\phi)(\gamma)(\sem M(\delta_1)(\gamma))
\equiv
\sem M(\delta_2)( \sem \Gamma(\phi)(\gamma))
\]

\subsection{As Agda}
Probably kinda pointless to put this here because it's too much manual work to turn
unicode back into \TeX.
\begin{lstlisting}[mathescape=true]
postulate
  Ctxd : Set
  Ctx : Ctxd $\to$ Set
  Tp : {$\Delta$ : Ctxd} $\to$ Ctx $\Delta$ $\to$ Set
  Tm : {$\Delta$ : Ctxd} {$\Gamma$ : Ctx $\Delta$} $\to$ Tp $\Gamma$ $\to$ Set
  Obj : Set
  Mor : Obj $\to$ Obj $\to$ Set
  iCtxObj : {$\Delta$ : Ctxd} ($\Gamma$ : Ctx $\Delta$)
    $\to$ Obj $\to$ Set
  iCtxMor : {$\Delta$ : Ctxd} ($\Gamma$ : Ctx $\Delta$)
    $\to$ {$\delta$1 $\delta$2 : Obj} ($\phi$ : Mor $\delta$1 $\delta$2)
    $\to$ iCtxObj $\Gamma$ $\delta$1 $\to$ iCtxObj $\Gamma$ $\delta$2
  iTpObj : {$\Delta$ : Ctxd} {$\Gamma$ : Ctx $\Delta$} (A : Tp $\Gamma$)
    $\to$ ($\delta$ : Obj) $\to$ iCtxObj $\Gamma$ $\delta$ $\to$ Set
  iTpMor : {$\Delta$ : Ctxd} {$\Gamma$ : Ctx $\Delta$} (A : Tp $\Gamma$)
    $\to$ {$\delta$1 $\delta$2 : Obj} ($\phi$ : Mor $\delta$1 $\delta$2)
    $\to$ ($\gamma$ : iCtxObj $\Gamma$ $\delta$1) $\to$ iTpObj A $\delta$1 $\gamma$ $\to$ iTpObj A $\delta$2 (iCtxMor $\Gamma$ $\phi$ $\gamma$)
  iTmObj : {$\Delta$ : Ctxd} {$\Gamma$ : Ctx $\Delta$} {A : Tp $\Gamma$} (M : Tm A)
    $\to$ ($\delta$ : Obj) ($\gamma$ : iCtxObj $\Gamma$ $\delta$) $\to$ iTpObj A $\delta$ $\gamma$
  iTmMor : {$\Delta$ : Ctxd} {$\Gamma$ : Ctx $\Delta$} {A : Tp $\Gamma$} (M : Tm A)
    $\to$ {$\delta$1 $\delta$2 : Obj} ($\phi$ : Mor $\delta$1 $\delta$2)
    $\to$ ($\gamma$ : iCtxObj $\Gamma$ $\delta$1) $\to$
      iTpMor A $\phi$ $\gamma$ (iTmObj M $\delta$1 $\gamma$) == iTmObj M $\delta$2 (iCtxMor $\Gamma$ $\phi$ $\gamma$)
\end{lstlisting}

%% module a where

%% data _==_ {A : Set} : A → A → Set where
%%   refl : {a : A} → a == a

%% postulate
%%   Ctxd : Set
%%   Ctx : Ctxd → Set
%%   Tp : {Δ : Ctxd} → Ctx Δ → Set
%%   Tm : {Δ : Ctxd} {Γ : Ctx Δ} → Tp Γ → Set
%%   Obj : Set
%%   Mor : Obj → Obj → Set
%%   iCtxObj : {Δ : Ctxd} (Γ : Ctx Δ)
%%     → Obj → Set
%%   iCtxMor : {Δ : Ctxd} (Γ : Ctx Δ)
%%     → {δ1 δ2 : Obj} (φ : Mor δ1 δ2)
%%     → iCtxObj Γ δ1 → iCtxObj Γ δ2
%%   iTpObj : {Δ : Ctxd} {Γ : Ctx Δ} (A : Tp Γ)
%%     → (δ : Obj) → iCtxObj Γ δ → Set
%%   iTpMor : {Δ : Ctxd} {Γ : Ctx Δ} (A : Tp Γ)
%%     → {δ1 δ2 : Obj} (φ : Mor δ1 δ2)
%%     → (γ : iCtxObj Γ δ1) → iTpObj A δ1 γ → iTpObj A δ2 (iCtxMor Γ φ γ)
%%   iTmObj : {Δ : Ctxd} {Γ : Ctx Δ} {A : Tp Γ} (M : Tm A)
%%     → (δ : Obj) (γ : iCtxObj Γ δ) → iTpObj A δ γ
%%   iTmMor : {Δ : Ctxd} {Γ : Ctx Δ} {A : Tp Γ} (M : Tm A)
%%     → {δ1 δ2 : Obj} (φ : Mor δ1 δ2)
%%     → (γ : iCtxObj Γ δ1) → iTpMor A φ γ (iTmObj M δ1 γ) == iTmObj M δ2 (iCtxMor Γ φ γ)

\subsection{Witness Types}
\[
\erule
{\[\forall c \in \C: \qquad \Delta; \Gamma \prov A_c : \rtype
\djust
\forall f : c \to d \in \C: \qquad \Delta; \Gamma, x : A_c \prov M_f : A_d
\]}
{\Delta, i : \C; \Gamma \prov (A_c, M_f) \star i : \rtype}
\]

We get to assume for every object $\delta\in\sem \Delta$ that
\[\sem {A_c}(\delta) : (\gamma : \sem {\Gamma}(\delta))  \to \rset\]
\[\sem {M_f}(\delta) : (\gamma : \sem {\Gamma}(\delta)) (x : \sem{A_c}(\delta, \gamma))  \to \sem {A_d}(\delta, \gamma)\]
and every $\phi : \delta_1 \to \delta_2$ that
\[\sem A_c(\phi) : (\gamma : \sem\Gamma(\delta_1)) \to \sem A_c(\delta_1)(\gamma) \to
 \sem A_c(\delta_2)(\sem \Gamma(\phi)(\gamma))\]
\[ \sem {M_f}(\phi) : (\gamma : \sem{\Gamma}(\delta_1))(x : \sem {A_c}(\delta_1, \gamma))  \to\]
\[\sem {A_d}(\phi)(\gamma)(\sem {M_f}(\delta_1)(\gamma, x))
\equiv
\sem {M_f}(\delta_2)( \sem {\Gamma}(\phi)(\gamma), \sem {A_c}(\phi)(x))
\]


and we need to construct for each $(\delta, c) \in \sem {\Delta, i : \C}$
(letting $S = ((A_c)_{c\in \C}, (M_f)_{f\in \C})$)
\[\sem {S \star i}(\delta, c) : (\gamma : \sem {\Gamma}(\delta))  \to \rset\]
and for each $(\phi, f) : (\delta_1, c) \to (\delta_2, d)$ construct
\[\sem {S \star i}(\phi, f) : (\gamma : \sem {\Gamma}(\delta_1))
 \to \sem {S \star i}((\delta_1, c), \gamma)
 \to \sem {S \star i}((\delta_2, d), \sem \Gamma(\phi)(\gamma)) \]

(note that silently what's going on is that $\sem \Gamma$, already a
functor from $\sem \Delta$ to $\rset$, is {\em also} weakenable to a
functor $\sem {\Delta, i : \C} \to \rset$, by outputting identity
morphisms for any morphism between $\C$-objects --- I think this is
why we need identities to exist, so at least reflexive graphs if not
categories? --- or maybe it's not really happening here, maybe it's
just projection, but I think it will come up)

But we can just set
\[\sem {S \star i}(\delta, c)(\gamma) = \sem {A_c}(\delta)(\gamma)\]
\[\sem {S \star i}(\phi, f)(\gamma)(x) = \sem {M_f}(\delta)(\gamma)(x)\]

\end{document}
