\documentclass{article}
\usepackage[tmargin=0.15in, bmargin=0.15in]{geometry}
\input{theorem}
\input{prooftree}
\usepackage{hyperref}
% https://tex.stackexchange.com/a/847
\hypersetup{
    colorlinks,
    urlcolor={blue},
}
\usepackage{makecell}
\usepackage{relsize}
\usepackage{latexsym}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,cd,decorations.pathreplacing}
\usetikzlibrary{hobby}
\usepackage{tcolorbox}
\usepackage{stackengine}
\newcommand\oast{\stackMath\mathbin{\stackinset{c}{0ex}{c}{0ex}{\ast}{\bigcirc}}}

\tcbuselibrary{breakable}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}

\def\sssection#1{\vskip1em \hrule\vskip 0.5em \noindent $\triangleright$ {\bf #1} \vskip0.5em \hrule\vskip 1em }
\def\I{\mathbb{I}}




\def\gets{\leftarrow}
\def\dia{\Diamond}
\def\all{\forall}

\def\spec{\mathsf{Spec}}
\def\breturn{\mathop{\mathbf{return}}\nolimits}
\def\bthunk{\mathop{\mathbf{thunk}}\nolimits}
\def\brun{\mathop{\mathbf{run}}\nolimits}
\def\bget{\mathop{\mathbf{get}}\nolimits}
\def\bGel{\mathop{\mathbf{Gel}}\nolimits}
\def\bgel{\mathop{\mathbf{gel}}\nolimits}
\def\bgbound{\mathop{\mathbf{gbound}}\nolimits}
\def\bgpath{\mathop{\mathbf{gpath}}\nolimits}
\def\bungel{\mathop{\mathbf{ungel}}\nolimits}
\def\bGet{\mathop\mathbf{Get}}
\def\dapt#1#2{#1[\![#2]\!]}
\def\dap#1#2{#1\{#2\}}
\def\ll{\langle\!\langle}
\def\rr{\rangle\!\rangle}
\def\rshape{\ {\mathsf{shape}}}
\def\rrefl{{\mathsf{refl}}}
\def\bd{\mathsf{Bd}}
\def\bdd{\mathsf{Bdd}}
\def\rset{\mathsf{Type}}
\def\rid{\mathsf{id}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\prequiv{\dashv\vdash}
\def\sq{\square}

\definecolor{blu}{rgb}{0.1,0.5,1}
\definecolor{orng}{rgb}{1,0.5,0.3}

\def\nameof#1{\ulcorner{#1}\urcorner}
\def\U{\mathsf{U}}
\def\uu{\mathsf{u}}
\def\uni{\U}



\definecolor{lred}{rgb}{0.95,0.8,0.8}
\definecolor{cyan}{rgb}{0.80,0.95,0.95}
\definecolor{lorange}{rgb}{0.95,0.90,0.80}
\definecolor{bluegray}{rgb}{0.6,0.6,0.85}
\definecolor{lgray}{gray}{0.8}
\newtcolorbox{declbox}{colframe=lred,colback=lred,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{thmbox}{colframe=cyan,colback=cyan,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{defnbox}{colframe=lorange,colback=lorange,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{tangentbox}{colframe=lgray,colback=lgray,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}

\input{linear}
\def\parr{\mathbin{\rotatebox[origin=c]{180}{\&}}}
\def\iff{\ \Longleftrightarrow\ }
\def\bu{\bullet}
\def\J{\mathbb{J}}
\def\R{\mathbb{R}}
\def\rpath#1{[#1]}
\def\rfst{\mathsf{fst}\,}
\def\rsnd{\mathsf{snd}\,}
\def\bunfold{\mathbf{unfold}}
\def\bfold{\mathbf{fold}}
\def\susp#1{\langle {#1} \rangle}
\def\ssusp#1{\langle\!\langle {#1} \rangle\!\rangle}
\def\dto{\mathrel{\dot\to}}
\def\dns{{\downarrow}}
\def\ups{{\uparrow}}
\def\sprov{\Vdash}
\def\signat{{\color{red}\Sigma}}
\def\ep#1{\underline{#1}}
\def\wat{{@}}
\def\wwat{\mathbin{\underline\wat}}
\def\cn{{:}}
\def\cprov{\mathrel\#}
\def\dv{{\div}}
\def\ww{{\mathsf w}}
\def\base{{\textfrak b}}

\def\N{{\mathbb N}}
\def\Z{{\mathbb Z}}
\def\munit{I}
\def\tt{{\mathsf t}}
\def\ii{{\mathbb I}}
\def\T{\mathbb{T}}
\def\tw{\mathop\triangleright\nolimits}
\def\tb{\mathop\blacktriangleleft}
\def\sw#1{^{#1}_{#1}}
\def\TP{\mathbf{TPre}}
\def\pp{\textsf{\textbf p}}
\def\nn{{\mathsf n}}
\def\PP{\textsf{\textbf P}}
\def\NN{\textsf{\textbf N}}
\def\zz{{\mathsf z}}
\def\sem#1{[\![#1]\!]}
\def\usem#1{\lceil\!\!\lceil{#1}\rceil\!\!\rceil}
\def\zem#1{\langle\!\langle#1\rangle\!\rangle}
\def\col#1{{\mathsf{C}}_{#1}}
\def\lax{\mathop\bigcirc}
\def\rjust{\mathsf{just}}
\def\rcvt{\mathsf{cvt}}
\def\rtype{\mathsf{type}}
\def\rdtype{\mathsf{disc}}
\def\rkind{\mathsf{kind}}
\def\rmode{\mathsf{mode}}
\def\rprel{\mathbf{Prel}}
\def\rrfam{\mathbf{Rfam}}
%\def\rset{\mathbf{Set}}
\def\rfinset{\mathbf{FinSet}}
\def\rrel{\mathbf{Rel}}
\def\rcat{\mathbf{Cat}}
\def\rfam{\mathbf{Fam}}
\def\binj{\mathbf{inj}}
\def\rtrue{\ \mathsf{true}}
\def\rfalse{\ \mathsf{false}}
\def\pbck{\ar[dr, phantom, pos=0, "\lrcorner"]}
\def\bpbck{\ar[ddrr, phantom, pos=0, "\lrcorner"]}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\btwo{\mathbf{2}}
\def\bone{\mathbf{1}}

\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\def\mapt{\ar[ddd,mapsto,shorten <=2em, shorten >=2em]}
\def\A{\mathbf{A}}
\def\B{\mathbb{B}}
\def\C{\mathbb{C}}
\def\W{\mathbb{W}}
\def\S{\mathbf{S}}
\def\G{\mathbf{G}}
\def\D{\mathbb{D}}
\def\E{\mathbb{E}}
\def\M{\mathbf{M}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\ltri{{\lhd}}
\def\rtri{{\rhd}}
\def\tri{\rhd}
\def\cc{\mathsf{c}}
\def\dd{\mathsf{d}}
\def\o{\circ}
\def\rctx{\,\mathsf{ctx}}
\def\rdctx{\,\mathsf{dctx}}
\def\del{\partial}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\definecolor{fib}{HTML}{ff7f00}
\definecolor{green}{HTML}{007f00}
\definecolor{red}{HTML}{df3f3f}
\definecolor{opfib}{HTML}{007fff}

% For lightening colors I used
% http://trycolors.com/ 6 parts white to 1 part color
\definecolor{opfibl}{HTML}{DBEDFF}
\definecolor{greenl}{HTML}{DBEDDB}
\definecolor{redl}{HTML}{FAE4E4}

% https://tex.stackexchange.com/questions/716631/curved-arrows-from-tikz-cd-do-not-work
\tikzset{
  curve/.style={
    settings={#1},
    to path={
      (\tikztostart)
      .. controls ($(\tikztostart)!\pv{pos}!(\tikztotarget)!\pv{height}!270:(\tikztotarget)$)
      and ($(\tikztostart)!1-\pv{pos}!(\tikztotarget)!\pv{height}!270:(\tikztotarget)$)
      .. (\tikztotarget)\tikztonodes
    },
  },
  settings/.code={%
    \tikzset{quiver/.cd,#1}%
    \def\pv##1{\pgfkeysvalueof{/tikz/quiver/##1}}%
  },
  quiver/.cd,
  pos/.initial=0.35,
  height/.initial=0,
}

\begin{document}

\def\
\tikzset{
   commutative diagrams/.cd,
   arrow style=tikz,
   diagrams={>=stealth}}
\tikzset{shorten <>/.style={shorten >=#1,shorten <=#1}}

\section{Weak Pushouts}

We suppose the existence of a property of commutative squares,
call it {\em cohesive}.
\[\begin{tikzcd}
	{X}  & { B} \\
	{A} & {R}
	\arrow["{}"', from=1-2, to=1-1]
	\arrow["", from=2-1, to=1-1]
	\arrow["{}"', from=2-2, to=1-2]
	\arrow["{}", from=2-2, to=2-1]
\end{tikzcd}\]
We say `$X$ is cohesive $A \to B$ over $R$' as an abbreviation.
We say $X$ is symmetric cohesive between $A$ and $B$ if $X$
is cohesive $A \to B$ and $B \to A$.
We assume
\begin{itemize}
\item every span has a universal (i.e. initial) cohesive completion
\item every span has a universal (i.e. initial) symmetric cohesive completion
\end{itemize}
We should expect (although I'm not sure how best to axiomatize) that
\[\begin{tikzcd}
	B & B \\
	B & A
	\arrow[equals, from=1-2, to=1-1]
	\arrow[equals, from=2-1, to=1-1]
	\arrow["f"', from=2-2, to=1-2]
	\arrow["f", from=2-2, to=2-1]
\end{tikzcd}\]
is the universal symmetric cohesive diagram on the span consisting of two copies of $f$.

First quick lemma I want to check to ensure I have things the right way around.
The cohesive completion of a span should inject into the symmetric cohesive completion.

% https://q.uiver.app/#q=WzAsNSxbMSwyLCJBIl0sWzIsMSwiQiJdLFsyLDIsIkMiXSxbMSwxLCJYIl0sWzAsMCwiWSJdLFsxLDNdLFswLDNdLFsyLDBdLFsyLDFdLFsxLDQsIiIsMix7ImN1cnZlIjoyfV0sWzAsNCwiIiwyLHsiY3VydmUiOi0yfV0sWzMsNCwiIiwyLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV1d
\[\begin{tikzcd}
	Y \\
	& X & B \\
	& A & C
	\arrow[dashed, from=2-2, to=1-1]
	\arrow[curve={height=12pt}, from=2-3, to=1-1]
	\arrow[from=2-3, to=2-2]
	\arrow[curve={height=-12pt}, from=3-2, to=1-1]
	\arrow[from=3-2, to=2-2]
	\arrow[from=3-3, to=2-3]
	\arrow[from=3-3, to=3-2]
\end{tikzcd}\]
So suppose $XABC$ is cohesive, and $YABC$ is symmetric cohesive. Therefore $YABC$
is also cohesive. But $XABC$ is the universal cohesive completion of $ABC$, so there
is a unique map $X \to Y$ making everything commute. Ok, that seems correct.


Ok, now let $ A$ be the cohesive completion of the span $1 \gets 0 \to 1$.
\[\begin{tikzcd}
	{ A}  & {1} \\
	{1} & {0}
	\arrow["{c}"', from=1-2, to=1-1]
	\arrow["d", from=2-1, to=1-1]
	\arrow["{!}"', from=2-2, to=1-2]
	\arrow["{!}", from=2-2, to=2-1]
\end{tikzcd}\]
I can consider the pushout of $ A$ with itself, to make a path consisting of
two steps. Call this ${ A}_2$, which has domain and codomain points as maps from $1$.
Or I can just recognize that there are maps $2 \to  A$ and $2 \to { A}_2$ accounting
for their respective boundaries.
I can then take the universal symmetric cohesive completion of these two
\[\begin{tikzcd}
	{K_2}  & { A} \\
	{{ A}_2} & {2}
	\arrow["{}"', from=1-2, to=1-1]
	\arrow["", from=2-1, to=1-1]
	\arrow["{}"', from=2-2, to=1-2]
	\arrow["{}", from=2-2, to=2-1]
\end{tikzcd}\]
and now $K_2$ is an object that represents two morphisms being composed to one.
More generally, I can take some pushouts of $n$ copies of $ A$, yielding ${ A}_n$.
Let $K_n$ be the universal symmetric completion
\[\begin{tikzcd}
	{K_n}  & { A} \\
	{{ A}_n} & {2}
	\arrow["{}"', from=1-2, to=1-1]
	\arrow["", from=2-1, to=1-1]
	\arrow["{}"', from=2-2, to=1-2]
	\arrow["{}", from=2-2, to=2-1]
\end{tikzcd}\]
For a type $C$ to behave like a category, it should be a fibrant object with respect
to the class of cofibrations $A_n \to K_n$. We should have solutions to lifting problems

\[\begin{tikzcd}
	{A_n} & C \\
	{K_n} & \textcolor{lgray}{1}
	\arrow[from=1-1, to=1-2]
	\arrow["{\eta_n}"', from=1-1, to=2-1]
	\arrow[color={lgray}, from=1-2, to=2-2]
	\arrow[dashed, from=2-1, to=1-2]
	\arrow[color={lgray}, from=2-1, to=2-2]
\end{tikzcd}\]
It might be that $\eta_0$ and $\eta_2$ suffice to be equivalent to the whole class of cofibrations.
\subsection{Associativity}
A type $C$ that is fibrant with respect to $\eta_2$ is a type that in some sense supports
composition of morphisms. I'd like to show that that composition must be associative. For
that I think I need to know the property of being a cohesive commutative square
somehow interacts well with composition.

\subsubsection{Vertical Composition}
% https://q.uiver.app/#q=WzAsNyxbMCwyLCJBIl0sWzIsMiwiQiJdLFs0LDIsIkMiXSxbMSwxLCJYIl0sWzMsMSwiWSJdLFsyLDAsIloiXSxbMiwzLCJEIl0sWzYsMV0sWzAsM10sWzEsM10sWzEsNF0sWzIsNF0sWzMsNV0sWzQsNV0sWzYsMCwiIiwyLHsiY3VydmUiOi0yfV0sWzYsMiwiIiwyLHsiY3VydmUiOjJ9XSxbNSwxLCIiLDIseyJzdHlsZSI6eyJuYW1lIjoiY29ybmVyIn19XV0=
\[\begin{tikzcd}
	&& Z \\
	& X && Y \\
	A && B && C \\
	&& D
	\arrow["\lrcorner"{anchor=center, pos=0.125, rotate=-45}, draw=none, from=1-3, to=3-3]
	\arrow[from=2-2, to=1-3]
	\arrow[from=2-4, to=1-3]
	\arrow[from=3-1, to=2-2]
	\arrow[from=3-3, to=2-2]
	\arrow[from=3-3, to=2-4]
	\arrow[from=3-5, to=2-4]
	\arrow[curve={height=-12pt}, from=4-3, to=3-1]
	\arrow[from=4-3, to=3-3]
	\arrow[curve={height=12pt}, from=4-3, to=3-5]
\end{tikzcd}\]
I think I want to require that if $X$ is cohesive $A \to B$ and $Y$ is cohesive $B \to C$,
then $Z$, given by the pushout of $X$ and $Y$ over $B$, is cohesive $A \to C$.

Notice that this also gives me vertical composability of symmetric cohesive squares.
If $X$ is symmetric cohesive $A = B$ and $Y$ is symmetric cohesive $B = C$, then
$Z$ is the same pushout regardless of which direction the morphisms go; it is then
symmetric cohesive $A = C$.
\subsection{Horizontal Composition}
Suppose we are trying to compose something like
\[\begin{tikzcd}
	A & B & C
	\arrow[""{name=0, anchor=center, inner sep=0}, "f", curve={height=-12pt}, from=1-1, to=1-2]
	\arrow[""{name=1, anchor=center, inner sep=0}, "g"', curve={height=12pt}, from=1-1, to=1-2]
	\arrow[""{name=2, anchor=center, inner sep=0}, "h", curve={height=-12pt}, from=1-2, to=1-3]
	\arrow[""{name=3, anchor=center, inner sep=0}, "k"', curve={height=12pt}, from=1-2, to=1-3]
	\arrow["\alpha", shorten <=3pt, shorten >=3pt, Rightarrow, from=0, to=1]
	\arrow["\beta", shorten <=3pt, shorten >=3pt, Rightarrow, from=2, to=3]
\end{tikzcd}\]
I think the appropriate diagram is something like
% https://q.uiver.app/#q=WzAsMTYsWzEsNywiQSJdLFs0LDcsIkIiXSxbNyw3LCJDIl0sWzEsNiwiQVxcb3BsdXMgQiJdLFs3LDYsIkJcXG9wbHVzIEMiXSxbNCw4LCJEIl0sWzQsNSwiQVxcb3BsdXMgQyJdLFswLDMsImYiXSxbMiw0LCJnIl0sWzYsMywiaCJdLFs4LDQsImsiXSxbMSwxLCJcXGFscGhhIl0sWzcsMSwiXFxiZXRhIl0sWzMsMiwiaFxcY2lyYyBmIl0sWzUsMywia1xcY2lyYyBnIl0sWzQsMCwiXFxiZXRhKlxcYWxwaGEiXSxbNSwxXSxbMCwzXSxbMSwzXSxbMSw0XSxbMiw0XSxbNSwwLCIiLDIseyJjdXJ2ZSI6LTJ9XSxbNSwyLCIiLDIseyJjdXJ2ZSI6Mn1dLFswLDZdLFsyLDZdLFszLDUsIiIsMix7InN0eWxlIjp7Im5hbWUiOiJjb3JuZXIifX1dLFs0LDUsIiIsMix7InN0eWxlIjp7Im5hbWUiOiJjb3JuZXIifX1dLFs2LDUsIiIsMix7InN0eWxlIjp7Im5hbWUiOiJjb3JuZXIifX1dLFszLDddLFszLDhdLFs0LDldLFs0LDEwXSxbNywxMV0sWzgsMTFdLFs5LDEyXSxbMTAsMTJdLFs3LDEzXSxbOSwxM10sWzgsMTRdLFsxMCwxNF0sWzYsMTRdLFs2LDEzXSxbMTMsMTVdLFsxNCwxNV0sWzExLDE1XSxbMTIsMTVdXQ==
\[\begin{tikzcd}
	&&&& {\beta*\alpha} \\
	& \alpha &&&&&& \beta \\
	&&& {h\circ f} \\
	f &&&&& {k\circ g} & h \\
	&& g &&&&&& k \\
	&&&& {A\oplus C} \\
	& {A\oplus B} &&&&&& {B\oplus C} \\
	& A &&& B &&& C \\
	&&&& D
	\arrow[from=2-2, to=1-5]
	\arrow[from=2-8, to=1-5]
	\arrow[from=3-4, to=1-5]
	\arrow[from=4-1, to=2-2]
	\arrow[from=4-1, to=3-4]
	\arrow[from=4-6, to=1-5]
	\arrow[from=4-7, to=2-8]
	\arrow[from=4-7, to=3-4]
	\arrow[from=5-3, to=2-2]
	\arrow[from=5-3, to=4-6]
	\arrow[from=5-9, to=2-8]
	\arrow[from=5-9, to=4-6]
	\arrow[from=6-5, to=3-4]
	\arrow[from=6-5, to=4-6]
	\arrow["\lrcorner"{anchor=center, pos=0.05, rotate=-45}, draw=none, from=6-5, to=9-5]
	\arrow[from=7-2, to=4-1]
	\arrow[from=7-2, to=5-3]
	\arrow["\lrcorner"{anchor=center, pos=0.05}, draw=none, from=7-2, to=9-5]
	\arrow[from=7-8, to=4-7]
	\arrow[from=7-8, to=5-9]
	\arrow["\lrcorner"{anchor=center, pos=0.05, rotate=-90}, draw=none, from=7-8, to=9-5]
	\arrow[from=8-2, to=6-5]
	\arrow[from=8-2, to=7-2]
	\arrow[from=8-5, to=7-2]
	\arrow[from=8-5, to=7-8]
	\arrow[from=8-8, to=6-5]
	\arrow[from=8-8, to=7-8]
	\arrow[curve={height=-12pt}, from=9-5, to=8-2]
	\arrow[from=9-5, to=8-5]
	\arrow[curve={height=12pt}, from=9-5, to=8-8]
   \arrow["\star"{anchor=center, pos=0.05}, draw=none, from=2-2, to=7-2]
   \arrow["\star"{anchor=center, pos=0.05, color={red}}, draw=none, from=1-5, to=6-5]
	\arrow["\star"{anchor=center, pos=0.05}, draw=none, from=2-8, to=7-8]
\end{tikzcd}\]
The assumptions include the following.
$A\oplus B$ and $A\oplus C$ and $B \oplus C$ are pushouts over $D$.
$h \o f$ and $k \o g$ are pushouts over $B$.
The maps $A \oplus C$ into $h\o f$ and $k\o g$ can be constructed from
the pushout UMP of $A \oplus C$. The object $\beta * \alpha$ is a pushout
over $\alpha$ and $\beta$ over $B$. The maps from $h \o f$ and $k \o g$ into
$\beta * \alpha$ can be constructed from pushout UMPs of the two 1-morphism compositions.

Given all of that, we axiomatize `horizontal composition' by asserting that
\begin{itemize}
\item $\alpha$ is cohesive $f \to g$ over $A \oplus B$,
\item $\beta$ is cohesive $h \to k$ over $B \oplus C$
\end{itemize}
then $\beta * \alpha$ is cohesive $h f \to kg$ over $A \oplus C$.
\subsection{A Potential Problem}
I can take the universal cohesive completion of
\[\begin{tikzcd}
	{X}  & { 1} \\
	{{ 1}} & {2}
	\arrow["{}"', from=1-2, to=1-1]
	\arrow["", from=2-1, to=1-1]
	\arrow["{}"', from=2-2, to=1-2]
	\arrow["{}", from=2-2, to=2-1]
\end{tikzcd}\]
And I get something that is like a 2-cell from $\rid$ to itself.

\subsection{Back to Associativity}
Suppose I have a category $C$ that `supports binary composition of morphisms'.
This means we can solve lifting problems
\[\begin{tikzcd}
	{A_2} & C \\
	{K_2} & \textcolor{lgray}{1}
	\arrow[from=1-1, to=1-2]
	\arrow["{\eta_2}"', from=1-1, to=2-1]
	\arrow[color={lgray}, from=1-2, to=2-2]
	\arrow[dashed, from=2-1, to=1-2]
	\arrow[color={lgray}, from=2-1, to=2-2]
\end{tikzcd}\]

\subsection{A Definite Mistake}

Wait, surely it's {\em not} the case that the only bidirectional
cells from a cell to itself are identities. If both the domain
and the codomain are like the standard Eckman-Hilton thing
with two directed cells from the identity to itself,
then any number of signed twists are allowable.

\section{Trees}
\subsection{Lax Categories}

There should be some way of getting handle on the definition
of a category where composition is merely lax, and
with a corresponding lax associativity etc., and specializations
of that to reversibility ought to follow.

\subsection{Low-Dimensional Cases}

The type of distinct 1-paths $P_1$ is the same as the type of 2-cells $C_2$.
It is $\mathsf{List}\ \mathsf{Unit}$. It is $\N$. We can call these $0$-trees.
The $0$-tree that is the natural number zero has the realization as the unit type.
The $0$-tree that is the natural number $n$ is the pushout of $n$ copies of
the walking morphism. We obtain this by applying some abstract morphism-creating
process to a contractible domain type and a contractible codomain type.

Now we consider the codes of $1$-trees, i.e. $2$-paths $P_2$, i.e.
$3$-cells $C_3$. This is the familiar type of ordered finite trees, whose
internal nodes can have any finite arity from $\N$. Neither internal
nodes nor leaves carry any data. To build the realization of a tree,
we need realizations of $2$-cells. Even though the codes of $1$-paths
and $2$-cells are the same type, the previous paragraph described
realizations of $1$-paths, and realizations of $2$-cells are just a
bit more. Suppose we have a $1$-path $p \in P_1$. The unique $0$-sphere $s \in S_0$ (whose realization is a 2-point set) goes into it. I can also characterize $S^0$ as being an element of
the $0$-spheres that are made up of two compatible $0$-paths.
There is also a canonical $1$-path $c \in C_1$ consisting of a single cell.
We construct a lift of $p$ via
\[\begin{tikzcd}
\sem{L_2(p)}_{C_2} \pbck & \sem p_{P_1} \\
	\sem c_{C_1} & \sem s_{S_0}
	\arrow[ from=1-2, to=1-1]
	\arrow[ from=2-1, to=1-1]
	\arrow[""', from=2-2, to=1-2]
	\arrow["", from=2-2, to=2-1]
\end{tikzcd}\]
where $L_2 : P_1 \to C_2$ is the name of this function that gives us the cell.

Ok, so what's a tree in $P_2$? It's either a leaf or a node with a
list of children each of which is a tree. It has a domain and codomain
that are in $P_1$.

Let's remind ourselves that a pullback in $\mathbf{Poly}$ exists that's like
\[\begin{tikzcd}
S_{n+1} \pbck & P_{n+1} \\
	 C_{n+1} & S_n
	\arrow[ to=1-2, from=1-1]
	\arrow[ to=2-1, from=1-1]
	\arrow[""', to=2-2, from=1-2]
	\arrow["", to=2-2, from=2-1]
\end{tikzcd}\]
\begin{center}\includegraphics[scale=0.50]{spheres-2025-08-03.png}\end{center}
So we can reason that the $C_{n+1} \to S_n$ and $S_{n+1} \to P_{n+1}$ maps
are both isomorphisms on codes. The content of $C_{n+2}$ is determined
by some pullback-esque map
\[\begin{tikzcd}
C_{n+2} \pbck & P_{n+1} \\
	 C_{n+1} & S_n
	\arrow[ to=1-2, from=1-1]
	\arrow[ to=2-1, from=1-1]
	\arrow[""', to=2-2, from=1-2]
	\arrow["", to=2-2, from=2-1]
\end{tikzcd}\]
except that's not really a pullback; the upstairs square on realizations isn't
a pushout, but the `weak pushout' that forms a directed cell. We still
have that $C_{n+2} \to P_{n+1}$ is an isomorphism on codes. This was
already guaranteed by composing the other two isomorphisms from earlier.

\subsection{Paths}

It remains to explain what exactly paths are.
\subsubsection{1-paths}
A 1-path in $P_1$ is a list of unit. We get the realization by gluing together
many copies of the unique element of $C_1$.

\subsubsection{2-paths}
Let's generalize spheres and paths a bit. Say $S$ and $P$
are the spheres and paths whose domain is a single cell, and let $S'$ and $P'$ be the more general
notion of spheres and paths that allow paths on the domain. Maybe I need this only for one
level, not hereditarily.

We define the codes of $P_2$ to be the inductive type of trees; either a leaf, or a node that knows
the list of its children. What's the realization of a node? Well, we have a list of $P_2$ for the children.
Knowing that I have a boundary map $\partial : P_2 \to S_1$, this is enough information to
horizontally glue their realizations together, yielding something in $P_2'$. Then I vertically
compose with the appropriate element of $C_2$ to get the full realization.
\subsubsection{3-paths}
A path in $P_3$ is something like a leaf over a chosen $C_2$, or it's a node, with some
extra data. That extra data is for starters a choice of an element in $C_3$, whose
realization we're going to glue to something. Running out of steam here.
\subsection{Operads}
Consider that trees are the free $T$-operad for $T$ being the list monad.

Recall a few things. Let $T$ be a cartesian monad on $\C$. A $T$-multicategory
is a monoid whose carrier is the span $C_0 \gets C_1 \to TC_0$. It has `operations'
in $C_1$, and `types' in $C_0$. The span composed monadically with itself tells
us which pairs of $C_1 \x TC_1$ that are composable. The monoid object tells
us that composition is associative. A $T$-operad is when $C_0$ is the terminal
object of $\C$.

So if we take $\C$ to be sets and $C_0$ to be the singleton set, and $T$ is the list
monad, then the types of operations are just arities. The free $T$-operad has trees
with $n$ leaves for the arity $n$. Associativity and unit laws means that trees compose
as expected.

For higher trees, what if the objects $C_0$ are the set of all arities, and
$TC_0$ is trees? No, I can't make stuff typecheck that way either.
\subsection{Thinking with Sets}
Earlier \texttt{rntz} suggested like the following approach.
Morally, $C_{-1}$ and $T_{-1}$ are 1.
\[\begin{array}{l}
\mathbf{data}\ T_{0} :  \rset\ \bf{where}\\
\qquad \mathsf{Leaf} :  T_{0} \\
\qquad \mathsf{Node} : T_{0}\to T_{0}
\end{array}\]
$C_0$ is the subset of $T_0$ with exactly one node, so the type $1$.
\[\begin{array}{l}
\mathbf{data}\ T_{1} : \rset\ \bf{where}\\
\qquad \mathsf{Leaf} : T_{1} \\
\qquad \mathsf{Node} : (t : T_{0}) \to (\star \in_0 t \to T_{1}) \to T_{1}\\
\end{array}\]
We define an auxiliary
\[\begin{array}{l}
\mathbf{data}\ \star \in_0 \_ : (t : T_0) \to \rset\ \mathbf{where}\\
\qquad \mathsf{here} : (t : T_0) \to \star \in_0 \mathsf{Node}\ t\\
\qquad \mathsf{next} : (t : T_0) \to \star \in_0 t \to \star \in_0\mathsf{Node}\   t\\
\end{array}\]
Define $C_1$ to be the subset of $T_1$ with exactly one ${\mathsf{Node}}$.
Let's try hypertrees now.
\[\begin{array}{l}
\mathbf{data}\ T_{2} : \N \to \rset\ \bf{where}\\
\qquad \mathsf{Leaf} :  (n : \N) \to T_{2}\ n\\
\qquad \mathsf{Node} : (t : T_1) \to  ( (n : \N) \to n \in t \to (t : T_{2}\ n) ) \to T_{2}\ (\partial\ t)\\
\end{array}\]

\vskip 0.5em \hrule \vskip 0.5em

What if I index $T_1$ by their boundary?
\[\begin{array}{l}
\mathbf{data}\ T_{1} : \N \to \rset\ \bf{where}\\
\qquad \mathsf{Leaf} : T_{1}\ 1 \\
\qquad \mathsf{Node} : (t : T_{0})  (k : \star \in_0 t \to (n : \N) \x  T_{1}\ n) \to T_{1}\ (\Sigma_t\  k)\\
\end{array}\]
And then what if I try indexing $T_2$ by multiple boundaries?
\[\begin{array}{l}
\mathbf{data}\ T_{2} : (n : \N)(t_1 : T_1\ n) \to \rset\ \bf{where}\\
\qquad \mathsf{Leaf} :  (n : \N) \to T_{2}\ n\ (u\ n)\\
\qquad \mathsf{Node} : (n : \N) (t_1 : T_1\ n)  (k: (n : \N) \to n \in t_1 \to (t_1' : T_1\ n) \x T_{2}\ n\ t_1') \to T_{2}\ n\ (\Sigma_{n,t_1}\ k)\\
\end{array}\]
where $u\ n : T_1\ n$. This is all equivalent to
\[\begin{array}{l}
\mathbf{data}\ T_{2} : (t_0 : T_0)(t_1 : T_1\ t_0) \to \rset\ \bf{where}\\
\qquad \mathsf{Leaf} :  (t_0 : T_0) \to T_{2}\ t_0\ (u\ t_0)\\
\qquad \mathsf{Node} : (t_0 : T_0) (t_1 : T_1\ t_0)  (k: (t_0 : T_0) \to t_0 \in t_1 \to (t_1' : T_1\ t_0) \x T_{2}\ t_0\ t_1') \to T_{2}\ t_0\ (\Sigma_{t_0,t_1}\ k)\\
\end{array}\]

This feels like this compresses to, ugh, something like the following, but it's a mess and not quite right
\[\begin{array}{l}
\mathbf{data}\ T_{n+1} : U_n \to  \rset\ \bf{where}\\
\qquad \mathsf{Leaf} :  (t : U_n) \to (\nu\ t \equiv 1) \to T_{n+1}\ t\\
\qquad \mathsf{Node} : (t : U_n)  (k: (x : \nu\ t) \to  (t' : T_{n+1}) \x \partial\partial t' = \mathsf{get}\ x) \to T_{n+1}
\end{array}\]
\[ U_{n+1} = (t : U_n) \x T_{n+1}\ t\]

%% \vskip0.5em\hrule\vskip0.5em
%% \[\begin{array}{l}
%% \mathbf{data}\ T_{2} : \rset\ \bf{where}\\
%% \qquad \mathsf{Leaf} :  C_1 \to T_{2}\\
%% \qquad \mathsf{Node} : (t : T_1) \to  ( (c : C_1) \to c \in t \to (t : T_{2}) \x \partial_1 t = c ) \to T_{2}\\
%% \end{array}\]
%% I think the general case looks like
%% \[\begin{array}{l}
%% \mathbf{data}\ T_{n+1} : \rset\ \bf{where}\\
%% \qquad \mathsf{Leaf} :  C_n \to T_{n+1}\\
%% \qquad \mathsf{Node} : (t : T_n) \to  ( (c : C_n) \to c \in t \to (t : T_{n+1}) \x \partial_n t = c ) \to T_{n+1}\\
%% \end{array}\]

%% \def\rset{\mathsf{Type}}

%% where $T_n$ is $n$-dimensional trees, $C_n$ is a subtype of $T_n$ that contains the
%% `singletons' only, and $\partial : T_n \to C_n$ extracts the boundary,
%% and ${\in} : C_n \to T_n \to \rtype$ is a relation that yields a type with one element for every way that a particular $C_n$ appears in $T_n$.

%% I definitely want $T_0$ to be $\N$ and $C_0$ to be $1$. Can I say
%% $T_{-1} = 1$ and $C_{-1} = 1$? Then

%% \[\begin{array}{l}
%% \mathbf{data}\ T_{0} : C_{-1} \to \rset\ \bf{where}\\
%% \qquad \mathsf{Leaf} : (c : C_{-1}) \to T_{0}\ c\\
%% \qquad \mathsf{Node} : (t : T_{-1}) \to ((c : C_{-1}) \to c \in t \to T_{0}\ c) \to T_{0}\ (\partial\ t)\\
%% \end{array}\]
%% looks correct if I say $\in $ is unit and $\partial$ yields the unique element. I get
%% zero and successor. $C_0$ consists of the element with one $\mathsf{Node}$. Then trees are
%% \[\begin{array}{l}
%% \mathbf{data}\ T_{1} : C_{0} \to \rset\ \bf{where}\\
%% \qquad \mathsf{Leaf} : (c : C_{0}) \to T_{1}\ c\\
%% \qquad \mathsf{Node} : (t : T_{0}) \to ((c : C_{0}) \to c \in t \to T_{1}\ c) \to T_{1}\ (\partial\ t)\\
%% \end{array}\]
\section{Braids}

Going back to the idea of trying to combine parametricity and HoTT to
get braid groups.

A circled set is a set together with a map from $S^1$.
Given circled sets $X, Y$, we can define $X \tensor Y$
by taking the pushout of the carriers of $X$ and $Y$ identifying
the basepoints of their respective circles, and letting the
circle of the tensor product be the composition of the two different
loops. Let $\rightsquigarrow$ be the evident notion of
circled set homomorphism, where we map carriers and preserve the circle.

The conjecture is that parametric functions of type
\[ ( X : \mathsf{CSet} )
\to (\overbrace{X \otimes \cdots \otimes X}^{\textstyle n\hbox{ times}})
\rightsquigarrow (\overbrace{X \otimes \cdots \otimes X}^{\textstyle n\hbox{ times}})
\]
are exactly braids on $n$ strands.

\subsection{Braids on One Strand}
I think I at least understand how to show the degenerate case of one strand,
which is a good start. We suppose we have a function
\[ j :  ( X : \mathsf{CSet} )
\to X \rightsquigarrow X
\]
which is the same thing as
\[ j :  ( X : \mathsf{Set} ) (\eta : S^1 \to X) \to
(h : X \to X) \x (h \o \eta = \eta)
\]
So we can temporarily set aside the homomorphism condition and analyze what
the first component of $j$, namely
\[ j_1 :  ( X : \mathsf{Set} ) (\eta : S^1 \to X) (x : X) \to X \]
could possibly be. For it is also a parametric function.
Its parametricity free theorem says
\[  ( X_1\ X_2 : \mathsf{Set} ) ({\sim} : X_1 \to X_2 \to \mathsf{Set}) \]
\[ (\eta_1 : S^1 \to X_1) (\eta_2 : S^1 \to X_2) (\_ : (s : S^1) \to \eta_1\ s \sim \eta_2\ s)\]
\[(x_1 : X_1) (x_2 :  X_2) (\_ : x_1 \sim x_2)\]
\[  \to j_1\ X_1\ \eta_1\ x_1 \sim j_1\ X_2\ \eta_2\ x_2\]
and if we pick a function $f : X_1 \to X_2 $ to instantiate the relation $\sim$, we get
\[  ( X_1\ X_2 : \mathsf{Set} ) (f : X_1 \to X_2 ) \]
\[ (\eta_1 : S^1 \to X_1) (x_1 : X_1) \]
\[  \to f(j_1\ X_1\ \eta_1\ x_1) = j_1\ X_2\ (f \o \eta_1)\ (f\ x_1)\]
And then if we pick $X_1 = 1 + S^1$ and say $\eta_1 = \binr$ and $x_1 = \binl *$, we get
\[  ( X_2 : \mathsf{Set} ) (f : 1 + S^1 \to X_2) \]
\[  \to f(j_1\ (1 + S^1)\ \binr\ (\binl *)) =  j_1\ X_2\ (f \o \binr)\ (f\ (\binl *))\]
Now if we say $f$ comes from case analyzing and yielding either $x_2 : X_2$ or $\eta_2 : S^1 \to X_2$ we have
\[  ( X_2 : \mathsf{Set} ) (x_2 : X_2) (\eta_2 : S^1 \to X_2) \]
\[  \to (\bcase j_1\ (1 + S^1)\ \binr\ (\binl *) \bof\]
\[ \binl * \imp x_2 \celse \binr s \imp \eta_2\ s) =  j_1\ X_2\ \eta_2\ x_2\]
So we discover there are two sorts of functions $j_1\ X_2\ \eta_2\ x_2$ can
be, depending on what $j_1\ (1 + S^1)\ \binr\ (\binl *)$ evaluates to.
Either it's just the identity map on $X_2$, or it's a fixed point in the
loop that lies in $X_2$ via $\eta_2$.

We want to reason that the latter case is impossible, because of the nontriviality
of $S^1$. That is, specifically because for any $s$, the constant map $\lambda x . s : S^1 \to S^1$ is distinct from the identity map $S^1 \to S^1$.
So suppose towards a contradiction that there exists $s_0$ such that
\[ j_1\ (1 + S^1)\ \binr\ (\binl *) = \binr s_0\]
This means
\[  ( X_2 : \mathsf{Set} ) (x_2 : X_2) (\eta_2 : S^1 \to X_2) \]
\[  \to \eta_2\ s_0 =  j_1\ X_2\ \eta_2\ x_2\]
we can let $X_2 = S^1$ and let $\eta_2 = \rid$, and we get
\[  (x_2 : S^1) \to  s_0 =  j_1\ S^1\ \rid\ x_2\]
But recall that we're supposed to have $h \o \eta = \eta$, i.e.
\[ ( s: S^1) \to h\ (\eta\ s) = \eta\ s\]
and $h = j_1\ S^1\ \rid$ and $\eta = \rid$ in this case, so
\[ ( s: S^1) \to \ j_1\ S^1\ \rid\  s =  s\]
So we find that $j_1\ S^1\ \rid$ is both the constant $s_0$ function, and the identity function, a contradiction.

\subsection{Braids on Two Strands}
Now let's start thinking about
\[ ( X : \mathsf{CSet} )
\to (X \otimes X) \rightsquigarrow (X \otimes X)
\]
which is
\[ m : ( X : \mathsf{Set} ) (\eta : S^1 \to X) (x : X \otimes X) \to X \otimes X\]
\[ p : ( X : \mathsf{Set} ) (\eta : S^1 \to X) (s : S^1) \to m\ X\ \eta\ (\eta_{X \otimes X} s) = \eta_{X \otimes X} s\]
My tentative plan is to analyze $m$ in isolation, and then `filter out' the possible
functions that could satisfy $m$'s type by looking at $p$.

We can further break down $m$ by deconstructing $X \otimes X$ on the left,
since it's a pushout. That is, having an $m$ as above is equivalent to having
\[ m_1 : ( X : \mathsf{Set} ) (\eta : S^1 \to X) (x : X) \to X \otimes X\]
\[ m_2 : ( X : \mathsf{Set} ) (\eta : S^1 \to X) (x : X) \to X \otimes X\]
together with a path
\[ ( X : \mathsf{Set} ) (\eta : S^1 \to X)
 \to m_1\ X\ \eta\ (\eta\ \mathsf{base})
=  m_2\ X\ \eta\ (\eta\ \mathsf{base})
\]

\subsubsection{Mapping One Strand into Two}
So the next thing for me to analyze is what $m_1, m_2$ can possibly be.
The parametricity free theorem for $m_1$ is like
\[  ( X_1\ X_2 : \mathsf{Set} ) ({\sim} : X_1 \to X_2 \to \mathsf{Set}) \]
\[ (\eta_1 : S^1 \to X_1) (\eta_2 : S^1 \to X_2) (\_ : (s : S^1) \to \eta_1\ s \sim \eta_2\ s)\]
\[(x_1 : X_1) (x_2 :  X_2) (\_ : x_1 \sim x_2)\]
\[  \to m_1\ X_1\ \eta_1\ x_1 \sim m_1\ X_2\ \eta_2\ x_2\]
where that last $\sim$ denotes the implied relation
of type  $(X_1 \otimes X_1) \to (X_2 \otimes X_2) \to \mathsf{Set}$ that
arises from the base relation $X_1 \to X_2 \to \mathsf{Set}$. Then functional
instantiation should give me
\[  ( X_1\ X_2 : \mathsf{Set} ) (f : X_1 \to X_2 ) \]
\[ (\eta_1 : S^1 \to X_1) (x_1 : X_1) \]
\[  \to (f\otimes f)(m_1\ X_1\ \eta_1\ x_1) = m_1\ X_2\ (f \o \eta_1)\ (f\ x_1)\]
where $f \otimes f$ is the hopefully evident functorial lifing of $f$ to
$(X_1 \otimes X_1) \to (X_2 \otimes X_2)$. Now comes the time that
I need to make a clever choice of $X_1$.

Let's try to substitute $S^1 + 1$ again for $X_1$, and $\binl$ for $\eta_1$ and $\binr$ for $x_1$.
And a case split between $\eta_2$
and $x_2$ for $f$. We'd get
\[  (  X_2 : \mathsf{Set} )(\eta_2 : S^1 \to X_2) (x_2 : X_2)  \]
\[  \to (f\otimes f)(m_1\ (S^1 + 1)\ \binl\ \binr) = m_1\ X_2\ \eta_2\ x_2\]
for \[ f (x : S^1 + 1) := \bcase x \bof \binl s \imp \eta_2 s \celse \binr \star \imp x_2 \]

Alright, so we learn that the value of $m_1\ (S^1 + 1)\ \binl\ \binr : (S^1 + 1) \otimes (S^1 + 1)$
determines the values of $m_1$ everywhere. But we can see that
\[ (S^1 + 1) \otimes (S^1 + 1) = S^1\wedge S^1 + 1 + 1\]
and we observe that
\[ f \otimes f  : ((S^1 + 1) \otimes (S^1 + 1)) \to (X_2 \otimes X_2) \]
I see; the functoriality of $\otimes$ means that we have three sort of maps.
If we're in one of the copies of $1$ in $S^1 \wedge S^1 + 1 + 1$, then we're doing either
\[ m_1\ X_2\ \eta_2\ x_2 = \binl x_2 : X_2 \otimes X_2\]
\[ m_1\ X_2\ \eta_2\ x_2 = \binr x_2 : X_2 \otimes X_2\]
Otherwise, there exists $s : S^1 \wedge S^1$, and we're doing some kind of constant map into the
wedge of circles:
\[ m_1\ X_2\ \eta_2\ x_2 = \bcase s \bof \binl s' \imp \binl (\eta_2\ s') \celse \binr s' \imp \binr (\eta_2\ s') : X_2 \otimes X_2\]

\subsection{Reasoning about Paths}
So we've established there are three things we can do to have a parametric set map of type
\[ ( X : \mathsf{Set} ) (\eta : S^1 \to X) (x : X) \to X \otimes X\]
Take $x$ to the left $X$, or to the right copy of $X$, or do a constant map into the circles wedged in $X \otimes X$.

If we have a hom from $X \otimes X$ to itself as a circled type, then we have 3 x 3 possibilities.
Further considerations below should eventually eliminate all but two of those.

But let's dive in and explicitly consider what else we have. Because the hom preserves the circle, we have
\[ p : \{ X : \mathsf{Set} \} \{\eta : S^1 \to X\} (s : S^1) \to m\ (\eta_{X \otimes X}\ s) = \eta_{X \otimes X}\ s\]
which breaks up into preserving the base and the loop of $X \otimes X$:
\[ p_1 : \{ X : \mathsf{Set} \} \{\eta : S^1 \to X\}  \to m\ (\eta_{X \otimes X}\ \mathsf{base}) = \eta_{X \otimes X}\ \mathsf{base}\]
\[ p_2 : \{ X : \mathsf{Set} \} \{\eta : S^1 \to X\}  \to \mathsf{ap}_m\  (\mathsf{ap}_{\eta_{X \otimes X}}\ \mathsf{loop}) =_{p_1} \mathsf{ap}_{\eta_{X \otimes X}}\ \mathsf{loop}\]
Recall that $m : X \otimes X \to X \otimes X$ is the carrier of the hom. Note that
\[ \mathsf{ap}_m\  (\mathsf{ap}_{\eta_{X \otimes X}}\ \mathsf{loop}):  ( m\ (\eta_{X \otimes X}\ \mathsf{base}) =  m\ (\eta_{X \otimes X}\ \mathsf{base}))\]
\[\mathsf{ap}_{\eta_{X \otimes X}}\ \mathsf{loop} :  (\eta_{X \otimes X}\ \mathsf{base} =  \eta_{X \otimes X}\ \mathsf{base})\]
So having a path over $p_1$ is more or less the same as asserting
\[ p_2 : \{ X : \mathsf{Set} \} \{\eta : S^1 \to X\}  \to \mathsf{ap}_m\  (\mathsf{ap}_{\eta_{X \otimes X}}\ \mathsf{loop}) = p_1 \bullet \mathsf{ap}_{\eta_{X \otimes X}}\ \mathsf{loop} \bullet p_1^{-1}\]
We want to make some definitions for convenience:
\[ x = \binl\ (\eta\ \mathsf{base}) \qquad y = \binr\ (\eta\ \mathsf{base})\]
\[ a = \binl\ (\mathsf{ap}_\eta\ \mathsf{loop}) \qquad c = \binr\ (\mathsf{ap}_\eta\ \mathsf{loop})\]
\[ b = (x = y)\]

\begin{center}\includegraphics[scale=0.50]{circles.png}\end{center}
Then we have
\[ m_1 : X \to X \otimes X \qquad m_2 : X \to X \otimes X \]
which by parametricity we've constrained to be one of 3 things each, either $\binl$ or $\binr$ or a constant map
factoring through $\eta_{X\otimes X}$. We know we have
\[q : m\ x = m\ y\]
because we're mapping into a pushout. And because the hom preserves the circle, we must have
\[ p_1 :  m\ x = x\]
\[ p_2 :  m(a b c b^{-1}) = p_1 a b c b^{-1} p_1^{-1}\]
where we're omitting $\bullet$ and writing path composition as juxtaposition, and forgetting
about $\mathsf{ap}_m$ and simply writing $m$.

\subsection{A Digression About Parametricity and Paths}

We should be able to show that a parametric path like
\[ j : (X : \rset) (\eta : S^1 \to X) \to (\eta\ \mathsf{base} = \eta\ \mathsf{base})\]
is the same as the loop space of the circle itself. Having $X$ around in the background
shouldn't make any additional paths.
So I think parametricity looks like
\[  (X_1\ X_2 : \rset) ({\sim} : X_1 \to X_2 \to \rset) \]
\[(\eta_1 : S^1 \to X_1) (\eta_2 : S^1 \to X_2)  (\eta_* : (s : S^1) \to \eta_1\ s \sim \eta_2\ s)\]
\[ \to \mathsf{trans}\ (\eta_*\ \mathsf{base})\ (j\ X_1\ \eta_1) \ (j\ X_2\ \eta_2) = \eta_*\ \mathsf{base}\]
for the  evident notion of relation transport
\[\mathsf{trans} : (a \sim b) \to (a = a') \to (b = b') \to (a' \sim b')\]
that does path induction on the two path arguments.

I guess that I perhaps want to set $X_1$ to $S^1$ and $\eta_1$ to $\rid$. I'd get
\[  ( X_2 : \rset) ({\sim} : S^1 \to X_2 \to \rset) \]
\[(\eta_2 : S^1 \to X_2)  (\eta_* : (s : S^1) \to  s \sim \eta_2\ s)\]
\[ \to \mathsf{trans}\ (\eta_*\ \mathsf{base})\ (j\ S^1\ \rid) \ (j\ X_2\ \eta_2) = \eta_*\ \mathsf{base}\]


Then perhaps I want to instantiate $a \sim b$ as $\eta_2(a) = b$,
\[  ( X_2 : \rset)  (\eta_2 : S^1 \to X_2)  (\eta_* : (s : S^1) \to  \eta_2 s = \eta_2\ s)\]
\[ \to \mathsf{trans}\ (\eta_*\ \mathsf{base})\ (j\ S^1\ \rid) \ (j\ X_2\ \eta_2) = \eta_*\ \mathsf{base}\]

And I think at this point $\mathsf{trans}$ specializes to equality composition, but because
the transport is happening at the relation that now incorporates $\eta_2$, we'd wrape the $j\ S^1\ \rid$ in $\eta_2$ and obtain

\[  ( X_2 : \rset)  (\eta_2 : S^1 \to X_2)  (\eta_* : (s : S^1) \to  \eta_2 s = \eta_2\ s)\]
\[ (\eta_2\ (j\ S^1\ \rid))^{-1} \bullet \mathsf{ \eta_*\ \mathsf{base}} \bullet (j\ X_2\ \eta_2) = \eta_*\ \mathsf{base}\]

Now I can instantiate  $\eta_*$ as $\lambda s . \rrefl\ (\eta_2 s)$ to get
\[  ( X_2 : \rset)  (\eta_2 : S^1 \to X_2)  \]
\[ (\eta_2\ (j\ S^1\ \rid))^{-1} \bullet  \rrefl\ (\eta_2\ \mathsf{\mathsf{base}}) \bullet (j\ X_2\ \eta_2) = \rrefl\ (\eta_2\ \mathsf{\mathsf{base}})\]
which would mean
\[ j\ X_2\ \eta_2 = \eta_2\ (j\ S^1\ \rid)\]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Opetopes as Data}
I want first get ahold of a family
\[T_1 : \{C_0 : \rset\} \{C_1 : C_0 \to C_0 \to \rset\} \to (C_0 \to C_0 \to \rset)\]
 that describes ``color-compatible lists''. The argument $C_0$ is a set of colors.
The argument $C_1 : C_0 \to C_0 \to \rset$ is a set of $1$-cells. $T_1$ outputs,
for a given domain and codomain, the paths that can be composed out of the given $1$-cells. We can do this with
\[\begin{array}{l}
\mathbf{data}\ T_1\  \{C_0 : \rset\}\ \{C_1 : C_0 \to C_0 \to \rset\} : (C_0 \to C_0 \to \rset)\ \mathbf{where}\\
\qquad \mathsf{Leaf}_1 : (c : C_0) \to T_1\ c\ c\\
\qquad \mathsf{Node}_1: (a\ b\ c : C_0) \to C_1\ a\ b \to T_1\ b\ c \to T_1\ a\ c
\end{array}\]
We can imaginine with prefix
\[\{C_0 : \rset\}\ \{C_1 : C_0 \to C_0 \to \rset\}\ \{a\ b : C_0\} \]
doing some programming
\[\begin{array}{l}
\mathsf{map}_1 : \{C_1' : C_0 \to C_0 \to \rset\}\\
\qquad (f : (a\ b : C_0) \to C_1\ a\ b \to C_1'\ a\ b)  \to   T_1\ \{C_1\}\ a\ b \to T_1\ \{C_1'\}\ a\ b \\
\eta_1 :    C_1\ a\ b \to T_1\ \{C_1\}\ a\ b \\
\mu_1 :   T_1\ \{T_1\ \{C_1\}\}\ a\ b \to T_1\ \{C_1\}\ a\ b\\
\end{array}\]
making this a monad in the category $C_0 \to C_0 \to \rset$. With those operations, we could imagine defining a notion of tree
indexed by 2-cells $C_2$.
\[\begin{array}{l}
U_2 :  \{C_0 : \rset\}\ \{C_1 : C_0 \to C_0 \to \rset\}
\ \{C_2 : \{c\ c' : C_0\} (f : C_1\ c\ c') (f' : T_1\ c\ c') \to  \rset\} \\
\qquad\qquad   (c\ c' : C_0)  \to  \rset\\
U_2\ c\ c' = \{ f : C_1\ c\ c', f' : T_1\ c\ c', t : T_2\ f\ f'\}\\
\mathbf{data}\ T_2\  \{C_0 : \rset\}\ \{C_1 : C_0 \to C_0 \to \rset\}
\ \{C_2 : \{c\ c' : C_0\} (f : C_1\ c\ c') (f' : T_1\ c\ c') \to  \rset\} \\
\qquad\qquad :  \{c\ c' : C_0\} (f : C_1\ c\ c') (f' : T_1\ c\ c') \to  \rset\ \mathbf{where}\\
\qquad \mathsf{Leaf}_2 : \{c\ c' : C_0\} (f : C_1\ c\ c') \to T_2\ f\ (\eta_1\ f)\\
\qquad \mathsf{Node}_2: \{c\ c' : C_0\} (f : C_1\ c\ c') (\chi : T_1\ U_2\ c\ c') (\phi : C_2\ f\ (\mathsf{map}_1\ .f\ \chi))\\
\qquad\qquad \to T_2\ f\ (\mu_1(\mathsf{map}_1\ .f'\ \chi))
\end{array}\]
Now it's time to stare at this and make some definitions and try to generalize.
Let's capture at the toplevel telescopes by saying
\[\begin{array}{rcl}
S_0 &=& (C_0 : \rset)\\
S_1 &=& (C_0 : \rset)(C_1 : C_0 \x C_0 \to \rset)\\
S_2 &=& (C_0 : \rset)(C_1 : C_0 \x C_0 \to \rset)\\
&&(C_2 : \{c\ c' : C_0\} (f : C_1\ c\ c') (f' : T_1\ c\ c') \to  \rset)\\
&\vdots
\end{array}\]
Let's now have
\[\begin{array}{rcl}
Z_0\ s &=& 1\\
Z_1\ s &=& (c : s.C_0)(c' : s.C_0) \\
Z_2\ s &=& (c : s.C_0)(c' : s.C_0)(f : s.C_1\ c\ c') (f' : T_1\ s\ c\ c')\\
&\vdots
\end{array}\]
So that $Z_n : S_{n-1} \to \rset$ and $S_{n} = (s : S_{n-1}) \x (Z_n\ s \to \rset)$.
But observe that this is nearly like saying
\[\begin{array}{rcl}
Z_0\ s &=& (z : Z_{-1}\ \bar s) \x 1\\
Z_1\ s &=& (z : Z_0\ \bar s) \x (c : s.C_0)(c' : s.C_0) \\
Z_2\ s &=& (z : Z_1\ \bar s) \x (f : s.C_1\ z) (f' : T_1\ s\ z)\\
&\vdots
\end{array}\]
where $\bar s$ takes the `tail' of $s$. This suggests saying
\[\begin{array}{lcl}
W_0\ s\ \_ &=& 1\\
W_1\ s\ \_ &=& (c : s.C_0) (c' : s.C_0) \\
W_2\ s\ z &=& (f : s.C_1\ z) (f' : T_1\ s.C_1\ s\ z)\\
&\vdots
\end{array}\]
And here we have $W_n : S_{n-1} \to Z_{n-1} \to \rset$ and $Z_n\ s = (z : Z_{n-1}\ \bar s) \x W_n\ s\ z$.

Let's rename $Z$ to $B$ and summarize what we know at this point.
\def\head{\mathop\mathsf{hd}}
\[
\begin{prooftree}
e : S_n
\justifies
\bar e : S_{n-1}
\end{prooftree}
\qquad
\begin{prooftree}
e : S_n
\justifies
\head e : B_n\  \bar e \to \rset
\end{prooftree}
\]
\[\begin{array}{l}
S_n : \rset\\
S_n = (s : S_{n-1}) \x (B_n\ s \to \rset)\\
\\
B_n : S_{n-1} \to \rset\\
B_n\ s = \{b : B_{n-1}\ \bar s, \quad \dom : \head s\ b, \quad \cod : T_{n-1}\   b\}\\
\end{array}
\]
%% We could say
%% \[T_{n} : (s : S_{n}) \to B_{n}\ \bar s \to \rset\]
%% or it might be perspicuous to expand this as
%% \[T_{n} : (s : S_{n-1}) \to (B_n\ s \to \rset) \to (B_{n}\  s \to \rset)\]
%% because we will want to understand $T_{n}$ as being a monad in $B_n\ s \to \rset$ for any $s : S_{n-1}$.

We more or less want to say
\[
\begin{array}{l}
%% \qquad\qquad \color{gray} \ \{C_2 : \{c\ c' : C_0\} (f : C_1\ c\ c') (f' : T_1\ c\ c') \to  \rset\} \\
\mathbf{data}\ T_n\  \{s : S_{n-1}\}\ \{C_n : B_n\ s \to \rset\} :  B_n\ s \to  \rset\ \mathbf{where}\\
%% \color{gray}\qquad\qquad :  \{c\ c' : C_0\} (f : C_1\ c\ c') (f' : T_1\ c\ c') \to  \rset\ \mathbf{where}\\
%% \color{gray}\qquad \mathsf{Leaf}_2 : \{c\ c' : C_0\} (f : C_1\ c\ c') \to T_2\ f\ (\eta_1\ f)\\
\qquad \mathsf{Leaf}_n : (b : B_{n-1}\ \bar s)  (f : \head s\ b) \to T_n\ \{b, f, \eta\ f\}\\
%% \color{gray}\qquad \mathsf{Node}_2: \{c\ c' : C_0\} (f : C_1\ c\ c') (\chi : T_1\ U_2\ c\ c') (\phi : C_2\ f\ (\mathsf{map}_1\ .f\ \chi))\\
%% \color{gray}\qquad\qquad \to T_2\ f\ (\mu_1(\mathsf{map}_1\ .f'\ \chi))\\
\qquad \mathsf{Node}_n: (b : B_{n-1}\ \bar s)  (f : \head s\ b) \\
\qquad\qquad (\chi : T_{n-1}\ \{\bar s\}\ \{U_n\}\ b) \\
\qquad\qquad (\phi : C_n\ \{b,f,\mathsf{map}\ \dom\ \chi\}) \\
\qquad\qquad   \to T_n\ \{b,f, \mu\ (\mathsf{map}\ \cod\ \chi)\}\\
\\
U_n:  \{s : S_{n-1}\} \{C_n : B_n\ s \to \rset\} (b : B_{n-1}\ \bar s) \to  \rset\\
U_n\ b = \{\dom : \head\ s\ b, \quad \cod : T_{n-1}\ b, \quad t : T_n\ \{b, \dom, \cod\}\}\\
\end{array}\]
%% We could

%% We hope to abstract $C_n = B_n \to \rset$, so
%% \[\begin{array}{rcl}
%% B_0 &=& 1\\
%% B_1 &=& C_0 \x C_0\\
%% B_2 &=& (c\ c' : C_0) (f : C_1\ c\ c')(f':T_1\ c\ c') \\
%% &\vdots
%% \end{array}\]
%% This suggests an inductive way of building up $B$ as $B_{n+1} := (b : B_{n}) \x D_{n+1}$.
%% \[\begin{array}{rcl}
%% D_0 &=& 1\\
%% D_1 \_&=& C_0 \x C_0\\
%% D_2 (c, c')&=& (f : C_1\ c\ c')(f':T_1\ c\ c') \\
%% &\vdots
%% \end{array}
%% \]

\subsection{Zipping}

I went through some other thinking, way in another direction of more extrinsic
typing. I wanted to do something like
\[
\begin{array}{l}
\mathbf{data}\ T :  \rset\ \mathbf{where}\\
\qquad \mathsf{Leaf} : T\\
\qquad \mathsf{Node}: (t: T)\ (n : \mathsf{Addr}\ t) \to T
\end{array}\]
where $\mathsf Addr\ t$ captures some notion of an address within $t$, naming
a node inside $t$. However, trying to define this notion of address seems
to lead quickly to positivity or termination problems. I thought for a while about
\[
\begin{array}{l}
\mathbf{data}\ T :  \rset\ \mathbf{where}\\
\qquad \mathsf{Leaf} : T\\
\qquad \mathsf{Node}: T \to [T] \to T
\end{array}\]
where I simply list all of the subtrees in some traversal order. But then zipping
up those results across the tree structure in the first $T$ argument becomes a headache.
I could say that $T_{-1} = \rid$ and then
\[
\begin{array}{l}
\mathbf{data}\ T_0\ (A : \rset) :   \rset\ \mathbf{where}\\
\qquad \mathsf{Leaf} : T_0\ A \\
\qquad \mathsf{Node}: A  \to T_{-1}\ (T_0\ A) \to T_0\ A
\end{array}\]
\[
\begin{array}{l}
\mathbf{data}\ T_1\ (A : \rset) :   \rset\ \mathbf{where}\\
\qquad \mathsf{Leaf} : T_1\ A\\
\qquad \mathsf{Node}: A  \to T_0\ (T_1\ A) \to T_1\ A
\end{array}\]
\[
\begin{array}{l}
\mathbf{data}\ T_2\ (A : \rset) :   \rset\ \mathbf{where}\\
\qquad \mathsf{Leaf} : T_2\ A\\
\qquad \mathsf{Node}: A  \to T_1\ (T_2\ A) \to T_2\ A
\end{array}\]
so I guess I could try to subsume this with
\[
\begin{array}{l}
\mathbf{data}\ T\ (A : \rset) :   \rset\ \mathbf{where}\\
\qquad \mathsf{Leaf} : T\ A\\
\qquad \mathsf{Node}: A  \to T\ (T\ A) \to T\ A
\end{array}\]

I note that there is a mapping $A \to T\ A$ given by
 taking $a : A$ to $\mathsf{Node}\ a\ \mathsf{Leaf} : T\ A$.
Surely this is natural in $A$.

\section{Parametricity and Braids again}

After thinking about it some more, I didn't really finish the reasoning
that even the one-braid case is really fully correct. Here's an attempt.

Suppose we have a map

\[ j : (X : \rset) (\eta : S^1 \to X) \to (h : X \to X) \x (h \o \eta \equiv \eta) \]
Then we want to show that
\[ j \equiv \lambda X \eta . \langle \rid_{X}, \rrefl_\eta \rangle \]
which by function extensionality means we need to show, for every $ (X : \rset) (\eta : S^1 \to X)$, that
\[  j\ X\ \eta \equiv \langle \rid_{X}, \rrefl_\eta \rangle \]
which by $\Sigma$ extensionality means we need to show that each component is equal.
Let's quickly remember how that works in general. Let's say we want to show
$t = u : (x : A) \x M\ x \equiv N\ x$ for some $M, N : A \to B$.
We need
\[ p_1 : t.1 \equiv u.1\]
\[ p_2 : t.2 \equiv_{p_1} u.2\]
Another way of understanding $p_2$ is as the diagram
\[\begin{tikzcd}
M\ t.1&M\ u.1\\
N\ t.1&N\ u.1\\
	\arrow["M\ p_1", to=1-2, from=1-1, equals]
	\arrow["t.2"', to=2-1, from=1-1, equals]
	\arrow["u.2", to=2-2, from=1-2, equals]
	\arrow["N\ p_1"', to=2-2, from=2-1, equals]
\end{tikzcd}\]

So concretely in our case
\[ p_1 : \pi_1\ (j\ X\ \eta) \equiv \rid_X \]
\[ p_2 : \pi_2\ (j\ X\ \eta) \equiv_{p_1} \rrefl_\eta \]
And $p_2$ is really the 2-cell in the diagram
\[\begin{tikzcd}
 \pi_1\ (j\ X\ \eta) \o \eta & \eta\\
	 \eta & \eta
	\arrow["p_1 \o \eta", to=1-2, from=1-1, equals]
	\arrow["\pi_2\ (j\ X\ \eta)"', to=2-1, from=1-1, equals]
	\arrow["\rrefl_\eta", to=2-2, from=1-2, equals]
	\arrow["\rrefl_\eta"', to=2-2, from=2-1, equals]
\end{tikzcd}\]

\subsection{Parametricity Principle}
What is the parametricity principle for $j$? We should have something like

\[j_\star :  (X_1\ X_2 : \rset) ({\sim} : X_1 \to X_2 \to \rset) \]
\[(\eta_1 : S^1 \to X_1) (\eta_2 : S^1 \to X_2)  (\eta_* : (s : S^1) \to \eta_1\ s \sim \eta_2\ s)\]
\[ \to (j\ X_1\ \eta_1) \sim_{(h : X \to X) \x (h\o \eta \equiv \eta)}(j\ X_2\ \eta_2)\]

Let's check our assumptions on parametricity principles for $\Sigma$ types.
We say $t \sim_{(x:A) \x B} u$ whenever we have
a relation for the first component
\[p_1 : t.1 \sim_A u.1\]
and also a relation for the second component
\[p_2 : t.2 \sim_{x:p_1 \prov B} u.2\]
where we have stashed the evidence of the relation $p_1$ away associated with the variable $x$.

So we can expand our parametricity principle to
\[\begin{array}{l}
j_\star :  (X_1\ X_2 : \rset) ({\sim} : X_1 \to X_2 \to \rset) \\
\qquad(\eta_1 : S^1 \to X_1) (\eta_2 : S^1 \to X_2)  (\eta_* : (s : S^1) \to \eta_1\ s \sim \eta_2\ s)\\
\qquad \to (h_\star : (j\ X_1\ \eta_1).1 \sim_{X \to X} (j\ X_2\ \eta_2).1) \x {}\\
\qquad  (j\ X_1\ \eta_1).2 \sim_{h_\star : X \to X \prov (h\o \eta \equiv \eta)}(j\ X_2\ \eta_2).2\\
\end{array}
\]
And I think the relation on the second-components that are paths is something like
\[\begin{tikzcd}
   (j\ X_1\ \eta_1).1\ (\eta_1\ s) &[3em]    (j\ X_2\ \eta_2).1\ (\eta_2\ s)\\
	 \eta_1\ s & \eta_2\ s
	\arrow["h_\star\ (\eta_\star\ s)", to=1-2, from=1-1, -, squiggly]
	\arrow[" (j\ X_1\ \eta_1).2\ s"',  to=2-1, from=1-1, equals]
	\arrow["(j\ X_2\ \eta_2).2\ s", to=2-2, from=1-2, equals]
	\arrow["\eta_\star\ s"', to=2-2, from=2-1, -, squiggly]
\end{tikzcd}\]

\subsection{Separate Names}
Alternatively we can break up $j$ and name subcomponents. We assume we have

\[ h : \{X : \rset\} \{\eta : S^1 \to X\} (x : X)\to X \]
\[ p : \{X : \rset\} \{\eta : S^1 \to X\} (s : S^1) \to  h\ (\eta\ s) \equiv \eta\ s \]

We then want to show that, morally, the sigma of these two is contractible, which amounts to showing

\[ h^= : \{X : \rset\} \{\eta : S^1 \to X\} (x : X) \to h\ x \equiv x \]
\[ p^= : \{X : \rset\} \{\eta : S^1 \to X\} (s : S^1) \to  \]

\[\begin{tikzcd}
  h\ (\eta\ s) &[3em] \eta\ s\\
	 \eta\ s & \eta\ s
	\arrow["h^=\ (\eta\ s)", to=1-2, from=1-1, equals]
	\arrow["p\ s"', to=2-1, from=1-1, equals]
	\arrow["\rrefl_{\eta\ s}", to=2-2, from=1-2, equals]
	\arrow["\rrefl_{\eta\ s}"', to=2-2, from=2-1, equals]
\end{tikzcd}\]
\usetikzlibrary{decorations.pathmorphing}
Now what we have in addition to $h$ and $p$ is parametricity principles
\[h_\star :  (X_1\ X_2 : \rset) ({\sim} : X_1 \to X_2 \to \rset) \]
\[(\eta_1 : S^1 \to X_1) (\eta_2 : S^1 \to X_2)  (\eta_* : (s : S^1) \to \eta_1\ s \sim \eta_2\ s)\]
\[(x_1 :  X_1) (x_2 :  X_2)  (x_* : x_1 \sim x_2) \]
\[ \to h\ \{X_1\}\ \{\eta_1\}\ x_1 \sim h\ \{X_2\}\ \{\eta_2\}\ x_2\]
and
\[p_\star :  (X_1\ X_2 : \rset) ({\sim} : X_1 \to X_2 \to \rset) \]
\[(\eta_1 : S^1 \to X_1) (\eta_2 : S^1 \to X_2)  (\eta_* : (s : S^1) \to \eta_1\ s \sim \eta_2\ s)  \]
\[(s : S^1) \to \]
\[\begin{tikzcd}
  h\ \{X_1\}\ \{\eta_1\}\ (\eta_1\ s) &[3em]   h\ \{X_2\}\ \{\eta_2\}\ (\eta_2\ s)\\
	 \eta_1\ s & \eta_2\ s
	\arrow["h_\star\ (\eta_\star\ s)", to=1-2, from=1-1, -, squiggly]
	\arrow["p\ \{X_1\}\ \{\eta_1\}\ s"',  to=2-1, from=1-1, equals]
	\arrow["p\ \{X_2\}\ \{\eta_2\}\ s", to=2-2, from=1-2, equals]
	\arrow["\eta_\star\ s"', to=2-2, from=2-1, -, squiggly]
\end{tikzcd}\]
Now what happens if we hypothesize up $(X : \rset)(\eta: S^1 \to X)(s:S^1)$,
 and apply $p_*$ to
\[\begin{array}{l@{\qquad}l@{\qquad}l}
X_1 := 1 + S^1 & X_2 := X&a \sim b := (\eta\ s|\eta)(a) \equiv b\\
\eta_1 := \binr & \eta_2 := \eta & \eta_* := \lambda s. \rrefl_{\eta\ s}\\
&s := s
\end{array}
\]
We get the diagram
\[\begin{tikzcd}
  h\ \{1 + S^1\}\ \{\binr\}\ (\binr\ s) &[3em]   h\ \{X\}\ \{\eta\}\ (\eta\ s)\\
	 \binr\ s & \eta\ s
	\arrow["h_\star\ (\eta_\star\ s)", to=1-2, from=1-1, -, squiggly]
	\arrow["p\ \{1 + S^1\}\ \{\binr\}\ s"',  to=2-1, from=1-1, equals]
	\arrow["p\ \{X\}\ \{\eta\}\ s", to=2-2, from=1-2, equals]
	\arrow["\rrefl_{\eta\ s}"', to=2-2, from=2-1, -, squiggly]
\end{tikzcd}\]
Which, I think substituting the relations would give me
\[\begin{tikzcd}
(\eta\ s|\eta)(h\ \{1 + S^1\}\ \{\binr\}\ (\binr\ s)) &[3em]   h\ \{X\}\ \{\eta\}\ (\eta\ s)\\
	 \eta\ s & \eta\ s
	\arrow["h_\star\ (\eta_\star\ s)", to=1-2, from=1-1, equals]
	\arrow["(\eta\ s|\eta)(p\ \{1 + S^1\}\ \{\binr\}\ s)"',  to=2-1, from=1-1, equals]
	\arrow["p\ \{X\}\ \{\eta\}\ s", to=2-2, from=1-2, equals]
	\arrow["\rrefl_{\eta\ s}"', to=2-2, from=2-1,equals]
\end{tikzcd}\]
So I'd be completely set if I could only prove
\[\begin{tikzcd}
(\eta\ s|\eta)(h\ \{1 + S^1\}\ \{\binr\}\ (\binr\ s)) &[3em]   h\ \{X\}\ \{\eta\}\ (\eta\ s)\\
	 \eta\ s & \eta\ s
	\arrow["h_\star\ (\eta_\star\ s)", to=1-2, from=1-1, equals]
	\arrow["(\eta\ s|\eta)(p\ \{1 + S^1\}\ \{\binr\}\ s)"',  to=2-1, from=1-1, equals]
	\arrow["h^=\ (\eta\ s)", to=2-2, from=1-2, equals]
	\arrow["\rrefl_{\eta\ s}"', to=2-2, from=2-1,equals]
\end{tikzcd}\]

\section{Triangles}
Here I'm convincing myself the equilateral triangle is
locally Rupert, i.e. there are poses that are arbitrarily
close to the identity that make it Rupert.

Let $c = \cos(\epsilon), s = \sin(\epsilon)$ and
 $c_k = \cos(k\epsilon), s_k = \sin(k\epsilon)$. Consider
\[M  = R_y(\epsilon)  R_x(k\epsilon)\]
\[= \left(\begin{array}{ccc}
c& 0 &-s \\
 0&1&0\\
 s& 0& c\\
\end{array}\right) \left(\begin{array}{ccc}
1& 0&0\\
 0&c_k&s_k\\
 0& -s_k& c_k\\
\end{array}\right)\]
\[ = \left(\begin{array}{ccc}
c& s s_k&-s  c_k\\
 0&c_k&s_k\\
 s& -cs_k& cc_k\\
\end{array}\right) \]

We can take the derivative with respect to $\epsilon$:
\[{\partial M\over \partial\epsilon} = \left(\begin{array}{ccc}
-s& c s_k + ks c_k&  ks  s_k - c  c_k\\
 0&-ks_k&kc_k\\
 c& ss_k - kcc_k& -sc_k -kcs_k\\
\end{array}\right)\]
Setting $\epsilon = 0$ gives
\[\left.{\partial M\over \partial\epsilon}\right|_{\epsilon=0} = \left(\begin{array}{ccc}
0& 0&  -k\\
 0&0&k\\
 1&  - k& 0\\
\end{array}\right)\]

Consider the equilateral triangle lying in the $xy$ plane defined by
\[\begin{array}{ccc}
 P_1 = (-1/2\ 0\ 0)^\top &
 P_2 = (0\ {\sqrt 3 / 2}\ 0)^\top &
 P_3 = (1/2\ 0\ 0)^\top
\end{array}\]

To first order, small rotations by $M$ applied to things already
in the $xy$ plane only result in $z$ displacements.
\[ \left.{\partial M\over \partial\epsilon}\right|_{\epsilon=0} P_1 = \left(\begin{array}{c} 0 \\ 0 \\ -1/2 \end{array}\right) \]\]
\[ \left.{\partial M\over \partial\epsilon}\right|_{\epsilon=0} P_2 = \left(\begin{array}{c} 0 \\ 0 \\ -k\sqrt{3}/2 \end{array}\right) \]
\[ \left.{\partial M\over \partial\epsilon}\right|_{\epsilon=0} P_3 = \left(\begin{array}{c} 0\\ 0 \\ 1/2 \end{array}\right) \]\]

So let's look at second order:
\[{\partial^2 M\over \partial\epsilon^2} = \left(\begin{array}{ccc}
-c& -s s_k + 2kc c_k  -k^2s s_k&    s  c_k +  2kc  s_k  + k^2s  c_k  \\
 0&-k^2c_k&-k^2s_k\\
 -s& cs_k + 2ksc_k + k^2cs_k& -cc_k +2kss_k -k^2cc_k\\
\end{array}\right)\]
\[\left.{\partial^2 M\over \partial\epsilon^2}\right|_{\epsilon=0} = \left(\begin{array}{ccc}
-1&  2k&  0  \\
 0&-k^2&0\\
 0& 0& -1 -k^2\\
\end{array}\right)\]
and we have
\[  \left.{\partial^2 M\over \partial\epsilon^2}\right|_{\epsilon=0} P_1 = \left(\begin{array}{c} 1/2 \\ 0 \\ 0 \end{array}\right) \]\]
\[  \left.{\partial^2 M\over \partial\epsilon^2}\right|_{\epsilon=0} P_2 = \left(\begin{array}{c} k\sqrt{3} \\ -k^2\sqrt{3}/2 \\ 0 \end{array}\right) \]\]
\[  \left.{\partial^2 M\over \partial\epsilon^2}\right|_{\epsilon=0} P_3 = \left(\begin{array}{c} -1/2 \\ 0 \\ 0 \end{array}\right) \]\]
$P_1$, the left base vertex, moves to the right as expected. $P_3$, the right base vertex moves left as expected.
If we select $k$ very small, then $P_2$ moves to the right, which is bad. If we select $k$ big enough, the downward $-k^2\sqrt{3}/2$
dominates the rightward $k\sqrt{3}$ and we stay in the triangle. A tiny translation upwards on the order of $\epsilon^2$ should
make us rupert.

The side of the triangle
has a slope of $-\sqrt 3$, and the slope of the velocity vector of the top
vertex is $(-k^2\sqrt 3/2)/(k\sqrt 3) = -k/2$.
 So we want $k/2$ to be at
least $\sqrt 3$, so $k$ must be at least $2\sqrt 3 \approx 3.464$. I picked
k in sage first just by looking at what seemed to work,
and I ended up picking $k = 4$, which indeed is more than
$3.464$.

\section{Opetopes and Flags}

Suppose I have a cartographic set $X$ under involutions $\sigma_0,\ldots,\sigma_n$.

I could ask for some extra data, some maps $f_{0}, \ldots, f_{n} : X \to 2$.
The function $f_i$ is interpreted as saying
whether a flag is attached to an $i$-dimensional cell that is in the domain (0) or codomain (1) of the higher-dimensional cell.
Here's an example 2-dimensional cartographic set.
\begin{center}\includegraphics[scale=0.70]{images/2025-09-01-higher.png}\end{center}
The flag $x = (a,f,\gamma)$ would have $f_0(x) = 0$ because $a$ is in the domain of $f$
and $f_1(x) = 0$ because $f$ is in the domain of $\gamma$, and $f_2(x) = 1$ because
$\gamma$ is in the codomain of the implied cell $k$.

We require that every cell has exactly one face that is a domain cell.

These are required to interact with $\sigma$ as follows. We require
\[f_n(x) \oplus f_{n-1}(x) \oplus f_n(\sigma_n(x)) \oplus f_{n-1}(\sigma_n(x)) = 1\]
for all $n$, where $\oplus$ means addition mod 2, and $f_{-1}$ conventionally is the constant 0 function.

Let's expand out what this means when we do a $\sigma_n$ flip. When we do such a flip, we're either
staying within the $n$-domain, or we're passing between $n$-codomain and $n$-domain.
Let's take for example the flag $x = (a, f, y)$ which has $\vec f(x) = [0,0,1]$. We do a $2$-flip,
and we wind up at $x = (a, f, \alpha)$. We have gone from the 2-codomain cell $\gamma$ to the 2-domain
cell $\alpha$. Because of this, the perspective on the input vs. outputness of $f$ does not change.
So $\vec f (a, f, \alpha) = [0,0,0]$.

Conversely, let's consider the face flip on $\vec f (a, h, \alpha) = [0, 1, 0]$.
That takes us to $\vec f (a, h, \beta) = [0, 0, 0]$. When $f_2$ doesn't change, $f_1$ does,
because we are traversing a composition boundary.

When we do a $\sigma_0$, just the leftmost bit flips.

If we have a $X$ with $\sigma_0,\ldots,\sigma_{n}$ and $f_0,\ldots,f_{n}$, then we can construct
$X \x 2$ with $\sigma_0,\ldots,\sigma_{n}$ acting on $X$ and $\sigma_{n+1}$ flipping $2$.
We let $f_0,\ldots,f_{n}$ draw from $X$, and $f_{n+1}$ takes the value of $2$.
This is suspension, which forms $S^{n+1}$ from $S^n$.

I want to think about composition. Here's one thing I can do.
\begin{center}\includegraphics[scale=0.70]{images/2025-09-01-pasting.png}\end{center}
In (1a) I have a tree with one unary node. In (1b) I break apart its left and right $\sigma_1$ edges.
This creates a hole at the bottom. In (2a) I have a tree with one binary node. In (2b) I break both
$\sigma_1$ walls on the right. This creates a hole ``on the right''. In (3) I glue these two shapes together,
grafting (1a) onto (2a).

I'm starting to think the important piece of data is simply the unique flag that is a codomain at every dimension.
In (1a), I take that flag and its $\sigma_0$ partner, and break the $\sigma_1$ bonds adjacent to them.
In (2a), I take that flag and its $\sigma_2$ partner, and break the $\sigma_1$ bonds adjacent to them.

\subsection{Higher Dimensions}
It's a real struggle to draw diagrams up a dimension, but I'm starting to see how some of it works.
A series of consecutive boring unary 3-cells between the same 2-diagram is going to look like
the product of a flag set that represents the 2-diagram and some external $\sigma_2$ and $\sigma_3$
edges that go around in a loop.

In the following diagram I have a 3-cell $L : \alpha \to \beta$ and a 3-cell $M : \beta \to \gamma$ that compose to an output 3-cell $N : \alpha \to \gamma$.
I can analyze all the flags in the various copies of the 2-cell shape $gf \imp k$ as belonging to some 3-cell in $L,M,N$ and some $2-cell$
in $\alpha,\beta\gamma$, with not all elements in the cross-product being feasible.

If my 2-digram shape had more 2-cells in it, it would have had some internal $\sigma_2$ edges as well.
\begin{center}\includegraphics[scale=0.50]{images/2025-09-01-pasting2.png}\end{center}

In a regular tree, an operation I might want to do is take a dangling leaf $L$ and graft on another tree $T$.
For leaf $L$, I delete four flags that constitute a non-codomain $1$-cell, and I take $T$ and split it like
I do (1b) above. This leaves both of them with 4 dangling $\sigma_1$-edges. We then glue them together.

In a 2-tree, I might want to take a dangling leaf $L$ and graft on another tree $T$.
For the leaf $L$, I delete all the flags of a 2-cell. This leaves various dangling $\sigma_2$-edges.
How many depends on the shape of the 2-cell that is the leaf. I know that the flags I deleted
have the form of a cross-product: because $\sigma_3$ commutes with $\sigma_0,\sigma_1$.
For the grafted tree $T$, I want to search around $\sigma_0,\sigma_1$, and then break all the nearby
$\sigma_2$, maybe?

No, I need a less trivial example to be sure I understand what I'm doing.

\subsection{A Less Trivial Example}
The below diagram is almost making me see how I want it to go.
Let's reindex so that a 2-tree is a suitable 2-cartographic set.
Then when I talk about just a ``tree'' I mean a 2-tree, and a 3-tree is a tree-of-trees.

The cell $M$ is an example of a tree. It has faces $\epsilon, \gamma, \phi$.
Of these $\gamma$ and $\epsilon$ really are nodes of the tree, and $\phi$ is the unique codomain 2-cell.

I can derive a 3-tree from a 2-tree by doubling flags.

I'm going to find that a 3-tree is either a leaf or has a node. A 3-tree with a node can be constructed
uniquely from a 2-tree $M$ that gives the arity of that node, plus a 3-tree $L_\alpha$ for each domain 2-cell $\alpha$ of $M$.

The flags of the composite structure are:
\begin{itemize}
\item A flag $m_x$ for every flag $x\in M$
\item A flag $n_x$ for every 2-codomain flag $x\in M$
\item $\cdots$
\end{itemize}
\begin{center}\includegraphics[scale=0.50]{images/2025-09-01-pasting3.png}\end{center}

\subsection{Pasting, Again}

No, my intuition evaporates there a bit. Here are some things I think I know:

\begin{itemize}
\item A one-node $n$-tree has a flag set isomorphic to $2 \x X$ where $\sigma_n$ acts on the $2$ part.
\item The boundary of an $n$-tree (which comprises its `domain' and `codomain' in the usual sense) can be found by
asking for its codomain $n$-cell. That $n$-cell includes $\sigma_0,\ldots,\sigma_{n-1}$ edges
so it is itself an $n-1$-tree.
\item Suppose we have an $n$-tree $B$. To be a leaf in $B$ is to be an
$(n-1)$-cell that is incident to the codomain $n$-cell,
but which is not itself a codomain $(n-1)$-cell. Pick a leaf $\ell \subseteq B$.
We'd like to attach an $n$-tree named $A$ at this leaf.

Here's another observation about a leaf: since we have commutativity of nonadjacent flips,
we know it's structured as $\ell = \ell' \x 2$ with $\sigma_0,\ldots,\sigma_{n-2}$ acting
on $\ell'$ and $\sigma_n$ acting on $2$. Say the flags of the form $\pair x 0$ are not
in the codomain $n$-cell, and say those of the form $\pair x 1$ are.

Let $Z_0$ be the codomain $(n-1)$-cell of the codomain $n$-cell of $A$.
Let $Z_1 = \sigma_{n-1} Z_0$. Note that it is not necessarily {\em all} of the
non-$(n-1)$-codomain flags of the codomain $n$-cell of $A$.

We ask for bijections $\psi_i : \ell' \x \{i\} \cong Z_i$ to explain how the attachment works.
These probably need to respect some of the flips as well.

The result of attachment is the set $B \setminus \ell \cup A$. We modify the action of
$\sigma_{n-1}$ on $B$ and on $A$, and leave everything else alone. We define $\sigma_{n-1}'$
on $B \setminus \ell \cup A$.

\[\begin{array}{ll}
\sigma_{n-1}' b = \psi_0(\sigma_{n-1} b) & \hbox{if $b\in B$ and $\sigma_{n-1} b \in \ell' \x \{ 0\}$}\\
\sigma_{n-1}' b = \psi_1(\sigma_{n-1} b) & \hbox{if $b\in B$ and $\sigma_{n-1} b \in \ell' \x \{ 1\}$}\\
\sigma_{n-1}' a = \sigma_{n-1}(\psi_{0}^{-1} a)& \hbox{if $a\in Z_0$}\\
\sigma_{n-1}' a = \sigma_{n-1}(\psi_{1}^{-1} a) & \hbox{if $a\in Z_1$}\\
\sigma_{n-1}' x = \sigma_{n-1}x & \hbox{otherwise.}
\end{array}\]
\end{itemize}

\subsection{A Mere Property}

Up till now I've been thinking in terms of trying to make a definition of cartographic-sets-as-opetopes that involves
inductively building up the tree structure. What if instead I step back and try to define a mere property that
characterizes certain cartographic sets as being tree-shaped in a more holistic way?

An $n$-map is as usual a set $X$ of flags and involutions
$\sigma_0,\ldots,\sigma_n$ which commute appropriately. An $m$-cell of an $n$-map is an equivalence class
of flags under all involutions except for $\sigma_m$.

An $n$-pretree is an $n$-map equipped with some functions $c_0, \ldots, c_n : X \to 2$ which
satisfy
\[c_i(x) \oplus c_{j}(\sigma_i(x)) =  \begin{cases}
c_i(\sigma_i(x)) \oplus c_{j}(x) + 1 & \hbox{if $j = i-1$;} \\
1 & \hbox{if $j = i$;} \\
0 &\hbox{otherwise.}
\end{cases}\]
Consider an $m$-cell $C$ and a sub-$(m-1)$-cell $D$ of it.
To traverse $D$, we are allowed every involution except $\sigma_m$ and $\sigma_{m-1}$.
This means $c_{m-1}$ is constant on $D$, because we always fall in the `otherwise' case of the above
definition if we avoid $\sigma_m$ and $\sigma_{m-1}$. Therefore we can abuse notation and write
of $c_{m-1}(C, D)$.

An $n$-tree is an $n$-pretree such that

\begin{itemize}
\item Every $m$-cell $C$ has exactly one sub-$(m-1)$-cell $D$ such that  $c_{m-1}(C, D) = 1$.
\item Every $n$-cell has a unique `path' to the unique $n$-cell $D$  with $c_n(X, D) = 1$.
\end{itemize}

I need to make the notion of `path' formal. What I have in mind is looking up the codomain $(n-1)$-cell
and $\sigma_n$-flipping to the next $n$-cell.

\subsection{A Quick HoTT Thought}

Another way of thinking about an $n$-map is as a functor
\[ f : \rset^{n+1} \to \rset\]
with some nice properties. We think of
\[ f\ (X_0 := 0)  \cdots (X_{n} := 0)\]
as being the set of flags, and we expect
\[ f\ (X_0 := 0) \cdots (X_i := 1) \cdots (X_{n} := 0)\]
to be the result of identifying pairs of flags joined by $\sigma_i$.
Conversely, the `one-cold' encoding
\[ f\ (X_0 := 1) \cdots (X_i := 0) \cdots (X_{n} := 1)\]
results in the type of $i$-cells.

The fact that $\sigma_i$ were involutions corresponds to the fact that the map
\[ f\ (X_0 := 0) \cdots (X_i := {!} : 0 \to 1) \cdots (X_{n} := 0)\]
(which arises from functoriality) everywhere has a fiber merely isomorphic to 2.

To say that $\sigma_i$ commutes with $\sigma_j$ should correspond to a requirement
that for any maps $g : A \to B$ and $h : C \to D$, we get a pullback square
% https://q.uiver.app/#q=WzAsNSxbMCwxXSxbMSwwLCJmXFwgXFxjZG90cyBBXFxjZG90cyBDXFxjZG90cyJdLFsxLDEsImZcXCBcXGNkb3RzIEFcXGNkb3RzIERcXGNkb3RzIl0sWzIsMCwiZlxcIFxcY2RvdHMgQlxcY2RvdHMgQ1xcY2RvdHMiXSxbMiwxLCJmXFwgXFxjZG90cyBCXFxjZG90cyBEXFxjZG90cyJdLFsxLDIsImZcXCBcXGNkb3RzIChYX2kgOj0gaClcXGNkb3RzIiwyXSxbMSwzLCJmXFwgXFxjZG90cyAoWF9pIDo9IGcpXFxjZG90cyJdLFszLDQsImZcXCBcXGNkb3RzIChYX2kgOj0gaClcXGNkb3RzIl0sWzIsNCwiZlxcIFxcY2RvdHMgKFhfaSA6PSBnKVxcY2RvdHMiLDJdLFsxLDQsIiIsMSx7InN0eWxlIjp7Im5hbWUiOiJjb3JuZXIifX1dXQ==
\[\begin{tikzcd}
	& {f\ \cdots A\cdots C\cdots} &[5em] {f\ \cdots B\cdots C\cdots} \\
	{} & {f\ \cdots A\cdots D\cdots} & {f\ \cdots B\cdots D\cdots}
	\arrow["{f\ \cdots (X_i := g)\cdots}", from=1-2, to=1-3]
	\arrow["{f\ \cdots (X_j := h)\cdots}"', from=1-2, to=2-2]
	\arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=1-2, to=2-3]
	\arrow["{f\ \cdots (X_j := h)\cdots}", from=1-3, to=2-3]
	\arrow["{f\ \cdots (X_i := g)\cdots}"', from=2-2, to=2-3]
\end{tikzcd}\]

\subsection{Back to Flags}

\begin{center}\includegraphics[scale=0.30]{images/2025-09-01-pasting4.png}\end{center}

A reasonable goal now would be to prove some flag-based definition of opetope equivalent to a standard one.
I think I'm expecting an $n$-opetope to be a connected $n$-map with extra functions $c_i : X \to 2$ such that
something like
satisfy
\[c_j(x) \oplus c_{j}(\sigma_i(x)) =  \begin{cases}
c_i(\sigma_i(x)) \oplus c_{i}(x) + 1 & \hbox{if $j = i-1$;} \\
c_j(x) \oplus c_{j}(\sigma_i(x)) & \hbox{if $j = i$;} \\
0 &\hbox{otherwise.}
\end{cases}\]
and some condition that says within any $m$-cell there exists a single connected $(m-1)$-subcell of it
with $c_m = 1$.

To relate this to standard opetopes I've stared a bit at some examples of Finster-style box-and-line diagrams,
but I hit a bit of an obstacle in that I'm not certain how to derive a flag set from one of them. I'd think it
would be a selection of nodes, one per dimension, but things break down when there are loops with zero inputs.
Even though I think the flag definition handles them correctly! The difficulty might just be understanding
how to relate the definitions.

\subsection{Leaves}
I at least want to understand leaves well. Here's a 1-dimensional leaf:
\begin{center}\includegraphics[scale=0.50]{images/2025-09-06-leaves-0.png}\end{center}
I have $\sigma_0$ and $\sigma_1$ flags acting redundantly on a (-1)-map

Here's a 2-dimensional one:
\begin{center}\includegraphics[scale=0.50]{images/2025-09-06-leaves-1.png}\end{center}
I have $\sigma_1$ and $\sigma_2$ flags acting redundantly on a 0-map.

Here's a 3-dimensional one:
\begin{center}\includegraphics[scale=0.50]{images/2025-09-06-leaves-2.png}\end{center}
I have $\sigma_2$ and $\sigma_3$ flags acting redundantly on a 1-map.
\end{document}
