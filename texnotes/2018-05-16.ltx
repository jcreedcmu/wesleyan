\documentclass{article}
\input{theorem}
\input{prooftree}
\usepackage{stmaryrd}
\usepackage{latexsym}
\usepackage{yfonts}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,arrows,cd,decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}
\usepackage{tcolorbox}
\tcbuselibrary{breakable}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}

\def\coe{\mathsf{coe}}
\def\bpush{\mathbf{push}}
\def\bpull{\mathbf{pull}}

\def\wo{\setminus}
\def\fA{\mathsf{A}}
\def\fC{\mathsf{C}}
\def\fX{\mathsf{X}}
\def\ff{\mathsf{f}}
\def\fm{\mathsf{m}}
\def\rspan{\mathsf{Span}}
% \def\El#1{\mathsf{El}({#1})}
\def\El#1{\ulcorner{#1}\urcorner}
\def\quote#1{{\ulcorner {#1} \urcorner}}
\def\U{\mathsf{U}}
\def\uu{\mathsf{u}}
\def\uni{\U}
\def\mor#1#2{#1 \to \underline{#2}}

\def\ridp{\mathsf{idp}}
\def\ssem#1{\langle\!\langle{#1}\rangle\!\rangle}

\definecolor{lred}{rgb}{0.95,0.8,0.8}
\definecolor{cyan}{rgb}{0.80,0.95,0.95}
\definecolor{orange}{rgb}{0.95,0.90,0.80}
\definecolor{bluegray}{rgb}{0.6,0.6,0.85}
\definecolor{lgray}{gray}{0.9}
\newtcolorbox{declbox}{colframe=lred,colback=lred,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{thmbox}{colframe=cyan,colback=cyan,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{defnbox}{colframe=orange,colback=orange,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}
\newtcolorbox{tangentbox}{colframe=lgray,colback=lgray,grow to right by=-10mm,grow to left by=-10mm,
boxrule=0pt,boxsep=0pt,breakable}

\input{linear}
\def\rpath#1{[#1]}
\def\rfst{\mathsf{fst}\,}
\def\rsnd{\mathsf{snd}\,}
\def\bunfold{\mathbf{unfold}}
\def\bfold{\mathbf{fold}}
\def\susp#1{\langle {#1} \rangle}
\def\ssusp#1{\langle\!\langle {#1} \rangle\!\rangle}
\def\dto{\mathrel{\dot\to}}
\def\dns{{\downarrow}}
\def\ups{{\uparrow}}
\def\sprov{\Vdash}
\def\signat{{\color{red}\Sigma}}
\def\ep#1{\underline{#1}}
\def\wat{\mathbin{@}}
\def\wwat{\mathbin{\underline\wat}}
\def\cn{{:}}
\def\dv{{\div}}
\def\ww{{\mathsf w}}
\def\base{{\textfrak b}}

\def\munit{I}
\def\tt{{\mathsf t}}
\def\rr{{\mathsf r}}
\def\ii{{\mathbb I}}
\def\pp{\textsf{\textbf p}}
\def\nn{{\mathsf n}}
\def\PP{\textsf{\textbf P}}
\def\NN{{\mathsf N}}
\def\zz{{\mathsf z}}
\def\sem#1{[\![#1]\!]}
\def\usem#1{\lceil\!\!\lceil{#1}\rceil\!\!\rceil}
\def\zem#1{\langle\!\langle#1\rangle\!\rangle}
\def\col#1{{\mathsf{C}}_{#1}}
\def\lax{\mathop\bigcirc}
\def\rjust{\mathsf{just}}
\def\rcvt{\mathsf{cvt}}
\def\rtype{\mathsf{type}}
\def\rdtype{\mathsf{disc}}
\def\rkind{\mathsf{kind}}
\def\rmode{\mathsf{mode}}
\def\rprel{\mathbf{Prel}}
\def\rrfam{\mathbf{Rfam}}
\def\rset{\mathbf{Set}}
\def\rfinset{\mathbf{FinSet}}
\def\rrel{\mathbf{Rel}}
\def\rcat{\mathbf{Cat}}
\def\rfam{\mathbf{Fam}}
\def\binj{\mathbf{inj}}
\def\rid{\mathsf{id}}
\def\rtrue{\mathrel\mathrm{true}}
\def\pbck{\ar[dr, phantom, pos=0, "\lrcorner"]}
\def\bpbck{\ar[ddrr, phantom, pos=0, "\lrcorner"]}
\def\erule#1#2{\begin{prooftree}#1\justifies #2\end{prooftree}}
\def\lpar{\bindnasrepma}
\def\lamp{\binampersand}
\def\btwo{\mathbf{2}}
\def\bone{\mathbf{1}}

\newarrow {Equiv} =====
\def\FinSet{\mathbf{FinSet}}
\def\x{\times}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\def\mapt{\ar[ddd,mapsto,shorten <=2em, shorten >=2em]}
\def\frommaps{\ar[from=uu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\frommapt{\ar[from=uuu,mapsto,shorten <=2em, shorten >=2em, crossing over]}
\def\C{\mathbf{C}}
\def\G{\mathbf{G}}
\def\S{\mathbf{S}}
\def\D{\mathbf{D}}
\def\E{\mathbf{E}}
\def\M{\mathbf{M}}
\def\pair#1#2{\langle#1,#2\rangle}
\def\tri{\triangleright}
\def\o{\circ}
\def\rctx{\,\mathsf{ctx}}
\def\rdctx{\,\mathsf{dctx}}
\def\del{\partial}
\def\also#1{\ \textcolor{blue}{\celse #1}}
\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\twocellswap#1#2{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift right=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift left=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,#2,from=\mynodeone,to=\mynodetwo]%
}
\def\maps{\ar[dd,mapsto,shorten <=2em, shorten >=2em]}
\author{Jason Reed}
\definecolor{fib}{HTML}{ff7f00}
\definecolor{green}{HTML}{007f00}
\definecolor{red}{HTML}{df3f3f}
\definecolor{opfib}{HTML}{007fff}

% For lightening colors I used
% http://trycolors.com/ 6 parts white to 1 part color
\definecolor{opfibl}{HTML}{DBEDFF}
\definecolor{greenl}{HTML}{DBEDDB}
\definecolor{redl}{HTML}{FAE4E4}
\def\njudge#1{\fcolorbox{opfib}{white}{#1}}
\def\nrule#1{\fcolorbox{white}{opfibl}{#1}}
\def\neqn#1{\fcolorbox{white}{redl}{#1}}



\def\judge#1{\vskip 2em\noindent \njudge{$#1$}\vskip 0.5em\noindent}
\def\rule#1{\vskip 2em \noindent \nrule{$#1$}\vskip 0.5em\noindent}
\def\eqn#1{\vskip 2em \noindent \neqn{$#1$}\vskip 0.5em\noindent}
\def\prof{\nrightarrow}
\def\tensor{\otimes}
\def\htensor{\mathrel{\hat\otimes}}
\def\lol{\multimap}
\def\hlol{\mathrel{\hat\multimap}}
\def\wtf{{\color{red}???}}

\def\re{\mathbf{E}}
\def\sh{\sharp}
\def\shp{\mathrel{\sharp}}
\def\zero{\texttt{0}}
\begin{document}

\def\
\tikzset{
   commutative diagrams/.cd,
   arrow style=tikz,
   diagrams={>=stealth}}

\section{More about Syntax for (Co)Ends}

Dan reminded me that, naturally, it'd be sensible to hope for a
path-induction-like elim rule for $\hom$.

\[
\erule
{\Delta, \gamma : \C ; \Gamma \prov e : A \qquad \Delta / \alpha - \C, \beta + \C; \Gamma \prov A : \rtype}
{\Delta, \alpha : \C, \beta : \C;\Gamma, h : \hom(\alpha, \beta) \prov \coe_h e : A}
\]

The thought I had about dependency and variance before went like this:

First consider the simply-typed case. If we have $A : \C \to \rset$ and we have
$B : \C^\op \to \rset$, then we have $B \to A : \C \to \rset$.
Syntactically, we would say
\[
\erule
{ \alpha + \C \prov A : \rtype \qquad  \alpha - \C \prov B : \rtype}
{ \alpha + \C \prov B \to A : \rtype}
\]
or more generally
\[
\erule
{\Delta \prov A : \rtype \qquad \Delta^\op \prov B : \rtype}
{\Delta \prov B \to A : \rtype}
\]
In the dependent case, suppose we have $B : \C^\op \to \rset$
and $A$ is a functor-ish thing (probably a fibration somehow, although I don't
understand how yet)  whose `object part'
is a function $(c : \C) \to B(c) \to \rset$.
By functor-ish what I mean is that for every $f : c \to d$
and every $y: B(d)$, then `the morphism part' of $A$ tells us how to
\[ A_{fy} :  A_c(B_f(y)) \to A_d(y)\]
and respects composition and identities appropriately.

Given these ingredients, we can indeed make a covariant functor, call it $(x : B) \to A$,
in $\C \to \rset$. Given an object $c$, we give $(x : B_c) \to A_c(x)$.
Given a morphism $f : c \to d$, we need to build something
\[((x : B_c) \to A_c(x)) \to ((y : B_d) \to A_d(y))\]
and we do this with the usual post- and pre-composition dance, just fixed up to
involve dependency:
\[\lambda \alpha : ((x : B_c) \to A_c(x)) .\lambda y : B_d .  A_{fy}(\alpha(B_f(y)))\]

So what have we shown, in syntax?
\[
\erule
{\alpha + \C; x : B \prov A : \rtype \qquad \alpha - \C \prov B : \rtype}
{\alpha + \C \prov (x : B) \to A : \rtype }
\]
and I could imagine generalizing this to
\[
\erule
{\Delta; x : B \prov A : \rtype \qquad \Delta^\op \prov B : \rtype}
{\Delta \prov (x : B) \to A : \rtype }
\]

More generally, we would expect well-formed contexts to be contravariant functors
functors out of $\Delta$; so still in the case of singleton $\Delta$,
we expect the well-formedness $\alpha + \C \prov \Gamma  \rctx$ to mean
 $\sem\Gamma : \C^\op \to \rset$ and $\alpha + \C ; \Gamma \prov A : \rtype$
to mean that $\sem A$ is a functor-ish thing whose object part is
\[(c : \C) \to \sem \Gamma(c) \to \rset \]
and whose morphism part is
\[(f : c \to d) (\gamma : \sem \Gamma(d)) \to \sem A_c (\sem \Gamma(\gamma)) \to \sem A_d(\gamma) \]

So we might expect a $\Pi$-intro-shaped variance rule to look like
\[
\erule
{\Delta^\op; \Gamma \prov A : \rtype \qquad \Delta ; \Gamma \prov B : \rtype}
{\Delta; \Gamma \prov (x : A) \to B}
\]
$\ldots$ errr nope, I generalized too fast, again. $\Gamma$ appearing under both $\Delta$
and $\Delta^\op$ is weird.


Wait, how can I support additional assumptions in $\Gamma$?
Suppose $B$ is itself dependent on some other regular (i.e. in $\Gamma$) variable
$z : C$. That means
$B$'s object part is, what, $(c : \C^\op) \to C(z) \to \rset$?

Wait, do I even know that ambivariant functors $\C\x\C^\op \to \rset$ admit
full $\Pi$ types?

Suppose I have
\[\Gamma : \C \x \C^\op \to \rset \]
\[A : (\delta : \C)(\delta' : \C^\op) (\gamma : \Gamma(\delta', \delta)) \to \rset\]
\[B : (\delta : \C)(\delta' : \C^\op) (\gamma : \Gamma(\delta', \delta))
(\alpha : A(\delta, \delta', \gamma)) \to \rset\]
this is wrong, because it's not using $A$ as a contravariant functor. Also wrong is
\[B : (\delta : \C)(\delta' : \C^\op) (\gamma : \Gamma(\delta', \delta))
(\alpha : A(\delta', \delta, \gamma)) \to \rset\]
because then there's a type mismatch of $\gamma$.

Should I be asking for a $\gamma : \Gamma(\delta', \delta)$ {\em and}
a $\gamma' : \Gamma(\delta, \delta')$? No, I can't do that, because I can't
apply $\Gamma$ to those arguments. Hmm.

\subsection{A Potential Way Out of the Confusion}

Maybe the way that I'm talking about a type depending on a term of another type isn't
canonical, but one of two symmetric possibilities.

Suppose there are such things as variance-polarized {\em non-categorical} assumptions, like
\[\alpha + \C ;  x + A \prov B : \rtype \eqno(+)\]
and
\[\alpha + \C ;  x - A \prov B : \rtype \eqno(-)\]
except what those mean semantically is that, regardless of variance,
\[B_c : A_c \to \rtype\]
but then a variance-dependent morphism part for any $f : c \to d$,
\[B_f : (x : A_c) \to B_c(x) \to B_c(A_f(x)) \eqno(+)\]
\[B_f : (x : A_d) \to B_c(A_f(x)) \to B_d(x) \eqno(-)\]
which means that I should have said in the first place that there's
a variance-dependent presupposition that
\[\alpha + \C \prov A : \rtype\eqno(+)\]
\[\alpha - \C \prov A : \rtype\eqno(-)\]
and with this stuff in place I should be able to at least be
able to talk about about $\Sigma$ types, as well as $\Pi$s.
\[
\erule
{\alpha + \C \prov A : \rtype \qquad \alpha + \C; x + A \prov B : \rtype}
{\alpha + \C \prov (x : A) \x B : \rtype}
\]
\[
\erule
{\alpha - \C \prov A : \rtype \qquad \alpha + \C; x - A \prov B : \rtype}
{\alpha + \C \prov (x : A) \to B : \rtype}
\]
Let's try to grind through semantically justifying the $\Sigma$ rule, then.
We have $A$ a functor $\C \to \rset$. We have $B$ with $B_c : A_c \to \rset$
and $B_f : (x : A_c) \to B_c(x) \to B_d(A_f(x))$ because $x + A$ is positive.
We set
\[((x:A) \x B)_c = (x: A_c) \x B_c(x)\]
\[((x:A) \x B)_f : ((x: A_c) \x B_c(x)) \to ((x: A_d) \x B_d(x))\]
\[((x:A) \x B)_f(x, b) = (A_f(x), B_f(x)(b))\]
yeah, nice and easy!
\subsection{$\Pi$ and $\Sigma$ interacting}
Ok, let's say we want to have types $A$, $B$, and $C$ such that $B$ depends on $x:A$ and $C$
depends on $x:A$ and $y:B$. We might as well have said that $C$ depends on $z : (x :A) \x B$.
So like
\[\Delta ; z :^m (x : A) \x B \prov C : \rtype\]
for some mode $m \in \{-,+\}$. So this probably ought to be the same thing as
\[\Delta ; x :^m A, y :^m B \prov C : \rtype\]
Does this mean everything in the context has to be at the same $m$?
Hopefully not --- but maybe that governs what can {\em depend} on
what. Maybe the context formation rules look like
\[
\erule
{\Delta\prov \Gamma \rctx \qquad \Delta^\op ; \Gamma^\op \prov A : \rtype}
{\Delta\prov (\Gamma, x - A) \rctx}
\]
\[
\erule
{\Delta\prov \Gamma \rctx \qquad \Delta; \Gamma \prov A : \rtype}
{\Delta\prov (\Gamma, x + A) \rctx}
\]
or as one rule I could say
\[
\erule
{\Delta\prov \Gamma \rctx \qquad \Delta^m ; \Gamma^m \prov A : \rtype}
{\Delta\prov (\Gamma, x :^m A) \rctx}
\]

Then maybe the hom intro and elim rules are like
\[
\erule
{}
{\Delta, \alpha : \C;\Gamma \prov \ridp : \alpha^\alpha}
\]
\[
\erule
{\Delta, \gamma : \C ; \Gamma \prov e : [\gamma/\alpha][\gamma/\beta][\ridp/h]A }
{\Delta, \alpha - \C, \beta + \C;\Gamma, h + \beta^\alpha \prov \coe_h e : A}
\]
And somehow the moral of the story might be, math gods willing, that
the two variances of {\em term} dependency collapse into the same
thing when the assumption is an end-like ambivariant $\alpha : \C$, by
the end's equalizer condition?

Or wait, maybe this is wrong. For yoneda purposes, I absolutely want to form a $\Pi$
type with the $h$, so it needs to be $h - \beta^\alpha$. But that asks for the opposite
variance of $\alpha$ and $\beta$. So maybe
\[
\erule
{\Delta, \gamma : \C ; \Gamma \prov e : [\gamma/\alpha][\gamma/\beta][\ridp/h]A
\qquad
\Delta, \alpha - \C, \beta + \C;\Gamma, h - \beta^\alpha \prov A : \rtype
}
{\Delta, \alpha : \C, \beta : \C;\Gamma, h - \beta^\alpha \prov \coe_h e : A}
\]
and separately I'd want to say
\[
\erule
{}
{\Delta, \alpha - \C, \beta + \C;\Gamma \prov  \beta^\alpha : \rtype}
\]
Arg, but this means that $\coe$ doesn't use $\alpha, \beta$ with a
consistent variance. That seems to spell likely doom for reasonable
higher-dimensional proofs about `directed equality'.

Hm, or is it fine, actually? Here's the thing: I'm never trying to make a category-shaped thing
out of regular-shaped stuff. There's no overt meaning that I'm assigning to variance
annotations when doing a term-typing judgment --- except I guess it could still
mean irrelevance with respect to one variable or the other or something?
But it's {\em formation} of types for which variance assignments are essential.
I think there is something simplifying about the fact that we're not trying
to set up a type theory where every type is a category, just a type theory
where some extrinsic hypotheses can be categorical.

Possibly it's worth clinging to the thought of categories as a
kind-of-type that's a higher mode than regular types. For I do have a
notion of `term' with categories occurring on the right, and it
obliterates the $\Gamma$ and leaves only $\Delta$.

\subsection{Starting Fresh}

When  $\prov \Delta \rdctx$, then $\sem \Delta$ is a category.
The rules for that judgment are
\[
\erule
{}
{\prov \cdot \rdctx}
\qquad
\erule
{\prov \Delta \rdctx}
{\prov \Delta, x : \C \rdctx}
\]
\[
\erule
{\prov \Delta \rdctx}
{\prov \Delta, x + \C \rdctx}
\qquad
\erule
{\prov \Delta \rdctx}
{\prov \Delta, x - \C \rdctx}
\]
The meaning is given by
\[
\begin{tabular}{rcl}
  $\sem\cdot$&$=$&$\mathbf{1}$\\
  $\sem{\Delta, x : \C}$&$=$&$\sem\Delta \x (\C \x \C^\op)$\\
  $\sem{\Delta, x + \C}$&$=$&$\sem\Delta \x \C$\\
  $\sem{\Delta, x - \C}$&$=$&$\sem\Delta \x \C^\op$
\end{tabular}
\]
I could also have a judgment $\prov \Delta \rdctx^:$ which only allows
$:$, not $+$ or $-$, that maybe I can use for the term typing judgement.

When $\prov \Delta \rdctx$ and $\Delta \prov \Gamma \rctx$,
then $\sem \Gamma$ is a functor $\sem \Delta \to \rset$. We write the object part
as $\Gamma_\delta$ and the morphism part as $\Gamma_\phi : \Gamma_\delta \to \Gamma_\epsilon$
for $\phi : \delta \to \epsilon \in \sem \Delta$. The rules
for context formation are
\[
\erule
{}
{\Delta \prov \cdot \rctx}
\]
\[
\erule
{\Delta \prov \Gamma \rctx \qquad \Delta ; \Gamma \prov A : \rtype}
{\Delta \prov \Gamma, x + A \rctx}
\qquad
\erule
{\Delta \prov \Gamma \rctx \qquad \Delta^\op ; \Gamma^\op \prov A : \rtype}
{\Delta \prov \Gamma, x - A \rctx}
\]

The syntactic involution $\Delta^\op$ should be pretty clear; flip $+$
and $-$, and leave $:$ alone. We see that
$\sem {\Delta^\op} \cong \sem \Delta^\op$, although the isomorphism is ever so slightly
nontrivial in the $:$ case because we need to swap the arguments. The
syntactic operation $\Gamma^\op$ should be pretty clear.

\begin{lemma}
If $\Delta \prov \Gamma \rctx$ then $\Delta^\op \prov \Gamma^\op \rctx$.
\end{lemma}

\begin{proof}
Suppose
\[\erule
{\Delta \prov \Gamma \rctx \qquad \Delta ; \Gamma \prov A : \rtype}
{\Delta \prov \Gamma, x + A \rctx}\]
We need to show $\Delta^\op \prov \Gamma^\op, x - A \rctx$. By induction hypothesis,
$\Delta^\op \prov \Gamma^\op \rctx$. So we derive
\[
\erule
{\Delta^\op \prov \Gamma^\op \rctx \qquad \Delta ; \Gamma \prov A : \rtype}
{\Delta^\op \prov \Gamma^\op, x - A \rctx}
\]
In the other case, we have
\[\erule
{\Delta \prov \Gamma \rctx \qquad \Delta^\op ; \Gamma^\op \prov A : \rtype}
{\Delta \prov \Gamma, x - A \rctx}\]
and need to show
$\Delta^\op \prov \Gamma^\op, x + A \rctx$. By induction hypothesis,
$\Delta^\op \prov \Gamma^\op \rctx$. So we derive
\[
\erule
{\Delta^\op \prov \Gamma^\op \rctx \qquad \Delta^\op ; \Gamma^\op \prov A : \rtype}
{\Delta^\op \prov \Gamma^\op, x + A \rctx}
\]
\cqed
\end{proof}

When $\prov \Delta\rdctx$ and $\Delta \prov \Gamma \rctx$ and
$\Delta; \Gamma \prov A : \rtype$, then the meaning of $A$ is a functor-ish thing that
has an object part and a morphism part. The object part for any $\delta\in \sem\Delta$
is
\[A_\delta : \Gamma_\delta \to \rset\]
and the morphism part is
$\ldots$whoops, generalized too fast again. Is the meaning of $\Gamma$
really straightforwardly a functor?

The examples I thought I understood were
\[\Delta; x + A \prov B : \rtype\]
meant
\[A : \sem \Delta \to \rset \qquad B_\delta : A_\delta \to \rset\]
\[B_\phi : (a : A_\delta) \to B_\delta(a) \to B_\epsilon(A_\phi(a)) \]
and
\[\Delta; x - A \prov B : \rtype\]
meant
\[A : \sem \Delta^\op \to \rset \qquad B_\delta : A_\delta \to \rset\]
\[B_\phi : (a : A_\epsilon) \to B_\delta(A_\phi(a)) \to B_\epsilon(a) \]

So let's slowly go through some two-variable examples.
I expect
\[\Delta; x + A, y + B \prov C : \rtype\]
to make sense, given
\[\Delta; x + A \prov B : \rtype\]
I think then
\[C_\delta : (a : A_\delta) \to B_\delta(a) \to \rset\]
\[C_\phi : (a : A_\delta) (b : B_\delta(a)) \to C_\delta(a,b) \to C_\epsilon(A_\phi(a),B_\phi(a, b))\]

Okay, any more of this and I need agda. Check out
\[\texttt{/Users/jreed/wes/agda/anon/2018-05-16.agda}\]

Let's see if I can figure out the pattern in that.\\
The thing I'm calling $\texttt{A+}$ in it is a type
\[\Delta;\cdot \prov A^+ : \rtype\]
and the thing I'm calling $\texttt{A-}$ is
\[\Delta^\op;\cdot \prov A^- : \rtype\]

The  $\texttt{B}$ types are
\[\Delta;x + A^+ \prov B^{++} : \rtype\]
\[\Delta^\op ;x - A^+ \prov B^{+-} : \rtype\]
\[\Delta;x - A^- \prov B^{-+} : \rtype\]
\[\Delta^\op ;x + A^- \prov B^{--} : \rtype\]
And the full complement of $C$-types is
\[\Delta ; x + A^+, y + B^{++} \prov C^{+++} : \rtype\]
\[\Delta^\op ; x - A^+, y - B^{++} \prov C^{++-} : \rtype\]
\[\Delta ; x + A^+, y - B^{+-} \prov C^{+-+} : \rtype\]
\[\Delta^\op ; x - A^+, y + B^{+-} \prov C^{+--} : \rtype\]
\[\Delta ; x - A^-, y + B^{-+} \prov C^{-++} : \rtype\]
\[\Delta^\op ; x + A^-, y - B^{-+} \prov C^{-+-} : \rtype\]
\[\Delta ; x - A^-, y - B^{--} \prov C^{--+} : \rtype\]
\[\Delta^\op ; x + A^-, y + B^{--} \prov C^{---} : \rtype\]
Ok, so I think the context formation rules I have above are good.

Now let's look at the morphism actions. Suppose $\phi : \delta \to \epsilon$ \\
\[A^+_\phi : A_\delta \to A_\epsilon\]
\[A^-_\phi : A_\epsilon \to A_\delta\]
\[B^{++}_\phi : (a : A_\delta) \to B_\delta(a) \to B_\epsilon(A^+_\phi(a)) \]
\[B^{+-}_\phi : (a : A_\delta) \to B_\epsilon(A^+_\phi(a))  \to B_\delta(a) \]
\[B^{-+}_\phi : (a : A_\epsilon) \to  B_\delta(A^-_\phi(a)) \to B_\epsilon(a)\]
\[B^{--}_\phi : (a : A_\epsilon) \to  B_\epsilon(a) \to B_\delta(A^-_\phi(a)) \]
\[C^{+++}_\phi : (a : A_\delta) (b : B_\delta(a)) \to C_\delta(a,b) \to C_\epsilon(A^+_\phi(a), B^{++}_\phi(a, b)) \]
\[C^{+-+}_\phi : (a : A_\delta) (b : B_\epsilon(A^+_\phi(a))) \to C_\delta(a,B_\phi^{+-}(a, b)) \to C_\epsilon(A^+_\phi(a), b) \]
\[C^{-++}_\phi : (a : A_\epsilon) (b : B_\delta(A^-_\phi(a))) \to C_\delta(A^-_\phi(a), b) \to C_\epsilon(a, B^{-+}_\phi(a, b)) \]

So this makes me think that I need to define
some notion of $\Gamma_\phi$ which for example takes $x - A^-, y + B^{-+}$ and yields
the $\Sigma$ type
\[(a : A_\epsilon) (b : B_\delta(A^-_\phi(a)))\]

\subsubsection{Bolding Trying Anyway Despite Not Really Understanding What I'm Doing}
Surely we have $(\cdot)_\phi = \top$.
Then I think
\[ (\Gamma, x + A)_\phi = (\gamma : \Gamma_\phi) \x A_\delta( S^+(\gamma) ) \]
\[ (\Gamma, x - A)_\phi = (\gamma : \Gamma_\phi) \x A_\epsilon( S^-(\gamma) ) \]
for some $S$ I don't understand yet.
Then when $\Delta ; \Gamma \prov A : \rtype$, we should have
\[ A_\phi : (\gamma : \Gamma_\phi) \to A_\delta(? (\gamma)) \to A_\epsilon(?(\gamma))\]
Ah, but I know what type the merely object-typed function  $A_\delta$ has: it's $\Gamma_\delta \to \rset$.
So there's got to be some kind of way of getting from $\Gamma_\phi$ to $\Gamma_\delta$, and from $\Gamma_\phi$ to $\Gamma_\epsilon$. Great, this solves the gap for both bits. I declare
\begin{declbox}
  $\Gamma_\delta : \rset$.\\
  $\Gamma_\phi : \rset$.\\
  $\Gamma^< : \Gamma_\phi \to \Gamma_\delta $\\
  $\Gamma^> : \Gamma_\phi \to \Gamma_\epsilon $\\
  $A_\delta : \Gamma_\delta \to \rset$\\
  $A_\phi : (\psi : \Gamma_\phi) \to A_\delta(\Gamma^< \psi) \to A_\epsilon(\Gamma^> \psi)$
\end{declbox}
and define
\begin{defnbox}
 $(\cdot)_\delta = \bone$\\
 $(\Gamma, x + A)_\delta = (\gamma : \Gamma_\delta) \x A_\delta(\gamma)$\\
 $(\Gamma, x - A)_\delta = (\gamma : \Gamma_\delta) \x A_\delta(\gamma)$\\
\\
 $(\cdot)_\phi = \bone$\\
 $(\Gamma, x + A)_\phi = (\psi : \Gamma_\phi) \x A_\delta( \Gamma^< (\psi) )$\\
 $(\Gamma, x - A)_\phi = (\psi : \Gamma_\phi) \x A_\epsilon( \Gamma^> (\psi) )$\\
\\
 $(\cdot)^< = {!}$\\
% $(\Gamma, x + A)^< :  (\psi : \Gamma_\phi) \x A_\delta(\Gamma^< (\psi)) \to (\gamma : \Gamma_\delta) \x A_\delta(\gamma)$\\
 $(\Gamma, x + A)^< (\psi , a) = (\Gamma^<(\psi), a)$\\
% $(\Gamma, x - A)^< :  (\psi : \Gamma_\phi) \x A_\epsilon( \Gamma^> (\psi) ) \to (\gamma : \Gamma_\delta) \x A_\delta(\gamma)$\\
 $(\Gamma, x - A)^< (\psi , a) = (\Gamma^<(\psi), A_\phi(\psi, a))\star$\\
 $(\cdot)^> = {!}$\\
 $(\Gamma, x + A)^> (\psi , a) = (\Gamma^>(\psi), A_\phi(\psi, a))$\\
 $(\Gamma, x - A)^> (\psi , a) = (\Gamma^>(\psi), a)$
\end{defnbox}
$\star$ some contravariance is going on here that I need to carefully explain, but I think it's right.
The statement of the theorem is that if $\Delta; \Gamma \prov A : \rtype$, and
$\phi : \delta \to \epsilon \in \sem \Delta$, then
 $A_\phi : (\psi : \Gamma_\phi) \to A_\delta(\Gamma^<\psi) \to A_\epsilon(\Gamma^> \psi)$.
But since $x - A$ is the type appearing in the context, it's actually
$\Delta^\op ;\Gamma^\op \prov A : \rtype$ that holds.

Maybe I could even sensibly define $\Gamma^<$ as $(\Gamma^\op)^>$, since
 $\Delta \prov \Gamma \rctx$ means  $\Delta^\op \prov \Gamma^\op \rctx$.
Yeah, I like that.

Great, this tells me what the morphism part of a type has to be. What about identities and composition?
Should guarantee that for $\phi : \delta \to \epsilon$ and $\sigma : \epsilon \to \beta$.
\begin{thmbox}
$\Gamma^<_\rid(\psi) = \Gamma^>_\rid(\psi)$\\
$A_\rid(\psi, a) = a$\\
$\Gamma^<_{\sigma \o \phi}(\psi) : \Gamma_{\sigma \o \phi} \to \Gamma_\delta$\\
$\Gamma^>_{\sigma \o \phi}(\psi) : \Gamma_{\sigma \o \phi} \to \Gamma_\beta$\\
$\Gamma^<_{\phi}(\psi) : \Gamma_{\phi} \to \Gamma_\delta$\\
$\Gamma^>_{\phi}(\psi) : \Gamma_{\phi} \to \Gamma_\epsilon$\\
$\Gamma^<_{\sigma}(\psi) : \Gamma_{\sigma} \to \Gamma_\epsilon$\\
$\Gamma^>_{\sigma}(\psi) : \Gamma_{\sigma} \to \Gamma_\beta$
\end{thmbox}
Hm, not as sure what to do with this. Do I need to generalize $<$ and $>$ to generate things
like $\Gamma_{\sigma \o \phi} \to \Gamma_\sigma$, for example, so I can assert commutative triangles?

\section{So What About Terms}

I'm reasonably confident that what
\(c : \C;\cdot \prov M : A \)
means is that
\[ \sem M \in \int_{c \in \C}  A_c \]
What about
\(c + \C;\cdot \prov M : A \)? In this case, $A$ is a covariant functor out of $\C$. It could
be weakened to a functor $\C \x \C^\op$, and I could still take the end
\[ \int_{c \in \C}  A_c \]
of the resulting bifunctor that simply doesn't depend on one of its arguments.
What is the result of that? It's the equalizer
\[
\begin{tikzcd}
  E \ar[r, >->] & \Pi_{c\in \C} A_c \ar[r, shift left]\ar[r, shift right] & \Pi_{c,c'\in \C} A_c
\end{tikzcd}
\]
where I'm requiring a choice of element $a_c \in A_c$ for every $c$, subject to
the constraint that for every $c, c'$,
\vfil\eject
\[
\begin{tikzcd}
  a_c : A_{c} \ar[r] & A_{c'} & \ar[l, equal] a_{c'} : A_{c'}
\end{tikzcd}
\]
Oh, right, it's just a global section.
If $f : c \to d$, it's the requirement that $A_f(M_c) = M_d$.
If we have two linked variables $c : \C$ and $c' : \C^\op$ then
the end-equalizer requirement is like $A_{fc}(M_{cc}) = A_{df}(M_{dd}) : A_{dc}$.

Ok, what could happen when we have term variables around? Let's say
\[ c + \C ; x + A \prov M : B\]
assuming
\[ c + \C ; \cdot \prov A : \rtype \]
\[ c + \C ; x + A \prov B : \rtype \]
meaning that we have $A_c : \rtype$ and $A_f : A_c \to A_d$
and $B_c : (a : A_c) \to \rtype$ and $B_f : (a : A_c) \to B_c(a) \to B_d(A_f(a))$.
We would expect $M_c : (a : A_c) \to B_c(a)$, and a transport principle like
\[(a : A_c) \to B_f(a, M_c(a)) = M_d(A_f(a))\]

Great, what about
\[ c + \C ; x - A \prov M : B\]
?
We have $A_c : \rtype$ and $A_f : A_d \to A_c$
and $B_c : (a : A_c) \to \rtype$ and $B_f : (a : A_d) \to B_c(A_f(a)) \to B_d(a)$.
We would expect still $M_c : (a : A_c) \to B_c(a)$ and
\[(a : A_d) \to B_f(a, M_c(A_f(a))) = M_d(a)\]

No problem. What about
\[ c : \C ; x + A \prov M : B\]
with two linked variables? Then
\[ c : \C ; \cdot \prov A : \rtype \]
\[ c : \C ; x + A \prov B : \rtype \]
and when $f : c \to d$ and $f' : d' \to c'$ we have
$A_{ff'} : A_{cc'} \to A_{dd'}$ and
$B_{ff'} : (a : A_{cc'}) \to B_{cc'}(a) \to B_{dd'}(A_{ff'}(a))$.
Then $M_{cc'} : (a : A_{cc'}) \to B_{cc'}(a)$, and
for every $c$ and $d$ and $f : c \to d$ we would ask for
\[ (a : A_{cd}) \to B_{fc}(A_{cf}(a), M_{cc}(A_{cf}(a))) = B_{df}(A_{fd}(a), M_{dd}(A_{fd}(a)))\]
Observe
\[B_{fc} (A_{cf}(a), M_{cc}(A_{cf}(a))):   B_{dc}(A_{fc}(A_{cf}(a)))\]
\[B_{df} (A_{fd}(a), M_{dd}(A_{fd}(a))) :  B_{dc}(A_{df}(A_{fd}(a)))\]
And these are the same type by functoriality of $A$.

Interesting! I was expecting the end-property for $A$ to be used.
But I don't suppose any actual terms are in play, just variables.

\subsection{On Contexts}
Ok, so there are two notions of $\Delta$-context that I can reasonably
imagine right now. There's one in which everything is polarized, and one
in which nothing is. Let me call the unpolarized one $\Omega$ or something.
The term judgment more naturally takes $\Omega$, and the type judgment $\Delta$.
There's noninverse operations going back and forth between them:
\[
\begin{tabular}{rcl}
  $\cdot^0$&$=$&$\cdot$\\
  $(\Delta, x + \C)^0$&$=$&$\Delta^0, x : \C$\\
  $(\Delta, x - \C)^0$&$=$&$\Delta^0, x : \C$\\
  $\cdot^\pm$&$=$&$\cdot$\\
  $(\Omega, x : \C)^\pm$&$=$&$\Omega^\pm, x_0 + \C, x_1 - \C$\\
\end{tabular}
\]
Plausibly these might be adjoint somehow. The $\hom$ rule might then look something like
\[
\erule
{\Omega, \gamma : \C ; \Gamma \prov e : [\gamma/\alpha][\gamma/\beta][\ridp/h] A \qquad \Omega^\pm, \alpha - \C, \beta + \C; \Gamma \prov A : \rtype}
{\Omega, \alpha : \C, \beta : \C;\Gamma, h : \hom(\alpha, \beta) \prov \coe_h e : A}
\]
allowing ambivalent use of most of the things in $\Omega$, but requiring contravariant use of $\alpha$
and covariant use of $\beta$. Still missing from this rule is a required assignment of variance to the
term variable $h$, but I don't know how to pick that yet.
\end{document}
